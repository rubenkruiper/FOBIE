[LINE#0] Naker is a biologically-inspired massively-parallel computer designed to model up to a billion spiking neurons in real-time.
0.805	[*A*]a biologically-inspired massively-parallel computer[*R*]to model up	context()	negated: False ,passive: False
0.964	[*A*]a biologically-inspired massively-parallel computer[*R*]designed[*A*]to model up to a billion spiking neurons in real-time	context()	negated: False ,passive: True
0.961	[*A*]Naker[*R*]is[*A*]a biologically-inspired massively-parallel computer designed to model up to a billion spiking neurons in real-time	context()	negated: False ,passive: True
[LINE#1] A full-fledged implementation of a SpiNNaker system will comprise more than 105 integrated circuits (half of which are SDRAMs and half multi-core systems-on-chip).
0.911	[*A*]half of which[*R*]are[*A*]half multi-core systems - on - chip	context()	negated: False ,passive: True
0.976	[*A*]A full - fledged implementation of a SpiNNaker system[*R*]will comprise[*A*]more than 105 integrated circuits ( half of which are half multi-core systems - on - chip	context()	negated: False ,passive: True
0.927	[*A*]more than 105 integrated circuits[*R*]are[*A*]SDRAMs	context()	negated: False ,passive: True
0.980	[*A*]A full - fledged implementation of a SpiNNaker system[*R*]will comprise[*A*]more than 105 integrated circuits ( half of which are SDRAMs	context()	negated: False ,passive: True
[LINE#2] Given this scale, it is unavoidable that some components fail and, in consequence, fault-tolerance is a foundation of the system design.
0.229	[*A*]it[*R*]is[*A*]unavoidable	context(fault - tolerance is)	negated: False ,passive: True
0.949	[*A*]fault - tolerance[*R*]is[*A*]a foundation of the system design[*A*]in consequence	context()	negated: False ,passive: True
[LINE#3] Although the target application can tolerate a certain, low level of failures, important efforts have been devoted to incorporate different techniques for fault tolerance.
0.903	[*A*]important efforts[*R*]have been devoted[*A*]to incorporate different techniques for fault tolerance	context()	negated: False ,passive: True
0.911	[*A*]the target application[*R*]can tolerate[*A*]a certain, low level of failures	context()	negated: False ,passive: False
[LINE#4] This paper is devoted to discussing how hardware and software mechanisms collaborate to make SpiNNaker operate properly even in the very likely scenario of component failures and how it can tolerate system-degradation levels well above those expected.
0.194	[*A*]it[*R*]can tolerate[*A*]system - degradation levels well above those	context(This paper to discussing)	negated: False ,passive: False
0.667	[*A*]This paper[*R*]to discussing[*A*]how it can tolerate system - degradation levels well above those	context()	negated: False ,passive: False
0.083	[*A*]those[*R*]expected	context()	negated: False ,passive: False
0.797	[*A*]This paper[*R*]is[*A*]devoted to discussing how it can tolerate system - degradation levels well above those	context()	negated: False ,passive: True
0.735	[*A*]This paper[*R*]to discussing[*A*]how	context()	negated: False ,passive: False
0.813	[*A*]This paper[*R*]is[*A*]devoted to discussing how	context()	negated: False ,passive: True
[LINE#5] This section reviews common terminology on fault-tolerance and microelectronics, introducing several important concepts related to SpiNNaker and putting in context how fault tolerance is addressed.
0.882	[*A*]This section[*R*]reviews common terminology introducing[*A*]several important concepts related to putting in context how fault tolerance is addressed	context(This section reviews)	negated: False ,passive: False
0.911	[*A*]several important concepts[*R*]related[*A*]to putting in context how fault tolerance is addressed	context()	negated: False ,passive: True
0.849	[*A*]This section[*R*]reviews common terminology introducing[*A*]several important concepts related to SpiNNaker	context(This section reviews)	negated: False ,passive: False
0.878	[*A*]This section[*R*]reviews[*A*]common terminology[*A*]introducing several important concepts	context()	negated: False ,passive: False
0.925	[*A*]several important concepts[*R*]related[*A*]to SpiNNaker	context()	negated: False ,passive: True
[LINE#6] Throughout this paper, we differentiate between soft and hard errors.
0.595	[*A*]we[*R*]differentiate[*A*]between soft and hard errors[*A*]Throughout this paper	context()	negated: False ,passive: False
[LINE#7] Soft errors are transient errors - usually produced by electromagnetic noise - that affect the state of a bit to an extent that it swaps its value (from 0 to 1, or vice versa).
0.488	[*A*]it[*R*]swaps[*A*]its value (from 0 to 1, or vice versa	context()	negated: False ,passive: False
0.817	[*A*]transient errors - usually produced by electromagnetic noise[*R*]affect[*A*]the state of a bit[*A*]to an extent that it swaps its value (from 0 to 1, or vice versa	context()	negated: False ,passive: False
0.748	[*A*]Soft errors[*R*]are[*A*]transient errors - usually produced by electromagnetic noise - that affect the state of a bit to an extent that it swaps its value (from 0 to 1, or vice versa	context()	negated: False ,passive: True
[LINE#8] Cosmic rays are nowadays the main cause of soft errors [4].
0.903	[*A*]Cosmic rays[*R*]are[*A*]nowadays[*A*]the main cause of soft errors	context()	negated: False ,passive: True
[LINE#9] In contrast, hard errors are permanent errors due to physical defects, usually introduced during fabrication.
0.934	[*A*]physical defects[*R*]introduced[*A*]during fabrication[*A*]usually	context()	negated: False ,passive: True
0.903	[*A*]hard errors[*R*]are[*A*]permanent errors	context()	negated: False ,passive: True
[LINE#10] Some authors consider a third type of error, intermittent failures in which a component is barely stable and behaves irregularly as correct or as erroneous, the main triggers for one behaviour or the other being environmental factors (such as temperature, or voltage) [5].
0.544	[*A*]other[*R*]being[*A*]environmental factors (such as temperature, or voltage	context()	negated: False ,passive: True
0.958	[*A*]a component[*R*]behaves[*A*]irregularly[*A*]as correct or as erroneous, the main triggers for one behaviour or the other being environmental factors (such as temperature, or voltage[*A*]intermittent failures	context()	negated: False ,passive: False
0.957	[*A*]a component[*R*]is[*A*]barely stable[*A*]intermittent failures	context()	negated: False ,passive: True
0.903	[*A*]Some authors[*R*]consider[*A*]a third type of error	context()	negated: False ,passive: False
[LINE#11] We consider intermittent failures as hard failures and deactivate components that exhibit this behaviour.
0.887	[*A*]deactivate components[*R*]exhibit[*A*]this behaviour	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]consider[*A*]intermittent failures as deactivate components	context()	negated: False ,passive: False
0.887	[*A*]hard failures[*R*]exhibit[*A*]this behaviour	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]consider[*A*]intermittent failures as hard failures	context()	negated: False ,passive: False
[LINE#12] All units within a SpiNNaker chip are provided with two levels of reset.
0.845	[*A*]All units within a SpiNNaker chip[*R*]are provided	context()	negated: False ,passive: False
[LINE#13] A 'soft' reset is a signal to the state machines to abandon their operation at the next convenient opportunity, thus allowing any handshakes to complete first.
0.935	[*A*]A 'soft' reset[*R*]is[*A*]a signal to the state machines to abandon their operation at the next convenient opportunity,	context()	negated: False ,passive: True
[LINE#14] The 'hard' reset involves switching off a component and restarting it in order to reach its initial state.
0.871	[*A*]The ' hard ' reset[*R*]involves[*A*]restarting it in order	context()	negated: False ,passive: True
0.926	[*A*]The ' hard ' reset[*R*]involves[*A*]switching off a component in order	context()	negated: False ,passive: True
[LINE#15] Note that the latter is really intended only for power-up.
[LINE#16] Globally Asynchronous Locally Synchronous (GALS) technology offers the possibility of synchronous and asynchronous logic to coexist, obtaining the best of each world [6].
0.841	[*A*]Asynchronous Locally Synchronous ( GALS ) technology[*R*]offers the possibility of asynchronous logic obtaining[*A*]the best of each world	context(Asynchronous Locally Synchronous ( GALS ) technology offers)	negated: False ,passive: False
0.890	[*A*]Asynchronous Locally Synchronous ( GALS ) technology[*R*]offers[*A*]the possibility of asynchronous logic	context()	negated: False ,passive: False
0.841	[*A*]Asynchronous Locally Synchronous ( GALS ) technology[*R*]offers the possibility of synchronous logic obtaining[*A*]the best of each world	context(Asynchronous Locally Synchronous ( GALS ) technology offers)	negated: False ,passive: False
0.890	[*A*]Asynchronous Locally Synchronous ( GALS ) technology[*R*]offers[*A*]the possibility of synchronous logic	context()	negated: False ,passive: False
[LINE#17] Most devices use synchronous logic whereas communication between them is implemented using asynchronous fabrics.
0.363	[*A*]communication between them[*R*]is implemented	context()	negated: False ,passive: False
0.835	[*A*]Most devices[*R*]use[*A*]synchronous logic[*A*]whereas communication between them is implemented using asynchronous fabrics	context()	negated: False ,passive: False
[LINE#18+19]  GALS simplifies development and reduces power consumption but, in contrast, makes fault tolerance difficult due to the lack of time awareness.
0.813	[*A*]GALS[*R*]simplifies[*A*]development	context()	negated: False ,passive: False
[LINE#20] The three main elements for fault-tolerance are the Host, the System Controller and the Monitor Processor and Process.
0.943	[*A*]The three main elements for fault - tolerance[*R*]are[*A*]the Host	context()	negated: False ,passive: True
[LINE#21] The Host is a regular computer which runs an application that interfaces with SpiNNaker giving the Host a range of control operations over the hardware.
0.920	[*A*]SpiNNaker[*R*]giving[*A*]the Host[*A*]a range of control operations over the hardware	context()	negated: False ,passive: False
0.698	[*A*]an application[*R*]interfaces	context()	negated: False ,passive: False
0.890	[*A*]a regular computer[*R*]runs[*A*]an application that interfaces with SpiNNaker giving the Host a range of control operations over the hardware	context()	negated: False ,passive: False
0.925	[*A*]The Host[*R*]is[*A*]a regular computer which runs an application	context()	negated: False ,passive: True
[LINE#22] The Host is in charge of starting the system, uploading neural applications and data and looking after the status of the system once it starts its execution.
0.925	[*A*]The Host[*R*]is[*A*]in charge of starting the system , uploading data	context()	negated: False ,passive: True
0.952	[*A*]The Host[*R*]is[*A*]in charge of starting the system , uploading neural applications	context()	negated: False ,passive: True
0.372	[*A*]it[*R*]starts[*A*]its execution	context()	negated: False ,passive: False
0.915	[*A*]The Host[*R*]is[*A*]in charge of starting the system[*A*]looking after the status of the system once it starts its execution	context()	negated: False ,passive: True
[LINE#23] It includes a User Interface that allows exploration of the status of SpiNNaker components (see Fig. 3).
0.941	[*A*]exploration of the status of SpiNNaker components[*R*]see[*A*]Fig	context(a User Interface allows)	negated: False ,passive: False
0.946	[*A*]a User Interface[*R*]allows[*A*]exploration of the status of SpiNNaker components (see Fig	context()	negated: False ,passive: False
0.498	[*A*]It[*R*]includes[*A*]a User Interface	context()	negated: False ,passive: True
[LINE#24] The Monitor Process is the application in charge of controlling the status of each chip components.
0.967	[*A*]The Monitor Process[*R*]is[*A*]the application in charge of controlling the status of each chip components	context()	negated: False ,passive: True
[LINE#25] It requires a dedicated core, namely the Monitor Processor, which is selected during the boot-up process from all the functional cores.
0.954	[*A*]namely the Monitor Processor[*R*]is selected[*A*]during the boot-up process from all the functional cores	context()	negated: False ,passive: True
0.452	[*A*]It[*R*]requires[*A*]a dedicated core	context()	negated: False ,passive: False
[LINE#26] The Monitor Process uses the System Controller, a specialized piece of hardware, to detect and try to heal failing components.
0.944	[*A*]The Monitor Process[*R*]uses[*A*]the System Controller[*A*]to try to heal failing components	context()	negated: False ,passive: False
0.944	[*A*]The Monitor Process[*R*]uses[*A*]the System Controller[*A*]to detect	context()	negated: False ,passive: False
[LINE#27] The System Controller supports soft and hard resets of the different components within a chip and also communicates with the System Controller in neighbouring chips.
0.933	[*A*]The System Controller[*R*]supports[*A*]hard resets of the different components within a chip	context()	negated: False ,passive: False
0.933	[*A*]The System Controller[*R*]supports[*A*]soft resets of the different components within a chip	context()	negated: False ,passive: False
0.928	[*A*]The System[*R*]communicates[*A*]with the System Controller	context()	negated: False ,passive: False
[LINE#28] Watchdog devices are added to the design in order to supervise the correct operation of critical components such as the Monitor Process, or the communication ports.
0.903	[*A*]Watchdog devices[*R*]are added[*A*]to the design in order	context()	negated: False ,passive: True
[LINE#29] If a component does not respond for a predetermined amount of time, the watchdog will apply 'soft' reset first, only resorting to 'hard' reset if this fails.
0.153	[*A*]this[*R*]fails	context()	negated: False ,passive: False
0.903	[*A*]a component[*R*]does not respond[*A*]for a predetermined amount of time	context()	negated: True ,passive: False
[LINE#30] If both resets fail the watchdog will mark the component as faulty in the System Controller so that the Monitor Process can switch it off or, alternatively, try more elaborated nursing.
0.933	[*A*]the Monitor Process[*R*]can try[*A*]more elaborated nursing	context()	negated: False ,passive: False
0.880	[*A*]the Monitor Process[*R*]can switch off[*A*]it	context()	negated: False ,passive: False
0.903	[*A*]the watchdog[*R*]will mark[*A*]the component	context()	negated: False ,passive: False
0.732	[*A*]both resets[*R*]fail	context()	negated: False ,passive: False
[LINE#31+32]  SpiNNaker's fault tolerance relies mainly on redundancy:18 cores, 6 output links, 2 PLLs (phase locked loops) and the memory subsystem.
0.939	[*A*]SpiNNaker 's fault tolerance[*R*]relies[*A*]mainly[*A*]on r	context()	negated: False ,passive: False
0.894	[*A*]phase[*R*]locked[*A*]loops	context()	negated: False ,passive: False
0.939	[*A*]SpiNNaker 's fault tolerance[*R*]relies[*A*]mainly[*A*]on r 2	context()	negated: False ,passive: False
0.939	[*A*]SpiNNaker 's fault tolerance[*R*]relies[*A*]mainly[*A*]on r 6 output links	context()	negated: False ,passive: False
0.939	[*A*]SpiNNaker 's fault tolerance[*R*]relies[*A*]mainly[*A*]on r edundancy:18 cores	context()	negated: False ,passive: False
[LINE#33] The main strength of this redundancy is that components do not have their identifiers hard-coded, and therefore the functionality of one component can be covered seamlessly by any redundant one.
0.926	[*A*]the functionality of one component[*R*]can be covered seamlessly[*A*]by any redundant one	context()	negated: False ,passive: True
0.967	[*A*]The main strength of this redundancy[*R*]is[*A*]therefore the functionality of one component can be covered seamlessly by any redundant one	context()	negated: False ,passive: True
0.786	[*A*]components[*R*]do not have[*A*]their identifiers hard - coded	context(The main strength of this redundancy is)	negated: True ,passive: False
0.822	[*A*]The main strength of this redundancy[*R*]is[*A*]that components do not have their identifiers hard - coded	context()	negated: False ,passive: True
[LINE#34] Practically, this means that critical components such as the Monitor Processor are extremely reliable.
0.847	[*A*]critical components such as the Monitor Processor[*R*]are[*A*]extremely reliable	context(this means)	negated: False ,passive: True
0.250	[*A*]this[*R*]means[*A*]that critical components such as the Monitor Processor are extremely reliable	context()	negated: False ,passive: False
[LINE#35] Table 1 shows the relative areas of the different components of the chip to put in context their likelihood of fail.
0.737	[*A*]Table 1[*R*]shows[*A*]the relative areas of the different components of the chip	context()	negated: False ,passive: False
[LINE#36] The largest part of the chip is devoted to cores and TCMs, the most redundant and therefore less critical components of SpiNNaker.
0.943	[*A*]The largest part of the chip[*R*]is devoted[*A*]to the most therefore less critical components of SpiNNaker	context()	negated: False ,passive: True
0.943	[*A*]The largest part of the chip[*R*]is devoted[*A*]to the most redundant components of SpiNNaker	context()	negated: False ,passive: True
0.943	[*A*]The largest part of the chip[*R*]is devoted[*A*]to TCMs	context()	negated: False ,passive: True
0.932	[*A*]The largest part of the chip[*R*]is devoted[*A*]to cores	context()	negated: False ,passive: True
[LINE#37+38]  Communications fault toleranceGiven that the supported application is communication-intensivethe interconnection fabric of SpiNNaker is another critical component and therefore great effort has been devoted to design a robust and stable infrastructure..
0.972	[*A*]communication - intensivethe interconnection fabric of SpiNNaker[*R*]is[*A*]therefore great effort has been devoted to design a stable infrastructure	context(Communications fault toleranceGiven the supported application is)	negated: False ,passive: True
0.955	[*A*]the supported application[*R*]is[*A*]communication - intensivethe interconnection fabric of SpiNNaker is therefore great effort has been devoted to design a stable infrastructure	context(Communications fault toleranceGiven)	negated: False ,passive: True
0.840	[*A*]Communications fault[*R*]toleranceGiven[*A*]that the supported application is communication - intensivethe interconnection fabric of SpiNNaker is therefore great effort has been devoted to design a stable infrastructure	context()	negated: False ,passive: False
0.972	[*A*]communication - intensivethe interconnection fabric of SpiNNaker[*R*]is[*A*]therefore great effort has been devoted to design a robust infrastructure	context(Communications fault toleranceGiven the supported application is)	negated: False ,passive: True
0.955	[*A*]the supported application[*R*]is[*A*]communication - intensivethe interconnection fabric of SpiNNaker is therefore great effort has been devoted to design a robust infrastructure	context(Communications fault toleranceGiven)	negated: False ,passive: True
0.840	[*A*]Communications fault[*R*]toleranceGiven[*A*]that the supported application is communication - intensivethe interconnection fabric of SpiNNaker is therefore great effort has been devoted to design a robust infrastructure	context()	negated: False ,passive: False
0.983	[*A*]Communications fault toleranceGiven that the supported application is communication - intensivethe interconnection fabric of SpiNNaker[*R*]is[*A*]another critical component	context()	negated: False ,passive: True
0.942	[*A*]the supported application[*R*]is[*A*]communication - intensivethe interconnection fabric of SpiNNaker	context()	negated: False ,passive: True
0.732	[*A*]Communications fault[*R*]toleranceGiven	context()	negated: False ,passive: False
[LINE#39] communicationThe Comms NoC connects the processing cores via a custom on-chip router offering a bandwidth of up to 1GByte/s.
0.943	[*A*]a custom on-chip router[*R*]offering[*A*]a bandwidth of[*A*]up to 1GByte/s	context()	negated: False ,passive: False
0.933	[*A*]communicationThe Comms NoC[*R*]connects[*A*]the processing cores	context()	negated: False ,passive: False
[LINE#40] The Communications Controller within each processing core handles packets on behalf of its simulated neurons and interfaces with the Comms NoC.
0.953	[*A*]The Communications Controller within each processing core[*R*]handles[*A*]packets	context()	negated: False ,passive: False
[LINE#41] Together the on-chip router and the self-timed fabric seamlessly extend on-chip communications onto inter-chip connections.
[LINE#42] The Comms NoC has 18 ports for internal use of the processing cores and six ports to communicate with six adjacent chips (Fig. 4).
0.973	[*A*]The Comms NoC[*R*]has[*A*]18 ports for internal use of the six ports to communicate with six adjacent chips ( Fig . 4 )	context()	negated: False ,passive: False
0.516	[*A*]The Comms NoC[*R*]has [number of] ports to communicate with six adjacent chips ( Fig . 4 )[*A*]18	context()	negated: False ,passive: False
0.999	[*A*]The Comms NoC[*R*]has[*A*]18 ports	context()	negated: False ,passive: False
0.973	[*A*]The Comms NoC[*R*]has[*A*]18 ports for internal use of the processing cores to communicate with six adjacent chips ( Fig . 4 )	context()	negated: False ,passive: False
[LINE#43] External ports contain two independent, unidirectional self-timed chip-to-chip interfaces, one for transmitting and the other one for receiving data; i.e. a failure in a link or interface only affects one of the directions.
0.920	[*A*]External ports[*R*]contain[*A*]two independent, unidirectional self-timed chip-to-chip interfaces	context(i.e. a failure in a link or interface affects)	negated: False ,passive: False
0.915	[*A*]i.e. a failure in a link or interface[*R*]affects[*A*]one of the directions	context()	negated: False ,passive: False
[LINE#44] Asynchronously arriving packets to the router are arbitrated and serialised.
0.751	[*A*]Asynchronously arriving packets[*R*]serialised	context()	negated: False ,passive: False
0.801	[*A*]Asynchronously arriving packets to the router[*R*]are arbitrated	context()	negated: False ,passive: False
[LINE#45] The router can process one packet per clock cycle.
0.903	[*A*]The router[*R*]can process[*A*]one packet per clock cycle	context()	negated: False ,passive: False
[LINE#46] It is expected that the average traffic demand will be much lower than this.
0.761	[*A*]the average traffic demand[*R*]will be[*A*]much lower than this	context(It is expected)	negated: False ,passive: True
0.162	[*A*]It[*R*]is expected	context()	negated: False ,passive: False
[LINE#47] In the event of a 'collision' packets can be delayed arbitrarily and buffering between routers helps to accommodate this.
0.713	[*A*]packets[*R*]can be delayed arbitrarily	context()	negated: False ,passive: False
[LINE#48] Packets are checked for integrity on arrival at the router; faulty packets are dropped into a register where they can be examined by the local Monitor Processor.
0.871	[*A*]Packets[*R*]are checked[*A*]for integrity[*A*]on arrival at the router	context(faulty packets are dropped)	negated: False ,passive: True
0.882	[*A*]faulty packets[*R*]are dropped[*A*]into a register	context()	negated: False ,passive: True
0.775	[*A*]they[*R*]can be examined[*A*]by the local Monitor Processor[*A*]a register	context()	negated: False ,passive: True
[LINE#49] Faults may be caused by corruption in transit - indicated by parity and framing errors - or by being outdated.
0.894	[*A*]Faults[*R*]may be caused[*A*]by corruption in	context()	negated: False ,passive: True
[LINE#50] AER packet routing is done with a 1024 entry associative look-up table.
0.993	[*A*]AER packet routing[*R*]is done with[*A*]1024 entry associative look - up table	context()	negated: False ,passive: False
0.933	[*A*]AER packet routing[*R*]is done[*A*]with a 1024 entry associative look-up table	context()	negated: False ,passive: True
[LINE#51] Each table entry has its own bitmap mask that will be applied to the source address before it is compared with the table entries in order.
0.452	[*A*]it[*R*]is compared[*A*]with the table entries in order	context()	negated: False ,passive: True
0.644	[*A*]its own bitmap mask[*R*]will be applied[*A*]to the source address	context()	negated: False ,passive: True
0.812	[*A*]Each table entry[*R*]has[*A*]its own bitmap mask that will be applied to the source address	context()	negated: False ,passive: False
[LINE#52] If an address is not found then the packet is default routed to the port opposite the one it came from.
0.735	[*A*]the one[*R*]came[*A*]from	context()	negated: False ,passive: True
0.894	[*A*]default[*R*]routed[*A*]to the port opposite the one	context()	negated: False ,passive: True
0.925	[*A*]the packet[*R*]is[*A*]default routed to the port opposite the one	context()	negated: False ,passive: True
0.767	[*A*]an address[*R*]is not found[*A*]then	context()	negated: True ,passive: True
[LINE#53] Table entries are therefore only used when packets turn or bifurcate.
0.677	[*A*]packets[*R*]bifurcate	context()	negated: False ,passive: False
0.767	[*A*]packets[*R*]turn	context()	negated: False ,passive: False
0.859	[*A*]Table entries[*R*]are used[*A*]when packets turn or bifurcate	context()	negated: False ,passive: True
[LINE#54] Each table entry can be deactivated independently if not functioning properly; there is therefore some flexibility (potential redundancy) in the way table entries are used.
0.732	[*A*]table entries[*R*]are used	context()	negated: False ,passive: False
[LINE#55] As the table uses standard cell latches the soft error rate is expected to be very low.
0.727	[*A*]the soft error rate[*R*]is expected	context(As the table uses standard cell latches)	negated: False ,passive: False
0.946	[*A*]As the table uses standard cell[*R*]latches[*A*]the soft error rate is expected to be very low	context()	negated: False ,passive: False
0.771	[*A*]the soft error rate[*R*]to be[*A*]very low	context()	negated: False ,passive: True
0.903	[*A*]the table[*R*]uses[*A*]standard cell	context()	negated: False ,passive: False
[LINE#56] Packets may be replicated to any subset of the router's outputs.
0.713	[*A*]Packets[*R*]may be replicated	context()	negated: False ,passive: False
[LINE#57] They are sent when all the desired outputs are ready to accept them, stalling until this time.
0.838	[*A*]all the desired outputs[*R*]to accept[*A*]them	context()	negated: False ,passive: False
0.860	[*A*]all the desired outputs[*R*]are[*A*]ready to accept them	context()	negated: False ,passive: True
0.582	[*A*]They[*R*]are sent[*A*]when all the desired outputs are ready to accept them	context()	negated: False ,passive: True
[LINE#58] In the event of an output being blocked this could cause problems and backlog the router.
0.732	[*A*]an output[*R*]being blocked	context()	negated: False ,passive: False
[LINE#59] Thus, after a programmable interval, the router attempts to route around any blocked (or broken) external links through a so-called emergency route.
0.920	[*A*]the router[*R*]attempts to route[*A*]around any broken ) external links through a so - called emergency route	context(the router attempts)	negated: False ,passive: False
0.954	[*A*]the router[*R*]attempts[*A*]to route around any broken ) external links through a so - called emergency route[*A*]after a programmable interval	context()	negated: False ,passive: False
0.920	[*A*]the router[*R*]attempts to route[*A*]around any blocked ( external links through a so - called emergency route	context(the router attempts)	negated: False ,passive: False
0.954	[*A*]the router[*R*]attempts[*A*]to route around any blocked ( external links through a so - called emergency route[*A*]after a programmable interval	context()	negated: False ,passive: False
[LINE#60] If this still fails after another programmable interval the offending packet is dropped into a local register and the subsequent packet is tried instead.
0.783	[*A*]the subsequent packet[*R*]is tried[*A*]instead	context()	negated: False ,passive: True
0.911	[*A*]the offending packet[*R*]is dropped[*A*]into a local register	context()	negated: False ,passive: True
0.481	[*A*]this[*R*]fails[*A*]after another programmable interval[*A*]still	context()	negated: False ,passive: True
[LINE#61] The Monitor Processor may be interrupted to examine the dropped packet and resend it - perhaps suitably modified - later.
0.865	[*A*]The Monitor Processor[*R*]to resend[*A*]it[*A*]perhaps suitably modified - later	context()	negated: False ,passive: False
0.883	[*A*]The Monitor Processor[*R*]may be interrupted[*A*]to resend it - perhaps suitably modified - later	context()	negated: False ,passive: True
0.922	[*A*]The Monitor Processor[*R*]to examine[*A*]the dropped packet	context()	negated: False ,passive: False
0.933	[*A*]The Monitor Processor[*R*]may be interrupted[*A*]to examine the dropped packet	context()	negated: False ,passive: True
[LINE#62] Emergency routed packets take advantage of the triangular topology to try to reach their destinations, as shown in Fig. 8.
0.737	[*A*]Emergency routed packets[*R*]take advantage to try[*A*]to reach their destinations	context(Emergency routed packets take)	negated: False ,passive: False
0.838	[*A*]Emergency routed packets[*R*]take[*A*]advantage[*A*]of the triangular topology[*A*]to try to reach their destinations[*A*]as shown in Fig	context()	negated: False ,passive: False
[LINE#63] Emergency routes are always adjacent to the intended path and the subsequent turns are therefore predefined.
0.735	[*A*]Emergency routes[*R*]are[*A*]therefore predefined	context()	negated: False ,passive: True
0.903	[*A*]Emergency routes[*R*]are[*A*]always[*A*]adjacent to the intended path	context()	negated: False ,passive: True
[LINE#64] This is coded into the short packet header.
0.153	[*A*]This[*R*]is coded	context()	negated: False ,passive: False
[LINE#65] A particular concern is the possible occurrence of (network-level) deadlock.
0.956	[*A*]A particular concern[*R*]is[*A*]the possible occurrence of (network-level) deadlock	context()	negated: False ,passive: True
[LINE#66] Conventional HPC networks avoid the formation of such chains by means of complex combinations of topology, routing algorithms and flow-control techniques [18].
0.905	[*A*]complex combinations of topology[*R*]routing[*A*]flow - control techniques	context()	negated: False ,passive: False
0.957	[*A*]Conventional HPC networks[*R*]avoid[*A*]the formation of such chains by means of complex combinations of topology	context()	negated: False ,passive: False
0.875	[*A*]Conventional HPC networks[*R*]avoid the formation of such chains by means of complex combinations of topology routing[*A*]algorithms	context(Conventional HPC networks avoid)	negated: False ,passive: False
0.945	[*A*]Conventional HPC networks[*R*]avoid[*A*]the formation of such chains by means of complex combinations of topology[*A*]routing algorithms	context()	negated: False ,passive: False
[LINE#67] Given that routing is application specific a different approach to deadlock avoidance was required.
0.801	[*A*]a different approach to deadlock avoidance[*R*]was required	context()	negated: False ,passive: False
0.918	[*A*]routing[*R*]is[*A*]application specific	context()	negated: False ,passive: True
[LINE#68] As neural applications do not require delivery guarantees, a time-out based, packet-dropping mechanism suffices, provided that the proportion of lost packets is low. .
0.853	[*A*]the proportion of lost packets[*R*]is[*A*]low	context()	negated: False ,passive: True
0.775	[*A*]packet-dropping mechanism[*R*]suffices[*A*]provided that the proportion of lost packets is low	context()	negated: False ,passive: False
0.769	[*A*]a time-out[*R*]based	context()	negated: False ,passive: False
0.903	[*A*]neural applications[*R*]do not require[*A*]delivery guarantees	context()	negated: True ,passive: False
[LINE#69] Topological robustnessTo assess the robustness of the two-dimensional triangular torus topology we tested how it loses connectivity in the presence of link failures.
0.397	[*A*]it[*R*]loses[*A*]connectivity[*A*]in the presence of link failures	context(we tested)	negated: False ,passive: False
0.365	[*A*]we[*R*]tested[*A*]how it loses connectivity in the presence of link failures	context()	negated: False ,passive: False
0.953	[*A*]Topological robustnessTo[*R*]assess[*A*]the robustness of the two-dimensional triangular torus topology	context()	negated: False ,passive: False
[LINE#70] A typical manufacturing process can be expected to produce components with a functional life of well over 10 years.
0.896	[*A*]a functional life[*R*]has time of[*A*]over 10 years	context()	negated: False ,passive: False
0.905	[*A*]A typical manufacturing process[*R*]to produce[*A*]components	context()	negated: False ,passive: False
0.769	[*A*]A typical manufacturing process[*R*]can be expected	context()	negated: False ,passive: False
[LINE#71] With a very pessimistic scenario model of a 5-year mean time to failure (MTTF) with sigma of 2 years, the expected number of link failures in a complete SpiNNaker system (65,536 nodes) for any given day (Fday) would lie between 160 and 360.We contrasted SpiNNaker topology with regular two- and three-dimensional tori for 65,536 nodes.
[LINE#72] The 2-D topologies are arranged as square networks of 256256 nodes whereas the 3-D torus is arranged as a 643232 network.
0.992	[*A*]2 - d topologies[*R*]are arranged as[*A*]square networks of 256256 nodes whereas the 3 - D torus is arranged as a 643232 network	context()	negated: False ,passive: False
0.785	[*A*]the 3-D torus[*R*]is arranged	context()	negated: False ,passive: False
0.926	[*A*]The 2-D topologies[*R*]are arranged[*A*]as square networks of 256256 nodes	context()	negated: False ,passive: True
[LINE#73] We assessed how the three topologies lose node-connectivity as the number of link failures increases from 1 to 65,536.
0.891	[*A*]the three topologies[*R*]lose[*A*]node-connectivity	context(We assessed)	negated: False ,passive: False
0.514	[*A*]We[*R*]assessed[*A*]how the three topologies lose node-connectivity as the number of link failures increases from 1 to 65,536	context()	negated: False ,passive: False
[LINE#74] A depth-first search algorithm was used to calculate this figure for 105 random uniform failure configurations.
0.921	[*A*]A depth-first search algorithm[*R*]to calculate[*A*]this figure[*A*]for 105 random uniform failure configurations	context()	negated: False ,passive: False
0.956	[*A*]A depth-first search algorithm[*R*]was used[*A*]to calculate this figure for 105 random uniform failure configurations	context()	negated: False ,passive: True
[LINE#75]  The average of these 105 runs is plotted in Fig..
0.943	[*A*]The average of these 105 runs[*R*]is plotted[*A*]in Fig	context()	negated: False ,passive: True
[LINE#76] In the figure we can see that the triangular two-dimensional torus implemented in SpiNNaker provides a robustness level similar to a three-dimensional torus.
0.968	[*A*]the triangular two-dimensional torus implemented in SpiNNaker[*R*]provides[*A*]a robustness level similar to a three-dimensional torus	context(we can see)	negated: False ,passive: False
0.444	[*A*]we[*R*]can see[*A*]that the triangular two-dimensional torus implemented in SpiNNaker provides a robustness level similar to a three-dimensional torus[*A*]In the figure	context()	negated: False ,passive: False
0.943	[*A*]the triangular two-dimensional torus[*R*]implemented[*A*]in SpiNNaker	context()	negated: False ,passive: True
[LINE#77] Both topologies can support up to 8,192 random link failures without any of the nodes losing connectivity with the rest of the system, more than one order of magnitude above (Fday).
0.999	[*A*]Both topologies[*R*]can support[*A*]8192 random link failures	context()	negated: False ,passive: False
0.903	[*A*]the nodes[*R*]losing[*A*]connectivity[*A*]with the rest of the system	context()	negated: False ,passive: False
0.903	[*A*]Both topologies[*R*]can support[*A*]up to 8,192 random link failures	context()	negated: False ,passive: False
[LINE#78] On average tens of thousands of link failures are required to lose one or more nodes.
[LINE#79] This robustness motivates the use of the triangular torus topology in SpiNNaker. .
0.918	[*A*]This robustness[*R*]motivates[*A*]the use of the triangular torus topology in SpiNNaker	context()	negated: False ,passive: False
[LINE#80] Interconnect stability under severe degradationThe packet dropping mechanism provides a deadlock-free interconnection network.
0.921	[*A*]Interconnect stability under severe degradationThe packet[*R*]provides[*A*]a deadlock-free interconnection network	context()	negated: False ,passive: False
[LINE#81] However, there is a loss of information that has to be assessed.
0.677	[*A*]information[*R*]to be assessed	context()	negated: False ,passive: False
[LINE#82] Spiking neuron systems can work when a few messages are lost but, even in very pessimistic scenarios, the number of dropped packets should be low (below 1 packet per million.
0.957	[*A*]the number of dropped packets[*R*]should be[*A*]low ( below 1 packet per million[*A*]even in very pessimistic scenarios	context()	negated: False ,passive: True
0.751	[*A*]a few messages[*R*]are lost	context()	negated: False ,passive: False
0.911	[*A*]Spiking neuron systems[*R*]can work[*A*]when a few messages are lost	context()	negated: False ,passive: False
[LINE#83] Approximatelly 1 packet each 1,500 cycles in the following experiments).
[LINE#84+85]  Simulation has verified that the network can deal with loads well-above the expected without significantly impacting applications (packet delay is acceptable)[21].The simulations model a 256256 network considering scenarios in which the network suffers different levels of hard failures.
0.903	[*A*]The simulations[*R*]model[*A*]a 256256 network considering scenarios	context()	negated: False ,passive: False
0.802	[*A*]the network[*R*]can deal well[*A*]above the expected without significantly impacting applications	context(Simulation has verified packet delay is)	negated: False ,passive: False
0.843	[*A*]Simulation[*R*]has verified[*A*]that the network can deal with loads well-above the expected without significantly impacting applications	context(packet delay is)	negated: False ,passive: False
0.777	[*A*]packet delay[*R*]is[*A*]acceptable	context()	negated: False ,passive: True
0.943	[*A*]the network[*R*]suffers[*A*]different levels of hard failures[*A*]scenarios	context()	negated: False ,passive: False
0.943	[*A*]a 256256 network[*R*]considering[*A*]scenarios in which the network suffers different levels of hard failures	context()	negated: False ,passive: False
[LINE#86] To account for the real-time constraint, this section investigates the temporal evolution of the system and focuses on stability, understood as the variability (which should be low) of the figures of merit and assesses the effectiveness of the emergency routing mechanism..
0.735	[*A*]the variability[*R*]should be[*A*]low	context()	negated: False ,passive: True
0.903	[*A*]this section[*R*]investigates[*A*]the temporal evolution of the system	context()	negated: False ,passive: False
[LINE#87] Simulation model of the SpiNNaker networkA simplified model of the SpiNNaker interconnection infrastructure has been implemented in INSEE [19].
0.958	[*A*]Simulation model of the SpiNNaker networkA simplified model of the SpiNNaker interconnection infrastructure[*R*]has been implemented[*A*]in INSEE	context()	negated: False ,passive: True
0.957	[*A*]Simulation model of the SpiNNaker networkA[*R*]simplified[*A*]model of the SpiNNaker interconnection infrastructure	context()	negated: False ,passive: False
[LINE#88] It includes the topological description of the system and a model of the router.
0.452	[*A*]It[*R*]includes[*A*]a model of the router	context()	negated: False ,passive: True
0.452	[*A*]It[*R*]includes[*A*]the topological description of the system	context()	negated: False ,passive: True
[LINE#89] Time is modelled in terms of abstract network cycles the time to route and forward a packet (1 network cycle10 processor cycles).
0.771	[*A*]Time[*R*]is modelled	context()	negated: False ,passive: False
0.905	[*A*]Time[*R*]is modelled[*A*]the time to route	context()	negated: False ,passive: True
[LINE#90] A network node represents a complete SpiNNaker chip, with all its cores and its router.
0.925	[*A*]A network node[*R*]represents[*A*]a complete SpiNNaker chip	context()	negated: False ,passive: False
[LINE#91] Nodes are modelled as independent traffic sources that inject packets following a Bernoulli temporal distribution that can be parameterized to generate any chosen injection rate.
0.928	[*A*]a Bernoulli temporal distribution[*R*]can be parameterized[*A*]to generate any chosen injection rate	context()	negated: False ,passive: True
0.897	[*A*]independent traffic sources[*R*]inject[*A*]packets	context()	negated: False ,passive: False
0.894	[*A*]Nodes[*R*]are modelled[*A*]as independent traffic sources	context()	negated: False ,passive: True
[LINE#92] The spatial distribution of the traffic is uniform.
0.865	[*A*]The spatial distribution of the traffic[*R*]is[*A*]uniform	context()	negated: False ,passive: True
[LINE#93] All ports are modelled as a single four-packet queue.
0.903	[*A*]All ports[*R*]are modelled[*A*]as a single four-packet queue	context()	negated: False ,passive: True
[LINE#94] If this is full and the node tries to inject a packet, it is dropped.
0.881	[*A*]the node[*R*]tries to inject[*A*]a packet	context(the node tries it is dropped)	negated: False ,passive: False
0.881	[*A*]the node[*R*]tries[*A*]to inject a packet	context(it is dropped)	negated: False ,passive: False
0.195	[*A*]it[*R*]is dropped	context()	negated: False ,passive: False
0.223	[*A*]this[*R*]is[*A*]full	context()	negated: False ,passive: True
[LINE#95] Communications are point-to-point.
0.894	[*A*]Communications[*R*]are[*A*]point-to-point	context()	negated: False ,passive: True
[LINE#96] Routing tables are not implemented, using Dimension Order Routing instead.
0.903	[*A*]Routing tables[*R*]are not implemented[*A*]using Dimension Order Routing instead	context()	negated: True ,passive: True
[LINE#97] This emulates the expected shape of communications - two straight lines with one inflection point [20].
0.497	[*A*]This[*R*]emulates[*A*]the expected shape of communications - two straight lines with one inflection point [20	context()	negated: False ,passive: False
[LINE#98] As discussed in Section 5, the SpiNNaker system is aware of network failures and can modify its routing tables to avoid conflictive areas.
0.915	[*A*]the SpiNNaker system[*R*]can modify its routing tables to avoid[*A*]conflictive areas	context(the SpiNNaker system can modify)	negated: False ,passive: False
0.853	[*A*]the SpiNNaker system[*R*]can modify[*A*]its routing tables[*A*]to avoid conflictive areas	context()	negated: False ,passive: False
0.949	[*A*]the SpiNNaker system[*R*]is[*A*]aware of network failures	context()	negated: False ,passive: True
[LINE#99] In contrast, DOR is oblivious and therefore unaware of network failures so our results should be taken as pessimisticThe experiments consider systems with 0 to 1024 link failures which covers scenarios well above Fday (as discussed before).
0.887	[*A*]DOR[*R*]is[*A*]therefore unaware of network failures	context()	negated: False ,passive: True
0.913	[*A*]0 to 1024 link failures[*R*]covers[*A*]scenarios	context()	negated: False ,passive: True
0.903	[*A*]pessimisticThe experiments[*R*]consider[*A*]systems	context()	negated: False ,passive: False
0.872	[*A*]DOR[*R*]is[*A*]oblivious[*A*]so our results should be taken as pessimisticThe experiments consider systems with 0 to 1024 link failures	context()	negated: False ,passive: True
[LINE#100] Consequently this evaluation should be understood as a worst-case study. .
0.903	[*A*]this evaluation[*R*]should be understood[*A*]as a worst-case study	context()	negated: False ,passive: True
[LINE#101] Experiments and discussion of resultsIn the following experimental work, we will use the maximum network load expected during regular operational levels of SpiNNaker which was derived in previous research [21].
[LINE#102] We show the evolution of a SpiNNaker network degrading progressively from 0 to 1024 random link failures which are introduced at the beginning of every sampling period (5,000 cycles).
0.905	[*A*]1024 random link failures[*R*]are introduced[*A*]at the beginning of every sampling period	context()	negated: False ,passive: True
0.933	[*A*]a SpiNNaker network[*R*]degrading progressively[*A*]from 0 to 1024 random link failures	context()	negated: False ,passive: True
0.568	[*A*]We[*R*]show[*A*]the evolution of a SpiNNaker network	context()	negated: False ,passive: False
[LINE#103] The figures of interest are accepted load, number of dropped packets and packet latency figures (average and maximum).
[LINE#104] Router parameters are fixed to the values suggested by previous experiments [21].
0.903	[*A*]the values[*R*]suggested[*A*]by previous experiments	context()	negated: False ,passive: True
0.903	[*A*]Router parameters[*R*]are fixed[*A*]to the values	context()	negated: False ,passive: True
[LINE#105+106]  To assess the impact of emergency routing on system stability, we plot results without (Fig. 10a) and with this mechanism (Fig.10b).To better understand the graphs, notice that the X-axis measures time (cycles).
0.108	[*A*]we[*R*]plot results with this mechanism notice	context(we plot)	negated: False ,passive: False
0.293	[*A*]we[*R*]plot results with this mechanism To better understand[*A*]the graphs	context(we plot)	negated: False ,passive: False
0.457	[*A*]we[*R*]plot[*A*]results with this mechanism	context()	negated: False ,passive: False
0.108	[*A*]we[*R*]plot results without ( Fig . 10a notice	context(we plot)	negated: False ,passive: False
0.293	[*A*]we[*R*]plot results without ( Fig . 10a To better understand[*A*]the graphs	context(we plot)	negated: False ,passive: False
0.503	[*A*]we[*R*]plot[*A*]results without ( Fig . 10a	context()	negated: False ,passive: False
[LINE#107] The labels at the top (1, 2, 4,,1024) indicate the total number of failures at the corresponding time: during the first 5 kcycles the network is fully operative, from 5k to 10k there is a single link failure, from 10k to 15k there are two failures, and so on.
[LINE#108+109]  Each performance metric has its own unit, indicated in the Y-axes:packets (for the dropped packets line), cycles (for the average and maximum delay lines) and packets/cycle/node (for the accepted load line).
0.367	[*A*]its own unit[*R*]indicated[*A*]in the	context()	negated: False ,passive: True
0.881	[*A*]Each performance metric[*R*]has[*A*]its own unit, indicated in the	context()	negated: False ,passive: False
[LINE#110] Note that plotted data, including the number of dropped packets, are not cumulative, but correspond to 10-cycle measurement periods.
[LINE#111] 10(a) shows how the progressive introduction of failures results in a high variability of performance metrics when emergency routing is not activated.
0.732	[*A*]emergency routing[*R*]is not activated	context()	negated: True ,passive: False
0.682	[*A*]10[*R*]shows[*A*]how the progressive introduction of failures results in a high variability of performance metrics	context()	negated: False ,passive: False
[LINE#112+113]  Accepted load drops by up to 25%, maximum delay noticeably fluctuates and the number of dropped packets grows linearly with the number of link failures.
0.926	[*A*]the number of dropped packets[*R*]grows linearly[*A*]with the number of link failures	context()	negated: False ,passive: True
0.732	[*A*]maximum delay[*R*]noticeably fluctuates	context()	negated: False ,passive: False
[LINE#114] For clarity, in the graphs the Y-axis is bounded by 0 and 500, which leaves out the number of dropped packets for 512 failures (around 800) and 1024 failures (around 1600).
0.503	[*A*]500[*R*]leaves out[*A*]the number of dropped packets[*A*]for 512 1024 failures	context()	negated: False ,passive: False
0.503	[*A*]500[*R*]leaves out[*A*]the number of dropped packets[*A*]for 512 failures	context()	negated: False ,passive: False
0.342	[*A*]0[*R*]leaves out[*A*]the number of dropped packets[*A*]for 512 1024 failures	context()	negated: False ,passive: False
0.342	[*A*]0[*R*]leaves out[*A*]the number of dropped packets[*A*]for 512 failures	context()	negated: False ,passive: False
[LINE#115] We can see that even with a single failure the system with emergency routing deactivated (approx. 1 packet dropped every 50 cycles) noticeably exceeds the acceptable limit.
0.867	[*A*]packet[*R*]dropped[*A*]every 50 cycles	context(We can see)	negated: False ,passive: True
0.271	[*A*]We[*R*]can see[*A*]that even with a single failure the system with emergency routing deactivated (approx. 1 packet dropped every 50 cycles	context()	negated: False ,passive: False
0.927	[*A*]approx[*R*]exceeds[*A*]the acceptable limit[*A*]noticeably	context()	negated: False ,passive: False
0.732	[*A*]emergency routing[*R*]deactivated	context()	negated: False ,passive: False
[LINE#116+117]  In contrast, evolution with the emergency routing activated, Fig.10(b), shows very stable performance metrics.
0.968	[*A*]evolution with the emergency routing activated, Fig.10(b[*R*]shows[*A*]very stable performance metrics	context()	negated: False ,passive: False
[LINE#118] Only some minor peaks in the maximum delay can be observed.
0.830	[*A*]Only some minor peaks in the maximum delay[*R*]can be observed	context()	negated: False ,passive: False
[LINE#119+120]  The most remarkable difference is in the number of dropped packets:no packets are dropped for experiments with fewer than 512 failures.
0.937	[*A*]The most remarkable difference[*R*]is[*A*]in the number of dropped packets:no packets	context()	negated: False ,passive: True
[LINE#121] Considering that these scenarios are well beyond the described pessimistic range of failures (160-360), we can confirm that the emergency routing plays a major role in improving fault tolerance at the network level.
0.927	[*A*]the emergency routing[*R*]plays[*A*]a major role in improving fault tolerance at the network level	context(we can confirm)	negated: False ,passive: False
0.271	[*A*]we[*R*]can confirm[*A*]that the emergency routing plays a major role in improving fault tolerance at the network level	context()	negated: False ,passive: False
[LINE#122] It is also worth noticing that, in all cases, when failures are introduced in the system we do not observe significant transient periods.
0.452	[*A*]we[*R*]do not observe[*A*]significant transient periods	context()	negated: True ,passive: False
0.894	[*A*]failures[*R*]are introduced[*A*]in the system	context()	negated: False ,passive: True
0.285	[*A*]It[*R*]is[*A*]also[*A*]worth noticing that, in all cases	context()	negated: False ,passive: True
[LINE#123] This means that, after a failure, the system reaches a stable situation very rapidly.
0.879	[*A*]the system[*R*]reaches very rapidly[*A*]after a failure	context(This means)	negated: False ,passive: False
0.224	[*A*]This[*R*]means[*A*]that, after a failure, the system reaches a stable situation very rapidly	context()	negated: False ,passive: False
[LINE#124] The conclusion is that the SpiNNaker interconnection network provides a highly stable communications fabric for the real-time simulation of spiking neurons.
0.952	[*A*]the SpiNNaker interconnection network[*R*]provides[*A*]a highly stable communications fabric for the real-time simulation of spiking neurons	context(The conclusion is)	negated: False ,passive: False
0.875	[*A*]The conclusion[*R*]is[*A*]that the SpiNNaker interconnection network provides a highly stable communications fabric for the real-time simulation of spiking neurons	context()	negated: False ,passive: True
[LINE#125] Even under very pessimistic scenarios the interconnection network does not show significant performance fluctuations and degrades gracefully. .
0.911	[*A*]the interconnection network[*R*]does not show[*A*]significant performance	context()	negated: True ,passive: False
0.909	[*A*]the interconnection network[*R*]does not show gracefully[*A*]Even under very pessimistic scenarios	context()	negated: True ,passive: False
[LINE#126+127]  interfacesThe self-timed communication fabric is implemented using handshake protocols because of their advantages for large networks:Chips can be interconnected without regard to wiring delays which simplifies machine construction as some chips will be adjacent on a PCBwhilst others may require considerable cabling or buffering with potential for delays and skew.Power economy by limiting logic transitions (no clock information is transmitted).Adequately high speed is retained.Well suited to short, intermittent transmissions - appropriate for neural communications.
0.953	[*A*]Adequately high speed[*R*]is[*A*]retained.Well suited to short, intermittent transmissions - appropriate for neural communications	context(wiring delays simplifies)	negated: False ,passive: True
0.858	[*A*]wiring delays[*R*]simplifies[*A*]machine construction	context()	negated: False ,passive: False
0.751	[*A*]no clock information[*R*]is transmitted	context()	negated: False ,passive: False
0.944	[*A*]can be interconnected without regard to wiring delays[*R*]will be[*A*]adjacent on a PCBwhilst others	context()	negated: False ,passive: True
[LINE#128] There is, however, a significant drawback to handshaking links: in the presence of noise they are prone to deadlock.
0.741	[*A*]they[*R*]are[*A*]prone to deadlock[*A*]in the presence of noise	context()	negated: False ,passive: True
[LINE#129] In this subsection these are deadlocks at the interface level, not to be confused with the previously discussed network-level deadlocks.
0.681	[*A*]these[*R*]are[*A*]deadlocks at the interface level[*A*]In this subsection	context()	negated: False ,passive: True
[LINE#130] A handshake link can be thought of as passing a data token from the sender to the receiver which the handshake returns so that the next data can be sent.
0.751	[*A*]the next data[*R*]can be sent	context()	negated: False ,passive: False
0.934	[*A*]the receiver[*R*]returns[*A*]the handshake	context()	negated: False ,passive: True
0.903	[*A*]a data[*R*]token[*A*]from the sender to the receiver	context()	negated: False ,passive: True
0.911	[*A*]A handshake link[*R*]can be thought[*A*]of as passing a data	context()	negated: False ,passive: True
[LINE#131+132]  Noise on the link may not only corrupt the data but alsothis control information, removing or introducing other tokens so that the sender and receiver lose coherence.
0.919	[*A*]the sender and receiver[*R*]lose[*A*]coherence	context()	negated: False ,passive: False
[LINE#133] In the most serious case, a lost token can result in each waiting for the other and the data link cannot recover.
0.751	[*A*]the data link[*R*]can not recover	context()	negated: True ,passive: False
0.948	[*A*]a lost token[*R*]can result[*A*]in each waiting for the other[*A*]In the most serious case	context()	negated: False ,passive: True
[LINE#134] Timeout is not possible as there is no concept of time, only sequencing.
0.821	[*A*]Timeout[*R*]is not[*A*]possible[*A*]as there is no concept of time[*A*]only sequencing	context()	negated: True ,passive: True
[LINE#135]  The on-chip network uses Silistix CHAIN [23] interconnection with 3-of-6 return-to-zero (RTZ).
0.937	[*A*]The on-chip network[*R*]uses[*A*]Silistix CHAIN	context()	negated: False ,passive: False
[LINE#136] This provides a convenient symbol set with 20 codes of which 16 are used.
0.260	[*A*]16[*R*]are used	context()	negated: False ,passive: False
0.800	[*A*]a convenient symbol[*R*]set	context()	negated: False ,passive: False
0.381	[*A*]This[*R*]provides[*A*]a convenient symbol set with 20 codes of which	context()	negated: False ,passive: False
[LINE#137] A separate channel provides an End-of-Packet (EoP) marker.
0.952	[*A*]A separate channel[*R*]provides[*A*]an End-of-Packet (EoP) marker	context()	negated: False ,passive: False
[LINE#138] The inter-chip links use a different protocol to balance speed, pin usage and (particularly) power consumption.
0.868	[*A*]The inter-chip links[*R*]use a different protocol to balance[*A*]particularly ) power consumption	context(The inter-chip links use)	negated: False ,passive: False
0.888	[*A*]The inter-chip links[*R*]use[*A*]a different protocol[*A*]to balance ( particularly ) power consumption	context()	negated: False ,passive: False
0.888	[*A*]The inter-chip links[*R*]use a different protocol to balance[*A*]pin usage	context(The inter-chip links use)	negated: False ,passive: False
0.888	[*A*]The inter-chip links[*R*]use[*A*]a different protocol[*A*]to balance pin usage	context()	negated: False ,passive: False
0.888	[*A*]The inter-chip links[*R*]use a different protocol to balance[*A*]speed	context(The inter-chip links use)	negated: False ,passive: False
0.888	[*A*]The inter-chip links[*R*]use[*A*]a different protocol[*A*]to balance speed	context()	negated: False ,passive: False
[LINE#139] Each four bit token is encoded as a 2-of-7 code (21 possible codes of which 17 are used: 4 bits plus EoP [24]).
0.992	[*A*]four bit token[*R*]is encoded as[*A*]a 2 of 7 code	context()	negated: False ,passive: False
0.299	[*A*]of which 17[*R*]are used	context()	negated: False ,passive: False
0.769	[*A*]Each four bit token[*R*]is encoded	context()	negated: False ,passive: False
[LINE#140] To reduce the number of transitions a non-return-to-zero (NRZ) coding is used.
0.845	[*A*]a non-return-to-zero (NRZ) coding[*R*]is used	context()	negated: False ,passive: False
0.698	[*A*]a non-return-to-zero[*R*]coding	context()	negated: False ,passive: False
[LINE#141] Noise glitches on the inter-chip wires introduce extra transitions, potentially in both the forward and return paths; these must be detected and recovered from at each end of the link.
0.911	[*A*]Noise glitches on the inter-chip wires[*R*]introduce potentially[*A*]extra transitions	context(these must be recovered)	negated: False ,passive: False
0.479	[*A*]these[*R*]must be recovered[*A*]from at each end of the link	context()	negated: False ,passive: True
0.914	[*A*]Noise glitches on the inter-chip wires[*R*]introduce potentially[*A*]extra transitions	context(these must be detected)	negated: False ,passive: False
0.219	[*A*]these[*R*]must be detected	context()	negated: False ,passive: False
[LINE#142] The off-chip wiring is the most likely place for noise to be induced and it is assumed that such noise will cause a short glitch (i.e. two extra transitions) on a wire.
0.945	[*A*]the most likely place[*R*]to be induced[*A*]noise	context()	negated: False ,passive: True
0.943	[*A*]The off - chip wiring[*R*]is[*A*]the most likely place for noise to be induced	context()	negated: False ,passive: True
[LINE#143] Glitches will be reasonably uncommon, therefore data integrity is not addressed in hardware; detection of damaged packets can be delegated to system software if any recovery is to be attempted.
0.905	[*A*]detection of damaged packets[*R*]to system[*A*]software	context()	negated: False ,passive: False
0.698	[*A*]any recovery[*R*]to be attempted	context()	negated: False ,passive: False
0.813	[*A*]any recovery[*R*]is[*A*]to be attempted	context()	negated: False ,passive: True
[LINE#144] The hardware simply has to keep running.
0.698	[*A*]The hardware[*R*]running	context()	negated: False ,passive: False
0.735	[*A*]The hardware[*R*]to keep[*A*]running	context()	negated: False ,passive: False
[LINE#145]  The majority of the fault tolerance resides in the receiver (Fig. 11) where various stages filter out potential problems.NRZ to RTZ Conversion:.
0.932	[*A*]The majority of the fault tolerance[*R*]resides[*A*]in the receiver	context()	negated: False ,passive: False
[LINE#146] The problem for the first stage of the receiver is that it may not know the level of an input wire at its reset time.
0.365	[*A*]it[*R*]may not know[*A*]the level of an input wire at its reset time	context(The problem for the first stage of the receiver is)	negated: True ,passive: False
0.861	[*A*]The problem for the first stage of the receiver[*R*]is[*A*]that it may not know the level of an input wire at its reset time	context()	negated: False ,passive: True
[LINE#147] This is overcome using a phase converter comprising two parallel RS flip-flops (Fig. 12) which acts as a transition detector which is set by one or more input transitions.
0.897	[*A*]a transition detector[*R*]is set[*A*]by one or more input transitions	context()	negated: False ,passive: True
0.954	[*A*]two parallel RS flip-flops[*R*]acts[*A*]as a transition detector	context()	negated: False ,passive: False
0.153	[*A*]This[*R*]is overcome	context()	negated: False ,passive: False
[LINE#148] It is cleared locally between the detection of a symbol and its external acknowledgement.
0.418	[*A*]It[*R*]is cleared[*A*]locally[*A*]between the detection of a symbol and its external acknowledgement	context()	negated: False ,passive: True
[LINE#149] Two transitions are made per symbol.
0.732	[*A*]Two transitions[*R*]are made	context()	negated: False ,passive: False
[LINE#150]  When at least two such phase converters are set, it is assumed that an input flit has been captured and passed to the next stage.2-of-7 to 3-of-6 Conversion:.
0.801	[*A*]at least two such phase converters[*R*]are set	context()	negated: False ,passive: False
[LINE#151] The flit is then searched by the symbol converter (Fig. 13) using an asynchronous state machine with Muller C-elements [25,26].
0.916	[*A*]The flit[*R*]is searched[*A*]by the symbol converter[*A*]then	context()	negated: False ,passive: True
[LINE#152] In the absence of errors exactly one of these will be set but a glitch may have set more.
0.767	[*A*]a glitch[*R*]may have set[*A*]more	context()	negated: False ,passive: False
0.683	[*A*]one of these[*R*]will be set[*A*]In the absence of errors	context()	negated: False ,passive: True
[LINE#153] The output is therefore filtered with a priority encoder based on mutual exclusion elements which chooses a single, legal, 'one-hot' code.
0.933	[*A*]mutual exclusion elements[*R*]chooses[*A*]a single, legal, 'one-hot' code	context()	negated: False ,passive: False
0.911	[*A*]a priority encoder[*R*]based[*A*]on mutual exclusion elements	context()	negated: False ,passive: True
0.859	[*A*]The output[*R*]is filtered[*A*]with a priority encoder	context()	negated: False ,passive: True
[LINE#154] There is no attempt to choose the 'correct' code - that information is not available - but any legal code will prevent a deadlock.
0.911	[*A*]any legal code[*R*]will prevent[*A*]a deadlock	context()	negated: False ,passive: False
0.749	[*A*]information[*R*]is not[*A*]available	context()	negated: True ,passive: True
[LINE#155] It is then a simple matter to generate a 3-of-6 code with an auxiliary EoP line appropriate for the NoC.Flit Counter: Glitches can easily insert extra flits into a packet but it is important that no packet exceeds a maximum length.
0.457	[*A*]It[*R*]is[*A*]then[*A*]a simple matter	context(Glitches can easily insert)	negated: False ,passive: True
0.898	[*A*]Glitches[*R*]can easily insert[*A*]extra flits[*A*]into a packet	context()	negated: False ,passive: False
[LINE#156+157]  A flit counter is added to keep track of the number of flitsand, if it exceeds a given threshold an extra EoP is inserted, notifying explicitly a framing error.
0.803	[*A*]an extra EoP[*R*]is inserted	context()	negated: False ,passive: False
0.397	[*A*]it[*R*]exceeds a given threshold an extra EoP is inserted, notifying[*A*]explicitly a framing error	context(it exceeds)	negated: False ,passive: False
0.443	[*A*]it[*R*]exceeds[*A*]a given threshold an extra EoP is inserted,	context()	negated: False ,passive: False
0.897	[*A*]A flit counter[*R*]to keep[*A*]track of the number of flitsand	context()	negated: False ,passive: False
0.911	[*A*]A flit counter[*R*]is added[*A*]to keep track of the number of flitsand	context()	negated: False ,passive: True
[LINE#158] The counter is reset on reception of an EoP.Transmitter: The only external input is the handshake acknowledge line.
[LINE#159] A phase converter detects at least one transition and treats that as the acknowledgement, further transitions being ignored until sending the next flit.
0.877	[*A*]transitions[*R*]until sending[*A*]the next flit	context()	negated: False ,passive: False
0.773	[*A*]A phase[*R*]treats[*A*]that[*A*]as the acknowledgement[*A*]further transitions being ignored until sending the next flit	context()	negated: False ,passive: False
0.911	[*A*]A phase converter[*R*]detects[*A*]at least one transition	context()	negated: False ,passive: False
[LINE#160] When a transmitter is reset its state is 'ready to send'.
0.305	[*A*]its state[*R*]to send	context()	negated: False ,passive: False
0.777	[*A*]its state[*R*]is[*A*]ready to send[*A*]When a transmitter is reset	context()	negated: False ,passive: True
0.732	[*A*]a transmitter[*R*]is reset	context()	negated: False ,passive: False
[LINE#161] Similarly, when a receiver is reset it sends an acknowledgement.
0.661	[*A*]it[*R*]sends[*A*]an acknowledgement[*A*]when a receiver is reset	context()	negated: False ,passive: False
0.698	[*A*]a receiver[*R*]reset	context()	negated: False ,passive: False
0.813	[*A*]a receiver[*R*]is[*A*]reset	context()	negated: False ,passive: True
[LINE#162+163]  If the reset occurred during reception this enables the transmitter to send again butif no acknowledgement was outstanding then there is a spurious transition which is filtered by the transmitter.
0.897	[*A*]a spurious transition[*R*]is filtered[*A*]by the transmitter	context()	negated: False ,passive: True
0.767	[*A*]the transmitter[*R*]to send[*A*]again	context()	negated: False ,passive: True
0.381	[*A*]this[*R*]enables[*A*]the transmitter[*A*]to send again butif no acknowledgement was outstanding	context()	negated: False ,passive: False
0.903	[*A*]the reset[*R*]occurred[*A*]during reception	context()	negated: False ,passive: True
[LINE#164] The glitch tolerance automatically provides a simple, robust, single-ended reset capability which means that a node may be reset independently and still recover communication with its neighbours..
0.819	[*A*]a node[*R*]may recover[*A*]communication with its neighbours[*A*]still	context(a simple , robust , single - ended reset capability means)	negated: False ,passive: False
0.807	[*A*]a simple , robust , single - ended reset capability[*R*]means[*A*]that a node may still recover communication with its neighbours	context()	negated: False ,passive: False
0.765	[*A*]The glitch tolerance[*R*]automatically provides[*A*]a simple , robust , single - ended reset capability which means that a node may still recover communication with its neighbours	context()	negated: False ,passive: False
0.678	[*A*]a node[*R*]may be reset independently	context(a simple , robust , single - ended reset capability means)	negated: False ,passive: False
0.827	[*A*]a simple , robust , single - ended reset capability[*R*]means[*A*]that a node may be reset independently	context()	negated: False ,passive: False
0.857	[*A*]The glitch tolerance[*R*]automatically provides[*A*]a simple , robust , single - ended reset capability which means that a node may be reset independently	context()	negated: False ,passive: False
[LINE#165] Performance assessmentOur novel fault tolerant interface was compared with a conventional unit.
0.949	[*A*]Performance assessmentOur novel fault tolerant interface[*R*]was compared[*A*]with a conventional unit	context()	negated: False ,passive: True
[LINE#166] Both circuits were simulated in Verilog handling roughly a million packets each in an extremely noisy environment in which packets have a 50% probability of being affected by a glitch.
0.960	[*A*]packets[*R*]have[*A*]a 50% probability of being affected by a glitch[*A*]an extremely noisy environment	context()	negated: False ,passive: False
0.887	[*A*]Both circuits[*R*]handling[*A*]roughly a million packets each[*A*]in an extremely noisy environment	context()	negated: False ,passive: False
0.947	[*A*]Both circuits[*R*]were simulated[*A*]in Verilog[*A*]handling roughly a million packets each in an extremely noisy environment	context()	negated: False ,passive: True
[LINE#167] This noise level is exceedingly high and thus the number of packets corrupted should not be a concern.
0.905	[*A*]the number of packets[*R*]should not be[*A*]a concern	context()	negated: True ,passive: True
0.713	[*A*]packets[*R*]corrupted	context()	negated: False ,passive: False
0.828	[*A*]This noise level[*R*]is[*A*]exceedingly high	context()	negated: False ,passive: True
[LINE#168] Results of these simulations are shown in Table 2.
0.931	[*A*]Results of these simulations[*R*]are shown[*A*]in Table 2	context()	negated: False ,passive: True
[LINE#169] Glitches represents the actual packet ratio affected by a glitch.
0.919	[*A*]the actual packet ratio[*R*]affected[*A*]by a glitch	context()	negated: False ,passive: True
0.894	[*A*]Glitches[*R*]represents[*A*]the actual packet ratio affected by a glitch	context()	negated: False ,passive: False
[LINE#170] Error-free Packets represents the percentage of the packets affected by a glitch that were interpreted correctly i.e., those that have resisted the glitch; Deadlocks represents the percentage of packets affected by a glitch that deadlocked the interface.
0.206	[*A*]those[*R*]have resisted[*A*]the glitch	context()	negated: False ,passive: False
0.698	[*A*]a glitch[*R*]were interpreted correctly	context()	negated: False ,passive: False
0.903	[*A*]the packets[*R*]affected[*A*]by a glitch	context()	negated: False ,passive: True
0.894	[*A*]packets[*R*]affected[*A*]by a glitch	context()	negated: False ,passive: True
0.915	[*A*]Error-free Packets[*R*]represents[*A*]the percentage of the packets affected by a glitch that were interpreted correctly i.e., those that have resisted the glitch; Deadlocks represents the percentage of packets	context()	negated: False ,passive: False
[LINE#171] As expected our design did not deadlock whereas a conventional unit deadlocked roughly 2% of the times that a glitch appears.
0.934	[*A*]the times[*R*]appears[*A*]a glitch	context()	negated: False ,passive: True
[LINE#172] This is very significant as a single deadlock has the potential to cripple a link permanently (until the whole system is rebooted).
0.751	[*A*]the whole system[*R*]is rebooted	context()	negated: False ,passive: False
0.909	[*A*]a single deadlock[*R*]has permanently[*A*]the potential to cripple a link	context()	negated: False ,passive: False
0.567	[*A*]This[*R*]is[*A*]very significant[*A*]as a single deadlock has the potential to cripple a link permanently (until the whole system is rebooted	context()	negated: False ,passive: True
[LINE#173] Given the communication-intensive application model supported by SpiNNaker this would mean a network becoming highly degraded very quickly if glitches appeared.
0.824	[*A*]a network[*R*]becoming very quickly[*A*]if glitches appeared	context(this would mean)	negated: False ,passive: True
0.432	[*A*]this[*R*]would mean[*A*]a network becoming highly degraded very quickly if glitches appeared	context()	negated: False ,passive: False
0.713	[*A*]glitches[*R*]appeared	context()	negated: False ,passive: False
0.943	[*A*]the communication-intensive application model[*R*]supported[*A*]by SpiNNaker	context()	negated: False ,passive: True
[LINE#174] The price of the deadlock-free interface is that glitches alter the received data roughly 10% more often.
0.871	[*A*]glitches[*R*]alter[*A*]the received data[*A*]roughly 10% more often	context(The price of the deadlock - free interface is)	negated: False ,passive: False
0.912	[*A*]The price of the deadlock-free interface[*R*]is[*A*]that glitches alter the received data roughly 10% more often	context()	negated: False ,passive: True
[LINE#175] This is acceptable as glitches should be rare and erroneous packets can be detected and dropped. .
0.749	[*A*]glitches[*R*]should be[*A*]erroneous	context()	negated: False ,passive: True
0.449	[*A*]This[*R*]is[*A*]acceptable[*A*]as glitches should be erroneous	context()	negated: False ,passive: True
0.749	[*A*]glitches[*R*]should be[*A*]rare	context()	negated: False ,passive: True
0.449	[*A*]This[*R*]is[*A*]acceptable[*A*]as glitches should be rare	context()	negated: False ,passive: True
0.687	[*A*]acceptable packets[*R*]can be detected	context(This is)	negated: False ,passive: False
0.395	[*A*]This[*R*]is[*A*]acceptable packets can be detected	context()	negated: False ,passive: True
[LINE#176] asynchronous on-chip links are much less sensitive to noise-induced glitches, so they employ simpler logic.
0.926	[*A*]asynchronous on-chip links[*R*]are[*A*]much less sensitive to noise-induced glitches	context()	negated: False ,passive: True
[LINE#177] However the potential for deadlock with handshake communications still applies.
0.889	[*A*]the potential for deadlock with handshake communications[*R*]applies[*A*]still	context()	negated: False ,passive: True
[LINE#178] To alleviate this intra-chip interfaces are provided with two levels of reset (soft and hard).
0.911	[*A*]this intra-chip interfaces[*R*]are provided[*A*]with two levels of reset ( hard	context()	negated: False ,passive: True
0.911	[*A*]this intra-chip interfaces[*R*]are provided[*A*]with two levels of reset ( soft	context()	negated: False ,passive: True
[LINE#179] Watchdog will apply soft reset first and if this does not solve the problem, it will perform a hard reset of the entire node, thus disrupting chip operation - but not deadlocking the on-chip network.
0.452	[*A*]it[*R*]will perform[*A*]a hard reset of the entire node[*A*]not deadlocking the on - chip network	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]will perform[*A*]a hard reset of the entire node[*A*]thus disrupting chip operation	context()	negated: False ,passive: False
0.381	[*A*]this[*R*]does not solve[*A*]the problem	context()	negated: True ,passive: False
0.920	[*A*]Watchdog[*R*]will apply[*A*]soft reset[*A*]first	context()	negated: False ,passive: False
[LINE#180] Diagnostics and dynamic configurationSystem routines can clearly be split into two: (i) power-on testing and initial configuration, and (ii) isolation and reconfiguration during normal operation.
0.783	[*A*]dynamic configurationSystem routines[*R*]can clearly be split[*A*]into two	context()	negated: False ,passive: True
0.749	[*A*]Diagnostics[*R*]can clearly be split[*A*]into two	context()	negated: False ,passive: True
[LINE#181]  In either case, the interaction between hardware and system software in each chip is coordinated by the Monitor Processor which maintains a continuously updated state (good, fault, disabled, etc.).
0.922	[*A*]the Monitor Processor[*R*]maintains[*A*]a continuously updated state (good	context()	negated: False ,passive: False
0.977	[*A*]the interaction between hardware and system software in each chip[*R*]is coordinated[*A*]by the Monitor Processor[*A*]In either case	context()	negated: False ,passive: True
[LINE#182] The System Controller can disable or reconfigure chip components.
0.922	[*A*]The System Controller[*R*]reconfigure[*A*]chip components	context()	negated: False ,passive: False
0.803	[*A*]The System Controller[*R*]can disable	context()	negated: False ,passive: False
[LINE#183] In extreme failure cases the System Controller can be accessed from a neighbouring SpiNNaker chip using a local debug facility..
0.922	[*A*]the System Controller[*R*]using[*A*]a local debug facility	context()	negated: False ,passive: False
0.954	[*A*]the System Controller[*R*]can be accessed[*A*]In extreme failure cases	context()	negated: False ,passive: True
[LINE#184] -on diagnostics and configurationEach SpiNNaker chip performs diagnostics and initialization using minimal system software stored in the Boot ROM.
0.925	[*A*]minimal system software[*R*]stored[*A*]in the Boot ROM	context()	negated: False ,passive: True
0.933	[*A*]configurationEach SpiNNaker chip[*R*]performs[*A*]initialization	context()	negated: False ,passive: False
0.933	[*A*]configurationEach SpiNNaker chip[*R*]performs[*A*]diagnostics	context()	negated: False ,passive: False
[LINE#185] In this stage each processing core performs a power-on self-test and initialisation of its private peripherals.
0.941	[*A*]each processing core[*R*]performs[*A*]power - on self - test and initialisation of its private peripherals[*A*]In this stage	context()	negated: False ,passive: False
0.909	[*A*]each processing core[*R*]performs[*A*]a and initialisation of its private peripherals[*A*]In this stage	context()	negated: False ,passive: False
[LINE#186] Healthy cores then compete to access the System Controller monitor election register, the winner becoming the Monitor Processor.
0.879	[*A*]Healthy cores[*R*]compete to access[*A*]the System Controller monitor election register	context(Healthy cores compete)	negated: False ,passive: False
0.929	[*A*]Healthy cores[*R*]compete[*A*]to access the System Controller monitor election register[*A*]then	context()	negated: False ,passive: False
0.918	[*A*]the winner[*R*]becoming[*A*]the Monitor Processor	context()	negated: False ,passive: True
[LINE#187] The remaining cores simply register their state in the System Controller and stall until the Monitor completes the node configuration (including detailed chip-level tests, initialising shared resources and detecting any connected Ethernet port).
0.913	[*A*]detailed chip - level tests[*R*]detecting[*A*]any connected Ethernet port	context()	negated: False ,passive: False
0.913	[*A*]detailed chip - level tests[*R*]initialising[*A*]shared resources	context()	negated: False ,passive: False
0.953	[*A*]the Monitor[*R*]completes[*A*]the node configuration ( including detailed chip - level tests	context()	negated: False ,passive: False
0.813	[*A*]The remaining cores[*R*]register their state detecting[*A*]any connected Ethernet port	context(The remaining cores register)	negated: False ,passive: False
0.813	[*A*]The remaining cores[*R*]register[*A*]their state[*A*]in the System Controller[*A*]detecting any connected Ethernet port	context()	negated: False ,passive: False
0.813	[*A*]The remaining cores[*R*]register their state initialising[*A*]shared resources	context(The remaining cores register)	negated: False ,passive: False
0.813	[*A*]The remaining cores[*R*]register[*A*]their state[*A*]in the System Controller	context()	negated: False ,passive: False
[LINE#188] All chip-level results are stored in the System Controller.
0.937	[*A*]All chip-level results[*R*]are stored[*A*]in the System Controller	context()	negated: False ,passive: True
[LINE#189] After this step, nodes enter a listening mode awaiting external instructions.
0.911	[*A*]a listening mode[*R*]awaiting[*A*]external instructions	context()	negated: False ,passive: True
0.938	[*A*]nodes[*R*]enter[*A*]a listening mode awaiting external instructions[*A*]After this step	context()	negated: False ,passive: False
[LINE#190] The host machine designates one or more Ethernet attached nodes to receive the system image to be executed by the Monitor Processors.
0.925	[*A*]the system image[*R*]to be executed[*A*]by the Monitor Processors	context()	negated: False ,passive: True
0.973	[*A*]one or more Ethernet attached nodes[*R*]to receive[*A*]the system image to be executed by the Monitor Processors	context()	negated: False ,passive: False
0.920	[*A*]Ethernet[*R*]attached[*A*]nodes to receive the system image	context()	negated: False ,passive: False
0.925	[*A*]The host machine[*R*]designates[*A*]one or more Ethernet attached nodes	context()	negated: False ,passive: False
[LINE#191] The image is transmitted in blocks to the Ethernet attached Monitors which compile the image, perform a CRC check and copy it to their local memory where it can be executed.
0.400	[*A*]it[*R*]can be executed[*A*]their local memory	context()	negated: False ,passive: True
0.918	[*A*]The image[*R*]is transmitted[*A*]in blocks to the Ethernet attached Monitors	context()	negated: False ,passive: True
0.928	[*A*]the Ethernet attached Monitors[*R*]compile[*A*]the image	context()	negated: False ,passive: False
0.920	[*A*]Ethernet[*R*]attached[*A*]Monitors which compile the image	context()	negated: False ,passive: False
0.918	[*A*]The image[*R*]is transmitted[*A*]in blocks to the Ethernet attached Monitors[*A*]perform a CRC check	context()	negated: False ,passive: True
[LINE#192] The system image informs the host machine and propagates itself to its neighbours; these neighbours send it forward their neighbours, and so on.
0.796	[*A*]The system[*R*]propagates[*A*]itself[*A*]to its neighbours	context(these neighbours send so on)	negated: False ,passive: False
0.888	[*A*]The system image[*R*]informs[*A*]the host machine	context(these neighbours send so on)	negated: False ,passive: False
0.791	[*A*]these neighbours[*R*]send so on[*A*]it	context()	negated: False ,passive: False
0.796	[*A*]The system[*R*]propagates[*A*]itself[*A*]to its neighbours	context(these neighbours send)	negated: False ,passive: False
0.888	[*A*]The system image[*R*]informs[*A*]the host machine	context(these neighbours send)	negated: False ,passive: False
0.838	[*A*]these neighbours[*R*]send[*A*]it[*A*]forward	context()	negated: False ,passive: False
[LINE#193] This way the system image is flood-filled in a redundant manner as each chip will receive several copies of the system image (see below).
0.903	[*A*]each chip[*R*]will receive[*A*]several copies of the system image (see below	context()	negated: False ,passive: False
0.932	[*A*]the system image[*R*]is[*A*]flood-filled in a redundant manner	context()	negated: False ,passive: True
[LINE#194] Once system boot is complete, the Monitor Processors test connections to neighbouring chips to record any faulty link or neighbour.
0.958	[*A*]the Monitor Processors test connections to neighbouring chips[*R*]to record[*A*]any faulty link or neighbour	context()	negated: False ,passive: False
0.813	[*A*]system boot[*R*]is[*A*]complete	context()	negated: False ,passive: True
[LINE#195] The host nominates one Ethernet-attached chip as the Reference Chip, making it the origin address, (0,0), of the network, notifying it of the topological characteristics, such as the number of chips.
0.859	[*A*]The host[*R*]nominates[*A*]one Ethernet-attached chip as the Reference Chip[*A*]making it the origin address	context()	negated: False ,passive: False
[LINE#196] The Reference Chip then broadcasts its address to its six neighbours, and so on.
0.919	[*A*]The Reference Chip[*R*]broadcasts[*A*]its address[*A*]to its six neighbours[*A*]then	context()	negated: False ,passive: False
[LINE#197] This generates a second wave through the network that enables each chip to compute its relative address in the network topology and configure point-to-point routing tables..
0.890	[*A*]each chip[*R*]to compute[*A*]its relative address in the configure point - to - point routing tables	context()	negated: False ,passive: False
0.873	[*A*]the network[*R*]enables[*A*]each chip[*A*]to compute its relative address in the configure point - to - point routing tables	context()	negated: False ,passive: False
0.926	[*A*]point - to - point[*R*]routing[*A*]tables	context()	negated: False ,passive: True
0.890	[*A*]each chip[*R*]to compute[*A*]its relative address in the network topology point - to - point routing tables	context()	negated: False ,passive: False
0.873	[*A*]the network[*R*]enables[*A*]each chip[*A*]to compute its relative address in the network topology point - to - point routing tables	context()	negated: False ,passive: False
0.381	[*A*]This[*R*]generates[*A*]a second wave through the network	context()	negated: False ,passive: False
[LINE#198] Evaluation of flood filling policiesData loading can be done via several flood-fill strategies, each offering different performance and fault resilience compromises.
0.544	[*A*]each[*R*]offering[*A*]different resilience compromises	context()	negated: False ,passive: False
0.544	[*A*]each[*R*]offering[*A*]different fault compromises	context()	negated: False ,passive: False
0.544	[*A*]each[*R*]offering[*A*]different performance compromises	context()	negated: False ,passive: False
0.801	[*A*]Evaluation of flood filling policiesData loading[*R*]can be done	context()	negated: False ,passive: False
[LINE#199] Several of these strategies were evaluated previously [17], but when that evaluation was performed, broadcast packets were addressed to all neighbours and consequently most strategies had to use point-to-point (unicast) packets, with the consequent overloading of the injection ports.
0.887	[*A*]most strategies[*R*]to use[*A*]point - to - point	context()	negated: False ,passive: False
0.859	[*A*]broadcast packets[*R*]were addressed[*A*]to all neighbours[*A*]when that evaluation was performed	context()	negated: False ,passive: True
0.732	[*A*]that evaluation[*R*]was performed	context()	negated: False ,passive: False
0.799	[*A*]Several of these strategies[*R*]were evaluated[*A*]previously	context()	negated: False ,passive: True
[LINE#200] To overcome this overhead a selective multicast able to forward packets to a subset of the neighbours was included in the final design.
[LINE#201] The following evaluation considers several strategies using this selective multicast.
0.903	[*A*]several strategies[*R*]using[*A*]this selective multicast	context()	negated: False ,passive: False
0.911	[*A*]The following evaluation[*R*]considers[*A*]several strategies using this selective multicast	context()	negated: False ,passive: False
[LINE#202] 6 summarizes the results of an event-driven simulation of the application loading process in the largest system configuration (256 256 nodes).
0.497	[*A*]6[*R*]summarizes[*A*]the results of an event-driven simulation of the application loading process in the largest system configuration	context()	negated: False ,passive: False
[LINE#203] The top two graphs consider SpiNNaker systems without failures and are intended to show the performance (time consumed in the floodfill).
0.894	[*A*]time[*R*]consumed[*A*]in the floodfill	context()	negated: False ,passive: True
0.551	[*A*]The top two[*R*]to show[*A*]the performance	context()	negated: False ,passive: False
0.592	[*A*]The top two[*R*]are intended[*A*]to show the performance	context()	negated: False ,passive: True
0.931	[*A*]The top two graphs[*R*]consider[*A*]SpiNNaker systems	context()	negated: False ,passive: False
[LINE#204] The bottom two consider systems with different link failure configurations and show the resilience level provided by each strategy.
0.911	[*A*]the resilience level[*R*]provided[*A*]by each strategy	context()	negated: False ,passive: True
0.911	[*A*]The bottom two[*R*]consider[*A*]systems	context()	negated: False ,passive: False
[LINE#205] Next we explain how these graphs can be interpreted.
0.678	[*A*]these graphs[*R*]can be interpreted	context(we explain)	negated: False ,passive: False
0.388	[*A*]we[*R*]explain[*A*]how these graphs can be interpreted	context()	negated: False ,passive: False
[LINE#206+207]  Seven different flood-fill policies were considered in the simulations:bcast sends the packet to all neighbouring chips.2msgsends the packet only to the neighbours in the positive X and Y directions.
0.913	[*A*]Seven different flood - fill policies[*R*]were considered[*A*]in the si	context(mulations:bcast sends)	negated: False ,passive: True
0.550	[*A*]mulations:bcast[*R*]sends[*A*]the packet[*A*]to all neighbouring chips.2msgsends	context()	negated: False ,passive: False
[LINE#208] This is the minimum number of neighbours required to perform an efficient flooding.3msg sends the packet to the neighbours in positive X, Y and XY diagonal.5msg sends the packet to all the neighbours but the one the original packet was received from.randP sends the packet in the positive X and Y directions and in addition randomly to each of the other directions with a P% probability.
0.944	[*A*]the one the original packet was received[*R*]sends[*A*]the packet	context()	negated: False ,passive: False
0.894	[*A*]neighbours[*R*]required[*A*]to perform an efficient flooding.3msg	context()	negated: False ,passive: True
0.751	[*A*]the original packet[*R*]was received	context()	negated: False ,passive: False
[LINE#209] We considered 25% (rand25), 50% (rand50) and 75% (rand75) in our evaluation.
0.452	[*A*]We[*R*]considered[*A*]25 %	context()	negated: False ,passive: False
[LINE#210] In the simulations considering several Ethernet ports, nodes located at (0, 0), (128, 128), (128, 0) and (0, 128) are connected to the host.
0.934	[*A*]nodes located at 128[*R*]are connected[*A*]In the simulations	context()	negated: False ,passive: True
0.749	[*A*]nodes[*R*]located[*A*]at 128	context()	negated: False ,passive: True
0.953	[*A*]nodes located at ( 0 )[*R*]are connected[*A*]In the simulations	context()	negated: False ,passive: True
0.989	[*A*]nodes located at ( 0 , 0 ) , ( 128 , 128 ) , ( 128 , 0 ) )[*R*]are connected[*A*]In the simulations	context()	negated: False ,passive: True
0.749	[*A*]nodes[*R*]located[*A*]at ( 0	context()	negated: False ,passive: True
0.903	[*A*]the simulations[*R*]considering[*A*]several Ethernet ports	context()	negated: False ,passive: False
[LINE#211+212+213]  The results without failures in Fig. and (b) show that (i) different flooding strategies provide diverse performance levels,(ii) given the 2D-pipelined nature of the application loading procedure, the loading times are not affected substantially by the network size; and (iii) similarly, the number of Ethernet-connected nodes does not affect significantly the time required to load the application.
0.953	[*A*]the number of Ethernet - connected nodes[*R*]does not affect significantly[*A*]the time required to load the application	context()	negated: True ,passive: False
0.891	[*A*]different flooding strategies[*R*]provide[*A*]diverse performance levels	context(The results without failures in Fig (b) show)	negated: False ,passive: False
0.922	[*A*]The results without failures in Fig[*R*](b) show[*A*]that (i) different flooding strategies provide diverse performance levels , ( ii ) given the 2D - pipelined nature of the application loading procedure	context()	negated: False ,passive: False
0.911	[*A*]the loading times[*R*]are not affected substantially[*A*]by the network size	context()	negated: True ,passive: True
[LINE#214] The configurations with failures - see Fig. 6(c) and (d) - present the normalized number of undelivered packets.
0.920	[*A*]The configurations with failures[*R*]see[*A*]Fig	context()	negated: False ,passive: False
[LINE#215] Points that are not shown in the plot mean that the loading process was successful.
0.793	[*A*]the loading process[*R*]was[*A*]successful	context(Points that are not shown in the plot mean)	negated: False ,passive: True
0.829	[*A*]Points that are not shown in the plot[*R*]mean[*A*]that the loading process was successful	context()	negated: False ,passive: False
0.877	[*A*]Points[*R*]are not shown[*A*]in the plot	context()	negated: True ,passive: True
[LINE#216] The failure distributions considered in this study are the following.vert represents a configuration where all the links along the Y-axis in the bisection are treated as faulty, leading to a network split in vertical columns.horiz represents a similar configuration, but affecting the horizontal axis.cross represents the union of horiz and vert.
0.917	[*A*]The failure affecting the horizontal axis.cross[*R*]represents[*A*]the union of vert	context()	negated: False ,passive: False
0.882	[*A*]The failure[*R*]affecting[*A*]the horizontal axis.cross	context(The failure affecting the horizontal axis.cross represents)	negated: False ,passive: False
0.917	[*A*]The failure affecting the horizontal axis.cross[*R*]represents[*A*]the union of horiz	context()	negated: False ,passive: False
0.968	[*A*]all the links along the Y - axis in the bisection[*R*]leading[*A*]to a network split in vertical columns.horiz	context()	negated: False ,passive: False
0.982	[*A*]all the links along the Y - axis in the bisection[*R*]are treated[*A*]as faulty[*A*]a configuration	context()	negated: False ,passive: True
0.911	[*A*]The failure distributions[*R*]considered[*A*]in this study	context()	negated: False ,passive: True
[LINE#217+218+219+220]  Small-scale examples of these three configurations are shown in Fig. 7.The remaining configurations represent uniform random sets of link failures: 1536 (rnd1), 3072 (rnd2), 6144 (rnd3), 12,288 (rnd4) and 24,576(rnd5).In general, those strategies sending more packets are less likely to lose packets but at the price of increasing the time required to finalize the whole process.
0.952	[*A*]those strategies sending more packets[*R*]are[*A*]less likely to lose at the price of increasing the time	context()	negated: False ,passive: True
0.732	[*A*]the time[*R*]required	context()	negated: False ,passive: False
0.756	[*A*]those strategies sending more packets[*R*]to lose	context()	negated: False ,passive: False
0.926	[*A*]those strategies sending more packets[*R*]are[*A*]less likely to lose packets	context()	negated: False ,passive: True
0.903	[*A*]those strategies[*R*]sending[*A*]more packets	context()	negated: False ,passive: False
0.913	[*A*]those strategies sending more packets[*R*]to lose[*A*]packets	context()	negated: False ,passive: False
0.882	[*A*]remaining configurations[*R*]represent[*A*]uniform random sets of link failures	context(Small - scale examples of these three configurations are shown)	negated: False ,passive: False
0.941	[*A*]Small - scale examples of these three configurations[*R*]are shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#221] In all cases, it will take only from 5 to 15 ms to load an application completely.
[LINE#222] Results also show that increasing the number of Ethernet connections improves robustness, especially in scenarios with multiple failures.
0.935	[*A*]increasing the number of Ethernet connections[*R*]improves[*A*]robustness	context(Results show)	negated: False ,passive: False
0.837	[*A*]Results[*R*]show[*A*]that increasing the number of Ethernet connections improves robustness, especially in scenarios with multiple failures	context()	negated: False ,passive: False
[LINE#223] We conclude that the SpiNNaker configuration process is efficient, scalable and robust.
0.852	[*A*]the SpiNNaker configuration process[*R*]is[*A*]robust	context(We conclude)	negated: False ,passive: True
0.225	[*A*]We[*R*]conclude[*A*]that the SpiNNaker configuration process is robust	context()	negated: False ,passive: False
0.852	[*A*]the SpiNNaker configuration process[*R*]is[*A*]scalable	context(We conclude)	negated: False ,passive: True
0.225	[*A*]We[*R*]conclude[*A*]that the SpiNNaker configuration process is scalable	context()	negated: False ,passive: False
0.852	[*A*]the SpiNNaker configuration process[*R*]is[*A*]efficient	context(We conclude)	negated: False ,passive: True
0.225	[*A*]We[*R*]conclude[*A*]that the SpiNNaker configuration process is efficient	context()	negated: False ,passive: False
[LINE#224] Moreover, there is a reasonable range of distribution strategies that allow trade-offs between speed and fault-resilience. .
0.887	[*A*]distribution strategies[*R*]allow[*A*]trade-offs between speed and fault-resilience	context()	negated: False ,passive: False
[LINE#225] reconfigurationDuring regular operation, the Monitor Processor periodically checks and updates the state of chip resources, including the state of the links to its neighbours, in the System Controller.
0.944	[*A*]the Monitor Processor[*R*]updates[*A*]the state of chip resources[*A*]including the state of the links to its neighbours , in the System Controller[*A*]periodically	context()	negated: False ,passive: False
0.759	[*A*]the Monitor Processor[*R*]periodically checks	context()	negated: False ,passive: False
[LINE#226] Any Monitor Processor can activate the neighbour diagnostic and recovery routine if it suspects a neighbour chip is not working properly.
0.707	[*A*]a neighbour chip[*R*]is not working properly	context(it suspects)	negated: True ,passive: False
0.924	[*A*]Any Monitor Processor[*R*]can activate[*A*]the recovery routine[*A*]if it suspects a neighbour chip is not working properly	context()	negated: False ,passive: False
0.707	[*A*]a neighbour chip[*R*]is not working properly	context(it suspects)	negated: True ,passive: False
0.397	[*A*]it[*R*]suspects[*A*]a neighbour chip is not working properly	context()	negated: False ,passive: False
0.924	[*A*]Any Monitor Processor[*R*]can activate[*A*]the neighbour diagnostic routine[*A*]if it suspects a neighbour chip is not working properly	context()	negated: False ,passive: False
[LINE#227] This nurse Chip will 'peek and poke' the remote System Controller to identify any healthy cores.
0.939	[*A*]the remote System Controller[*R*]to identify[*A*]any healthy cores	context()	negated: False ,passive: False
0.602	[*A*]This nurse[*R*]will peek	context()	negated: False ,passive: False
[LINE#228] It will first try to change the remote Monitor Processor, then try to overcome a Boot ROM failure by copying the boot-up code to the remote System RAM and remapping the remote Boot ROM and System RAM.
0.588	[*A*]It[*R*]will try[*A*]to change the remote Monitor Processor , then try to overcome a Boot ROM failure by remapping the remote Boot System RAM[*A*]first	context()	negated: False ,passive: False
0.588	[*A*]It[*R*]will try[*A*]to change the remote Monitor Processor , then try to overcome a Boot ROM failure by remapping the remote Boot ROM[*A*]first	context()	negated: False ,passive: False
0.426	[*A*]It[*R*]will try to change then[*A*]the remote Monitor Processor	context(It will try)	negated: False ,passive: False
0.588	[*A*]It[*R*]will try[*A*]to change the remote Monitor Processor , then try to overcome a Boot ROM failure by copying the boot - up code to the remote System RAM[*A*]first	context()	negated: False ,passive: False
[LINE#229] Finally, the Nurse Chip will reset the remote chip to attempt to recover from a transient fault.
0.915	[*A*]the Nurse Chip[*R*]will reset the remote chip to attempt[*A*]to recover from a transient fault	context(the Nurse Chip will reset)	negated: False ,passive: False
0.950	[*A*]the Nurse Chip[*R*]will reset[*A*]the remote chip[*A*]to attempt to recover from a transient fault[*A*]Finally	context()	negated: False ,passive: False
[LINE#230] If nothing works, the failed chip is isolated by disabling its clocks.
0.825	[*A*]the failed chip[*R*]by disabling[*A*]its clocks	context()	negated: False ,passive: False
0.751	[*A*]the failed chip[*R*]is isolated	context()	negated: False ,passive: False
0.767	[*A*]nothing[*R*]works	context()	negated: False ,passive: False
[LINE#231] When cores or chips are detected to be faulty, the system tries to migrate their functionality (typically neurons) to other cores.
0.796	[*A*]the system[*R*]tries to migrate[*A*]their functionality	context(the system tries)	negated: False ,passive: False
0.874	[*A*]the system[*R*]tries[*A*]to migrate their functionality[*A*]When cores or chips are detected to be faulty	context()	negated: False ,passive: False
0.754	[*A*]cores or chips[*R*]to be[*A*]faulty	context()	negated: False ,passive: True
0.751	[*A*]cores or chips[*R*]are detected	context()	negated: False ,passive: False
[LINE#232] This process is in principle straightforward, however depending on the failure some of the neural information may be impossible to recover.
0.814	[*A*]some of the neural information[*R*]may be[*A*]impossible to recover	context()	negated: False ,passive: True
0.925	[*A*]This process[*R*]is[*A*]in principle straightforward	context()	negated: False ,passive: True
[LINE#233] For example, to migrate from a chip because it cannot access its SDRAM, only the neural information stored in local memory can be recovered.
0.830	[*A*]only the neural information stored in local memory[*R*]can be recovered	context()	negated: False ,passive: False
0.919	[*A*]only the neural information[*R*]stored[*A*]in local memory	context()	negated: False ,passive: True
0.350	[*A*]it[*R*]can not access[*A*]its SDRAM	context()	negated: True ,passive: False
[LINE#234] The way to regenerate unrecoverable information will depend on the executed application but, as discussed before, losing neurons is acceptable in a biological brain and therefore it may be so in the simulated application.
0.225	[*A*]it[*R*]may be[*A*]so	context()	negated: False ,passive: True
0.925	[*A*]losing neurons[*R*]is[*A*]acceptable[*A*]in a biological brain	context()	negated: False ,passive: True
0.932	[*A*]The way to regenerate unrecoverable information[*R*]will depend[*A*]on the executed application in the simulated application	context()	negated: False ,passive: False
[LINE#235] When routers or links stop working properly, part of the routing tables may need to be reconstructed dynamically to avoid unreliable areas of the network.
0.913	[*A*]part of the routing tables[*R*]to be reconstructed dynamically[*A*]to avoid unreliable areas of the network	context()	negated: False ,passive: True
0.699	[*A*]routers or links[*R*]stop working properly working properly	context(routers or links stop)	negated: False ,passive: False
0.787	[*A*]routers or links[*R*]stop[*A*]working properly	context()	negated: False ,passive: False
[LINE#236] When a route is destroyed, the system can generate new routes by the back propagation of a routing key from the destination node to the source node.
0.943	[*A*]the system[*R*]can generate[*A*]new routes[*A*]When a route is destroyed	context()	negated: False ,passive: False
0.732	[*A*]a route[*R*]is destroyed	context()	negated: False ,passive: False
[LINE#237] The host system will collect the required information from this procedure and will generate and propagate the updated routing tables.
0.732	[*A*]The host[*R*]will generate	context()	negated: False ,passive: False
0.911	[*A*]The host system[*R*]will collect[*A*]the required information from this procedure	context()	negated: False ,passive: False
[LINE#238] Alternatively, a distributed reconfiguration may rely on the Monitor Processes around the failing components for the generation and propagation of the updated routing tables.
0.952	[*A*]a distributed reconfiguration[*R*]may rely[*A*]on the Monitor Processes[*A*]around the failing components for the propagation of the updated routing tables	context()	negated: False ,passive: False
0.952	[*A*]a distributed reconfiguration[*R*]may rely[*A*]on the Monitor Processes[*A*]around the failing components for the generation of the updated routing tables	context()	negated: False ,passive: False
[LINE#239] Finally, each SpiNNaker chip is provided with a watchdog timer which detects when the Monitor Processor has not responded for a long time.
0.933	[*A*]the Monitor Processor[*R*]has not responded[*A*]for a long time	context()	negated: True ,passive: False
0.944	[*A*]a watchdog timer[*R*]detects[*A*]when the Monitor Processor has not responded for a long time	context()	negated: False ,passive: False
0.961	[*A*]each SpiNNaker chip[*R*]is provided[*A*]with a watchdog timer[*A*]Finally	context()	negated: False ,passive: True
[LINE#240] When this is detected, the recovery process first tries to recover the Monitor Processor by soft resetting it.
0.889	[*A*]the recovery process[*R*]tries to recover[*A*]the Monitor Processor	context(the recovery process tries)	negated: False ,passive: False
0.886	[*A*]the recovery process[*R*]tries[*A*]to recover the Monitor Processor by soft resetting it[*A*]When this is detected[*A*]first	context()	negated: False ,passive: False
0.153	[*A*]this[*R*]is detected	context()	negated: False ,passive: False
[LINE#241] If this measure does not solve the problem, then it hard resets the chip, forcing the System Controller to select another core as a Monitor Processor.
0.333	[*A*]it[*R*]hard resets the chip forcing[*A*]the System Controller[*A*]to select another core as a Monitor Processor	context(it hard resets)	negated: False ,passive: False
0.686	[*A*]it[*R*]hard resets[*A*]the chip[*A*]forcing the System Controller to select another core as a Monitor Processor[*A*]then	context()	negated: False ,passive: False
0.944	[*A*]the System Controller[*R*]to select[*A*]another core as a Monitor Processor	context()	negated: False ,passive: False
0.903	[*A*]this measure[*R*]does not solve[*A*]the problem	context()	negated: True ,passive: False
[LINE#242+243]  Fault tolerant architectureFrom Section 3some fault-tolerant features will already be apparent.
0.911	[*A*]Fault tolerant architectureFrom Section 3some fault-tolerant features[*R*]will be[*A*]apparent[*A*]already	context()	negated: False ,passive: True
[LINE#244] Firstly the application itself is robust against minor perturbations in timing and should tolerate a percentage of missing spikes and neurons.
0.903	[*A*]the application[*R*]should tolerate[*A*]a percentage of neurons	context()	negated: False ,passive: False
0.903	[*A*]the application[*R*]should tolerate[*A*]a percentage of missing spikes	context()	negated: False ,passive: False
0.802	[*A*]Firstly the application[*R*]is[*A*]robust	context()	negated: False ,passive: True
[LINE#245] Secondly, there is a huge hardware resource available which provides a high degree of redundancy.
0.913	[*A*]a huge hardware resource available[*R*]provides[*A*]a high degree of redundancy	context()	negated: False ,passive: False
[LINE#246] Although each node has 18 cores, the intended use does not require any specific number of cores, merely (any) one to provide node control and some others to run the application.
0.903	[*A*]some others[*R*]to run[*A*]the application	context()	negated: False ,passive: False
0.911	[*A*]the intended use[*R*]does not require[*A*]any specific number of cores[*A*]merely	context()	negated: True ,passive: False
0.925	[*A*]each node[*R*]has[*A*]18 cores	context()	negated: False ,passive: False
[LINE#247] Indeed for cost purposes it is intended to use some flawed devices; yield estimates suggest that this may improve the usability of manufactured dice from 50% to around 80%.
0.330	[*A*]this[*R*]may improve[*A*]the usability of manufactured dice	context(yield estimates suggest)	negated: False ,passive: False
0.397	[*A*]it[*R*]is intended[*A*]to use some flawed devices	context(yield estimates suggest)	negated: False ,passive: True
0.814	[*A*]yield estimates[*R*]suggest[*A*]that this may improve the usability of manufactured dice from 50% to around 80%	context()	negated: False ,passive: False
0.411	[*A*]it[*R*]to use[*A*]some flawed devices	context()	negated: False ,passive: False
[LINE#248] Based on the area use of the die the majority of flaws may be expected to be in local memories; these may leave a core degraded but still usable although the simplest action is still to shut it down.
0.445	[*A*]these[*R*]may leave[*A*]a still usable[*A*]although the simplest action is still to shut it down	context()	negated: False ,passive: False
0.719	[*A*]the majority of flaws[*R*]may be expected	context(these may leave)	negated: False ,passive: False
0.445	[*A*]these[*R*]may leave[*A*]a core[*A*]degraded[*A*]although the simplest action is still to shut it down	context()	negated: False ,passive: False
0.881	[*A*]the simplest action[*R*]is[*A*]still[*A*]to shut it down	context()	negated: False ,passive: True
0.905	[*A*]the majority of flaws[*R*]to be[*A*]in local memories	context()	negated: False ,passive: True
[LINE#249] Preliminary evidence from the first batch of fabricated chips suggests these estimates to be appropriate if slightly pessimistic.
0.767	[*A*]these estimates[*R*]to be[*A*]appropriate	context()	negated: False ,passive: True
0.948	[*A*]Preliminary evidence from the first batch of fabricated chips[*R*]suggests[*A*]these estimates[*A*]to be appropriate	context()	negated: False ,passive: False
[LINE#250+251]  Of 46 chips, 30 (65%) were flawless chips, 12 (26%)have 17 working cores and 4 (9%) have more serious problems.
0.973	[*A*]30 65 %[*R*]were[*A*]46 chips	context()	negated: False ,passive: False
0.905	[*A*]30 ( 65 %[*R*]were[*A*]flawless chips	context()	negated: False ,passive: True
[LINE#252] Of the 12, 11 have private memory faults and one a peripheral logic fault.
0.638	[*A*]Of the 12 , 11[*R*]have[*A*]one a peripheral logic fault	context()	negated: False ,passive: False
0.544	[*A*]11[*R*]have[*A*]private memory faults	context()	negated: False ,passive: False
[LINE#253+254]  From this small sample it seems likely that 42 of 46 (93%)dice will be serviceable because manufacturing faults can be tolerated.
0.732	[*A*]manufacturing faults[*R*]can be tolerated	context()	negated: False ,passive: False
[LINE#255] This represents an increase of roughly 40% in terms of achievable computing power (from 540 to 744 cores).This redundancy can also be used to protect against (less likely) run-time faults by offloading work.
0.887	[*A*]This redundancy[*R*]to protect[*A*]against (less likely) run-time faults	context()	negated: False ,passive: True
0.907	[*A*]This redundancy[*R*]can be used[*A*]to protect against (less likely) run-time faults by offloading work	context()	negated: False ,passive: True
0.497	[*A*]This[*R*]represents[*A*]an increase of roughly 40% in terms of achievable computing power (from 540 to 744 cores	context()	negated: False ,passive: False
[LINE#256] By keeping a stand-by core on each node a run-time fault can be accommodated without too much effort, particularly as the majority of the data is held in the separate, shared SDRAM.
[LINE#257] The SDRAM devices are 'known good' before packaging.
0.796	[*A*]The SDRAM devices[*R*]are known good[*A*]before packaging	context()	negated: False ,passive: True
[LINE#258] Each provides a node with more than its anticipated store requirement, thus there is capacity to test and map around any dubious region.
0.713	[*A*]capacity[*R*]to test	context()	negated: False ,passive: False
[LINE#259] This is one of the tasks for the local Monitor Processor.
0.495	[*A*]This[*R*]is[*A*]one of the tasks for the local Monitor Processor	context()	negated: False ,passive: True
[LINE#260] In addition to redundancy, a number of features have been included either as design considerations or specifically for fault-tolerance.
0.948	[*A*]a number of features[*R*]have been included[*A*]either as design considerations or specifically for fault-tolerance	context()	negated: False ,passive: True
[LINE#261] 5 shows a map of the expected failure types and the mechanisms provided to reduce their impact in the usability of SpiNNaker.
0.870	[*A*]the mechanisms provided[*R*]to reduce[*A*]their impact in the usability of SpiNNaker	context()	negated: False ,passive: False
0.859	[*A*]the mechanisms[*R*]provided[*A*]to reduce their impact in the usability of SpiNNaker	context()	negated: False ,passive: True
0.449	[*A*]5[*R*]shows[*A*]a map of the mechanisms	context()	negated: False ,passive: False
0.449	[*A*]5[*R*]shows[*A*]a map of the expected failure types	context()	negated: False ,passive: False
[LINE#262] Naker is an application specific design intended to model large biological neural networks - the name "SpiNNaker" being derived from 'Spiking Neural Network architecture'.
0.905	[*A*]the name[*R*]being derived[*A*]from 'Spiking Neural Network architecture	context()	negated: False ,passive: True
0.919	[*A*]an application specific design[*R*]intended[*A*]to model large biological neural networks	context()	negated: False ,passive: True
0.967	[*A*]Naker[*R*]is[*A*]an application specific design intended to model large biological neural networks - the name "SpiNNaker"	context()	negated: False ,passive: True
[LINE#263]  It consists of a toroidal arrangement of processing nodes, each incorporating a purpose-built, multi-core System-on-Chip (SoC) and an SDRAM memory.
0.590	[*A*]each[*R*]incorporating[*A*]an SDRAM memory	context()	negated: False ,passive: False
0.498	[*A*]It[*R*]consists[*A*]of a toroidal arrangement of processing nodes[*A*]each incorporating an SDRAM memory	context()	negated: False ,passive: True
0.657	[*A*]each[*R*]incorporating[*A*]a purpose - built , multi-core System - on - Chip	context()	negated: False ,passive: False
0.569	[*A*]It[*R*]consists[*A*]of a toroidal arrangement of processing nodes[*A*]each incorporating a purpose - built , multi-core System - on - Chip	context()	negated: False ,passive: True
[LINE#264] Neurons are modelled in software running on embedded ARM968 processors; each core is intended to model a nominal 1000 neurons.
0.891	[*A*]Neurons[*R*]are modelled[*A*]in software[*A*]running on embedded ARM968 processors	context(each core is intended)	negated: False ,passive: True
0.882	[*A*]each core[*R*]is intended[*A*]to model a nominal 1000 neurons	context()	negated: False ,passive: True
0.887	[*A*]each core[*R*]to model[*A*]a nominal 1000 neurons	context()	negated: False ,passive: False
[LINE#265] Small-scale SpiNNaker systems have successfully been used as control systems in embedded applications [1], providing robots with real-time stimulus-response behaviour as described in [2].
0.952	[*A*]Small-scale SpiNNaker systems[*R*]have successfully been used[*A*]as control systems in embedded applications[*A*]providing robots with real-time stimulus-response behaviour as described in [2]	context()	negated: False ,passive: True
[LINE#266] However the ultimate aiming of the project is to construct a machine able to simulate up to 109 neurons in real time.
0.911	[*A*]a machine able[*R*]to simulate[*A*]up to 109 neurons[*A*]in real time	context()	negated: False ,passive: False
0.967	[*A*]the ultimate aiming of the project[*R*]is[*A*]to construct a machine able to simulate up to 109 neurons in real time	context()	negated: False ,passive: True
[LINE#267] To put this number in context some small primates have brains with slightly lower neuron counts whereas the human brain has roughly 86 times this number [3].
0.991	[*A*]some small primates[*R*]have[*A*]brains with slightly lower neuron counts whereas the human brain has roughly 86 times this number [ 3 ]	context()	negated: False ,passive: False
0.932	[*A*]the human brain[*R*]has[*A*]roughly 86 times this number	context()	negated: False ,passive: False
0.911	[*A*]some small primates[*R*]have[*A*]brains with slightly lower neuron counts	context()	negated: False ,passive: False
[LINE#268+269]  To reach this number of neuronsmore than one hundred thousand integrated circuits will be needed (half of which are SpiNNaker chips and the other half SDRAMs).A system of this scale may be expected to suffer component failures and many features of its design are included to provide a certain degree of fault tolerance.
0.925	[*A*]half of which[*R*]are[*A*]the other half SDRAMs	context()	negated: False ,passive: True
0.851	[*A*]A system of this scale[*R*]to suffer[*A*]many features of its design	context()	negated: False ,passive: False
0.913	[*A*]A system of this scale[*R*]to suffer[*A*]component failures	context()	negated: False ,passive: False
0.785	[*A*]A system of this scale[*R*]may be expected	context()	negated: False ,passive: False
0.856	[*A*]this number of neuronsmore than one hundred thousand integrated circuits[*R*]will be needed	context()	negated: False ,passive: False
[LINE#270] These features can sometimes be justified on cost alone: the overall yield for the 100mm2 SpiNNaker SoC was estimated, using public domain yield statistics on a 20-core, at 50% fault-free chips, 25% single-fault chips, 10% two-fault chips and the remaining 15% will be unusable due to critical failures.
0.195	[*A*]the remaining 15 %[*R*]will have unusable of[*A*]20 - core	context()	negated: False ,passive: False
0.953	[*A*]the remaining 15 %[*R*]will be[*A*]unusable[*A*]due to critical failures[*A*]at 50 % fault - free chips[*A*]25 %	context()	negated: False ,passive: True
0.732	[*A*]the overall yield for the 100mm2[*R*]was estimated	context()	negated: False ,passive: False
0.993	[*A*]the overall yield for the 100mm2 SpiNNaker SoC[*R*]was estimated at[*A*]25 % single - fault chips	context()	negated: False ,passive: False
0.893	[*A*]These features[*R*]can be justified[*A*]on cost alone[*A*]sometimes	context(the overall yield for the 100mm2 was estimated)	negated: False ,passive: True
0.923	[*A*]the overall yield for the 100mm2[*R*]was estimated[*A*]at 50 % fault - free chips , 25 % single - fault chips	context()	negated: False ,passive: True
[LINE#271]  Early test on the production chip (in Fig. 2) show similar, if rather better, yield characteristics.
0.965	[*A*]Early test on the production chip (in Fig[*R*]show[*A*]similar, if rather better, yield characteristics	context()	negated: False ,passive: False
[LINE#272] The 35% of chips having one or two faults would not be usable without fault tolerance features.
0.913	[*A*]The 35% of chips[*R*]would not be[*A*]usable[*A*]without fault tolerance features	context()	negated: True ,passive: True
0.813	[*A*]chips[*R*]having[*A*]one or two faults	context()	negated: False ,passive: False
[LINE#273] Fault tolerance is addressed at a number of levels, not least the application itself, which is intrinsically fault-tolerant.
0.927	[*A*]not least the application[*R*]is[*A*]intrinsically fault-tolerant	context()	negated: False ,passive: True
0.903	[*A*]Fault tolerance[*R*]is addressed[*A*]at a number of levels	context()	negated: False ,passive: True
[LINE#274] SpiNNaker incorporates measures to enable continued function in the presence of faults; in fact it has been designed as a power- and cost-effective fault-tolerant platform.
0.388	[*A*]it[*R*]has been designed[*A*]as a cost - effective fault - tolerant platform	context()	negated: False ,passive: True
0.934	[*A*]SpiNNaker[*R*]incorporates[*A*]measures to enable continued function in the presence of faults	context(it has been designed)	negated: False ,passive: False
0.504	[*A*]it[*R*]has been designed[*A*]as a power - - effective fault - tolerant platform	context()	negated: False ,passive: True
[LINE#275] The major defence against faults in such a system is the massive processing resource.
0.960	[*A*]The major defence against faults in such a system[*R*]is[*A*]the massive processing resource	context()	negated: False ,passive: True
[LINE#276] Processors are almost free and dedicating a small proportion of the processing power for system management and reconfiguration yields significant distributed 'intelligence' without much impact on the application.
0.931	[*A*]Processors[*R*]are dedicating[*A*]a small proportion of the processing power for system reconfiguration yields significant	context()	negated: False ,passive: False
0.931	[*A*]Processors[*R*]are dedicating[*A*]a small proportion of the processing power for system management	context()	negated: False ,passive: False
0.749	[*A*]Processors[*R*]are[*A*]almost free	context()	negated: False ,passive: True
[LINE#277] From the outset the intention has been to allocate one core on each SoC entirely to system management; if this eventually proves insufficient it is simple to delegate a second core to this task.
[LINE#278] Cores devoted to system management can identify and map around failed devices at run time.
0.813	[*A*]map[*R*]around failed[*A*]devices[*A*]at run time	context()	negated: False ,passive: True
0.785	[*A*]Cores devoted to system management[*R*]can identify	context()	negated: False ,passive: False
0.894	[*A*]Cores[*R*]devoted[*A*]to system management	context()	negated: False ,passive: True
[LINE#279] Particular attention has been paid to inter-chip communications where link failures or transient congestion may be routed around rapidly without software intervention.
0.924	[*A*]link failures or transient congestion[*R*]may be routed rapidly[*A*]inter-chip communications	context()	negated: False ,passive: True
0.903	[*A*]Particular attention[*R*]has been paid[*A*]to inter-chip communications	context()	negated: False ,passive: True
[LINE#280] Finally some more conventional techniques - such as automatic CRC generation and checking and watchdog timers - are employed in each processing node.
0.968	[*A*]some more conventional techniques - such as automatic watchdog timers[*R*]are employed[*A*]in each processing node[*A*]Finally	context()	negated: False ,passive: True
0.968	[*A*]some more conventional techniques - such as automatic checking timers[*R*]are employed[*A*]in each processing node[*A*]Finally	context()	negated: False ,passive: True
0.978	[*A*]some more conventional techniques - such as automatic CRC generation timers[*R*]are employed[*A*]in each processing node[*A*]Finally	context()	negated: False ,passive: True
[LINE#281] As a large-scale system has not yet been built the full possibilities of software reconfiguration have yet to be explored.
[LINE#282] However statistical models of the architecture have been developed and used to verify the principles, and the hardware mechanisms themselves have been tested in silicon in small-scale (4 chip) systems.
0.897	[*A*]the hardware mechanisms[*R*]have been tested[*A*]in silicon[*A*]in small - scale ( 4 chip ) systems	context()	negated: False ,passive: True
0.785	[*A*]statistical models of the architecture[*R*]have been developed	context()	negated: False ,passive: False
[LINE#283] The construction of a larger machine is in progress.
0.948	[*A*]The construction of a larger machine[*R*]is[*A*]in progress	context()	negated: False ,passive: True
[LINE#284] Other fault-tolerant features.
[LINE#285] Clock redundancySpiNNaker chips have two independent PLLs with the intention of running the processors and the router at one frequency (200MHz) and the SDRAM at another (166MHz) to improve overall performance.
0.964	[*A*]Clock redundancySpiNNaker chips[*R*]have[*A*]two independent PLLs with the intention of the SDRAM at another ( 166MHz	context()	negated: False ,passive: False
0.957	[*A*]Clock redundancySpiNNaker chips[*R*]have[*A*]two independent PLLs with the intention of running the router at one frequency	context()	negated: False ,passive: False
0.957	[*A*]Clock redundancySpiNNaker chips[*R*]have[*A*]two independent PLLs with the intention of running the processors	context()	negated: False ,passive: False
[LINE#286] However clock sources can be switched so, in the event of a PLL failure, all subsystems' clocks can be derived from the same source.
0.975	[*A*]all subsystems' clocks[*R*]can be derived[*A*]from the same source[*A*]However clock sources can be switched so, in the event of a PLL failure	context()	negated: False ,passive: True
0.903	[*A*]clock sources[*R*]can be switched so[*A*]in the event of a PLL failure	context()	negated: False ,passive: True
[LINE#287] This may reduce performance on that node but has no other consequence as the GALS interconnection is inherently adaptive. .
0.867	[*A*]the GALS interconnection[*R*]is[*A*]inherently adaptive	context()	negated: False ,passive: True
0.571	[*A*]This[*R*]has[*A*]no other consequence as the GALS interconnection is inherently adaptive	context()	negated: False ,passive: False
0.381	[*A*]This[*R*]may reduce[*A*]performance	context()	negated: False ,passive: False
0.183	[*A*]This[*R*]may reduce[*A*]performance on that node	context()	negated: False ,passive: False
[LINE#288] S implications on fault toleranceUsing a GALS approach not only facilitates the SoC design process but also simplifies isolation of faulty components in run time by supporting resetting or disabling on-chip components independently from the rest of the SoC. .
0.931	[*A*]S implications on fault[*R*]toleranceUsing[*A*]a GALS approach	context()	negated: False ,passive: False
[LINE#289] toleranceVarious RAM is spread across a SpiNNaker chip (private TCMs, on-chip SRAM and off-chip RAM) which, as explained before, are the main expected points of failure.
0.905	[*A*]off - chip RAM[*R*]are[*A*]the main expected points of failure	context()	negated: False ,passive: True
0.918	[*A*]toleranceVarious RAM[*R*]is spread[*A*]across a SpiNNaker chip	context()	negated: False ,passive: True
[LINE#290+291]  In principle it is possible to work-around hard failures in private memories butthe degree of redundancy in the system means our plan is simply to inactivate cores with permanent TCM failure(s).
0.693	[*A*]our plan[*R*]is[*A*]simply[*A*]to inactivate cores with permanent TCM failure	context(butthe degree of redundancy in the system means)	negated: False ,passive: True
0.927	[*A*]butthe degree of redundancy in the system[*R*]means[*A*]our plan is simply to inactivate cores with permanent TCM failure	context()	negated: False ,passive: False
[LINE#292] The SDRAMs have some spare capacity and are mapped by the Monitor Processor so hard failures can be worked around.
0.707	[*A*]so hard failures[*R*]can be worked around	context(The SDRAMs are mapped)	negated: False ,passive: False
0.822	[*A*]The SDRAMs[*R*]are mapped[*A*]by the Monitor Processor	context()	negated: False ,passive: True
0.827	[*A*]The SDRAMs[*R*]have[*A*]some spare capacity	context()	negated: False ,passive: False
[LINE#293] Soft errors present a different challenge.
0.903	[*A*]Soft errors[*R*]present[*A*]a different challenge	context()	negated: False ,passive: False
[LINE#294] The SDRAM is usually accessed in blocks via DMA.
0.883	[*A*]The SDRAM[*R*]is accessed[*A*]in blocks[*A*]usually	context()	negated: False ,passive: True
[LINE#295] The DMA controller includes a fully programmable CRC generator and checker so faulty blocks can be detected and subject to software recovery.
0.911	[*A*]so faulty blocks[*R*]can be[*A*]subject to software recovery	context()	negated: False ,passive: True
0.944	[*A*]The DMA controller[*R*]includes[*A*]a fully programmable CRC checker	context()	negated: False ,passive: True
0.751	[*A*]so faulty blocks[*R*]can be detected	context()	negated: False ,passive: False
0.944	[*A*]The DMA controller[*R*]includes[*A*]a fully programmable CRC generator	context()	negated: False ,passive: True
[LINE#296] Private memories are not protected by error detection; this was a pragmatic decision to maximise the speed and capacity of the chip.
0.395	[*A*]this[*R*]was[*A*]a pragmatic decision to maximise capacity of the chip	context()	negated: False ,passive: True
0.882	[*A*]Private memories[*R*]are not protected[*A*]by error detection	context(this was)	negated: True ,passive: True
0.395	[*A*]this[*R*]was[*A*]a pragmatic decision to maximise the speed	context()	negated: False ,passive: True
[LINE#297] Soft errors in code space can cause a software crash resulting in some lost neural information.
0.911	[*A*]a software crash[*R*]resulting[*A*]in some lost neural information	context()	negated: False ,passive: True
0.926	[*A*]Soft errors in code space[*R*]can cause[*A*]a software crash resulting in some lost neural information	context()	negated: False ,passive: False
[LINE#298] Recovery from this should be achieved by the watchdog mechanism resetting the affected core.
0.911	[*A*]the watchdog mechanism[*R*]resetting[*A*]the affected core	context()	negated: False ,passive: False
0.751	[*A*]Recovery from this[*R*]should be achieved	context()	negated: False ,passive: False
[LINE#299] Corruption of data space may be detected by software limit checks or crashing or other erratic behaviour.
0.948	[*A*]Corruption of data space[*R*]may be detected[*A*]by software limit checks or crashing or other erratic behaviour	context()	negated: False ,passive: True
[LINE#300+301]  There may be some loss of data or some erroneous neural firingbut the application should be robust enough to withstand this; it almost certainly happens in biological systems too! .
0.349	[*A*]it[*R*]happens[*A*]in biological systems[*A*]too	context()	negated: False ,passive: True
0.735	[*A*]the application[*R*]to withstand[*A*]this	context()	negated: False ,passive: False
0.767	[*A*]the application[*R*]should be[*A*]robust enough to withstand this	context()	negated: False ,passive: True
[LINE#302] Connecting with the outside worldA SpiNNaker system communicates with a host computer via Ethernet (Fig. 1) using TCP/IP.
0.953	[*A*]Connecting with the outside worldA SpiNNaker system[*R*]communicates[*A*]with a host computer	context()	negated: False ,passive: True
[LINE#303] This communication is used for different management actions, such as loading to the chip memories the application code or the neural connectivity information.
0.937	[*A*]This communication[*R*]is used[*A*]for different management actions, such as loading to the chip memories the application code or the neural connectivity information	context()	negated: False ,passive: True
[LINE#304] Although all chips have an Ethernet interface in practice only a few will make use of it to reduce power consumption and maximize the computing resources available to neurons.
0.422	[*A*]only a few[*R*]will make to maximize[*A*]the computing resources available to neurons	context(only a few will make)	negated: False ,passive: False
0.377	[*A*]only a few[*R*]will make[*A*]use of it[*A*]to maximize the computing resources available to neurons	context()	negated: False ,passive: False
0.440	[*A*]only a few[*R*]will make[*A*]use of it[*A*]to reduce power consumption	context()	negated: False ,passive: False
0.918	[*A*]all chips[*R*]have[*A*]an Ethernet interface	context()	negated: False ,passive: False
[LINE#305] Each Ethernet-connected chip translates frame-based communication to inter-chip packet-based communication.
[LINE#306] The presence of several possible interfaces does, however, eliminate another possible single-point failure.
0.899	[*A*]The presence of several possible interfaces[*R*]does eliminate[*A*]another possible single-point failure	context()	negated: False ,passive: False
[LINE#307] architectureSpiNNaker simulates spiking neural networks using Izhikevich [7] and Leaky Integrate and Fire [8] models which emulate the dynamics of biological neural systems.
0.947	[*A*]architectureSpiNNaker[*R*]simulates spiking[*A*]neural networks using Izhikevich [ 7 Fire [ 8 ] models	context(architectureSpiNNaker simulates)	negated: False ,passive: False
0.902	[*A*]architectureSpiNNaker[*R*]simulates[*A*]spiking neural networks	context()	negated: False ,passive: False
0.950	[*A*]Izhikevich [ 7 Fire [ 8 ] models[*R*]emulate[*A*]the dynamics of biological neural systems	context()	negated: False ,passive: False
0.918	[*A*]neural networks[*R*]using[*A*]Izhikevich [ 7 Fire [ 8 ] models	context()	negated: False ,passive: False
0.877	[*A*]models[*R*]emulate[*A*]the dynamics of biological neural systems	context()	negated: False ,passive: False
0.886	[*A*]neural networks[*R*]using[*A*]models which emulate the dynamics of biological neural systems	context()	negated: False ,passive: False
0.932	[*A*]architectureSpiNNaker[*R*]simulates spiking[*A*]neural networks using Leaky Integrate [ 8 ] models	context()	negated: False ,passive: False
0.914	[*A*]architectureSpiNNaker[*R*]simulates spiking neural networks using[*A*]Izhikevich [ 7 ] [ 8 ] models	context(architectureSpiNNaker simulates spiking)	negated: False ,passive: False
0.898	[*A*]architectureSpiNNaker[*R*]simulates spiking[*A*]neural networks	context()	negated: False ,passive: False
0.950	[*A*]Izhikevich [ 7 ] [ 8 ] models[*R*]emulate[*A*]the dynamics of biological neural systems	context()	negated: False ,passive: False
[LINE#308] However SpiNNaker has an architecture general enough to run other flavours of application [9].
0.961	[*A*]SpiNNaker[*R*]has[*A*]an architecture general enough to run other flavours of application	context()	negated: False ,passive: False
[LINE#309] For example it also supports Multilayer Perceptron models [10] and other non-neural applications such as ray-tracing, many body interaction, finite element analysis and analogue circuit simulation.
0.528	[*A*]it[*R*]supports[*A*]other non-neural applications such as ray - tracing , many analogue circuit simulation	context()	negated: False ,passive: False
0.528	[*A*]it[*R*]supports[*A*]other non-neural applications such as ray - tracing , many finite element analysis	context()	negated: False ,passive: False
0.528	[*A*]it[*R*]supports[*A*]other non-neural applications such as ray - tracing , many body interaction	context()	negated: False ,passive: False
0.456	[*A*]it[*R*]supports[*A*]Multilayer Perceptron models	context()	negated: False ,passive: False
[LINE#310] Spiking neural systems have abundant parallelism and no explicit requirement of coherence as only local information is used by the neurons.
0.911	[*A*]Spiking neural systems[*R*]have[*A*]no explicit requirement of coherence	context()	negated: False ,passive: False
0.911	[*A*]only local information[*R*]is used[*A*]by the neurons	context()	negated: False ,passive: True
0.911	[*A*]Spiking neural systems[*R*]have[*A*]abundant parallelism	context()	negated: False ,passive: False
[LINE#311] The process is as follows: each neuron has a membrane potential which is affected by incoming stimuli (signals).
0.777	[*A*]The process[*R*]is[*A*]as follows	context(each neuron has)	negated: False ,passive: True
0.941	[*A*]each neuron[*R*]has[*A*]a membrane potential which is affected by incoming stimuli (signals)	context()	negated: False ,passive: False
0.897	[*A*]a membrane potential[*R*]is affected[*A*]by incoming stimuli	context()	negated: False ,passive: True
[LINE#312] If the membrane potential exceeds a given threshold, the neuron discharges and fires a signal (a so-called spike) which is transmitted to all neurons connected through a synaptic connection, typically in the order of 103 [11].
0.732	[*A*]all neurons[*R*]connected	context()	negated: False ,passive: False
0.903	[*A*]the neuron[*R*]fires[*A*]a signal	context()	negated: False ,passive: False
0.732	[*A*]the neuron[*R*]discharges	context()	negated: False ,passive: False
0.911	[*A*]the membrane potential[*R*]exceeds[*A*]a given threshold	context()	negated: False ,passive: False
[LINE#313+314]  Biological neurons work in a noisy environment [12] and, indeed, die during normal operation(adult humans lose about one neuron per second [13]).
0.903	[*A*]adult humans[*R*]lose[*A*]about one neuron per second	context()	negated: False ,passive: False
0.925	[*A*]Biological neurons[*R*]work[*A*]in a noisy environment	context()	negated: False ,passive: False
[LINE#315] Thus their operation is neither perfect nor deterministic.
0.452	[*A*]their operation[*R*]is[*A*]neither perfect nor deterministic	context()	negated: False ,passive: True
[LINE#316] The SpiNNaker architecture reflects this behaviour.
0.933	[*A*]The SpiNNaker architecture[*R*]reflects[*A*]this behaviour	context()	negated: False ,passive: True
[LINE#317] Neurons are modelled as event-driven applications executed by the processing cores.
0.919	[*A*]event-driven applications[*R*]executed[*A*]by the processing cores	context()	negated: False ,passive: True
0.894	[*A*]Neurons[*R*]are modelled[*A*]as event-driven applications	context()	negated: False ,passive: True
[LINE#318+319]  Spikes are represented by short network packets (40 bits) using Address-Event Representation(AER), a format widely used in neural network models [14-16].
0.903	[*A*]a format[*R*]widely used[*A*]in neural network models	context()	negated: False ,passive: True
0.894	[*A*]Spikes[*R*]are represented[*A*]by short network packets	context()	negated: False ,passive: True
[LINE#320] Packets are multicast routed in hardware with the on-chip routers replicating them as necessary to reach all their destinations.
0.871	[*A*]the on-chip routers[*R*]replicating[*A*]them	context()	negated: False ,passive: False
0.862	[*A*]Packets[*R*]routed[*A*]in hardware with the on-chip routers replicating them as necessary to reach all their destinations	context()	negated: False ,passive: True
0.713	[*A*]Packets[*R*]are multicast	context()	negated: False ,passive: False
[LINE#321] Given that digital electronics are orders of magnitude faster than the biological process - for example, biological spikes are propagated through an axon for up to 20ms while transmitting a packet through the SpiNNaker interconnection network should take a few microseconds at most - it is possible to multiplex many neurons onto a processor and many spikes onto a network although the consequence of a single-point failure can easily be more serious than the loss of one neuron. .
0.943	[*A*]the consequence of a single-point failure[*R*]can easily be[*A*]more serious than the loss of one neuron	context()	negated: False ,passive: True
0.903	[*A*]biological spikes[*R*]are propagated[*A*]while transmitting a packet through the SpiNNaker interconnection network	context()	negated: False ,passive: True
0.901	[*A*]digital electronics[*R*]are faster[*A*]orders of magnitude	context()	negated: False ,passive: True
[LINE#322+323]  Naker chipThe basic unit of the system is the SpiNNaker chip (Fig. 4), custom GALS SoC with a network router and 18 cores sharing some resources such as a SRAM, a boot ROM, a System Controller, an Ethernet interface and an 128Mbyte off-chip (but in-package, see Fig. 2).
0.963	[*A*]Naker chipThe basic unit of the system[*R*]is[*A*]the SpiNNaker chip	context(custom GALS SoC with 18 cores sharing some resources such as off - chip ( but in-package see)	negated: False ,passive: True
0.958	[*A*]custom GALS SoC with 18 cores sharing some resources such as off - chip ( but in-package[*R*]see[*A*]Fig	context()	negated: False ,passive: False
0.903	[*A*]18 cores[*R*]sharing[*A*]some resources such as off - chip	context()	negated: False ,passive: False
0.962	[*A*]custom GALS SoC with 18 cores sharing some resources such as an 128Mbyte ( but in-package[*R*]see[*A*]Fig	context()	negated: False ,passive: False
0.903	[*A*]18 cores[*R*]sharing[*A*]some resources such as an 128Mbyte ( but in-package	context()	negated: False ,passive: False
0.981	[*A*]Naker chipThe basic unit of the system[*R*]is[*A*]the SpiNNaker chip ( Fig . 4 ) , custom GALS SoC with 18 cores sharing some resources such as an 128Mbyte ( but in-package , see Fig	context()	negated: False ,passive: True
0.963	[*A*]Naker chipThe basic unit of the system[*R*]is[*A*]the SpiNNaker chip	context(custom GALS SoC with 18 cores sharing some resources such as an Ethernet interface ( but in-package see)	negated: False ,passive: True
0.958	[*A*]custom GALS SoC with 18 cores sharing some resources such as an Ethernet interface ( but in-package[*R*]see[*A*]Fig	context()	negated: False ,passive: False
0.947	[*A*]18 cores[*R*]sharing[*A*]some resources such as an Ethernet interface ( but in-package	context()	negated: False ,passive: False
0.963	[*A*]Naker chipThe basic unit of the system[*R*]is[*A*]the SpiNNaker chip	context(custom GALS SoC with 18 cores sharing some resources such as a boot ROM , a System Controller ( but in-package see)	negated: False ,passive: True
0.971	[*A*]custom GALS SoC with 18 cores sharing some resources such as a boot ROM , a System Controller ( but in-package[*R*]see[*A*]Fig	context()	negated: False ,passive: False
0.947	[*A*]18 cores[*R*]sharing[*A*]some resources such as a boot ROM , a System Controller ( but in-package	context()	negated: False ,passive: False
0.963	[*A*]Naker chipThe basic unit of the system[*R*]is[*A*]the SpiNNaker chip	context(custom GALS SoC with 18 cores sharing some resources such as a SRAM ( but in-package see)	negated: False ,passive: True
0.953	[*A*]custom GALS SoC with 18 cores sharing some resources such as a SRAM ( but in-package[*R*]see[*A*]Fig	context()	negated: False ,passive: False
0.918	[*A*]18 cores[*R*]sharing[*A*]some resources such as a SRAM ( but in-package	context()	negated: False ,passive: False
0.963	[*A*]Naker chipThe basic unit of the system[*R*]is[*A*]the SpiNNaker chip	context(custom GALS SoC with a network router ( but in-package see)	negated: False ,passive: True
0.920	[*A*]custom GALS SoC with a network router ( but in-package[*R*]see[*A*]Fig	context()	negated: False ,passive: False
[LINE#324] SDRAM.Each processing core is an ARM968, with two private tightly coupled memories for instructions (ITCM) and data (DTCM), some peripherals - including direct access to the Comms NoC - and a bridge to the shared resources.
0.931	[*A*]SDRAM.Each processing core[*R*]is[*A*]an ARM968[*A*]with two private tightly coupled memories for a bridge to the shared resources	context()	negated: False ,passive: True
0.931	[*A*]SDRAM.Each processing core[*R*]is[*A*]an ARM968[*A*]with two private tightly coupled memories for some peripherals - including direct access to	context()	negated: False ,passive: True
0.894	[*A*]SDRAM.Each processing core[*R*]is[*A*]an ARM968[*A*]with two private tightly coupled memories for data	context()	negated: False ,passive: True
0.894	[*A*]SDRAM.Each processing core[*R*]is[*A*]an ARM968[*A*]with two private tightly coupled memories for instructions	context()	negated: False ,passive: True
[LINE#325] Related workResearch in simulating biologically-plausible neural networks (brain-like systems) is not new.
0.845	[*A*]Related workResearch in simulating biologically-plausible neural networks[*R*]is not[*A*]new	context()	negated: True ,passive: True
[LINE#326] In the early 1990s a team at U.C.Berkeley worked on the Connectionist Network Supercomputer [27] which aimed to build a supercomputer specifically tailored for neural computation as a tool for connectionist research.
0.941	[*A*]the Connectionist Network Supercomputer[*R*]aimed to build[*A*]a supercomputer specifically tailored for neural computation as a tool for connectionist research	context(the Connectionist Network Supercomputer aimed)	negated: False ,passive: False
0.909	[*A*]the Connectionist Network Supercomputer[*R*]aimed[*A*]to build a supercomputer	context()	negated: False ,passive: False
0.868	[*A*]a supercomputer[*R*]tailored[*A*]as a tool for connectionist research	context()	negated: False ,passive: True
0.932	[*A*]Berkeley[*R*]worked[*A*]on the Connectionist Network Supercomputer	context()	negated: False ,passive: False
[LINE#327] The system was a 2D mesh, with a target size of 128 nodes (scalable to 512).
0.952	[*A*]The system[*R*]was[*A*]a 2D mesh, with a target size of 128 nodes (scalable to 512	context()	negated: False ,passive: True
[LINE#328] Each node would incorporate a general-purpose RISC processor plus a vector coprocessor, 16 MBytes of RAM and a router.
0.903	[*A*]Each node[*R*]would incorporate[*A*]a vector coprocessor , 16 MBytes of a router	context()	negated: False ,passive: False
0.903	[*A*]Each node[*R*]would incorporate[*A*]a vector coprocessor	context()	negated: False ,passive: False
0.918	[*A*]Each node[*R*]would incorporate[*A*]a general - purpose RISC processor	context()	negated: False ,passive: False
[LINE#329] As far as we know, the node was built (under the codename T0), but the system never operated as a network.
0.732	[*A*]the system[*R*]never operated	context()	negated: True ,passive: False
0.883	[*A*]the node[*R*]was built[*A*]under the codename[*A*]As far as we know	context()	negated: False ,passive: True
0.243	[*A*]we[*R*]know	context()	negated: False ,passive: False
[LINE#330+331+332]  Experiments using up to five nodes in a bus configuration were discussed in [28].More recently, the Microelectronics Division at the Technical University of Berlin worked on a project entitled Design and implementation of spiking neural networks [http://mikro.ee.tu-berlin.de/spinn]whose objectives are similar to those of SpiNNaker.
0.851	[*A*]Experiments using up to five nodes in a bus configuration[*R*]were discussed[*A*]in [ 28[*A*]More recently	context(the Microelectronics Division at the Technical University of Berlin worked)	negated: False ,passive: True
0.952	[*A*]the Microelectronics Division at the Technical University of Berlin[*R*]worked[*A*]on implementation of spiking neural networks	context()	negated: False ,passive: False
0.804	[*A*]http://mikro.ee.tu-berlin.de/spinn]whose objectives[*R*]are[*A*]similar to those of SpiNNaker	context()	negated: False ,passive: True
0.880	[*A*]http://mikro.ee.tu-berlin.de/spinn]whose objectives[*R*]are[*A*]similar to those of SpiNNaker[*A*]a project entitled Design	context()	negated: False ,passive: True
0.961	[*A*]the Microelectronics Division at the Technical University of Berlin[*R*]worked[*A*]on a project	context()	negated: False ,passive: False
0.877	[*A*]Experiments using up to five nodes in a bus configuration[*R*]were discussed[*A*]in [ 28[*A*]More recently	context()	negated: False ,passive: True
0.894	[*A*]Experiments[*R*]using[*A*]up to five nodes[*A*]in a bus configuration	context()	negated: False ,passive: False
[LINE#333] A product of this is the Spiking Neural Network Emulation Engine (SEE), an acceleration board implemented with FPGAs interconnected via an on-board bus.
0.935	[*A*]A product of this[*R*]is[*A*]the Spiking Neural Network Emulation Engine	context(an acceleration board implemented with FPGAs interconnected)	negated: False ,passive: True
0.814	[*A*]an acceleration board implemented with FPGAs[*R*]interconnected	context()	negated: False ,passive: False
0.925	[*A*]an acceleration board[*R*]implemented[*A*]with FPGAs	context()	negated: False ,passive: True
[LINE#334] SEE accelerators were able to perform neural computations 30 times faster than a desktop PC [29].
0.874	[*A*]accelerators[*R*]to perform faster[*A*]neural computations	context()	negated: False ,passive: False
[LINE#335] However, as these boards cannot be connected to form a network, they are not able to scale to the magnitudes of SpiNNaker.
0.597	[*A*]they[*R*]are not[*A*]able to scale to the magnitudes of SpiNNaker	context()	negated: True ,passive: True
0.620	[*A*]they[*R*]to scale[*A*]to the magnitudes of SpiNNaker	context()	negated: False ,passive: False
[LINE#336] Research on spiking neural networks has also used different off-the-shelf technologies such as FPGAs [30], graphic processors [31] and general purpose processors and accelerators [32], obtaining speed-ups of over two orders of magnitude compared to software-only implementations.
0.909	[*A*]Research on spiking neural networks[*R*]has used different off - the - shelf technologies such as accelerators obtaining[*A*]speed - ups of over two orders of magnitude compared to software-only implementations	context(Research on spiking neural networks has used)	negated: False ,passive: False
0.909	[*A*]Research on spiking neural networks[*R*]has used[*A*]different off - the - shelf technologies such as accelerators[*A*]obtaining speed - ups of over two orders of magnitude compared to software-only implementations	context()	negated: False ,passive: False
0.862	[*A*]Research on spiking neural networks[*R*]has used different off - the - shelf technologies such as general purpose processors obtaining[*A*]speed - ups of over two orders of magnitude[*A*]compared to software-only implementations	context(Research on spiking neural networks has used)	negated: False ,passive: False
0.909	[*A*]Research on spiking neural networks[*R*]has used[*A*]different off - the - shelf technologies such as general purpose processors[*A*]obtaining speed - ups of over two orders of magnitude compared to software-only implementations	context()	negated: False ,passive: False
0.862	[*A*]Research on spiking neural networks[*R*]has used different off - the - shelf technologies such as graphic processors obtaining[*A*]speed - ups of over two orders of magnitude[*A*]compared to software-only implementations	context(Research on spiking neural networks has used)	negated: False ,passive: False
0.909	[*A*]Research on spiking neural networks[*R*]has used[*A*]different off - the - shelf technologies such as graphic processors[*A*]obtaining speed - ups of over two orders of magnitude compared to software-only implementations	context()	negated: False ,passive: False
0.909	[*A*]Research on spiking neural networks[*R*]has used different off - the - shelf technologies such as FPGAs [ 30 obtaining[*A*]speed - ups of over two orders of magnitude compared to software-only implementations	context(Research on spiking neural networks has used)	negated: False ,passive: False
0.923	[*A*]Research on spiking neural networks[*R*]has used[*A*]different off - the - shelf technologies such as FPGAs [ 30	context()	negated: False ,passive: False
[LINE#337] The relatively small scale of these systems allowed the assumption of a complete absence of component failures and, therefore, did not address reliability issues and did not incorporate fault-tolerant techniques.
0.938	[*A*]The relatively small scale of these systems[*R*]did not incorporate[*A*]fault - tolerant techniques	context()	negated: True ,passive: False
[LINE#338] As far as we know, there are only three active projects comparable to SpiNNaker in terms of simulation scale.
0.243	[*A*]we[*R*]know	context()	negated: False ,passive: False
[LINE#339] First, the Blue Brain project [http://bluebrain.epfl.ch/] aims to create biologically accurate functional models of the brain; however, model complexity (far more intricate than SpiNNaker's) only allows real-time execution of roughly a neuron per node [33].
0.909	[*A*]the Blue Brain project[*R*]aims to create[*A*]biologically accurate functional models of the brain	context(the Blue Brain project aims model complexity ( far more intricate than SpiNNaker 's allows)	negated: False ,passive: False
0.947	[*A*]the Blue Brain project[*R*]aims[*A*]to create biologically accurate functional models of the brain[*A*]First	context(model complexity ( far more intricate than SpiNNaker 's allows)	negated: False ,passive: False
0.963	[*A*]model complexity (far more intricate than SpiNNaker's[*R*]allows[*A*]real-time execution of roughly a neuron per node [33	context()	negated: False ,passive: False
[LINE#340+341]  This is a low figure in comparison with the several thousand(simpler) neurons per node supported by SpiNNaker.
0.957	[*A*]the several thousand(simpler) neurons per node[*R*]supported[*A*]by SpiNNaker	context()	negated: False ,passive: True
0.567	[*A*]This[*R*]is[*A*]a low figure in comparison with the several thousand(simpler) neurons per node	context()	negated: False ,passive: True
[LINE#342] Secondly, DARPA's System of Neuromorphic Adaptive Plastic Scalable Electronics (SyNAPSE) project claims that it has achieved the simulation of spiking neural networks the size of a cat's brain [34] - 109 neurons - using Izhikevich models like those supported by SpiNNaker.
0.309	[*A*]it[*R*]has achieved[*A*]the simulation of spiking neural networks the size of a cat's brain [34] - 109 neurons - using Izhikevich models like those	context(DARPA 's System of Neuromorphic Adaptive Plastic Scalable Electronics ( SyNAPSE ) project claims)	negated: False ,passive: False
0.847	[*A*]DARPA's System of Neuromorphic Adaptive Plastic Scalable Electronics (SyNAPSE) project[*R*]claims[*A*]that it has achieved the simulation of spiking neural networks the size of a cat's brain [34] - 109 neurons - using Izhikevich models like those	context()	negated: False ,passive: False
0.269	[*A*]those[*R*]supported[*A*]by SpiNNaker	context()	negated: False ,passive: True
[LINE#343] However their simulations run 2-3 orders of magnitude slower than real-time.
0.999	[*A*]their simulations[*R*]run[*A*]2 -3 orders	context()	negated: False ,passive: False
0.701	[*A*]their simulations[*R*]run[*A*]2-3 orders of magnitude slower than real-time	context()	negated: False ,passive: False
[LINE#344] In contrast with the biologically-inspired SpiNNaker architecture, neither Blue Brain nor SyNAPSE contemplate the construction of a custom architecture but use general-purpose supercomputers from the IBM BlueGene family, depending on the underlying platform for their reliability and fault tolerance.
0.885	[*A*]neither Blue Brain nor SyNAPSE[*R*]use[*A*]general-purpose supercomputers[*A*]from the IBM BlueGene family[*A*]depending on the underlying platform for their reliability and fault tolerance	context()	negated: False ,passive: False
0.897	[*A*]neither Blue Brain nor SyNAPSE[*R*]contemplate[*A*]the construction of a custom architecture	context()	negated: False ,passive: False
[LINE#345] The IBM BlueGene/L consists of 64K compute nodes, each based on PowerPC 400 processors.
0.590	[*A*]each[*R*]based[*A*]on PowerPC 400 processors	context()	negated: False ,passive: True
0.880	[*A*]The IBM BlueGene/L[*R*]compute[*A*]nodes	context()	negated: False ,passive: False
0.913	[*A*]The IBM BlueGene/L[*R*]consists[*A*]of 64K	context()	negated: False ,passive: True
[LINE#346] Additionally, it contains several service nodes that reside outside the core [35] and communicate with it using Ethernet.
0.897	[*A*]several service nodes[*R*]reside[*A*]outside the core	context()	negated: False ,passive: False
0.326	[*A*]it[*R*]contains[*A*]several service nodes that reside outside the core [ 35 ]	context()	negated: False ,passive: False
[LINE#347] This infrastructure is used for booting, controlling and monitoring the system.
0.903	[*A*]This infrastructure[*R*]is used[*A*]for monitoring the system	context()	negated: False ,passive: True
0.767	[*A*]This infrastructure[*R*]is used[*A*]for controlling	context()	negated: False ,passive: True
0.903	[*A*]This infrastructure[*R*]is used[*A*]for booting	context()	negated: False ,passive: True
[LINE#348] System monitoring and job execution is done by the combined action of service and I/O nodes which maintain log files.
0.903	[*A*]job execution[*R*]is done[*A*]by the O nodes	context()	negated: False ,passive: True
0.897	[*A*]the O nodes[*R*]maintain[*A*]log files	context()	negated: False ,passive: False
0.903	[*A*]System monitoring[*R*]is done[*A*]by the O nodes	context()	negated: False ,passive: True
0.767	[*A*]job execution[*R*]is done[*A*]by the	context()	negated: False ,passive: True
0.767	[*A*]System monitoring[*R*]is done[*A*]by the	context()	negated: False ,passive: True
0.903	[*A*]job execution[*R*]is done[*A*]by the combined action of service	context()	negated: False ,passive: True
0.903	[*A*]System monitoring[*R*]is done[*A*]by the combined action of service	context()	negated: False ,passive: True
[LINE#349] During boot-up service nodes can control the computing core to the lowest level of granularity [36].
[LINE#350] Service nodes can also directly write to and read from the device control registers of each processor.
0.682	[*A*]Service nodes[*R*]can directly write[*A*]to	context()	negated: False ,passive: False
[LINE#351] This feature is useful for handling runtime problems and investigating any booting up issues.
0.925	[*A*]This feature[*R*]is[*A*]useful for investigating any booting up issues	context()	negated: False ,passive: True
0.925	[*A*]This feature[*R*]is[*A*]useful for handling runtime problems	context()	negated: False ,passive: True
[LINE#352] For fault tolerance at boot-up or at run-time a self-test mechanism is kept in each chip to perform system diagnostics.
[LINE#353+354]  The BlueGene supercomputer or others, e.g., the Cray XT family of supercomputers[37,38], being general-purpose will provide solutions that do not match the power-efficiency of SpiNNaker.
0.937	[*A*]The BlueGene supercomputer or others, e.g., the Cray XT family of supercomputers[37,38], being general-purpose will provide solutions[*R*]do not match	context()	negated: True ,passive: False
0.879	[*A*]general-purpose[*R*]will provide[*A*]solutions that do not match the power-efficiency of SpiNNaker	context()	negated: False ,passive: False
[LINE#355] Last but not least, the FACETS project [39] is attempting to create a faster than real-time hardware system for the simulation of networks of large but unspecified size.
0.578	[*A*]the FACETS project[*R*]is attempting to create to create	context(the FACETS project is attempting)	negated: False ,passive: False
0.622	[*A*]the FACETS project[*R*]is attempting[*A*]to create	context()	negated: False ,passive: False
[LINE#356] This architecture, while biologically inspired, uses a fixed synapse and neuron model and, therefore, is not a system as general as SpiNNaker.
0.887	[*A*]This architecture[*R*]uses[*A*]a neuron model	context()	negated: False ,passive: False
0.887	[*A*]This architecture[*R*]uses[*A*]a fixed synapse model	context()	negated: False ,passive: False
[LINE#357] It employs analogue circuits to implement most of the central dynamic functions.
0.388	[*A*]It[*R*]employs analogue circuits to implement[*A*]most of the central dynamic functions	context(It employs)	negated: False ,passive: False
0.388	[*A*]It[*R*]employs[*A*]analogue circuits[*A*]to implement most of the central dynamic functions	context()	negated: False ,passive: False
[LINE#358] For these blocks what would constitute a 'fault' is not precisely defined since analogue circuits exhibit a continuum of states.
0.903	[*A*]analogue circuits[*R*]exhibit[*A*]a continuum of states	context()	negated: False ,passive: False
[LINE#359] It is therefore relevant to discuss fault tolerance only with respect to the digital components: the communications infrastructure of the design.
[LINE#360] The FACETS architecture uses wafer-scale devices [40] to achieve the necessary connectivity.
0.877	[*A*]The FACETS architecture[*R*]uses[*A*]wafer-scale devices[*A*]to achieve the necessary connectivity	context()	negated: False ,passive: False
[LINE#361] It uses AER signalling (similar to SpiNNaker), but with a circuit-switched, synchronous communications subsystem.
0.498	[*A*]It[*R*]uses[*A*]AER signalling (similar to SpiNNaker	context()	negated: False ,passive: False
[LINE#362] Systems of this kind are fault tolerant in the sense of being reconfigurable in the event of a failed link; however they are not live-reroutable, thus the system provides no protection against transient faults nor does it permit packet recovery or retransmission while the system is active.
0.903	[*A*]the system[*R*]provides[*A*]no protection against transient faults	context()	negated: False ,passive: False
0.933	[*A*]Systems of this kind[*R*]are[*A*]fault tolerant in the sense of being reconfigurable in the event of a failed link	context(they are not)	negated: False ,passive: True
0.303	[*A*]they[*R*]are not[*A*]live-reroutable	context()	negated: True ,passive: True
0.813	[*A*]the system[*R*]is[*A*]active	context()	negated: False ,passive: True
[LINE#363] A failed link requires at least a local reconfiguration with possible further routing impact.
0.943	[*A*]A failed link[*R*]requires[*A*]at least a local reconfiguration with possible further routing impact	context()	negated: False ,passive: False
[LINE#364] FACETS authors discuss fault tolerance but only as a general property of neural systems; the system does not include specifically designed fault-tolerant mechanisms.
0.787	[*A*]FACETS authors[*R*]discuss[*A*]fault tolerance[*A*]only as a general property of neural systems	context(the system does not include)	negated: False ,passive: False
0.878	[*A*]the system[*R*]does not include[*A*]specifically designed fault-tolerant mechanisms	context()	negated: True ,passive: True
[LINE#365] Thus the FACETS system, and its associated HICANN devices, once again represent a very different system designed to solve a different problem: faster than real-time neural simulation, for which power consumption is not a factor and fault tolerance merely a side effect rather than a design feature.
0.783	[*A*]its associated HICANN devices[*R*]represent[*A*]a very different system designed to solve a different problem : faster than real - time neural simulation ,[*A*]once again	context()	negated: False ,passive: False
0.903	[*A*]power consumption[*R*]is not[*A*]a tolerance	context()	negated: True ,passive: True
0.948	[*A*]a very different system[*R*]designed[*A*]to solve a different problem : faster than real - time neural simulation , for which power consumption is not a tolerance merely a side effect rather than a design feature	context()	negated: False ,passive: True
0.903	[*A*]power consumption[*R*]is not[*A*]a fault	context()	negated: True ,passive: True
0.948	[*A*]a very different system[*R*]designed[*A*]to solve a different problem : faster than real - time neural simulation , for which power consumption is not a fault merely a side effect rather than a design feature	context()	negated: False ,passive: True
0.903	[*A*]power consumption[*R*]is not[*A*]a factor	context()	negated: True ,passive: True
0.948	[*A*]a very different system[*R*]designed[*A*]to solve a different problem : faster than real - time neural simulation , for which power consumption is not a factor merely a side effect rather than a design feature	context()	negated: False ,passive: True
0.927	[*A*]the FACETS system[*R*]represent[*A*]a very different system designed to solve a different problem : faster than real - time neural simulation ,[*A*]once again	context()	negated: False ,passive: False
[LINE#366] Outside of the field of brain-like systems we can cite a heterogeneous SoC with certain architectural similarities to SpiNNaker [41].
0.740	[*A*]we[*R*]can cite[*A*]a heterogeneous SoC with certain architectural similarities to SpiNNaker [41[*A*]Outside of the field of brain-like systems	context()	negated: False ,passive: False
[LINE#367] This consists of an array of processors connected over an on-chip NoC and containing various heterogeneous system components.
0.903	[*A*]processors connected[*R*]containing[*A*]various heterogeneous system components	context()	negated: False ,passive: False
0.713	[*A*]processors[*R*]connected	context()	negated: False ,passive: False
0.381	[*A*]This[*R*]consists[*A*]of an array of processors	context()	negated: False ,passive: True
[LINE#368] However, that project considers general-purpose applications within mission critical scenarios requiring the robustness of triple modular redundancy.
0.911	[*A*]mission critical scenarios[*R*]requiring[*A*]the robustness of triple modular redundancy	context()	negated: False ,passive: False
0.903	[*A*]that project[*R*]considers[*A*]general-purpose applications within mission critical scenarios	context()	negated: False ,passive: False
[LINE#369] This approach is an expensive solution unsuitable for SpiNNaker.
0.937	[*A*]This approach[*R*]is[*A*]an expensive solution unsuitable for SpiNNaker	context()	negated: False ,passive: True
[LINE#370] In addition, their NoC appears to be a conventional synchronous design rather than the SpiNNaker self-timed communication fabric which may difficult scaling up the system.
0.945	[*A*]the SpiNNaker self-timed communication fabric[*R*]may difficult scaling[*A*]up[*A*]the system	context()	negated: False ,passive: False
0.669	[*A*]their NoC[*R*]to be[*A*]a conventional synchronous design	context()	negated: False ,passive: True
0.413	[*A*]their NoC[*R*]appears	context()	negated: False ,passive: False
[LINE#371] Reviewing the literature on general purpose multiprocessor systems we can see how memory fault tolerance efforts have been devoted mainly to the interconnect structure [42], and to the use of ECC (originally following [43]), although this may not be in itself sufficient [44].
0.897	[*A*]memory fault tolerance efforts[*R*]have been devoted[*A*]mainly[*A*]to the interconnect structure	context(we can see)	negated: False ,passive: True
0.504	[*A*]we[*R*]can see[*A*]how memory fault tolerance efforts have been devoted mainly to the interconnect structure	context()	negated: False ,passive: False
0.250	[*A*]this[*R*]may not be[*A*]in itself	context()	negated: True ,passive: True
[LINE#372] Given that symmetric redundancy of memory is expensive, recent work has introduced the concept of heterogeneous fault tolerance: graceful fall-back onto other components able to perform the same function, possibly with reduced performance [45,46].
0.937	[*A*]recent work[*R*]has introduced[*A*]the concept of heterogeneous fault tolerance: graceful fall-back onto other components able to perform the same function, possibly with reduced performance [45,46	context()	negated: False ,passive: False
0.841	[*A*]symmetric redundancy of memory[*R*]is[*A*]expensive	context()	negated: False ,passive: True
[LINE#373] Such an approach lowers overall hardware costs and represents a reasonable compromise in a power- or area-constrained design.
0.933	[*A*]Such an approach[*R*]represents[*A*]a reasonable compromise in a power- or area-constrained design	context()	negated: False ,passive: False
0.911	[*A*]Such an approach[*R*]lowers[*A*]overall hardware costs	context()	negated: False ,passive: False
[LINE#374] Our asymmetric memory architecture follows this approach.
0.681	[*A*]Our asymmetric memory architecture[*R*]follows[*A*]this approach	context()	negated: False ,passive: True
[LINE#375] Implementing fault tolerance in direct networks (such as 3D tori) is complex and costly and, therefore, a hot research topic.
0.969	[*A*]Implementing fault tolerance in direct networks ( such as 3 D tori[*R*]is[*A*]therefore[*A*]a hot research topic	context()	negated: False ,passive: True
0.929	[*A*]Implementing fault tolerance in direct networks ( such as 3 D tori[*R*]is[*A*]costly	context()	negated: False ,passive: True
0.929	[*A*]Implementing fault tolerance in direct networks ( such as 3 D tori[*R*]is[*A*]complex	context()	negated: False ,passive: True
[LINE#376] Current solutions are neither easy nor cheap to implement in silicon (see, for example, [47,48]).
0.903	[*A*]Current solutions[*R*]are[*A*]neither easy nor cheap to implement in silicon	context()	negated: False ,passive: True
[LINE#377] The simple emergency routing mechanism implemented in SpiNNker has been shown to be very effective for this purpose.
0.950	[*A*]The simple emergency routing mechanism implemented in SpiNNker[*R*]to be[*A*]very effective for this purpose	context()	negated: False ,passive: True
0.869	[*A*]The simple emergency routing mechanism implemented in SpiNNker[*R*]has been shown	context()	negated: False ,passive: False
0.937	[*A*]The simple emergency routing mechanism[*R*]implemented[*A*]in SpiNNker	context()	negated: False ,passive: True
[LINE#378] Summary and conclusionsThis paper has focused on introducing the broad collection of fault tolerance mechanisms implemented in SpiNNaker.
0.903	[*A*]conclusionsThis paper[*R*]has focused[*A*]on introducing the broad collection of fault tolerance mechanisms	context()	negated: False ,passive: False
0.925	[*A*]fault tolerance mechanisms[*R*]implemented[*A*]in SpiNNaker	context()	negated: False ,passive: True
0.903	[*A*]Summary paper[*R*]has focused[*A*]on introducing the broad collection of fault tolerance mechanisms	context()	negated: False ,passive: False
[LINE#379] Such features are quite extensive, and we have presented descriptions of the principal mechanisms and, where available, the pre-silicon assessment of their effectiveness.
0.309	[*A*]we[*R*]have presented[*A*]descriptions of the pre-silicon assessment of their effectiveness	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]have presented[*A*]descriptions of the principal mechanisms	context()	negated: False ,passive: False
0.767	[*A*]Such features[*R*]are[*A*]quite extensive	context()	negated: False ,passive: True
[LINE#380] Some of the most important features discussed in this paper are the following:A collection of system routines able to detect faults and to quickly recover from them when possible or to isolate components and to reconfigure the system otherwise.A range of application loading policies offering different levels of resilience and performance which can be used depending on the level of system degradation.The use of GALS logic that facilitates the SoC design process, simplifies timing closure and simplifies the isolation of faulty components but introduces weaknesses that have been overcome with custom-hardware.Asymmetric redundancy of the memory subsystem, granting graceful fall-back onto other components able to perform the same function although with reduced performance.
0.905	[*A*]the system[*R*]facilitates[*A*]the SoC design process	context()	negated: False ,passive: False
0.945	[*A*]application loading policies offering different levels of resilience and performance[*R*]can be used[*A*]depending on the level of system	context()	negated: False ,passive: True
0.905	[*A*]weaknesses[*R*]have been overcome[*A*]granting graceful fall-back onto other components able to perform the same function	context()	negated: False ,passive: True
0.887	[*A*]the system[*R*]simplifies[*A*]timing closure	context()	negated: False ,passive: False
0.910	[*A*]Some of the most important features[*R*]are[*A*]the following:A collection of system routines able to detect faults and to quickly recover from them when possible or to isolate components and to reconfigure the system otherwise.A range of application loading policies	context()	negated: False ,passive: True
0.919	[*A*]the most important features[*R*]discussed[*A*]in this paper	context()	negated: False ,passive: True
[LINE#381] Such an approach lowers overall hardware costs and represents a reasonable compromise in a power- or area-constrained design.A novel robust self-timed chip-to-chip interface circuit, resilient to noise-induced glitches preventing deadlocks.A stable communication fabric able to support communication demands exceeding those expected during regular operation.The novel emergency routing mechanism helps to deal with congestion and network failures.
0.773	[*A*]communication demands[*R*]exceeding[*A*]those expected during regular operation.The novel emergency routing mechanism	context()	negated: False ,passive: False
0.760	[*A*]stable communication fabric[*R*]to support[*A*]communication demands exceeding those	context()	negated: False ,passive: False
0.931	[*A*]noise-induced glitches[*R*]preventing[*A*]deadlocks.A	context()	negated: False ,passive: False
0.933	[*A*]Such an approach[*R*]represents[*A*]a reasonable compromise in a power- or area-constrained design.A novel robust self-timed chip-to-chip interface circuit, resilient to noise-induced glitches	context()	negated: False ,passive: False
0.234	[*A*]those[*R*]expected[*A*]during regular operation.The novel emergency routing mechanism	context()	negated: False ,passive: True
0.911	[*A*]Such an approach[*R*]lowers[*A*]overall hardware costs	context()	negated: False ,passive: False
[LINE#382] The main conclusion of this paper is that SpiNNaker is a well-balanced fault-resilient architecture in which fault-tolerance has been considered a fundamental foundation of its design.
0.914	[*A*]SpiNNaker[*R*]is[*A*]a well-balanced fault-resilient architecture in which fault-tolerance has been considered a fundamental foundation of its design	context(The main conclusion of this paper is)	negated: False ,passive: True
0.911	[*A*]The main conclusion of this paper[*R*]is[*A*]that SpiNNaker is a well-balanced fault-resilient architecture	context()	negated: False ,passive: True
[LINE#383] This should facilitate its scaling from the prototype, 4-chip systems into practical, large-scale networks with over 1 million cores.
0.250	[*A*]This[*R*]should facilitate[*A*]its scaling[*A*]from the prototype, 4-chip systems	context()	negated: False ,passive: False
