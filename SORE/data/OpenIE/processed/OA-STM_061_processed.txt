[LINE#0] Detecting and dealing with congestion in delay-tolerant networks (DTNs) is an important and challenging problem.
0.949	[*A*]dealing with congestion in delay - tolerant networks[*R*]is[*A*]an challenging problem	context()	negated: False ,passive: True
0.949	[*A*]dealing with congestion in delay - tolerant networks[*R*]is[*A*]an important problem	context()	negated: False ,passive: True
0.613	[*A*]Detecting[*R*]is[*A*]an challenging problem	context()	negated: False ,passive: True
0.613	[*A*]Detecting[*R*]is[*A*]an important problem	context()	negated: False ,passive: True
[LINE#1] Current DTN forwarding algorithms typically direct traffic towards more central nodes in order to maximise delivery ratios and minimise delays, but as traffic demands increase these nodes may become saturated and unusable.
0.927	[*A*]Current DTN[*R*]forwarding[*A*]algorithms	context()	negated: False ,passive: False
[LINE#2] We propose CafRep, an adaptive congestion aware protocol that detects and reacts to congested nodes and congested parts of the network by using implicit hybrid contact and resources congestion heuristics.
0.913	[*A*]an adaptive congestion aware protocol[*R*]reacts[*A*]to congested congested parts of the network	context()	negated: False ,passive: False
0.913	[*A*]an adaptive congestion aware protocol[*R*]reacts[*A*]to congested nodes	context()	negated: False ,passive: False
0.756	[*A*]an adaptive congestion aware protocol[*R*]detects	context()	negated: False ,passive: False
0.498	[*A*]We[*R*]propose[*A*]CafRep	context()	negated: False ,passive: False
[LINE#3] CafRep exploits localised relative utility based approach to offload the traffic from more to less congested parts of the network, and to replicate at adaptively lower rate in different parts of the network with non-uniform congestion levels.
0.698	[*A*]the traffic[*R*]to replicate	context()	negated: False ,passive: False
0.927	[*A*]CafRep exploits[*R*]localised[*A*]relative utility based approach to offload[*A*]from more to less congested parts of the network	context()	negated: False ,passive: False
[LINE#4] We extensively evaluate our work against benchmark and competitive protocols across a range of metrics over three real connectivity and GPS traces such as Sassy [44], San Francisco Cabs [45] and Infocom 2006 [33].
0.568	[*A*]We[*R*]GPS[*A*]traces such as Infocom 2006	context()	negated: False ,passive: False
0.568	[*A*]We[*R*]GPS[*A*]traces such as San Francisco Cabs	context()	negated: False ,passive: False
0.568	[*A*]We[*R*]GPS[*A*]traces such as Sassy [ 44	context()	negated: False ,passive: False
0.418	[*A*]We[*R*]extensively evaluate[*A*]our work against competitive protocols across a range of metrics over three real connectivity	context()	negated: False ,passive: False
0.418	[*A*]We[*R*]extensively evaluate[*A*]our work against benchmark protocols across a range of metrics over three real connectivity	context()	negated: False ,passive: False
[LINE#5] We show that CafRep performs well, independent of network connectivity and mobility patterns, and consistently outperforms the state-of-the-art DTN forwarding algorithms in the face of increasing rates of congestion.
0.278	[*A*]We[*R*]show[*A*]that CafRep performs well , independent of mobility patterns	context()	negated: False ,passive: False
0.638	[*A*]CafRep[*R*]performs well independent	context(We show)	negated: False ,passive: False
0.278	[*A*]We[*R*]show[*A*]that CafRep performs well , independent of network connectivity	context()	negated: False ,passive: False
0.730	[*A*]CafRep[*R*]performs well	context(We show)	negated: False ,passive: False
0.382	[*A*]We[*R*]show[*A*]that CafRep performs well , consistently outperforms the state - of - the - art DTN forwarding algorithms in the face of increasing rates of congestion	context()	negated: False ,passive: False
0.949	[*A*]CafRep[*R*]consistently outperforms[*A*]the state - of - the - art DTN forwarding algorithms	context()	negated: False ,passive: False
[LINE#6] CafRep maintains higher availability and success ratios while keeping low delays, packet loss rates and delivery cost.
0.852	[*A*]CafRep[*R*]maintains success ratios keeping[*A*]low delivery cost	context(CafRep maintains)	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]maintains[*A*]success ratios[*A*]while keeping low delivery cost	context()	negated: False ,passive: False
0.852	[*A*]CafRep[*R*]maintains success ratios keeping[*A*]low packet loss rates	context(CafRep maintains)	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]maintains[*A*]success ratios[*A*]while keeping low packet loss rates	context()	negated: False ,passive: False
0.852	[*A*]CafRep[*R*]maintains success ratios keeping[*A*]low delays	context(CafRep maintains)	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]maintains[*A*]success ratios[*A*]while keeping low delays	context()	negated: False ,passive: False
0.852	[*A*]CafRep[*R*]maintains higher availability keeping[*A*]low delivery cost	context(CafRep maintains)	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]maintains[*A*]higher availability[*A*]while keeping low delivery cost	context()	negated: False ,passive: False
0.852	[*A*]CafRep[*R*]maintains higher availability keeping[*A*]low packet loss rates	context(CafRep maintains)	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]maintains[*A*]higher availability[*A*]while keeping low packet loss rates	context()	negated: False ,passive: False
0.852	[*A*]CafRep[*R*]maintains higher availability keeping[*A*]low delays	context(CafRep maintains)	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]maintains[*A*]higher availability[*A*]while keeping low delays	context()	negated: False ,passive: False
[LINE#7] We test CafRep in the presence of two application scenarios, with fixed rate traffic and with real world Facebook application traffic demands, showing that regardless of the type of traffic CafRep aims to deliver, it reduces congestion and improves forwarding performance.
0.388	[*A*]it[*R*]reduces[*A*]congestion	context(We test showing)	negated: False ,passive: False
0.503	[*A*]We[*R*]test[*A*]CafRep[*A*]in the presence of two application scenarios	context()	negated: False ,passive: False
0.730	[*A*]CafRep[*R*]aims to deliver to deliver	context(CafRep aims)	negated: False ,passive: False
0.295	[*A*]We[*R*]test[*A*]CafRep[*A*]in the presence of two application scenarios[*A*]showing that regardless of the type of traffic CafRep aims to deliver , it improves forwarding performance	context()	negated: False ,passive: False
0.388	[*A*]it[*R*]reduces[*A*]congestion	context(We test showing)	negated: False ,passive: False
0.137	[*A*]We[*R*]test CafRep showing[*A*]that regardless of the type of traffic CafRep aims to deliver , it reduces congestion	context(We test)	negated: False ,passive: False
0.244	[*A*]We[*R*]test[*A*]CafRep[*A*]in the presence of two application scenarios[*A*]showing that regardless of the type of traffic CafRep aims to deliver , it reduces congestion	context()	negated: False ,passive: False
0.730	[*A*]CafRep[*R*]aims to deliver to deliver	context(CafRep aims)	negated: False ,passive: False
0.764	[*A*]CafRep[*R*]aims[*A*]to deliver	context()	negated: False ,passive: False
[LINE#8] Conclusion and future workWe proposed CafRep that uses a combined local social, buffer and delay metrics for congestion aware message forwarding and replication that maximises message delivery ratio and availability of nodes while minimising latency and packet loss rates at times of increasing congestion levels.
0.905	[*A*]congestion aware message replication[*R*]maximises[*A*]message delivery availability of nodes	context()	negated: False ,passive: False
0.918	[*A*]future workWe[*R*]proposed[*A*]CafRep	context()	negated: False ,passive: False
0.940	[*A*]CafRep[*R*]uses[*A*]a combined local delay metrics for congestion aware message replication	context()	negated: False ,passive: False
0.906	[*A*]CafRep[*R*]uses[*A*]a combined local delay metrics for congestion aware message	context()	negated: False ,passive: False
0.940	[*A*]CafRep[*R*]uses[*A*]a combined local buffer metrics for congestion aware message replication	context()	negated: False ,passive: False
0.906	[*A*]CafRep[*R*]uses[*A*]a combined local buffer metrics for congestion aware message	context()	negated: False ,passive: False
0.939	[*A*]congestion aware message replication[*R*]maximises[*A*]message delivery availability of nodes[*A*]while minimising packet loss rates at times of increasing congestion levels	context()	negated: False ,passive: False
0.939	[*A*]congestion aware message replication[*R*]maximises[*A*]message delivery availability of nodes[*A*]while minimising latency loss rates at times of increasing congestion levels	context()	negated: False ,passive: False
0.939	[*A*]congestion aware message replication[*R*]maximises[*A*]message delivery ratio of nodes[*A*]while minimising packet loss rates at times of increasing congestion levels	context()	negated: False ,passive: False
0.939	[*A*]congestion aware message replication[*R*]maximises[*A*]message delivery ratio of nodes[*A*]while minimising latency loss rates at times of increasing congestion levels	context()	negated: False ,passive: False
0.940	[*A*]CafRep[*R*]uses[*A*]a combined local social metrics for congestion aware message replication	context()	negated: False ,passive: False
0.927	[*A*]that maximises message delivery availability of nodes[*R*]minimising[*A*]packet loss rates[*A*]at times of increasing congestion levels	context()	negated: False ,passive: False
0.927	[*A*]that maximises message delivery availability of nodes[*R*]minimising[*A*]latency loss rates[*A*]at times of increasing congestion levels	context()	negated: False ,passive: False
0.927	[*A*]that maximises message delivery ratio of nodes[*R*]minimising[*A*]packet loss rates[*A*]at times of increasing congestion levels	context()	negated: False ,passive: False
0.927	[*A*]that maximises message delivery ratio of nodes[*R*]minimising[*A*]latency loss rates[*A*]at times of increasing congestion levels	context()	negated: False ,passive: False
0.751	[*A*]congestion aware message[*R*]forwarding	context()	negated: False ,passive: False
0.906	[*A*]CafRep[*R*]uses[*A*]a combined local social metrics for congestion aware message	context()	negated: False ,passive: False
0.918	[*A*]Conclusion workWe[*R*]proposed[*A*]CafRep	context()	negated: False ,passive: False
[LINE#9] At the core of CafRep is a combined relative utility driven heuristic that allows highly adaptive forwarding and replication policies by managing to detect and offload congested parts of the network and adapting the sending/forwarding rates based on resource and contact predictions.
0.926	[*A*]the sending / forwarding rates[*R*]based[*A*]on contact predictions	context()	negated: False ,passive: True
0.926	[*A*]the sending / forwarding rates[*R*]based[*A*]on resource	context()	negated: False ,passive: True
0.877	[*A*]heuristic[*R*]allows[*A*]highly adaptive replication policies	context()	negated: False ,passive: False
0.920	[*A*]heuristic[*R*]allows[*A*]highly adaptive forwarding policies by managing to offload congested parts of the network	context()	negated: False ,passive: False
0.877	[*A*]heuristic[*R*]allows[*A*]highly adaptive forwarding policies	context()	negated: False ,passive: False
[LINE#10] We empirically investigated a number of weighting models for analysing the impact of different utilities on the CafRep performance.
0.614	[*A*]We[*R*]empirically investigated[*A*]a number of weighting models for analysing the impact of different utilities on the CafRep performance	context()	negated: False ,passive: False
[LINE#11]  We have done extensive performance analysis of CafRep in three CRAWDAD real connectivity and GPS traces with different mobility and connectivity patterns:.
0.522	[*A*]We[*R*]GPS[*A*]traces[*A*]with different connectivity	context()	negated: False ,passive: False
0.522	[*A*]We[*R*]GPS[*A*]traces[*A*]with different mobility	context()	negated: False ,passive: False
0.498	[*A*]We[*R*]have done[*A*]extensive performance analysis of CafRep[*A*]in three CRAWDAD real connectivity	context()	negated: False ,passive: False
[LINE#12] Infocom 2006, Sassy and San Francisco Cabs.
[LINE#13] We show that CafRep outperforms five other state of the art DTN adaptive and non-adaptive routing protocols across the majority of metrics across all the traces.
0.947	[*A*]CafRep[*R*]outperforms[*A*]five other state of the art DTN non-adaptive routing protocols across the majority of metrics across all the traces	context(We show)	negated: False ,passive: False
0.382	[*A*]We[*R*]show[*A*]that CafRep outperforms five other state of the art DTN non-adaptive routing protocols across the majority of metrics across all the traces	context()	negated: False ,passive: False
0.947	[*A*]CafRep[*R*]outperforms[*A*]five other state of the art DTN adaptive routing protocols across the majority of metrics across all the traces	context(We show)	negated: False ,passive: False
0.382	[*A*]We[*R*]show[*A*]that CafRep outperforms five other state of the art DTN adaptive routing protocols across the majority of metrics across all the traces	context()	negated: False ,passive: False
[LINE#14] We also show that CafRep maintains performance levels in two application scenarios: publish subscribe constant bit rate podcasting and Facebook traffic application.
[LINE#15] We believe that CafRep provides a useful generic and highly adaptive congestion control framework suitable for different types of resource constraint DTN application scenarios.
0.947	[*A*]CafRep[*R*]provides[*A*]a highly adaptive congestion control framework suitable for different types of resource constraint DTN application scenarios	context(We believe)	negated: False ,passive: False
0.317	[*A*]We[*R*]believe[*A*]that CafRep provides a highly adaptive congestion control framework suitable for different types of resource constraint DTN application scenarios	context()	negated: False ,passive: False
0.947	[*A*]CafRep[*R*]provides[*A*]a useful generic congestion control framework suitable for different types of resource constraint DTN application scenarios	context(We believe)	negated: False ,passive: False
0.317	[*A*]We[*R*]believe[*A*]that CafRep provides a useful generic congestion control framework suitable for different types of resource constraint DTN application scenarios	context()	negated: False ,passive: False
[LINE#16] We also plan to investigate the efficiency of CafRep in the context of more realistic anycast and multicast applications.
0.508	[*A*]We[*R*]plan to investigate[*A*]the efficiency of CafRep in the context of multicast applications	context(We plan)	negated: False ,passive: False
0.579	[*A*]We[*R*]plan[*A*]to investigate the efficiency of CafRep in the context of multicast applications	context()	negated: False ,passive: False
0.508	[*A*]We[*R*]plan to investigate[*A*]the efficiency of CafRep in the context of more realistic anycast	context(We plan)	negated: False ,passive: False
0.579	[*A*]We[*R*]plan[*A*]to investigate the efficiency of CafRep in the context of more realistic anycast	context()	negated: False ,passive: False
[LINE#17] Congestion aware forwarding and replication for DTNs.
[LINE#18] Varying mobility patterns, topology changes, disconnections and resource restrictions pose many challenges for the design and implementation of congestion aware data transmission in DTNs.
0.947	[*A*]resource restrictions[*R*]pose[*A*]many challenges for the implementation of congestion aware data transmission in DTNs	context()	negated: False ,passive: False
0.903	[*A*]resource restrictions[*R*]pose[*A*]many challenges for the design	context()	negated: False ,passive: False
0.942	[*A*]disconnections[*R*]pose[*A*]many challenges for the implementation of congestion aware data transmission in DTNs	context()	negated: False ,passive: False
0.894	[*A*]disconnections[*R*]pose[*A*]many challenges for the design	context()	negated: False ,passive: False
0.947	[*A*]topology changes[*R*]pose[*A*]many challenges for the implementation of congestion aware data transmission in DTNs	context()	negated: False ,passive: False
0.903	[*A*]topology changes[*R*]pose[*A*]many challenges for the design	context()	negated: False ,passive: False
0.952	[*A*]Varying mobility patterns[*R*]pose[*A*]many challenges for the implementation of congestion aware data transmission in DTNs	context()	negated: False ,passive: False
0.911	[*A*]Varying mobility patterns[*R*]pose[*A*]many challenges for the design	context()	negated: False ,passive: False
[LINE#19] This section systematically outlines particular challenges that motivate our criteria described in Section 3.2 that guide our proposal..
0.447	[*A*]our criteria[*R*]guide[*A*]our proposal	context()	negated: False ,passive: False
0.638	[*A*]our criteria[*R*]described[*A*]in Section 3.2	context()	negated: False ,passive: True
0.810	[*A*]particular challenges[*R*]motivate[*A*]our criteria described in Section 3.2	context()	negated: False ,passive: False
0.649	[*A*]This section[*R*]systematically outlines[*A*]particular challenges that motivate our criteria	context()	negated: False ,passive: False
[LINE#20] Distributed decisionsThe limited connectivity and fragmented nature of opportunistic networks mean that it is neither efficient to obtain and maintain a global level of knowledge of the network nor to rely on closed-loop (acknowledgement based) techniques for any decisions.
0.874	[*A*]Distributed decisionsThe limited connectivity and fragmented nature of opportunistic networks[*R*]mean[*A*]that it is neither efficient to obtain and maintain a global level of knowledge of the network nor to rely on closed-loop (acknowledgement based) techniques for any decisions	context()	negated: False ,passive: False
[LINE#21] We aim to allow each device in the DTN network to act independently and base their decisions on the limited localised knowledge with the aim to enable better performance of the whole network. .
0.184	[*A*]We[*R*]aim to allow each device to base[*A*]their decisions[*A*]on the limited localised knowledge with the aim	context(We aim to allow)	negated: False ,passive: False
0.433	[*A*]We[*R*]aim to allow[*A*]each device[*A*]in the DTN network	context(We aim)	negated: False ,passive: False
0.433	[*A*]We[*R*]aim[*A*]to allow each device in the DTN network	context()	negated: False ,passive: False
0.397	[*A*]We[*R*]aim to allow[*A*]each device	context(We aim)	negated: False ,passive: False
0.560	[*A*]We[*R*]aim[*A*]to allow each device in the DTN network to act independently	context()	negated: False ,passive: False
0.698	[*A*]each device[*R*]to act independently	context()	negated: False ,passive: False
[LINE#22] Limited resourcesAs buffer capacity, transfer bandwidth and battery life are limited, the messages can only be transferred successfully if the efficient coordination between the devices competing for resources is provided. .
0.732	[*A*]battery life[*R*]are limited	context()	negated: False ,passive: False
0.732	[*A*]transfer bandwidth[*R*]are limited	context()	negated: False ,passive: False
0.773	[*A*]the efficient coordination between the devices[*R*]is provided	context()	negated: False ,passive: False
0.903	[*A*]the devices[*R*]competing[*A*]for resources	context()	negated: False ,passive: False
0.907	[*A*]the messages[*R*]can be transferred successfully[*A*]if the efficient coordination between the devices competing for resources is provided	context()	negated: False ,passive: True
[LINE#23] Network density and localised surges in trafficNode connectivity in DTNs is sporadic and islands of connectivity may range in size, from sparse to dense.
0.954	[*A*]surges in trafficNode connectivity in DTNs islands of connectivity[*R*]may range[*A*]from sparse to dense	context()	negated: False ,passive: True
0.919	[*A*]localised islands of connectivity[*R*]may range[*A*]in size[*A*]from sparse to dense	context()	negated: False ,passive: True
0.926	[*A*]Network density islands of connectivity[*R*]may range[*A*]in size[*A*]from sparse to dense	context()	negated: False ,passive: True
0.897	[*A*]surges in trafficNode connectivity in DTNs[*R*]is[*A*]sporadic	context()	negated: False ,passive: True
0.359	[*A*]localised[*R*]is[*A*]sporadic	context()	negated: False ,passive: True
0.813	[*A*]Network density[*R*]is[*A*]sporadic	context()	negated: False ,passive: True
[LINE#24] Sparse networks present limited forwarding options at any given time, while dense networks are prone to suffering from transmission collisions due to wireless interference.
0.887	[*A*]dense networks[*R*]to suffering[*A*]from transmission collisions due to wireless interference	context()	negated: False ,passive: False
0.937	[*A*]dense networks[*R*]are[*A*]prone to suffering from transmission collisions due to wireless interference	context()	negated: False ,passive: True
[LINE#25] We aim to propose a protocol that could work well across these highly different network scenarios. .
0.279	[*A*]We[*R*]aim to propose[*A*]a protocol that could work well across these highly different network scenarios	context(We aim)	negated: False ,passive: False
0.397	[*A*]We[*R*]aim[*A*]to propose a protocol	context()	negated: False ,passive: False
0.887	[*A*]a protocol[*R*]could work well[*A*]across these highly different network scenarios	context()	negated: False ,passive: False
[LINE#26] In response to the challenges described in Section 3.1, we focus on the following research question:How can disconnection prone nodes with different mobility and connectivity patterns and with limited resources, communicate in an efficient, adaptive and robust manner when there are a large number of data sources and destinations?We address this question by identifying the following criteria that guide our proposal..
0.112	[*A*]We[*R*]address this question by identifying[*A*]the following criteria that guide our proposal	context(We address)	negated: False ,passive: False
0.112	[*A*]We[*R*]address this question by identifying[*A*]the following criteria that guide our proposal	context(We address)	negated: False ,passive: False
0.544	[*A*]question:How[*R*]can disconnection[*A*]prone nodes	context()	negated: False ,passive: False
0.112	[*A*]We[*R*]address this question by identifying[*A*]the following criteria that guide our proposal	context(We address)	negated: False ,passive: False
0.544	[*A*]question:How[*R*]can disconnection[*A*]prone nodes with different mobility	context()	negated: False ,passive: False
0.112	[*A*]We[*R*]address this question by identifying[*A*]the following criteria that guide our proposal	context(We address)	negated: False ,passive: False
0.112	[*A*]We[*R*]address this question by identifying[*A*]the following criteria that guide our proposal	context(We address)	negated: False ,passive: False
0.112	[*A*]We[*R*]address this question by identifying[*A*]the following criteria that guide our proposal	context(We address)	negated: False ,passive: False
0.544	[*A*]question:How[*R*]can disconnection[*A*]prone nodes with limited resources	context()	negated: False ,passive: False
0.825	[*A*]the following criteria[*R*]guide[*A*]our proposal	context()	negated: False ,passive: False
0.112	[*A*]We[*R*]address this question by identifying[*A*]the following criteria that guide our proposal	context(We address)	negated: False ,passive: False
0.388	[*A*]We[*R*]address[*A*]this question	context()	negated: False ,passive: False
0.903	[*A*]the challenges[*R*]described[*A*]in Section 3.1	context()	negated: False ,passive: True
[LINE#27] We define efficiency in terms of providing support for minimising the traffic latency and optimising utilisation of network resources.
0.452	[*A*]We[*R*]define[*A*]efficiency	context()	negated: False ,passive: False
[LINE#28] More specifically, for DTN forwarding algorithms traffic latency is a key concern, as the freshness of data is important and it is persistently challenged by disconnections and congestion of intermediaries that prevent efficient store-carry-and-forward routing.
0.877	[*A*]intermediaries[*R*]prevent[*A*]efficient store-carry-and-forward routing	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]is persistently challenged[*A*]by congestion of intermediaries	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]is persistently challenged[*A*]by disconnections	context()	negated: False ,passive: True
0.841	[*A*]the freshness of data[*R*]is[*A*]important	context()	negated: False ,passive: True
0.855	[*A*]DTN[*R*]forwarding[*A*]algorithms traffic latency	context()	negated: False ,passive: False
[LINE#29] Similarly, DTN forwarding algorithms identify a subset of better connected nodes to which they forward the majority of the traffic.
0.933	[*A*]DTN forwarding algorithms[*R*]identify[*A*]a subset of better connected nodes	context()	negated: False ,passive: False
0.855	[*A*]DTN[*R*]forwarding[*A*]algorithms	context()	negated: False ,passive: False
[LINE#30] As these nodes become overloaded, forwarding to a lower ranked node may lead to more even spread of the network load in the network and lower congestion rates, but also to increased number of intermediaries for the forwarded messages.
0.961	[*A*]forwarding to a lower ranked node[*R*]may lead[*A*]to[*A*]As these nodes become overloaded	context()	negated: False ,passive: False
0.544	[*A*]lower[*R*]ranked[*A*]node	context()	negated: False ,passive: True
0.767	[*A*]these nodes[*R*]become[*A*]overloaded	context()	negated: False ,passive: True
[LINE#31] We aim to provide a mechanism that manages to dynamically balance more even utilisation of network nodes while keeping the traffic delays and number of forwarded packets low. .
0.921	[*A*]more even utilisation of network nodes[*R*]keeping[*A*]the number of forwarded packets low	context()	negated: False ,passive: False
0.858	[*A*]a mechanism[*R*]manages to dynamically[*A*]balance	context(a mechanism manages)	negated: False ,passive: False
0.858	[*A*]a mechanism[*R*]manages[*A*]to dynamically balance	context()	negated: False ,passive: False
0.194	[*A*]We[*R*]aim to provide[*A*]a mechanism that manages to dynamically balance	context(We aim)	negated: False ,passive: False
0.397	[*A*]We[*R*]aim[*A*]to provide a mechanism	context()	negated: False ,passive: False
[LINE#32] N nodes typically have self organised fully distributed behaviour which means that they base their decisions on the knowledge gathered in their local environment.
0.770	[*A*]self[*R*]organised[*A*]fully distributed behaviour	context(N nodes have)	negated: False ,passive: False
0.858	[*A*]N nodes[*R*]have[*A*]self organised fully distributed behaviour	context()	negated: False ,passive: False
0.835	[*A*]the knowledge[*R*]gathered[*A*]in their local environment	context()	negated: False ,passive: True
[LINE#33] As we aim to optimise network wide behaviour based on nodes localised decisions, the question of how the individual nodes can get the feedback about the remote network state and affect it becomes highly challenging.
0.574	[*A*]the question of how the individual nodes can affect it[*R*]becomes[*A*]highly challenging	context()	negated: False ,passive: True
0.848	[*A*]the individual nodes[*R*]can affect[*A*]it	context()	negated: False ,passive: False
0.713	[*A*]nodes[*R*]localised	context()	negated: False ,passive: False
0.569	[*A*]we[*R*]aim[*A*]to optimise network wide behaviour based on nodes localised decisions	context()	negated: False ,passive: False
0.927	[*A*]the question of how the individual nodes can get the feedback about the remote network state[*R*]becomes[*A*]highly challenging	context()	negated: False ,passive: True
0.911	[*A*]the individual nodes[*R*]can get[*A*]the feedback about the remote network state	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]aim[*A*]to optimise network wide behaviour	context()	negated: False ,passive: False
[LINE#34] We aim to provide an adaptive mechanism that achieves network-wide optimisations by only fully relying on localised node aggregate heuristics and multi-dimensional metrics. .
0.279	[*A*]We[*R*]aim to provide[*A*]an adaptive mechanism that achieves network-wide optimisations by only fully relying on localised node aggregate heuristics and multi-dimensional metrics	context(We aim)	negated: False ,passive: False
0.397	[*A*]We[*R*]aim[*A*]to provide an adaptive mechanism	context()	negated: False ,passive: False
0.897	[*A*]an adaptive mechanism[*R*]achieves[*A*]network-wide optimisations	context()	negated: False ,passive: False
[LINE#35] We define robustness in terms of providing increased packet resiliency and collaboration between the nodes.
0.452	[*A*]We[*R*]define[*A*]robustness	context()	negated: False ,passive: False
[LINE#36] More specifically, due to nodes limited battery resources and high mobility, our aim is to investigate strategies for ensuring that the effect of dropped packets is minimal on the final delivery rates.
[LINE#37] As the closed-loop acknowledgement-based loss recovery is ineffective in DTN environments, we look into packet replication techniques that can help with this.
0.754	[*A*]packet replication techniques[*R*]can help[*A*]with this	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]look[*A*]into packet replication techniques	context()	negated: False ,passive: False
0.967	[*A*]the closed-loop acknowledgement-based loss recovery[*R*]is[*A*]ineffective in DTN environments	context()	negated: False ,passive: True
[LINE#38] Similarly, in order to avoid greedy localised node-only behaviour that leads to decreased intermediary resources and lower network-wide performance, we aim to provide a mechanism that carefully balances opportunistic usage of intermediary resources and cooperative behaviour that leads to improved end to end delivery rates. .
0.271	[*A*]we[*R*]aim to provide[*A*]a mechanism that carefully balances opportunistic usage of cooperative behaviour	context(we aim)	negated: False ,passive: False
0.271	[*A*]we[*R*]aim to provide[*A*]a mechanism that carefully balances opportunistic usage of intermediary resources	context(we aim)	negated: False ,passive: False
0.905	[*A*]greedy localised node-only behaviour[*R*]leads[*A*]to decreased lower network - wide performance	context()	negated: False ,passive: False
0.271	[*A*]we[*R*]aim to provide[*A*]a mechanism that carefully balances opportunistic usage of cooperative behaviour	context(we aim)	negated: False ,passive: False
0.887	[*A*]cooperative behaviour[*R*]leads[*A*]to improved end to end delivery rates	context()	negated: False ,passive: False
0.887	[*A*]a mechanism[*R*]carefully balances[*A*]opportunistic usage of cooperative behaviour	context()	negated: False ,passive: False
0.271	[*A*]we[*R*]aim to provide[*A*]a mechanism that carefully balances opportunistic usage of intermediary resources	context(we aim)	negated: False ,passive: False
0.388	[*A*]we[*R*]aim[*A*]to provide a mechanism	context()	negated: False ,passive: False
0.905	[*A*]greedy localised node-only behaviour[*R*]leads[*A*]to decreased intermediary resources	context()	negated: False ,passive: False
0.887	[*A*]a mechanism[*R*]carefully balances[*A*]opportunistic usage of intermediary resources	context()	negated: False ,passive: False
[LINE#39] Analytical modelWe model the network as a temporal graph G=(V,E) because the connectivity of the network E and the state of the nodes V change over time.
[LINE#40]  We model each of these as time series and depict the vertices as V={Vt: tT} and the edges as E={Et: tT}, where t is a member of the time series.
0.925	[*A*]t[*R*]is[*A*]a member of the time series[*A*]tT	context()	negated: False ,passive: True
0.925	[*A*]t[*R*]is[*A*]a member of the time series[*A*]Et : tT	context()	negated: False ,passive: True
0.911	[*A*]time[*R*]series[*A*]the edges as E=	context()	negated: False ,passive: False
0.498	[*A*]We[*R*]model[*A*]each of these[*A*]as time series the edges as E=	context()	negated: False ,passive: False
0.385	[*A*]t[*R*]is a member of[*A*]the time series	context()	negated: False ,passive: False
0.925	[*A*]t[*R*]is[*A*]a member of the time series[*A*]E= { Et : tT	context()	negated: False ,passive: True
0.498	[*A*]We[*R*]model[*A*]each of these[*A*]as time series V= { Vt	context()	negated: False ,passive: False
[LINE#41]  T. We assume that connectivity is bidirectional and therefore the edges of the graph are undirected, the edge connecting nodes.
0.738	[*A*]the edges of the graph[*R*]are undirected	context(We assume therefore)	negated: False ,passive: False
0.504	[*A*]We[*R*]assume therefore[*A*]the edges of the graph are undirected , the edge	context()	negated: False ,passive: False
0.903	[*A*]the edge[*R*]connecting[*A*]nodes	context()	negated: False ,passive: False
0.753	[*A*]connectivity[*R*]is[*A*]bidirectional	context(We assume)	negated: False ,passive: True
0.188	[*A*]We[*R*]assume[*A*]that connectivity is bidirectional	context()	negated: False ,passive: False
[LINE#42] The traditional representation of a path in a graph that is commonly used to depict the route that a message is transmitted along is an alternating sequence of vertices and edges.
0.954	[*A*]The traditional representation of a path in a graph[*R*]is[*A*]an alternating sequence of edges	context()	negated: False ,passive: True
0.954	[*A*]The traditional representation of a path in a graph[*R*]is[*A*]an alternating sequence of vertices	context()	negated: False ,passive: True
0.934	[*A*]the route[*R*]is transmitted[*A*]a message	context()	negated: False ,passive: True
0.742	[*A*]a graph[*R*]to depict[*A*]the route that a message is transmitted along	context()	negated: False ,passive: False
0.837	[*A*]a graph[*R*]is used[*A*]to depict the route	context()	negated: False ,passive: True
[LINE#43]  In this work we model a path as a sequence of resource locations a message occupies, where each index represents a particular time interval.
0.882	[*A*]each index[*R*]represents[*A*]a particular time interval	context(a message occupies)	negated: False ,passive: False
0.861	[*A*]a message[*R*]occupies[*A*]where each index represents a particular time interval	context()	negated: False ,passive: False
0.595	[*A*]we[*R*]model[*A*]a path as a sequence of resource locations[*A*]In this work	context()	negated: False ,passive: False
[LINE#44] Intuitively the best route is the path with the smallest resource cost, i.e. the path with the minimum number of transfers and shortest storage time.
0.932	[*A*]the best route[*R*]is[*A*]the path with the smallest resource cost	context()	negated: False ,passive: True
[LINE#45] Each second a message occupies storage or transfer bandwidth it adds cost to a network resource, and it can be more efficient for messages to travel via a greater number of hops with smaller in-network delays in order to arrive at the destination, rather than to be kept in storage waiting for a high demand resource to become available adding to the messages latency.
0.713	[*A*]messages[*R*]to travel	context()	negated: False ,passive: False
0.799	[*A*]a high demand resource[*R*]to become[*A*]available	context()	negated: False ,passive: True
0.225	[*A*]it[*R*]can be[*A*]more efficient	context()	negated: False ,passive: True
0.894	[*A*]storage[*R*]waiting[*A*]for a high demand resource to become available	context()	negated: False ,passive: True
0.522	[*A*]it[*R*]adds[*A*]cost[*A*]to a network resource	context()	negated: False ,passive: False
0.943	[*A*]a message[*R*]occupies[*A*]storage or transfer bandwidth[*A*]Each second	context()	negated: False ,passive: False
[LINE#46] We aim to carefully manage the trade-off between increasing the storage occupation and increasing the hop count.
0.514	[*A*]We[*R*]aim to carefully manage[*A*]the trade-off between increasing the storage occupation and increasing the hop count	context(We aim)	negated: False ,passive: False
0.514	[*A*]We[*R*]aim[*A*]to carefully manage the trade-off between increasing the storage occupation and increasing the hop count	context()	negated: False ,passive: False
[LINE#47] Using alternative paths is particularly suitable for social DTNs due to the path explosion phenomenon [9].The demand of a resource is dependent on the set of forwarding demands.
0.385	[*A*]a resource[*R*]is dependent on[*A*]the set	context()	negated: False ,passive: False
0.916	[*A*]Using alternative paths[*R*]is[*A*]particularly suitable for social DTNs	context(The demand of a resource is)	negated: False ,passive: True
0.930	[*A*]The demand of a resource[*R*]is[*A*]dependent on the set of forwarding demands	context()	negated: False ,passive: True
[LINE#48] The amount of demand for a resource X at a time t is given by: DXt=SXVDXVFSDt(X)where FSDt(X) denotes the number of paths between source node S and destination D that contains the resource X at time t.
0.887	[*A*]destination D[*R*]contains[*A*]the resource X[*A*]at time	context()	negated: False ,passive: False
0.889	[*A*]FSDt[*R*]denotes[*A*]the number of paths between source node S and destination D	context()	negated: False ,passive: False
0.896	[*A*]The amount of demand for a resource X at a time t[*R*]is given[*A*]by	context()	negated: False ,passive: True
[LINE#49] Which paths contain X is influenced by the effects of the forwarding strategy.
0.777	[*A*]X[*R*]is influenced[*A*]by the effects of the forwarding strategy	context(Which paths contain)	negated: False ,passive: True
0.923	[*A*]Which paths[*R*]contain[*A*]X is influenced by the effects of the forwarding strategy	context()	negated: False ,passive: False
[LINE#50]  Each resource X in the network can have a different stress level at any given time t as a result we denote stress as STxt=.
0.498	[*A*]we[*R*]denote[*A*]stress[*A*]as STxt=	context()	negated: False ,passive: False
0.956	[*A*]Each resource X in the network[*R*]can have[*A*]a different stress level at any given time t as a result	context()	negated: False ,passive: False
[LINE#51] DxtCx which is a measure of demand DXt of a resource X at a given time t against the capacity for that resource CX.
0.823	[*A*]DxtCx[*R*]is[*A*]a measure of demand DXt of a resource X at a given time t against the capacity for that resource CX	context()	negated: False ,passive: True
[LINE#52+53]  i.e. the level of demand Dxt of a resource X at a given timet is greater than the resource capacity CX.
0.982	[*A*]i.e. the level of demand Dxt of a resource X at a given timet[*R*]is[*A*]greater than the resource capacity	context()	negated: False ,passive: True
[LINE#54] The total cost of delivering a single copy of a message is the sum of all storage and transmission occurrences in the lifetime of a given message along a path between the source and the destination.
0.967	[*A*]The total cost of delivering a single copy of a message[*R*]is[*A*]the sum of all storage and transmission occurrences	context()	negated: False ,passive: True
[LINE#55] As messages can be replicated, one or more copies of the message are transmitted, each following an independent path.
0.926	[*A*]one or more copies of the message[*R*]are transmitted[*A*]each following an independent path	context()	negated: False ,passive: True
0.713	[*A*]messages[*R*]can be replicated	context()	negated: False ,passive: False
[LINE#56] The number of paths is limited by a replication limit (M) and the cost of delivery for a replicated message is the sum of all path costs in the replication path set.
0.973	[*A*]the cost of delivery for a replicated message[*R*]is[*A*]the sum of all path costs in the replication path set	context()	negated: False ,passive: True
0.919	[*A*]The number of paths[*R*]is limited[*A*]by a replication limit	context()	negated: False ,passive: True
[LINE#57] In order to impartially evaluate the inherent load distribution of a network we observe the stress effects of a uniformly non-biased forwarding strategy that selects the next hop randomly.
0.911	[*A*]a uniformly non-biased forwarding strategy[*R*]selects randomly[*A*]the next hop	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]observe[*A*]the stress effects of a uniformly non-biased forwarding strategy	context()	negated: False ,passive: False
[LINE#58] The result of selecting the next hop randomly is congruent with a random walk and therefore nodes that are better connected are more likely to receive messages.
0.913	[*A*]nodes that are better connected[*R*]to receive[*A*]messages	context()	negated: False ,passive: False
0.926	[*A*]nodes that are better connected[*R*]are[*A*]more likely to receive messages	context()	negated: False ,passive: True
0.716	[*A*]nodes[*R*]are[*A*]better connected	context()	negated: False ,passive: True
0.943	[*A*]The result of selecting the next hop randomly[*R*]is congruent[*A*]with a random walk	context()	negated: False ,passive: True
[LINE#59] Forwarding based on a heuristic which favours a node because of its connectivity puts well connected nodes in even greater demand than when simply randomly selected.
0.887	[*A*]a heuristic[*R*]favours[*A*]a node	context()	negated: False ,passive: False
[LINE#60+61]  Connectivity observations such as: how recently a node has encountered the destination, the duration of connectivity a node has experienced with the destination, how frequently a node encountersthe destination and a nodes betweenness or degree centrality are each used as heuristics within forwarding strategies.
0.732	[*A*]a node[*R*]has experienced	context()	negated: False ,passive: False
0.903	[*A*]a node[*R*]has encountered[*A*]the destination	context()	negated: False ,passive: False
[LINE#62] The better the node is connected the greater the probability it has of fulfilling the criteria of this type of forwarding strategy.
0.925	[*A*]the greater the probability[*R*]has[*A*]it	context()	negated: False ,passive: True
[LINE#63] Forwarding based on connectivity is a method of seeking the shortest path.
0.937	[*A*]Forwarding based on connectivity[*R*]is[*A*]a method of seeking the shortest path	context()	negated: False ,passive: True
[LINE#64] Shortest path routing is greedy and it can be the best solution in a network with no opposing traffic.
0.569	[*A*]it[*R*]can be[*A*]the best solution in a network with no opposing traffic	context()	negated: False ,passive: True
0.828	[*A*]Shortest path routing[*R*]is[*A*]greedy	context()	negated: False ,passive: True
[LINE#65] However, this is not realistic because it assumes no delay.
0.452	[*A*]it[*R*]assumes[*A*]no delay	context()	negated: False ,passive: False
0.250	[*A*]this[*R*]is not[*A*]realistic[*A*]because it assumes no delay	context()	negated: True ,passive: True
[LINE#66+67]  Delay is relative to the level of congestion experienced by a resource X at a given time t, and is a measurement of the current demand D and buffered demand B over the number of available outlets for the resource X at a given time divided by the degree centrality of the node X at time t dt(X) which can be denoted as delayt(X)=DXt+mBtdt(X).We define resource consumption as subgraph G=(V,E) where the set of vertices are defined as the set of vertices that have a demand greater than 0.
0.887	[*A*]Delay[*R*]is relative to[*A*]the level	context()	negated: False ,passive: False
0.919	[*A*]the set of vertices[*R*]are defined[*A*]as the set of vertices	context()	negated: False ,passive: True
0.498	[*A*]We[*R*]define[*A*]resource consumption as subgraph G=	context()	negated: False ,passive: False
0.877	[*A*]vertices[*R*]have[*A*]a demand greater than 0	context()	negated: False ,passive: False
0.756	[*A*]time t dt(X[*R*]can be denoted	context()	negated: False ,passive: False
0.919	[*A*]the level of congestion[*R*]experienced[*A*]by a resource X[*A*]at a given time t	context()	negated: False ,passive: True
0.943	[*A*]a given time[*R*]divided[*A*]by the degree centrality of the node X at time t dt(X	context()	negated: False ,passive: True
0.938	[*A*]Delay[*R*]is[*A*]relative to the level of congestion	context()	negated: False ,passive: True
[LINE#68]  Dvt>0 and the set of edges is defined as the set of edges that have a demand greater than 0.
0.919	[*A*]the set of edges[*R*]is defined[*A*]as the set of edges	context()	negated: False ,passive: True
0.877	[*A*]edges[*R*]have[*A*]a demand greater than 0	context()	negated: False ,passive: False
0.381	[*A*]0[*R*]is defined[*A*]as the set of edges	context()	negated: False ,passive: True
[LINE#69+70]  Network utilisation can be measured as difference between the available resources G and the consumed resources G depicted as U=|G|+G|G|+G where |G| and |G| denote the size of the set of vertexes for G and G, and||G|| and ||G|| denote the size of the set of edges for G and G.
0.893	[*A*]| | G | |[*R*]denote[*A*]the size of the set of edges for G.	context()	negated: False ,passive: False
0.910	[*A*]Network utilisation[*R*]can be measured[*A*]as difference between the available resources	context(| | G | | denote)	negated: False ,passive: True
0.893	[*A*]| | G | |[*R*]denote[*A*]the size of the set of edges for G	context()	negated: False ,passive: False
0.918	[*A*]| G | | | G | |[*R*]denote[*A*]the size of the set of edges for G.	context()	negated: False ,passive: False
0.910	[*A*]Network utilisation[*R*]can be measured[*A*]as difference between the available resources	context(| G | | | G | | denote)	negated: False ,passive: True
0.918	[*A*]| G | | | G | |[*R*]denote[*A*]the size of the set of edges for G	context()	negated: False ,passive: False
0.939	[*A*]| G |[*R*]denote[*A*]the size of the set of vertexes[*A*]U= | G | +G | G | +G	context()	negated: False ,passive: False
0.944	[*A*]the available resources[*R*]depicted[*A*]as U= | G | +G | G | +G	context()	negated: False ,passive: True
[LINE#71] The relationship between F and G is constrained such that 0UCG where CG is the total capacity of the graph.
0.860	[*A*]CG[*R*]is[*A*]the total capacity of the graph[*A*]that 0UCG	context()	negated: False ,passive: True
0.845	[*A*]The relationship between F and G[*R*]is constrained	context()	negated: False ,passive: False
[LINE#72+73]  The forwarding criteria H influences the size of F (the number of paths that wish to use these resources) based on its utilisation of G. Given two forwarding criteria H and Heach utilising the network to the value of U and U respectively, H has a greater capacity than H if U>U. H is therefore more effective as F can utilise more of the elements of G.Existing DTN forwarding algorithms direct traffic towards the most desirable next-hop nodes as this is the optimal solution when the network is free.
0.929	[*A*]based on its utilisation of G. Given two forwarding criteria H and Heach utilising the network to the value of U and U respectively, H has a greater capacity than H if U>U. H[*R*]is[*A*]therefore more effective	context(U algorithms)	negated: False ,passive: True
0.793	[*A*]U[*R*]algorithms[*A*]direct traffic[*A*]towards the most desirable next-hop nodes	context()	negated: False ,passive: False
0.913	[*A*]The forwarding criteria H[*R*]influences[*A*]the size of F (the number of paths	context(H has)	negated: False ,passive: False
0.896	[*A*]H[*R*]has[*A*]a greater capacity than H[*A*]if U>U. H is therefore more effective as F can utilise more of the elements of G.Existing DTN forwarding algorithms direct traffic towards the most desirable next-hop nodes	context()	negated: False ,passive: False
0.449	[*A*]this[*R*]is[*A*]the optimal solution when the network is free	context()	negated: False ,passive: True
0.739	[*A*]paths[*R*]wish to use[*A*]these resources	context(paths wish)	negated: False ,passive: False
0.790	[*A*]paths[*R*]wish[*A*]to use these resources	context()	negated: False ,passive: False
0.813	[*A*]the network[*R*]is[*A*]free	context()	negated: False ,passive: True
0.877	[*A*]F[*R*]can utilise[*A*]more of the elements of G.Existing DTN	context()	negated: False ,passive: False
0.932	[*A*]Heach[*R*]utilising[*A*]the network[*A*]to the value of U and U[*A*]respectively	context()	negated: False ,passive: False
[LINE#74+75+76]  When the traffic demands increase, these nodes become inundated and this is made even more challenging as the flow of traffic is unpredictable and has a tendency to accumulate in some regions of the network [2] shows that the price of anarchy is unbounded if the optimal forwarding solution is based purely on minimising delay in a flow-independent model, but that this can be improved by forwarding based on how congested the resource is in addition to the delay cost, resulting in the price of anarchy beingat most 4/3 provided the cost functions are all linear or d/logd if the cost functions are polynomials.
0.951	[*A*]the price of anarchy[*R*]is[*A*]unbounded[*A*]if the optimal forwarding solution is based purely on minimising delay in a flow-independent model	context(2 shows)	negated: False ,passive: True
0.244	[*A*]2[*R*]shows[*A*]that the price of anarchy is unbounded if the optimal forwarding solution is based purely on minimising delay in a flow-independent model	context()	negated: False ,passive: False
0.869	[*A*]the price of anarchy beingat[*R*]provided[*A*]most 4/3	context()	negated: False ,passive: True
0.911	[*A*]the cost functions[*R*]are[*A*]polynomials	context()	negated: False ,passive: True
0.921	[*A*]these nodes[*R*]inundated[*A*]When the traffic demands increase	context()	negated: False ,passive: True
0.451	[*A*]this[*R*]can be improved[*A*]based on how congested the resource is in addition to the delay cost	context()	negated: False ,passive: True
0.895	[*A*]the cost functions[*R*]are[*A*]linear or d/logd[*A*]if the cost functions are polynomials	context()	negated: False ,passive: True
0.943	[*A*]these nodes[*R*]become[*A*]inundated[*A*]When the traffic demands increase	context()	negated: False ,passive: True
0.953	[*A*]the flow of traffic[*R*]has[*A*]a tendency to accumulate in some regions of the network	context()	negated: False ,passive: False
0.698	[*A*]the traffic[*R*]increase	context()	negated: False ,passive: False
0.925	[*A*]the resource[*R*]is[*A*]in addition to the delay cost[*A*]resulting in the price of anarchy beingat	context()	negated: False ,passive: True
0.919	[*A*]the optimal forwarding solution[*R*]is based[*A*]purely[*A*]on minimising delay in a flow-independent model	context()	negated: False ,passive: True
0.841	[*A*]the flow of traffic[*R*]is[*A*]unpredictable	context()	negated: False ,passive: True
0.767	[*A*]the traffic[*R*]demands[*A*]increase	context()	negated: False ,passive: False
[LINE#77]  Design space and multi-layer overview of CafRepWe briefly describe the design space for CafRep and show different dimensions of possible approaches that can be useful for congestion aware dissemination in DTNs in Fig..
0.968	[*A*]multi-layer overview of CafRepWe[*R*]show[*A*]different dimensions of possible approaches[*A*]briefly	context()	negated: False ,passive: False
0.735	[*A*]possible approaches[*R*]can be[*A*]useful	context()	negated: False ,passive: True
0.903	[*A*]Design space[*R*]briefly show[*A*]different dimensions of possible approaches	context()	negated: False ,passive: False
0.949	[*A*]multi-layer overview of CafRepWe[*R*]briefly describe[*A*]the design space for CafRep	context()	negated: False ,passive: False
0.918	[*A*]Design space[*R*]briefly describe[*A*]the design space for CafRep	context()	negated: False ,passive: False
[LINE#78] The vertical axis represents the Direction Influence that refers to the connectivity dimension such as centrality, similarity, interaction strength and other social contexts that identify affiliation such as clique identification and delivery probability used to influence the social forwarding decisions.
0.903	[*A*]delivery probability[*R*]used[*A*]to influence the social forwarding decisions	context()	negated: False ,passive: True
0.897	[*A*]other social contexts[*R*]identify[*A*]affiliation	context()	negated: False ,passive: False
0.922	[*A*]the Direction Influence[*R*]refers[*A*]to the connectivity dimension such as other social contexts	context()	negated: False ,passive: False
0.922	[*A*]the Direction Influence[*R*]refers[*A*]to the connectivity dimension such as interaction strength	context()	negated: False ,passive: False
0.922	[*A*]the Direction Influence[*R*]refers[*A*]to the connectivity dimension such as similarity	context()	negated: False ,passive: False
0.922	[*A*]the Direction Influence[*R*]refers[*A*]to the connectivity dimension such as centrality	context()	negated: False ,passive: False
0.925	[*A*]The vertical axis[*R*]represents[*A*]the Direction Influence	context()	negated: False ,passive: False
[LINE#79] The two horizontal axes represent the resource dimensions.
0.919	[*A*]The two horizontal axes[*R*]represent[*A*]the resource dimensions	context()	negated: False ,passive: False
[LINE#80] The multi-path transport approach, such as Caf [14,31,15,30], introduces methods of avoiding congested regions of the network.
0.950	[*A*]The multi-path transport approach, such as Caf[*R*]introduces[*A*]methods of avoiding congested regions of the network	context()	negated: False ,passive: False
[LINE#81] The replication restriction technique, such as Retiring Replicants [38], helps to increase network capacity by reducing the in-network occupancy of redundant messages.
0.971	[*A*]The replication restriction technique, such as Retiring Replicants[*R*]helps[*A*]to increase network capacity by reducing the in-network occupancy of redundant messages	context()	negated: False ,passive: False
[LINE#82] Our CafRep's design philosophy is to consider the combination of route optimisation with multi-path transport, sending rate restriction and social connectivity.
0.872	[*A*]Our CafRep 's design philosophy[*R*]is[*A*]to consider the combination of route optimisation with multi-path transport , sending rate social connectivity	context()	negated: False ,passive: True
0.887	[*A*]multi-path transport[*R*]sending[*A*]rate restriction	context()	negated: False ,passive: False
0.872	[*A*]Our CafRep 's design philosophy[*R*]is[*A*]to consider the combination of route optimisation with multi-path transport	context()	negated: False ,passive: True
[LINE#83]  CafRep takes a multi-layered approach that is illustrated in Fig..
0.913	[*A*]a multi-layered approach[*R*]is illustrated[*A*]in Fig	context()	negated: False ,passive: True
0.834	[*A*]CafRep[*R*]takes[*A*]a multi-layered approach that is illustrated in Fig	context()	negated: False ,passive: False
[LINE#84] The edges in the graph on the Network Layer illustrate connectivity and the vertices represent the nodes.
0.903	[*A*]the vertices[*R*]represent[*A*]the nodes	context()	negated: False ,passive: False
0.961	[*A*]The edges in the graph on the Network Layer[*R*]illustrate[*A*]connectivity	context()	negated: False ,passive: False
[LINE#85] In reality the connections go up and down over a period of time and the network can get disconnected for the majority of time, but for simplicity the time series information has been flattened.
0.957	[*A*]the connections[*R*]go[*A*]down[*A*]over a period of time[*A*]In reality	context()	negated: False ,passive: True
0.767	[*A*]the network[*R*]can get[*A*]disconnected	context()	negated: False ,passive: True
0.957	[*A*]the connections[*R*]go[*A*]up[*A*]over a period of time[*A*]In reality	context()	negated: False ,passive: True
0.944	[*A*]the time series information[*R*]has been flattened[*A*]for simplicity	context()	negated: False ,passive: True
[LINE#86+87]  source node and destination node belong to the same interest group, multiple paths exist between the two nodes and the socially optimal routeis also the most congested path.
0.882	[*A*]destination node[*R*]belong[*A*]to the same interest group	context(multiple paths exist)	negated: False ,passive: False
0.882	[*A*]source node[*R*]belong[*A*]to the same interest group	context(multiple paths exist)	negated: False ,passive: False
0.882	[*A*]multiple paths[*R*]exist[*A*]between the two nodes and the socially optimal routeis	context()	negated: False ,passive: True
[LINE#88] The Interest Layer, a part of the Application Layer, maps users into areas of interest as each application can have its own topics and interest groups.
0.903	[*A*]each application[*R*]can have[*A*]interest groups	context()	negated: False ,passive: False
0.940	[*A*]The Interest Layer[*R*]maps[*A*]users	context()	negated: False ,passive: False
0.835	[*A*]each application[*R*]can have[*A*]its own topics	context()	negated: False ,passive: False
0.894	[*A*]The Interest Layer[*R*]maps[*A*]users[*A*]as each application can have its own topics	context()	negated: False ,passive: False
[LINE#89] CafRep Layer combines Congestion Layer and Social Layer in order to broaden the next hop selection criteria allowing nodes with capacity, or less direct routes, to receive messages by monitoring both social and congestion signals and dynamically balancing between them.
0.918	[*A*]nodes with capacity, or less direct routes[*R*]to receive[*A*]messages	context(the next hop selection criteria allowing)	negated: False ,passive: False
0.897	[*A*]the next hop selection criteria[*R*]allowing[*A*]nodes with capacity, or less direct routes, to receive messages by monitoring both social and congestion signals and dynamically balancing between them	context()	negated: False ,passive: False
0.938	[*A*]CafRep Layer[*R*]combines[*A*]Congestion Layer and Social Layer[*A*]in order	context()	negated: False ,passive: False
[LINE#90] The Network Layer, on the Physical Layer, illustrates the actual route a message would take through this example network, given the trade-off between shortest path and resource-driven routing, in order to redistribute load to avoid congestion as identified in our criteria. .
0.937	[*A*]a message[*R*]would take through[*A*]this example network, given the trade-off between shortest path and resource-driven routing, in order	context()	negated: False ,passive: False
0.795	[*A*]congestion[*R*]identified[*A*]in our criteria	context()	negated: False ,passive: True
0.976	[*A*]The Network Layer[*R*]illustrates[*A*]the actual route a message would take through this example network,[*A*]on the Physical Layer	context()	negated: False ,passive: False
[LINE#91] Congestion aware forwarding and replication: CafRep.
[LINE#92]  Rep design overviewWe describe unified adaptive forwarding and adaptive replication management approach into a common congestion control framework for DTN routing,.
0.944	[*A*]Rep design overviewWe[*R*]describe[*A*]adaptive replication management approach[*A*]into a common congestion control framework for DTN routing	context()	negated: False ,passive: False
0.944	[*A*]Rep design overviewWe[*R*]describe[*A*]unified adaptive forwarding[*A*]into a common congestion control framework for DTN routing	context()	negated: False ,passive: False
[LINE#93] CafRep (Congestion Aware Forwarding and Replication).
[LINE#94] CafRep works as a local adaptive forwarding and replication protocol that diverts the load from its conventional social aware path at times of congestion and directs it via a different path that decreases the load of hotspots and end-to-end delays while keeping high success ratios.
0.897	[*A*]a different path[*R*]decreases[*A*]the load of end - to - end delays	context()	negated: False ,passive: False
0.897	[*A*]a different path[*R*]decreases[*A*]the load of hotspots delays[*A*]while keeping high success ratios	context()	negated: False ,passive: False
0.825	[*A*]a replication protocol[*R*]directs[*A*]it	context()	negated: False ,passive: False
0.883	[*A*]a replication protocol[*R*]diverts[*A*]the load from its conventional social aware path at times of congestion	context()	negated: False ,passive: False
0.938	[*A*]CafRep[*R*]works[*A*]as a replication protocol	context()	negated: False ,passive: False
0.938	[*A*]CafRep[*R*]works[*A*]as a local adaptive forwarding	context()	negated: False ,passive: False
[LINE#95] It dynamically combines three types of implicit congestion heuristics: social (contact) driven heuristics that exploits contact relationships among nodes to allow optimal directionality and delivery probability of a node; node resource driven heuristics that aim to adopt to the nodes' buffer availability, delays and congesting rates; and ego network (regional) driven heuristics that aim to detect and adapt buffer availability, delays and congesting rates of different parts of the network.
0.845	[*A*]node resource[*R*]driven[*A*]heuristics that aim to adopt to the nodes' buffer availability, delays and congesting rates	context()	negated: False ,passive: False
0.828	[*A*]regional) driven heuristics[*R*]aim to adapt[*A*]buffer availability	context(regional ) driven heuristics aim)	negated: False ,passive: False
0.684	[*A*]regional) driven heuristics[*R*]aim to detect	context(regional ) driven heuristics aim)	negated: False ,passive: False
0.922	[*A*]regional) driven heuristics[*R*]aim[*A*]to detect and adapt buffer availability, delays and congesting rates of different parts of the network	context()	negated: False ,passive: False
0.887	[*A*]driven heuristics[*R*]exploits[*A*]contact relationships among nodes	context()	negated: False ,passive: False
0.898	[*A*]heuristics[*R*]aim to adopt[*A*]to the nodes' buffer availability, delays and congesting rates	context(heuristics aim)	negated: False ,passive: False
0.898	[*A*]heuristics[*R*]aim[*A*]to adopt to the nodes' buffer availability, delays and congesting rates	context()	negated: False ,passive: False
0.452	[*A*]It[*R*]dynamically combines[*A*]three types of implicit congestion heuristics	context()	negated: False ,passive: False
[LINE#96] Selecting the node that represents the best carrier for the message and deciding on the optimal number of replicas to forward are both multiple attribute decision problems across multiple measures, where the aim is to select the node and number of messages that provide the maximum utility for carrying a certain number of messages.
0.784	[*A*]the aim[*R*]is	context()	negated: False ,passive: False
0.927	[*A*]the node[*R*]represents[*A*]the best carrier for deciding on the optimal number of replicas	context()	negated: False ,passive: False
0.925	[*A*]the aim[*R*]is[*A*]to select the number of messages	context()	negated: False ,passive: True
0.921	[*A*]Selecting the node[*R*]are[*A*]multiple attribute decision problems across multiple measures , where the aim is to select the number of messages	context()	negated: False ,passive: True
0.925	[*A*]the aim[*R*]is[*A*]to select the node of messages	context()	negated: False ,passive: True
0.921	[*A*]Selecting the node[*R*]are[*A*]multiple attribute decision problems across multiple measures , where the aim is to select the node of messages	context()	negated: False ,passive: True
0.887	[*A*]the node[*R*]represents[*A*]the best carrier for the message	context()	negated: False ,passive: False
0.877	[*A*]messages[*R*]provide[*A*]the maximum utility[*A*]for carrying a certain number of messages	context()	negated: False ,passive: False
[LINE#97] To achieve this we propose CafRepUtilD heuristic (Formula (1)) that is responsible for determining the overall improvement an encountered node represents when compared to the sending node, and deciding on which nodes will be selected as next hop and how many copies of the message are to be disseminated.
0.795	[*A*]how many copies of the message[*R*]are[*A*]to be disseminated	context(CafRepUtilD heuristic deciding)	negated: False ,passive: True
0.932	[*A*]CafRepUtilD heuristic[*R*]deciding[*A*]how many copies of the message are to be disseminated	context()	negated: False ,passive: False
0.773	[*A*]how many copies of the message[*R*]to be disseminated	context()	negated: False ,passive: False
0.871	[*A*]nodes[*R*]will be selected[*A*]as next hop	context(CafRepUtilD heuristic deciding)	negated: False ,passive: True
0.895	[*A*]CafRepUtilD heuristic[*R*]deciding[*A*]on which nodes will be selected as next hop	context()	negated: False ,passive: False
0.934	[*A*]CafRepUtilD heuristic[*R*]is[*A*]responsible for determining the overall improvement	context()	negated: False ,passive: True
0.498	[*A*]we[*R*]propose[*A*]CafRepUtilD heuristic	context()	negated: False ,passive: False
0.897	[*A*]the overall improvement[*R*]represents[*A*]when compared to the sending node	context()	negated: False ,passive: True
[LINE#98+99]  Formula (1) shows the CafRepUtilD utility calculation node(X) uses when forwarding a message towards a destination (D) in order to evaluate each encountered node (i) within its contact set (C) as the sum of the set of carefully selected equally weighted utilities of different congestion heuristics:(1)CafRepUtilD(X)=hHUtilh(X)CafRepUtil gets calculated for all contacts of the sending node (node X) and selects the best next hop as the node with the highest CafRepUtil value if its CafRepUtil is higher than the sending node's.
0.954	[*A*]CafRepUtilD(X)=hHUtilh(X)CafRepUtil[*R*]selects[*A*]the best next hop as the node with the highest CafRepUtil value	context()	negated: False ,passive: False
0.970	[*A*]CafRepUtilD(X)=hHUtilh(X)CafRepUtil[*R*]gets[*A*]calculated for all contacts of the sending node (node X) and selects the best next hop as the node with the highest CafRepUtil value	context()	negated: False ,passive: True
0.760	[*A*]its CafRepUtil[*R*]is[*A*]higher than the sending node's	context()	negated: False ,passive: True
0.911	[*A*]CafRepUtilD(X)=hHUtilh(X)CafRepUtil[*R*]gets calculated[*A*]for all contacts of the sending node	context(Formula ( 1 shows)	negated: False ,passive: True
0.948	[*A*]the CafRepUtilD utility calculation node[*R*]uses[*A*]when forwarding a message towards a destination (D) in order	context(Formula ( 1 shows)	negated: False ,passive: True
0.938	[*A*]Formula (1[*R*]shows[*A*]the CafRepUtilD utility calculation node	context()	negated: False ,passive: False
[LINE#100] The number of messages to be sent to it is decided by Formula (2).
0.920	[*A*]The number of messages[*R*]is decided[*A*]by Formula	context()	negated: False ,passive: True
0.821	[*A*]messages[*R*]to be sent[*A*]to it	context()	negated: False ,passive: True
[LINE#101] more than one copy of the message ReplRate shows how the number of copies can be divided between the two nodes.
0.900	[*A*]the number of copies[*R*]can be divided[*A*]between the two nodes	context(more than one copy of the message shows)	negated: False ,passive: True
0.956	[*A*]more than one copy of the message[*R*]shows[*A*]how the number of copies can be divided between the two nodes	context()	negated: False ,passive: False
[LINE#102]  This division is dependent on the CafRepUtil utility value of each node; therefore, the division of the replication rate for the destination d between node X and node C(X) is given by Formula (2) where M is the number of replicas of a message m at node.
0.885	[*A*]This division[*R*]is dependent on[*A*]the CafRepUtil utility value	context()	negated: False ,passive: False
0.920	[*A*]This division[*R*]is[*A*]dependent on the CafRepUtil utility value of each node	context(the division of the replication rate for the destination d between node X and node C ( X is given)	negated: False ,passive: True
0.972	[*A*]the division of the replication rate for the destination d between node X and node C(X[*R*]is given[*A*]by Formula	context()	negated: False ,passive: True
0.926	[*A*]M[*R*]is[*A*]the number of replicas of a message m at node	context()	negated: False ,passive: True
[LINE#103+104]  X.(2)ReplRateD(X)=MCafRepUtilD(C(X))CafRepUtilD(X)+CafRepUtilD(C(X))There are seven non-trivial heuristics h(X)that cover different dimensions of the problem and when combined they allow managing a number of trade-offs between different challenges we identified in Section 3.
0.688	[*A*]they[*R*]allow managing[*A*]a number of trade-offs between different challenges[*A*]when combined	context()	negated: False ,passive: False
0.887	[*A*]different challenges[*R*]identified[*A*]in Section 3	context()	negated: False ,passive: True
0.905	[*A*]seven non-trivial heuristics h[*R*]cover[*A*]different dimensions of the problem	context()	negated: False ,passive: True
[LINE#105] For each of the heuristics we define their respective utilities as measurements of their relative gain, loss or equality, calculated as pair-wise comparison between the node's own congestion heuristics and that of the encountered contacts.
0.562	[*A*]we[*R*]define[*A*]their respective utilities[*A*]as measurements of their relative gain, loss or equality[*A*]For each of the heuristics	context()	negated: False ,passive: False
[LINE#106+107+108]  More specifically, we use a pair-wise comparison matrix on the normalised relative weights of the social and resources heuristics of nodes and their ego networks in the following way.(3)Utilh(X)=h(C(X))h(X)+h(C(X))The set of our selected congestion heuristics node retentiveness (Ret), node receptiveness(Rec), node congesting rate (CR), and their weighted ego-network counterparts (WENRet,WENRec,WENCR), along with a node social heuristic (Social), and is given in Formula (4).
0.418	[*A*]we[*R*]use[*A*]a pair-wise comparison matrix[*A*]on the normalised relative weights of the resources heuristics of their ego networks in the following way	context()	negated: False ,passive: False
0.569	[*A*]we[*R*]use[*A*]a pair-wise comparison matrix[*A*]on the normalised relative weights of the resources heuristics of nodes in the following way	context()	negated: False ,passive: False
0.418	[*A*]we[*R*]use[*A*]a pair-wise comparison matrix[*A*]on the normalised relative weights of the social heuristics of their ego networks in the following way	context()	negated: False ,passive: False
0.852	[*A*]WENRet , WENRec , WENCR[*R*]along is given[*A*]in Formula	context()	negated: False ,passive: True
0.913	[*A*]node congesting rate[*R*]is given[*A*]in Formula	context()	negated: False ,passive: True
0.976	[*A*]Utilh ( X ) =h ( C ( X ) ) h ( X ) +h[*R*]node[*A*]retentiveness	context()	negated: False ,passive: False
0.569	[*A*]we[*R*]use[*A*]a pair-wise comparison matrix[*A*]on the normalised relative weights of the social heuristics of nodes in the following way	context()	negated: False ,passive: False
[LINE#109] In this paper, we use SimBetTS as our social heuristic that was introduced in [8].(4)hH={Ret,Rec,CR,Social,WENRet,WENRec,WENCR}Before we move to describing CafRep algorithm in a greater detail we briefly describe the congestion heuristics used in CafRep for completeness purposes.
[LINE#110+111]  More detailed description of these heuristics is given in [31,48].Retentiveness (Ret)refers to the node's available storage for the new packets that are sent to them.
0.993	[*A*]More detailed description of these heuristics[*R*]is given in[*A*]3148 ].retentiveness	context()	negated: False ,passive: False
0.825	[*A*]the new packets[*R*]are sent[*A*]to them	context()	negated: False ,passive: True
0.920	[*A*]Retentiveness[*R*]refers[*A*]to the node's available storage for the new packets	context()	negated: False ,passive: False
0.829	[*A*]More detailed description of these heuristics[*R*]is given[*A*]in [31,48	context()	negated: False ,passive: True
[LINE#112] Retentiveness is an important attribute to consider because of the store and forward nature of opportunistic DTN networks.
0.931	[*A*]Retentiveness[*R*]is[*A*]an important attribute to consider[*A*]because of the forward nature of opportunistic DTN networks	context()	negated: False ,passive: True
0.918	[*A*]Retentiveness[*R*]is[*A*]an important attribute to consider because of the store	context()	negated: False ,passive: True
[LINE#113] Nodes with limited storage, either due to popularity or simply due to more limited hardware constraints, are more susceptible to packet loss.
0.971	[*A*]Nodes with limited storage, either due to popularity or simply due to more limited hardware constraints[*R*]are[*A*]more susceptible to packet loss	context()	negated: False ,passive: True
[LINE#114] Retentiveness is calculated as an exponentially weighted moving average of a node's remaining storage.
0.931	[*A*]Retentiveness[*R*]is calculated[*A*]as an exponentially weighted moving average of a node's remaining storage	context()	negated: False ,passive: True
[LINE#115+116]  Formula (5) shows retentiveness of X is calculated as the sum of all message occupancy subtracted from the node's buffer capacity(Bc(X)).(5)Ret(X)=Bc(X)-i=1Nmsizei(X)Receptiveness (Rec) refers to the node's ability to receive packets and forward them on.
0.891	[*A*]retentiveness of X[*R*]is calculated[*A*]as the sum of all message occupancy	context(Formula ( 5 shows)	negated: False ,passive: True
0.926	[*A*]Formula (5[*R*]shows[*A*]retentiveness of X	context()	negated: False ,passive: False
0.959	[*A*]Ret(X)=Bc(X)-i=1Nmsizei[*R*]refers[*A*]to the node's ability	context()	negated: False ,passive: False
0.911	[*A*]all message occupancy[*R*]subtracted[*A*]from the node's buffer capacity	context()	negated: False ,passive: True
[LINE#117] This is an important observation as increasing in-network delays is an indication that the volume of traffic a node or region is receiving is greater than the bandwidth available to it for offloading.
0.936	[*A*]the volume of traffic a node or region is receiving[*R*]is[*A*]greater than the bandwidth available to it for offloading	context()	negated: False ,passive: True
0.945	[*A*]the volume of traffic[*R*]is receiving[*A*]a node or region	context()	negated: False ,passive: True
0.812	[*A*]increasing in-network delays[*R*]is[*A*]an indication that the volume of traffic a node or region is receiving is greater than the bandwidth available to it for offloading	context()	negated: False ,passive: True
0.206	[*A*]This[*R*]is[*A*]an important observation[*A*]as increasing in-network delays is an indication that the volume of traffic a node or region is receiving is greater than the bandwidth available to it for offloading	context()	negated: False ,passive: True
[LINE#118] The total current message delay is calculated as the sum of the difference between the time each message in a node's buffer was received and the current time.
0.957	[*A*]each message in a node's buffer[*R*]was received[*A*]the time	context()	negated: False ,passive: True
0.952	[*A*]The total current message delay[*R*]is calculated[*A*]as the sum of the difference between the time each message in a node's buffer was received and the current time	context()	negated: False ,passive: True
[LINE#119] The delay between receiving a message and forwarding a message is constrained by the size of the buffer and the bandwidth available for a node to offload the messages.
0.970	[*A*]The delay between receiving a message and forwarding a message[*R*]is constrained[*A*]by the size of the bandwidth available for a node	context()	negated: False ,passive: True
0.953	[*A*]The delay between receiving a message and forwarding a message[*R*]is constrained[*A*]by the size of the buffer	context()	negated: False ,passive: True
[LINE#120] Nodes with large amounts of storage are more susceptible to receiving more messages than they are capable of offloading.
0.361	[*A*]they[*R*]are[*A*]capable of offloading	context()	negated: False ,passive: True
0.863	[*A*]Nodes with large amounts of storage[*R*]to receiving[*A*]more messages than they are capable of offloading	context()	negated: False ,passive: False
0.932	[*A*]Nodes with large amounts of storage[*R*]are[*A*]more susceptible to receiving more messages	context()	negated: False ,passive: True
[LINE#121]  Formula (6) shows receptiveness is the total current message delay, calculated as the sum of differences between the current time (Tnow) and the time each message was received (.
0.911	[*A*]Formula[*R*]shows[*A*]receptiveness	context()	negated: False ,passive: False
0.933	[*A*]each message[*R*]was received[*A*]the time	context()	negated: False ,passive: True
[LINE#122] Mreceived).(6)Rec(X)=i=1N(Tnow-mreceivedi(X))Congesting rate (CR) refers to a measure of how fast a node is likely to congest, an important observation as it indicates stability.
0.452	[*A*]it[*R*]indicates[*A*]stability	context()	negated: False ,passive: False
0.698	[*A*]a node[*R*]to congest	context()	negated: False ,passive: False
0.813	[*A*]a node[*R*]is[*A*]likely to congest	context()	negated: False ,passive: True
[LINE#123] Congesting rate is calculated as the percentage of time a node or region has been congested divided by the average time between fullness periods for the node or region, given in Formula (7).
0.920	[*A*]the node or region[*R*]given[*A*]in Formula	context()	negated: False ,passive: True
0.939	[*A*]a node or region[*R*]divided[*A*]by the average time between fullness periods for the node or region	context()	negated: False ,passive: True
0.769	[*A*]a node or region[*R*]has been congested	context()	negated: False ,passive: False
0.903	[*A*]Congesting rate[*R*]is calculated[*A*]as the percentage of time	context()	negated: False ,passive: True
[LINE#124] This congestion signal indicates the likelihood of traffic spikes that could cause the message to be dropped.
0.678	[*A*]the message[*R*]to be dropped	context(traffic spikes could cause)	negated: False ,passive: False
0.858	[*A*]traffic spikes[*R*]could cause[*A*]the message to be dropped	context()	negated: False ,passive: False
0.911	[*A*]This congestion signal[*R*]indicates[*A*]the likelihood of traffic spikes	context()	negated: False ,passive: False
[LINE#125]  Each node keeps track of the percentage of time it has been full (T%Full(X)) in Formula (7a), and the average time between its fullness periods (TAT(X)) in Formula (7b).(7)CR(X)=T%Full(X)TAT(X)(7a)T%Full(X)=100TFullBuffer(X)TTotalTime(X)(7b)TAT(X)=1Ni=1NTiend(X)-Tistart(X)Note that TFullBuffer(X) is the time the buffer has been and TTotalTime(X).
0.933	[*A*]the buffer[*R*]has been[*A*]the time	context()	negated: False ,passive: True
0.225	[*A*]it[*R*]has been[*A*]full	context()	negated: False ,passive: True
0.903	[*A*]Each node[*R*]keeps[*A*]track of the percentage of time	context()	negated: False ,passive: False
[LINE#126] Tistart(X) and Tiend(X) are the start and end of between full buffer periods respectively.
0.877	[*A*]Tiend[*R*]are[*A*]end of between full buffer periods[*A*]respectively	context()	negated: False ,passive: True
0.874	[*A*]Tiend[*R*]are respectively[*A*]the start of between full buffer periods	context()	negated: False ,passive: True
0.906	[*A*]Tistart[*R*]are[*A*]end of between full buffer periods[*A*]respectively	context()	negated: False ,passive: True
0.904	[*A*]Tistart[*R*]are respectively[*A*]the start of between full buffer periods	context()	negated: False ,passive: True
[LINE#127] Ego Network retentiveness, receptiveness and congesting rate (WENret WENrec WENcr) refer to congestion heuristics of the node's ego network.
0.894	[*A*]receptiveness[*R*]refer[*A*]to congestion heuristics of the node 's ego network	context()	negated: False ,passive: False
0.933	[*A*]Ego Network retentiveness[*R*]refer[*A*]to congestion heuristics of the node 's ego network	context()	negated: False ,passive: False
[LINE#128] Ego network (EN) is defined here as a network consisting of a single node together with the nodes they have encountered and gives each node their own perspective of the network.
0.862	[*A*]Ego[*R*]gives[*A*]each node[*A*]their own perspective of the network	context()	negated: False ,passive: False
0.884	[*A*]the nodes[*R*]have encountered[*A*]they	context()	negated: False ,passive: True
0.903	[*A*]a network[*R*]consisting[*A*]of a single node together with the nodes	context()	negated: False ,passive: True
0.914	[*A*]Ego network[*R*]is defined[*A*]here[*A*]as a network	context()	negated: False ,passive: True
[LINE#129] CafRep allows nodes to aggregate resource observations disseminated by encountered nodes in order to form an ego-network perspective of the network.
0.911	[*A*]aggregate resource observations[*R*]disseminated[*A*]by encountered nodes[*A*]in order	context()	negated: False ,passive: True
0.920	[*A*]CafRep[*R*]allows[*A*]nodes to aggregate resource observations	context()	negated: False ,passive: False
[LINE#130] Ego-network information can be aggregated in many different ways and we have explored a number of models for weighting the contacts within a nodes ego-network in order to improve the accuracy of prediction of the EN congestion levels.
0.569	[*A*]we[*R*]have explored[*A*]a number of models for weighting the contacts within a nodes ego - network[*A*]in order	context()	negated: False ,passive: False
0.769	[*A*]Ego - network information[*R*]can be aggregated	context()	negated: False ,passive: False
[LINE#131] This is highly important as it leads to better performance for both forwarding and replication optimizations and making the nodes less selfish.
0.452	[*A*]it[*R*]leads[*A*]to better performance for replication optimizations	context()	negated: False ,passive: False
0.307	[*A*]This[*R*]is[*A*]highly important[*A*]as it leads to better performance for replication optimizations	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]leads[*A*]to better performance for both forwarding optimizations	context()	negated: False ,passive: False
0.415	[*A*]This[*R*]is[*A*]highly important[*A*]as it leads to better performance for both forwarding optimizations	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]leads[*A*]to making the nodes less selfish	context()	negated: False ,passive: False
0.307	[*A*]This[*R*]is[*A*]highly important[*A*]as it leads to making the nodes less selfish	context()	negated: False ,passive: True
[LINE#132] More specifically, we have considered techniques such as simple average, weighted moving average (EWMA) and social weighting of the nodes ego network congestion heuristics.
0.678	[*A*]the nodes[*R*]ego	context(we have considered)	negated: False ,passive: False
0.388	[*A*]we[*R*]have considered[*A*]techniques such as simple average	context()	negated: False ,passive: False
0.573	[*A*]we[*R*]weighted[*A*]moving average (EWMA) and social weighting of the nodes ego network congestion heuristics	context()	negated: False ,passive: False
[LINE#133] Our experiments have shown that EWMA gives better performance than the simple weighting and the social weighting across diverse network topologies.
0.936	[*A*]EWMA[*R*]gives[*A*]better performance than the social weighting across diverse network topologies	context(Our experiments have shown)	negated: False ,passive: False
0.499	[*A*]Our experiments[*R*]have shown[*A*]that EWMA gives better performance than the social weighting across diverse network topologies	context()	negated: False ,passive: False
0.902	[*A*]EWMA[*R*]gives[*A*]better performance than the simple weighting	context(Our experiments have shown)	negated: False ,passive: False
0.383	[*A*]Our experiments[*R*]have shown[*A*]that EWMA gives better performance than the simple weighting	context()	negated: False ,passive: False
[LINE#134] Formula (8) shows how we use EWMA to aggregate congestion heuristic information in order to allow the short-term fluctuations to be smoothed out and longer-term trends to be highlighted making it suitable for forecasting.
0.443	[*A*]we[*R*]use[*A*]EWMA[*A*]to aggregate congestion	context(Formula ( 8 shows)	negated: False ,passive: False
0.929	[*A*]Formula (8[*R*]shows[*A*]how we use EWMA to aggregate congestion heuristic information in order	context()	negated: False ,passive: False
[LINE#135] This is updated at each new encounter for each congestion heuristic (h).(8)WENh(X,Ci(X))=(1-)WENh(X)+h(Ci(X)) is a fraction that represents the responsiveness of the smoothing, this is typically around 0.8 [38,26].
0.181	[*A*]this[*R*]is[*A*]typically[*A*]around 0.8 [38,26	context()	negated: False ,passive: True
0.887	[*A*]a fraction[*R*]represents[*A*]the responsiveness of the smoothing	context()	negated: False ,passive: False
[LINE#136+137]  Related state of the art work on congestion control in DTNs[38,26] that uses implicit local congestion signals to estimate global congestion levels uses EWMA with values of 0.85 or 0.9 for the most recent value a node observes.
0.923	[*A*]Related state of the art work on congestion control[*R*]uses[*A*]implicit local congestion signals[*A*]to estimate global congestion levels	context(Related state of the art work on congestion control in DTNs [ 38,26 ] that uses implicit local congestion signals to estimate global congestion levels uses)	negated: False ,passive: False
0.995	[*A*]Related state of the art work on congestion control in DTNs[38,26] that uses implicit local congestion signals to estimate global congestion levels[*R*]uses[*A*]EWMA[*A*]in DTNs[38,26	context()	negated: False ,passive: False
[LINE#138] In [38], each node independently calculates a local approximation of the current congestion level as the ratio of drops and replications collected in the last time interval.
0.894	[*A*]replications[*R*]collected[*A*]in the last time interval	context()	negated: False ,passive: True
0.964	[*A*]each node[*R*]independently calculates[*A*]a local approximation of the current congestion level as the ratio of replications[*A*]In [ 38	context()	negated: False ,passive: False
0.813	[*A*]drops[*R*]collected[*A*]in the last time interval	context()	negated: False ,passive: True
0.964	[*A*]each node[*R*]independently calculates[*A*]a local approximation of the current congestion level as the ratio of drops[*A*]In [ 38	context()	negated: False ,passive: False
[LINE#139] [38] calculate new congestion value using an estimated weighted moving average (EWMA) with the new congestion view being weighted 0.9 to keep node's congestion view fresh.
0.769	[*A*]the new congestion view[*R*]being weighted	context()	negated: False ,passive: False
[LINE#140] Similarly, in [26], the locally calculated encounter value (EV) used to track node's rate of encounter uses the exponentially weighted moving average that places an emphasis proportional to 0.85 on the most recent complete Current Window counter.
0.913	[*A*]the locally calculated encounter value[*R*]to track[*A*]node's rate of encounter	context()	negated: False ,passive: False
[LINE#141] The authors argue that their experiments showed that  of 0.85 and update interval of around 30s allow for reasonable results in a variety of networks.
0.154	[*A*]their experiments[*R*]showed[*A*]that of 0.85	context(The authors argue)	negated: False ,passive: False
0.597	[*A*]The authors[*R*]argue[*A*]that their experiments showed that of 0.85	context()	negated: False ,passive: False
[LINE#142] In our experiments we have chosen a value of 0.8 even though results were similar for 0.85 and 0.9..
0.444	[*A*]we[*R*]have chosen[*A*]a value of 0.8[*A*]even though results were similar for 0.85 and 0.9[*A*]In our experiments	context()	negated: False ,passive: False
[LINE#143] Rep algorithmOur CafRep algorithm functions as follows.
[LINE#144] When a forwarding node (X), meets contacts on its way, it exchanged relevant heuristics and calculates the CafRepUtil of each contact.
0.925	[*A*]a forwarding node[*R*]calculates[*A*]the CafRepUtil of each contact	context()	negated: False ,passive: False
0.607	[*A*]it[*R*]exchanged[*A*]relevant heuristics[*A*]When a forwarding node ( X ) , meets contacts on its way	context()	negated: False ,passive: False
0.825	[*A*]a forwarding node[*R*]meets[*A*]contacts on its way	context()	negated: False ,passive: False
[LINE#145] The CafRepUtil allows the node X to detect how well connected its contact Y is and how available Y and Y's ego network are in terms of buffer, delay and congesting rate parameters.
0.925	[*A*]Y 's ego network[*R*]are[*A*]in terms of congesting rate parameters	context(The CafRepUtil allows the node X to detect)	negated: False ,passive: True
0.941	[*A*]the node X[*R*]to detect[*A*]how available Y 's ego network are in terms of congesting rate parameters	context(The CafRepUtil allows)	negated: False ,passive: False
0.951	[*A*]The CafRepUtil[*R*]allows[*A*]the node X to detect how available Y 's ego network are in terms of congesting rate parameters	context()	negated: False ,passive: False
0.925	[*A*]Y 's ego network[*R*]are[*A*]in terms of delay	context(The CafRepUtil allows the node X to detect)	negated: False ,passive: True
0.941	[*A*]the node X[*R*]to detect[*A*]how available Y 's ego network are in terms of delay	context(The CafRepUtil allows)	negated: False ,passive: False
0.951	[*A*]The CafRepUtil[*R*]allows[*A*]the node X to detect how available Y 's ego network are in terms of delay	context()	negated: False ,passive: False
0.925	[*A*]Y 's ego network[*R*]are[*A*]in terms of buffer	context(The CafRepUtil allows the node X to detect)	negated: False ,passive: True
0.941	[*A*]the node X[*R*]to detect[*A*]how available Y 's ego network are in terms of buffer	context(The CafRepUtil allows)	negated: False ,passive: False
0.951	[*A*]The CafRepUtil[*R*]allows[*A*]the node X to detect how available Y 's ego network are in terms of buffer	context()	negated: False ,passive: False
0.825	[*A*]Y[*R*]are[*A*]in terms of congesting rate parameters	context(The CafRepUtil allows the node X to detect)	negated: False ,passive: True
0.941	[*A*]the node X[*R*]to detect[*A*]how available Y are in terms of congesting rate parameters	context(The CafRepUtil allows)	negated: False ,passive: False
0.951	[*A*]The CafRepUtil[*R*]allows[*A*]the node X to detect how available Y are in terms of congesting rate parameters	context()	negated: False ,passive: False
0.825	[*A*]Y[*R*]are[*A*]in terms of delay	context(The CafRepUtil allows the node X to detect)	negated: False ,passive: True
0.908	[*A*]the node X[*R*]to detect[*A*]how available Y are in terms of delay	context(The CafRepUtil allows)	negated: False ,passive: False
0.951	[*A*]The CafRepUtil[*R*]allows[*A*]the node X to detect how available Y are in terms of delay	context()	negated: False ,passive: False
0.825	[*A*]Y[*R*]are[*A*]in terms of buffer	context(The CafRepUtil allows the node X to detect)	negated: False ,passive: True
0.908	[*A*]the node X[*R*]to detect[*A*]how available Y are in terms of buffer	context(The CafRepUtil allows)	negated: False ,passive: False
0.951	[*A*]The CafRepUtil[*R*]allows[*A*]the node X to detect how available Y are in terms of buffer	context()	negated: False ,passive: False
0.523	[*A*]how well connected its contact Y[*R*]is	context(The CafRepUtil allows the node X to detect)	negated: False ,passive: False
0.843	[*A*]the node X[*R*]to detect[*A*]how well connected its contact Y is	context(The CafRepUtil allows)	negated: False ,passive: False
0.914	[*A*]The CafRepUtil[*R*]allows[*A*]the node X to detect how well connected its contact Y is	context()	negated: False ,passive: False
[LINE#146]  If there are multiple encounters, node X sorts them in the reverse order (from the highest to the lowest) in terms of their CafRepUtil, calculates respective sending and replication rates for each node and sends the appropriate ReplRate copies of the messages to each one of them invoking the pseudo code for interest-driven content transmission over CafRep given in Fig..
0.903	[*A*]node X[*R*]calculates[*A*]replication rates[*A*]for each node	context()	negated: False ,passive: False
0.903	[*A*]node X[*R*]calculates[*A*]respective sending for each node	context()	negated: False ,passive: False
0.961	[*A*]interest - driven content transmission over CafRep[*R*]given[*A*]in Fig	context()	negated: False ,passive: True
0.805	[*A*]each one of them[*R*]invoking[*A*]the pseudo code for interest - driven content transmission over CafRep	context()	negated: False ,passive: False
0.890	[*A*]node X[*R*]sends[*A*]the appropriate ReplRate copies of the messages[*A*]to each one of them	context()	negated: False ,passive: False
0.915	[*A*]node X[*R*]sorts[*A*]them[*A*]in the reverse order ( from the highest to the lowest	context()	negated: False ,passive: False
[LINE#147] If the receiving node still has available resources after receiving all the topics of interest, node X will send additional messages it has in its buffer (in a FIFO manner) as long as they are not duplicates.
0.870	[*A*]the receiving node[*R*]has available resources after receiving[*A*]all the topics of interest	context(the receiving node has)	negated: False ,passive: False
0.941	[*A*]the receiving node[*R*]has[*A*]available resources[*A*]after receiving all the topics of interest[*A*]still	context()	negated: False ,passive: False
0.616	[*A*]they[*R*]are not[*A*]duplicates	context()	negated: True ,passive: True
0.417	[*A*]it[*R*]has[*A*]in its buffer (in a FIFO manner[*A*]as long as they are not duplicates	context()	negated: False ,passive: False
0.907	[*A*]node X[*R*]will send[*A*]additional messages it has in its buffer (in a FIFO manner) as long	context()	negated: False ,passive: False
[LINE#148] The reason for this is that the node X should offload the messages to nodes with better resources even if they are not directly or indirectly interested in it as they will have better opportunities to forward these messages on.
0.616	[*A*]they[*R*]will have[*A*]better opportunities to forward these messages on	context()	negated: False ,passive: False
0.891	[*A*]the node X[*R*]should offload[*A*]the messages to nodes with better resources	context(The reason for this is)	negated: False ,passive: False
0.792	[*A*]The reason for this[*R*]is[*A*]that the node X should offload the messages to nodes with better resources even if they are not directly or indirectly interested in it as they will have better opportunities	context()	negated: False ,passive: True
[LINE#149] If two contacts are equally suited to forward a message, they each receive half of the available copies.
0.575	[*A*]they[*R*]receive[*A*]half of the available copies	context()	negated: False ,passive: False
0.903	[*A*]two contacts[*R*]are[*A*]equally suited to forward a message	context()	negated: False ,passive: True
[LINE#150] A contact receives more or fewer messages depending whether it has greater or smaller utility respectfully.
0.445	[*A*]it[*R*]has respectfully[*A*]greater or smaller utility	context()	negated: False ,passive: False
0.769	[*A*]more or fewer messages[*R*]depending	context()	negated: False ,passive: False
0.835	[*A*]A contact[*R*]receives[*A*]more or fewer messages depending[*A*]whether it has greater or smaller utility respectfully	context()	negated: False ,passive: False
[LINE#151] The replication rate is rounded to the nearest integer so that in the single copy case messages are propagated provided a minimum of equivalent utility is met.
0.932	[*A*]The replication rate[*R*]is[*A*]rounded to the nearest integer	context()	negated: False ,passive: True
[LINE#152] In this way, CafRep adapts the initial number of copies (M) in order to carefully manage the trade-off between the network size and traffic demands.
0.920	[*A*]CafRep[*R*]adapts[*A*]the initial number of copies[*A*]in order	context()	negated: False ,passive: False
[LINE#153] As CafRepUtil of a node moves up and down, the replication limit grows to take advantage of all available resources, but backs-off when congestion increases, similar to how TCP updates its congestion window [22].
0.762	[*A*]TCP[*R*]updates[*A*]its congestion window	context()	negated: False ,passive: False
0.932	[*A*]the replication limit[*R*]grows[*A*]to take advantage of all available resources	context()	negated: False ,passive: True
[LINE#154] As a result, our protocol is able to replicate at adaptively lower rates in the parts of the network that have low buffer availability, increased node delay and are likely to congest faster.
0.735	[*A*]the network[*R*]have are[*A*]likely to congest faster	context()	negated: False ,passive: True
0.698	[*A*]the network[*R*]have	context()	negated: False ,passive: False
0.887	[*A*]the network[*R*]have[*A*]low buffer availability	context()	negated: False ,passive: False
0.305	[*A*]our protocol[*R*]to replicate	context()	negated: False ,passive: False
0.790	[*A*]our protocol[*R*]is[*A*]able to replicate at adaptively lower rates in the parts of the network	context()	negated: False ,passive: True
[LINE#155] As CafRep node discovers parts of the network with higher buffer availability, lower node delays and slower congesting rates, it replicates at higher rates.
0.948	[*A*]CafRep[*R*]node[*A*]discovers parts of the network with higher buffer availability , slower congesting rates	context()	negated: False ,passive: False
0.195	[*A*]it[*R*]replicates	context()	negated: False ,passive: False
0.920	[*A*]CafRep[*R*]node[*A*]discovers parts of the network with higher buffer availability	context()	negated: False ,passive: False
[LINE#156] Using social utilities together with resource utilities as part of CafRepUtil enables little (or no) replication at high rates on nodes and network regions that available but not on the direct path to the destination.
0.946	[*A*]Using social utilities together with resource utilities as part of CafRepUtil[*R*]enables[*A*]no ) replication at high rates on network regions that not on the direct path to the destination	context()	negated: False ,passive: False
0.968	[*A*]Using social utilities together with resource utilities as part of CafRepUtil[*R*]enables[*A*]no ) replication at high rates on network regions	context()	negated: False ,passive: False
0.946	[*A*]Using social utilities together with resource utilities as part of CafRepUtil[*R*]enables[*A*]little ( replication at high rates on network regions that not on the direct path to the destination	context()	negated: False ,passive: False
0.968	[*A*]Using social utilities together with resource utilities as part of CafRepUtil[*R*]enables[*A*]little ( replication at high rates on network regions	context()	negated: False ,passive: False
0.968	[*A*]Using social utilities together with resource utilities as part of CafRepUtil[*R*]enables[*A*]no ) replication at high rates on nodes	context()	negated: False ,passive: False
0.968	[*A*]Using social utilities together with resource utilities as part of CafRepUtil[*R*]enables[*A*]little ( replication at high rates on nodes	context()	negated: False ,passive: False
[LINE#157] At the same time, using Resources Utilities allows CafRep to replicate at nodes that do not have high social utilities but have high available resources.
0.877	[*A*]nodes[*R*]do not have[*A*]high available resources	context()	negated: True ,passive: False
0.722	[*A*]CafRep[*R*]to replicate	context(using Resources Utilities allows)	negated: False ,passive: False
0.958	[*A*]using Resources Utilities[*R*]allows[*A*]CafRep to replicate at nodes[*A*]At the same time	context()	negated: False ,passive: False
0.877	[*A*]nodes[*R*]do not have[*A*]high social utilities	context()	negated: True ,passive: False
[LINE#158] With the use of combined adaptive forwarding and replication, we allow the sender to stop sending until it finds the right node that it can redirect the traffic to without incurring additional packet loss.
0.397	[*A*]it[*R*]can redirect[*A*]the traffic[*A*]to	context(it finds)	negated: False ,passive: False
0.695	[*A*]the sender[*R*]to stop[*A*]sending[*A*]until it finds the right node that it can redirect the traffic to without incurring additional packet loss	context(we allow)	negated: False ,passive: False
0.397	[*A*]it[*R*]can redirect[*A*]the traffic[*A*]to	context(it finds)	negated: False ,passive: False
0.467	[*A*]it[*R*]finds[*A*]the right node	context()	negated: False ,passive: False
0.698	[*A*]the sender[*R*]sending	context()	negated: False ,passive: False
0.695	[*A*]the sender[*R*]to stop[*A*]sending[*A*]until it finds the right node that it can redirect the traffic to without incurring additional packet loss	context(we allow)	negated: False ,passive: False
0.168	[*A*]we[*R*]allow[*A*]the sender to stop sending until it finds the right node that it can redirect the traffic to without incurring additional packet loss	context()	negated: False ,passive: False
[LINE#159] Using ego network resource utilities in addition to social utilities allows CafRep to account for a wider view of the network resources and connectivity patterns while allowing differing local conditions.
0.857	[*A*]CafRep[*R*]to account for a wider view of the network resources and connectivity patterns allowing[*A*]differing local conditions	context(Using ego network resource utilities in addition to social utilities allows CafRep to account)	negated: False ,passive: False
0.936	[*A*]CafRep[*R*]to account[*A*]for a wider view of the network resources and connectivity patterns	context(Using ego network resource utilities in addition to social utilities allows)	negated: False ,passive: False
0.969	[*A*]Using ego network resource utilities in addition to social utilities[*R*]allows[*A*]CafRep to account for a wider view of the network resources and connectivity patterns	context()	negated: False ,passive: False
[LINE#160] This is very suitable for the DTNs where the nodes and parts of the networks can be highly heterogeneous in terms of connectivity and resource parameters.
0.960	[*A*]parts of the networks[*R*]can be[*A*]highly heterogeneous[*A*]the DTNs	context()	negated: False ,passive: True
0.952	[*A*]the nodes[*R*]can be[*A*]highly heterogeneous[*A*]the DTNs	context()	negated: False ,passive: True
0.495	[*A*]This[*R*]is[*A*]very suitable for the DTNs	context()	negated: False ,passive: True
[LINE#161] We argue that CafRepUtil congestion metric is more efficient for heterogeneous DTNs than the metrics that estimates global congestion parameters in DTNs proposed in EBR and RR as it conveys information about which parts of the network are more congested than the others, and can opportunistically use parts of the network that are available while the others are busy.
0.895	[*A*]global congestion parameters in DTNs[*R*]proposed[*A*]in RR[*A*]as it conveys information about which	context(the metrics estimates)	negated: False ,passive: False
0.879	[*A*]the metrics[*R*]estimates[*A*]global congestion parameters in DTNs proposed in RR	context()	negated: False ,passive: False
0.895	[*A*]global congestion parameters in DTNs[*R*]proposed[*A*]in EBR[*A*]as it conveys information about which	context(the metrics estimates)	negated: False ,passive: False
0.879	[*A*]the metrics[*R*]estimates[*A*]global congestion parameters in DTNs proposed in EBR	context()	negated: False ,passive: False
0.569	[*A*]it[*R*]conveys[*A*]information about which parts of the network are more congested than the others	context()	negated: False ,passive: False
0.919	[*A*]parts of the network[*R*]are[*A*]more congested than the others	context()	negated: False ,passive: True
0.932	[*A*]CafRepUtil congestion[*R*]is[*A*]more efficient for heterogeneous DTNs than the metrics	context(We argue)	negated: False ,passive: True
0.317	[*A*]We[*R*]argue[*A*]that CafRepUtil congestion metric is more efficient for heterogeneous DTNs than the metrics	context()	negated: False ,passive: False
0.767	[*A*]the others[*R*]are[*A*]busy	context()	negated: False ,passive: True
0.771	[*A*]parts of the network[*R*]are[*A*]available	context()	negated: False ,passive: True
0.755	[*A*]estimates[*R*]can opportunistically use[*A*]parts of the network that are available	context()	negated: False ,passive: False
[LINE#162] In this way, CafRep enables replication at different rates at different parts of the network that are dissimilar from each other and thus have different social and resource characteristics and patterns. .
0.934	[*A*]different rates at different parts of the network[*R*]have[*A*]different resource patterns	context()	negated: False ,passive: False
0.934	[*A*]different rates at different parts of the network[*R*]have[*A*]different social patterns	context()	negated: False ,passive: False
0.934	[*A*]different rates at different parts of the network[*R*]have[*A*]different social characteristics	context()	negated: False ,passive: False
0.735	[*A*]the network[*R*]are[*A*]dissimilar from each other	context()	negated: False ,passive: True
0.920	[*A*]CafRep[*R*]enables[*A*]replication[*A*]at different rates at different parts of the network	context()	negated: False ,passive: False
[LINE#163]  Content transmission over CafRepWe describe an example of an interest driven overlay for content dissemination on the top of CafREP in Fig..
0.918	[*A*]an interest[*R*]driven[*A*]overlay[*A*]for content dissemination[*A*]on the top of CafREP in Fig	context()	negated: False ,passive: False
0.939	[*A*]Content transmission over CafRepWe[*R*]describe[*A*]an example of an interest	context()	negated: False ,passive: False
[LINE#164] We assume that the content contains topics and each topic has chunks that can be exchanged when the two nodes meet via summary vector.
0.783	[*A*]each topic[*R*]has[*A*]chunks that can be exchanged	context(We assume)	negated: False ,passive: False
0.194	[*A*]We[*R*]assume[*A*]that each topic has chunks	context()	negated: False ,passive: False
0.911	[*A*]the two nodes[*R*]meet[*A*]via summary vector	context()	negated: False ,passive: False
0.786	[*A*]chunks[*R*]can be exchanged[*A*]when the two nodes meet via summary vector	context()	negated: False ,passive: True
0.882	[*A*]the content[*R*]contains[*A*]topics	context(We assume)	negated: False ,passive: False
0.194	[*A*]We[*R*]assume[*A*]that the content contains topics	context()	negated: False ,passive: False
[LINE#165] For easier bootstrapping, we assume that some subscribers that are known to the publishers, while others are discovered in an ad hoc manner.
0.894	[*A*]others[*R*]are discovered[*A*]in an ad hoc manner	context()	negated: False ,passive: True
0.887	[*A*]some subscribers[*R*]are known[*A*]to the publishers[*A*]while others are discovered in an ad hoc manner	context()	negated: False ,passive: True
0.195	[*A*]we[*R*]assume	context()	negated: False ,passive: False
[LINE#166] When propagating resource and centrality information, our nodes also propagate their interests by exchanging their interest profiles (topics they are interested in) and summary vectors in order to avoid sending chunks to nodes that are already carrying the same chunks.
0.591	[*A*]our nodes[*R*]propagate[*A*]their interests[*A*]When propagating centrality information	context()	negated: False ,passive: False
0.616	[*A*]they[*R*]are[*A*]interested in summary vectors in order	context()	negated: False ,passive: True
0.361	[*A*]they[*R*]are[*A*]interested in	context()	negated: False ,passive: True
0.893	[*A*]nodes[*R*]are carrying[*A*]the same chunks[*A*]already	context()	negated: False ,passive: False
0.591	[*A*]our nodes[*R*]propagate[*A*]their interests[*A*]When propagating resource information	context()	negated: False ,passive: False
[LINE#167] The Summary Vector contains a list of chunk IDs per topic that a node currently carries per topic.
0.934	[*A*]a node[*R*]carries[*A*]per topic[*A*]currently	context()	negated: False ,passive: True
0.933	[*A*]The Summary Vector[*R*]contains[*A*]a list of chunk IDs per topic	context()	negated: False ,passive: False
[LINE#168] , when two nodes meet, the sending node scans for neighbouring nodes' and calculates their respective relative CafRep Utilities.
0.732	[*A*]two nodes[*R*]meet	context()	negated: False ,passive: False
0.845	[*A*]two nodes[*R*]meet calculates[*A*]their respective relative CafRep Utilities[*A*]meet , the sending node scans for neighbouring	context(two nodes meet)	negated: False ,passive: False
0.862	[*A*]two nodes[*R*]meet[*A*]the sending node scans for neighbouring and calculates their respective relative CafRep Utilities	context()	negated: False ,passive: False
[LINE#169] Each neighbouring nodes' CafRep Utility is weighted and sorted in a list so that the node with the largest weight appears first in the list.
0.932	[*A*]the node with the largest weight[*R*]appears[*A*]first[*A*]in the list	context()	negated: False ,passive: True
0.845	[*A*]Each neighbouring nodes ' CafRep Utility[*R*]is weighted	context()	negated: False ,passive: False
[LINE#170+171]  When the sending and replication rates are determined for a node, pseudo code in Fig.4 is invoked per node to transmit the content to each node.
0.965	[*A*]pseudo code in Fig.4[*R*]is invoked[*A*]per node[*A*]to transmit the content to each node[*A*]When the replication rates are determined for a node	context()	negated: False ,passive: True
0.911	[*A*]the replication rates[*R*]are determined[*A*]for a node	context()	negated: False ,passive: True
0.965	[*A*]pseudo code in Fig.4[*R*]is invoked[*A*]per node[*A*]to transmit the content to each node[*A*]When the sending rates are determined for a node	context()	negated: False ,passive: True
0.911	[*A*]the sending rates[*R*]are determined[*A*]for a node	context()	negated: False ,passive: True
[LINE#172] Before the sending node starts sending the chunks to its contact, the receiving node is queried about its topics and chunks that it already has per topic.
0.754	[*A*]chunks[*R*]has[*A*]already	context()	negated: False ,passive: True
0.941	[*A*]the receiving node[*R*]is queried[*A*]about chunks[*A*]Before the sending node starts sending the chunks to its contact	context()	negated: False ,passive: True
0.555	[*A*]its topics[*R*]has[*A*]already	context()	negated: False ,passive: True
0.941	[*A*]the receiving node[*R*]is queried[*A*]about its topics[*A*]Before the sending node starts sending the chunks to its contact	context()	negated: False ,passive: True
0.825	[*A*]the sending node[*R*]sending[*A*]the chunks[*A*]to its contact	context()	negated: False ,passive: False
0.800	[*A*]the sending node[*R*]starts	context()	negated: False ,passive: False
[LINE#173+174]  When the queried node responds, the sending node finds the intersection of the topics between the two nodesand then it calculates for each topic the complement of the two summary vectors the nodes have to determine the list of topics and associated chunks to be sent without duplication. .
0.949	[*A*]the sending node[*R*]finds[*A*]the intersection of the topics between the two nodesand[*A*]When the queried node responds	context(it calculates)	negated: False ,passive: False
0.388	[*A*]it[*R*]calculates[*A*]for each topic[*A*]the complement of the two summary vectors	context()	negated: False ,passive: False
0.561	[*A*]chunks[*R*]to be sent	context()	negated: False ,passive: False
0.887	[*A*]the nodes[*R*]associated[*A*]chunks to be sent without duplication	context()	negated: False ,passive: False
0.887	[*A*]the nodes[*R*]to determine[*A*]the list of topics	context()	negated: False ,passive: False
0.751	[*A*]the queried node[*R*]responds	context()	negated: False ,passive: False
[LINE#175] Exploring different weighting for congestion heuristicsCafFRep adaptively moves the traffic away from the more overloaded parts of the network to freer parts of the network while avoiding greedy choices of choosing the currently more available nodes that may congest later on.
0.788	[*A*]the currently more available nodes[*R*]may congest[*A*]later on	context()	negated: False ,passive: True
0.968	[*A*]Exploring different weighting for congestion heuristicsCafFRep[*R*]adaptively moves[*A*]the traffic[*A*]away from the more overloaded parts of the network[*A*]to freer parts of the network[*A*]while avoiding greedy choices of choosing the currently more available nodes	context()	negated: False ,passive: False
[LINE#176] The decisions of how cautious (versus how greedy) a node should be when choosing the next hop and deciding on the number of packets are not trivial to make and could depend on the state of the network and relative weights of the CafRep utilities.
0.918	[*A*]The decisions[*R*]could depend[*A*]on the relative weights of the CafRep utilities	context()	negated: False ,passive: False
0.947	[*A*]The decisions[*R*]could depend[*A*]on the state of the network weights of the CafRep utilities	context()	negated: False ,passive: False
0.887	[*A*]The decisions[*R*]choosing[*A*]the next hop	context()	negated: False ,passive: False
[LINE#177] At times of low congestion, social utility is the primary utility for forwarding and replication policy but as the congestion increases the social utility plays a smaller role while resource considerations become increasingly important.
0.767	[*A*]resource considerations[*R*]become[*A*]increasingly important	context()	negated: False ,passive: True
0.903	[*A*]the congestion[*R*]increases[*A*]the social utility	context()	negated: False ,passive: False
[LINE#178] More specifically, social utility allows the nodes to find the most direct route to the destinations and gives more copies to the nodes with higher social utility value but can congest them and cause them to be unusable.
0.878	[*A*]the nodes[*R*]to find[*A*]the most direct route to the destinations	context(social utility allows)	negated: False ,passive: False
0.920	[*A*]social utility[*R*]allows[*A*]the nodes to find the most direct route to the destinations	context()	negated: False ,passive: False
0.810	[*A*]social utility[*R*]can congest[*A*]them	context()	negated: False ,passive: False
0.887	[*A*]social utility[*R*]gives[*A*]more copies[*A*]to the nodes with higher social utility value	context()	negated: False ,passive: False
[LINE#179] When congestion happens, the combined utility allows CafRep to de-cluster individual nodes and parts of the network by leveraging social metric with resource constraints.
0.898	[*A*]CafRep[*R*]to de-cluster[*A*]individual parts of the network	context(the combined utility allows)	negated: False ,passive: False
0.965	[*A*]the combined utility[*R*]allows[*A*]CafRep to de-cluster individual parts of the network by leveraging social metric with resource constraints[*A*]When congestion happens	context()	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]to de-cluster[*A*]individual nodes of the network	context(the combined utility allows)	negated: False ,passive: False
0.965	[*A*]the combined utility[*R*]allows[*A*]CafRep to de-cluster individual nodes of the network by leveraging social metric with resource constraints[*A*]When congestion happens	context()	negated: False ,passive: False
0.713	[*A*]congestion[*R*]happens	context()	negated: False ,passive: False
[LINE#180] In Section 3.5.1 we defined CafRep utility as the sum of the equally contributing utility values.
0.639	[*A*]we[*R*]defined[*A*]CafRep utility[*A*]as the sum of the equally contributing utility values[*A*]In Section 3.5.1	context()	negated: False ,passive: False
[LINE#181] Computing optimal weights that adaptively favour different utilities differently at different times is a very difficult problem even with the complete knowledge about the environment [47].
0.949	[*A*]Computing optimal weights[*R*]is[*A*]a very difficult problem even with the complete knowledge about the environment	context()	negated: False ,passive: True
0.837	[*A*]optimal weights[*R*]adaptively differently[*A*]at different times	context()	negated: False ,passive: False
[LINE#182] In the case of inherent uncertainty of the DTN environments, extreme heterogeneity of the connectivity patters and no feedback, related research [47] has ruled out provably efficient online routing algorithms.
0.964	[*A*]related research[*R*]has ruled out[*A*]provably efficient online routing algorithms[*A*]In the case of inherent uncertainty of the DTN environments	context()	negated: False ,passive: False
[LINE#183] In [46], the authors analysed the impact of storage and transmission limitations on DTN message routing by and aimed to provide a comprehensive formalisation of this problem based on the first principle of Wardrop, but their based their work on the Oracle based routing algorithm.
0.952	[*A*]the authors[*R*]analysed[*A*]the impact of transmission limitations on DTN message[*A*]In [ 46	context()	negated: False ,passive: False
0.943	[*A*]a comprehensive formalisation of this problem[*R*]based[*A*]on the first principle of Wardrop	context()	negated: False ,passive: True
0.788	[*A*]DTN message[*R*]aimed	context()	negated: False ,passive: False
0.817	[*A*]DTN message[*R*]routing[*A*]by	context()	negated: False ,passive: True
0.952	[*A*]the authors[*R*]analysed[*A*]the impact of storage on DTN message[*A*]In [ 46	context()	negated: False ,passive: False
[LINE#184] This is not applicable to our work as we are interested in fully distributed opportunistic approach.
0.452	[*A*]we[*R*]are[*A*]interested in fully distributed opportunistic approach	context()	negated: False ,passive: True
0.250	[*A*]This[*R*]is not[*A*]applicable to our work[*A*]as we are interested in fully distributed opportunistic approach	context()	negated: True ,passive: True
[LINE#185+186]  Even though we do not aim to theoretically analyse different utility weighting models, we have, in our earlier work [31],considered assigning different weights to each of the utilities for Caf in order to empirically explore their relative importance on the adaptive forwarding.
0.164	[*A*]utility weighting models we have in our earlier work considered assigning weights to each of the utilities for Caf in order to empirically explore their relative importance on the adaptive forwarding[*R*]have difference of[*A*]31 ]	context()	negated: False ,passive: False
0.562	[*A*]we[*R*]have[*A*]different utility weighting models, we have, in our earlier work [31],considered assigning different weights to each of the utilities for Caf in order	context()	negated: False ,passive: False
[LINE#187] Our extensive experiments over RollerNet trace [21] revealed a number of interesting findings.
0.748	[*A*]Our extensive experiments over RollerNet trace[*R*]revealed[*A*]a number of interesting findings	context()	negated: False ,passive: False
[LINE#188] We showed that utilising only a single forwarding strategy based on one node utility leads to suboptimal next hop choices.
0.903	[*A*]utilising only a single forwarding strategy[*R*]leads[*A*]to suboptimal next hop choices	context(We showed)	negated: False ,passive: False
0.279	[*A*]We[*R*]showed[*A*]that utilising only a single forwarding strategy based on one node utility leads to suboptimal next hop choices	context()	negated: False ,passive: False
0.926	[*A*]only a single forwarding strategy[*R*]based[*A*]on one node utility	context()	negated: False ,passive: True
[LINE#189] For example, in [15] retentiveness was weighted significantly higher than receptiveness and our results showed increased delays and decreased success ratios over Infocom 2006 trace [33] compared to when they were equally weighted [31].
0.320	[*A*]they[*R*]were equally weighted	context()	negated: False ,passive: False
0.847	[*A*]receptiveness[*R*]decreased[*A*]success ratios over Infocom 2006 trace[*A*]compared to when they were equally weighted [ 31	context()	negated: False ,passive: False
0.894	[*A*]receptiveness[*R*]showed[*A*]increased delays	context()	negated: False ,passive: False
[LINE#190] Similarly, when we weighted the receptiveness significantly higher than the retentiveness, Caf performance was lower due to the increased packet loss rates [31] as a result of greedy storage utilisation.
0.963	[*A*]Caf performance[*R*]was[*A*]lower due to the increased packet loss rates[*A*]when we weighted the receptiveness significantly higher than the retentiveness	context()	negated: False ,passive: True
0.445	[*A*]we[*R*]weighted significantly higher[*A*]the receptiveness	context()	negated: False ,passive: False
[LINE#191] Another interesting finding was that using ego network retentiveness only was highly valuable for forwarding in social opportunistic networks such as Infocom trace [33].
0.951	[*A*]using ego network retentiveness[*R*]was[*A*]highly valuable for forwarding in social opportunistic networks such as Infocom trace [33	context(Another interesting finding was)	negated: False ,passive: True
0.885	[*A*]Another interesting finding[*R*]was[*A*]that using ego network retentiveness only was highly valuable for forwarding in social opportunistic networks such as Infocom trace [33	context()	negated: False ,passive: True
[LINE#192] In particular, even a simple ego network retentiveness utility for the majority of time performed better than more sophisticated analysis of the node only resources statistics.
0.906	[*A*]In particular, even a simple ego network retentiveness utility for the majority of time[*R*]performed better	context()	negated: False ,passive: False
[LINE#193] This was expected as Infocom is a social trace with high degree of reoccurring contacts.
0.938	[*A*]Infocom[*R*]is[*A*]a social trace with high degree of reoccurring contacts	context()	negated: False ,passive: True
0.543	[*A*]This[*R*]was expected[*A*]as Infocom is a social trace with high degree of reoccurring contacts	context()	negated: False ,passive: True
[LINE#194] Both of our empirical results with Caf over RollerNet and Infocom 2006 traces [21,33] revealed that combined metric of similar weights allows the forwarding protocol to be sufficiently dynamic and flexible to operate as mainly social protocol at times of low congestion and as a mainly resource driven protocol at times of high congestion.
0.929	[*A*]the forwarding protocol[*R*]to be[*A*]flexible to operate as mainly social protocol as a mainly resource driven protocol at times of high congestion	context(Both of our empirical results with Infocom 2006 traces revealed combined metric of similar weights allows)	negated: False ,passive: True
0.941	[*A*]combined metric of similar weights[*R*]allows[*A*]the forwarding protocol to be flexible to operate as mainly social protocol as a mainly resource driven protocol at times of high congestion	context(Both of our empirical results with Infocom 2006 traces revealed)	negated: False ,passive: False
0.651	[*A*]Both of our empirical results with Infocom 2006 traces[*R*]revealed[*A*]that combined metric of similar weights allows the forwarding protocol to be flexible to operate as mainly social protocol as a mainly resource driven protocol at times of high congestion	context()	negated: False ,passive: False
0.929	[*A*]the forwarding protocol[*R*]to be[*A*]flexible to operate as mainly social protocol at times of low congestion	context(Both of our empirical results with Infocom 2006 traces revealed combined metric of similar weights allows)	negated: False ,passive: True
0.941	[*A*]combined metric of similar weights[*R*]allows[*A*]the forwarding protocol to be flexible to operate as mainly social protocol at times of low congestion	context(Both of our empirical results with Infocom 2006 traces revealed)	negated: False ,passive: False
0.651	[*A*]Both of our empirical results with Infocom 2006 traces[*R*]revealed[*A*]that combined metric of similar weights allows the forwarding protocol to be flexible to operate as mainly social protocol at times of low congestion	context()	negated: False ,passive: False
0.894	[*A*]resource[*R*]driven[*A*]protocol at times of high congestion	context()	negated: False ,passive: False
0.718	[*A*]the forwarding protocol[*R*]to operate	context()	negated: False ,passive: False
0.929	[*A*]the forwarding protocol[*R*]to be[*A*]flexible to operate as mainly social protocol as a mainly resource driven protocol at times of high congestion	context(Both of our empirical results with Caf over RollerNet traces revealed combined metric of similar weights allows)	negated: False ,passive: True
0.941	[*A*]combined metric of similar weights[*R*]allows[*A*]the forwarding protocol to be flexible to operate as mainly social protocol as a mainly resource driven protocol at times of high congestion	context(Both of our empirical results with Caf over RollerNet traces revealed)	negated: False ,passive: False
0.673	[*A*]Both of our empirical results with Caf over RollerNet traces[*R*]revealed[*A*]that combined metric of similar weights allows the forwarding protocol to be flexible to operate as mainly social protocol as a mainly resource driven protocol at times of high congestion	context()	negated: False ,passive: False
0.929	[*A*]the forwarding protocol[*R*]to be[*A*]flexible to operate as mainly social protocol at times of low congestion	context(Both of our empirical results with Caf over RollerNet traces revealed combined metric of similar weights allows)	negated: False ,passive: True
0.941	[*A*]combined metric of similar weights[*R*]allows[*A*]the forwarding protocol to be flexible to operate as mainly social protocol at times of low congestion	context(Both of our empirical results with Caf over RollerNet traces revealed)	negated: False ,passive: False
0.673	[*A*]Both of our empirical results with Caf over RollerNet traces[*R*]revealed[*A*]that combined metric of similar weights allows the forwarding protocol to be flexible to operate as mainly social protocol at times of low congestion	context()	negated: False ,passive: False
0.878	[*A*]the forwarding protocol[*R*]to operate[*A*]at times of low congestion	context()	negated: False ,passive: True
0.743	[*A*]the forwarding protocol[*R*]to be[*A*]sufficiently dynamic	context(Both of our empirical results with Infocom 2006 traces revealed combined metric of similar weights allows)	negated: False ,passive: True
0.909	[*A*]combined metric of similar weights[*R*]allows[*A*]the forwarding protocol to be sufficiently dynamic	context(Both of our empirical results with Infocom 2006 traces revealed)	negated: False ,passive: False
0.651	[*A*]Both of our empirical results with Infocom 2006 traces[*R*]revealed[*A*]that combined metric of similar weights allows the forwarding protocol to be sufficiently dynamic	context()	negated: False ,passive: False
0.743	[*A*]the forwarding protocol[*R*]to be[*A*]sufficiently dynamic	context(Both of our empirical results with Caf over RollerNet traces revealed combined metric of similar weights allows)	negated: False ,passive: True
0.909	[*A*]combined metric of similar weights[*R*]allows[*A*]the forwarding protocol to be sufficiently dynamic	context(Both of our empirical results with Caf over RollerNet traces revealed)	negated: False ,passive: False
0.673	[*A*]Both of our empirical results with Caf over RollerNet traces[*R*]revealed[*A*]that combined metric of similar weights allows the forwarding protocol to be sufficiently dynamic	context()	negated: False ,passive: False
[LINE#195] In this section, we describe our experiments with different CafRep weightings across three topologically different traces: one highly social (Infocom 2006 [33]), one sparse social (Sassy [44]) and one highly sparse vehicular (SF Cabs [45]).
0.444	[*A*]we[*R*]describe[*A*]our experiments[*A*]In this section	context()	negated: False ,passive: False
[LINE#196] These traces are described in Section 4.1.
0.903	[*A*]These traces[*R*]are described[*A*]in Section 4.1	context()	negated: False ,passive: True
[LINE#197] As with Caf evaluation, extreme differences between CafRep utilities do not result in performance gain, so here we look at the finer differences between the CafRep utilities' weightings.
0.686	[*A*]we[*R*]look[*A*]at the finer differences between the CafRep utilities' weightings[*A*]so here	context(extreme differences between CafRep utilities do not result)	negated: False ,passive: False
0.929	[*A*]extreme differences between CafRep utilities[*R*]do not result[*A*]in performance gain	context()	negated: True ,passive: True
[LINE#198] As per each individual trace, we could not detect dramatic differences in the performance results between different CafRep weightings.
0.740	[*A*]we[*R*]could not detect[*A*]dramatic differences in the performance results between different CafRep weightings[*A*]As per each individual trace	context()	negated: True ,passive: False
[LINE#199] 5 shows no more that 5% difference in success ratios between the best and worst performer per trace.
0.323	[*A*]5[*R*]shows[*A*]no more that 5% difference in success ratios between the best and worst performer per trace	context()	negated: False ,passive: False
[LINE#200] However, we could clearly detect that some utilities were significantly more dominant than the others across different traces.
0.878	[*A*]some utilities[*R*]were[*A*]significantly more dominant than the others across different traces	context(we could clearly detect)	negated: False ,passive: True
0.271	[*A*]we[*R*]could clearly detect[*A*]that some utilities were significantly more dominant than the others across different traces	context()	negated: False ,passive: False
[LINE#201] More specifically, in order to understand the impact of the SocialUtil, we looked into High SocialUtil (0.6 of the CafrepUtil), Low SocialUtil (0.3 of CafRepUtil) and Equal SocialUtil (0.5 of the CafRepUtil) while the node utilities end ego network utilities were ranked equally.
0.443	[*A*]we[*R*]looked[*A*]into High SocialUtil	context(ego network utilities were ranked)	negated: False ,passive: False
0.443	[*A*]we[*R*]looked[*A*]into High SocialUtil	context(ego network utilities were ranked)	negated: False ,passive: False
0.743	[*A*]ego network utilities[*R*]were ranked[*A*]equally	context()	negated: False ,passive: True
0.800	[*A*]the node utilities[*R*]end	context()	negated: False ,passive: False
[LINE#202] 5 and 6 show that CafRep with lowest social weighting (0.3) has the highest success ratio (46-48%) and the lowest delay (29-45h) for San Francisco Cab trace [45].
0.967	[*A*]CafRep with lowest social weighting[*R*]has[*A*]the lowest delay ( 29-45 h ) for San Francisco Cab trace	context(6 show)	negated: False ,passive: False
0.315	[*A*]6[*R*]show[*A*]that CafRep with lowest social weighting ( 0.3 ) has the lowest delay ( 29-45 h ) for San Francisco Cab trace	context()	negated: False ,passive: False
0.938	[*A*]CafRep with lowest social weighting[*R*]has[*A*]the highest success ratio	context(6 show)	negated: False ,passive: False
0.315	[*A*]6[*R*]show[*A*]that CafRep with lowest social weighting ( 0.3 ) has the highest success ratio	context()	negated: False ,passive: False
0.967	[*A*]CafRep with lowest social weighting[*R*]has[*A*]the lowest delay ( 29-45 h ) for San Francisco Cab trace	context(5 show)	negated: False ,passive: False
0.315	[*A*]5[*R*]show[*A*]that CafRep with lowest social weighting ( 0.3 ) has the lowest delay ( 29-45 h ) for San Francisco Cab trace	context()	negated: False ,passive: False
0.938	[*A*]CafRep with lowest social weighting[*R*]has[*A*]the highest success ratio	context(5 show)	negated: False ,passive: False
0.315	[*A*]5[*R*]show[*A*]that CafRep with lowest social weighting ( 0.3 ) has the highest success ratio	context()	negated: False ,passive: False
[LINE#203] This is expected as this trace has the sparsest topology with least repetitive connectivity patterns.
0.925	[*A*]this trace[*R*]has[*A*]the sparsest topology with least repetitive connectivity patterns	context()	negated: False ,passive: False
0.497	[*A*]This[*R*]is expected[*A*]as this trace has the sparsest topology with least repetitive connectivity patterns	context()	negated: False ,passive: True
[LINE#204] CafRep with high SocialUtil achieved highest success ratios (90-81%) and lowest delays (67-132s) for Infocom 2006 and Sassy (73-64% and 44-83min).
0.967	[*A*]CafRep with high SocialUtil[*R*]achieved[*A*]highest lowest delays ( 67-132 s ) for Sassy 44-83min	context()	negated: False ,passive: False
0.949	[*A*]CafRep with high SocialUtil[*R*]achieved[*A*]highest lowest delays ( 67-132 s ) for Sassy	context()	negated: False ,passive: False
0.967	[*A*]CafRep with high SocialUtil[*R*]achieved[*A*]highest lowest delays ( 67-132 s ) for Infocom 2006	context()	negated: False ,passive: False
0.939	[*A*]CafRep with high SocialUtil[*R*]achieved[*A*]highest success ratios	context()	negated: False ,passive: False
[LINE#205] CafRep with equal SocialUtil and low SocialUtil closely follow the high Social utility for the respective traces.
0.949	[*A*]CafRep with low SocialUtil[*R*]closely follow[*A*]the high Social utility for the respective traces	context()	negated: False ,passive: False
0.949	[*A*]CafRep with equal SocialUtil[*R*]closely follow[*A*]the high Social utility for the respective traces	context()	negated: False ,passive: False
[LINE#206+207]  This is expected as both of these traces are social and have more repeating contact patternsso SocialUtil is able to utilise the complex graphs statistic in order to make better predictions about the most direct route to the destination.
0.961	[*A*]have more repeating contact patternsso SocialUtil[*R*]is[*A*]able to utilise the complex graphs statistic in order	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]is expected[*A*]as both of these traces	context()	negated: False ,passive: True
[LINE#208] Even though both include human mobility patterns, compared to Infocom 2006 trace, Sassy trace [44] has much less regular and sparser connectivity, no highly central points (as the ones deployed by Infocom 2006).
0.991	[*A*]2006 trace[*R*]has[*A*]sparser connectivity	context()	negated: False ,passive: False
0.934	[*A*]Sassy trace[*R*]has[*A*]sparser connectivity	context()	negated: False ,passive: False
0.991	[*A*]2006 trace[*R*]has[*A*]much less regular connectivity	context()	negated: False ,passive: False
0.918	[*A*]the ones[*R*]deployed[*A*]by Infocom 2006	context()	negated: False ,passive: True
0.934	[*A*]Sassy trace[*R*]has[*A*]much less regular connectivity	context()	negated: False ,passive: False
[LINE#209+210+211]  This results in lower performance results for all weightings of SocailUtils for Sassy compared to Infocom.2006.In order to understand the relative importance of ego network utilities and node utilities, we looked into CafRep with low SocialUtil (0.2 of CafREpUtil) and unequal weightings between ego network utilities and node utilities: first we weighted ego network utilities 0.6 and node utilities as 0.2 of CafREpUtil (we refer to it as HighEN Util) and then we weighted ego network utilities 0.2 and node utility as 0.6 of CafRepUtil.
0.905	[*A*]ego network utilities[*R*]node[*A*]utility[*A*]as 0.6 of CafRepUtil	context(we weighted)	negated: False ,passive: False
0.577	[*A*]we[*R*]weighted[*A*]ego network utilities node utility as 0.6 of CafRepUtil[*A*]in then	context()	negated: False ,passive: False
0.392	[*A*]This[*R*]results[*A*]in then we weighted ego network utilities node utility as 0.6 of CafRepUtil	context()	negated: False ,passive: True
0.595	[*A*]we[*R*]weighted[*A*]ego network utilities[*A*]0.2 utility[*A*]then	context()	negated: False ,passive: False
0.392	[*A*]This[*R*]results[*A*]in then we weighted ego network utilities 0.2 utility as 0.6 of CafRepUtil	context()	negated: False ,passive: True
0.392	[*A*]This[*R*]results[*A*]in : first we weighted ego network utilities node utilities as 0.2 of CafREpUtil ( we refer to it as HighEN Util	context()	negated: False ,passive: True
0.350	[*A*]we[*R*]refer[*A*]to it[*A*]as HighEN Util	context()	negated: False ,passive: False
0.607	[*A*]we[*R*]weighted[*A*]ego[*A*]0.6 utilities as 0.2 of CafREpUtil ( we refer to it as HighEN Util[*A*]first	context()	negated: False ,passive: False
0.392	[*A*]This[*R*]results[*A*]in : first we weighted ego network utilities 0.6 utilities as 0.2 of CafREpUtil ( we refer to it as HighEN Util	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]results[*A*]in unequal weightings between ego network node utilities	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]results[*A*]in unequal weightings between ego network utilities	context()	negated: False ,passive: True
0.477	[*A*]This[*R*]results[*A*]in lower performance results for all weightings of SocailUtils for Sassy[*A*]compared to Infocom.2006.In order	context(we looked)	negated: False ,passive: True
0.477	[*A*]This[*R*]results[*A*]in lower performance results for all weightings of SocailUtils for Sassy[*A*]compared to Infocom.2006.In order	context(we looked)	negated: False ,passive: True
0.433	[*A*]we[*R*]looked[*A*]into CafRep[*A*]with low SocialUtil	context()	negated: False ,passive: False
[LINE#212] It is interesting to see that ego network resources play less important role than node resources in San Francisco Cab trace [45] compared to Sassy [44] and Infocom 2006 [33] traces.
0.947	[*A*]network resources[*R*]play[*A*]less important role than node resources in San Francisco Cab trace	context()	negated: False ,passive: False
[LINE#213] More specifically, CafRep with HighEN Util achieves lower success ratio than CafRep with LowEN Util for the SF Cabs trace [45] (and vice versa for SASSY and Infocom 2006 traces).
0.905	[*A*]CafRep with HighEN Util[*R*]achieves[*A*]lower success ratio than CafRep with LowEN Util[*A*]for the SF Cabs trace	context()	negated: False ,passive: False
0.938	[*A*]CafRep with HighEN Util[*R*]achieves[*A*]lower success ratio than CafRep with LowEN Util[*A*]for the SF Cabs trace [ 45 ] ( and vice versa for SASSY 2006 traces	context()	negated: False ,passive: False
[LINE#214] 5 shows CafRep with HighEN Utils success ratio ranging from around 47% to 44% for SF Cab trace, followed by 68-60% for Sassy trace and 86-76% for Infocom 2006 trace.
0.776	[*A*]SF Cab trace[*R*]followed	context()	negated: False ,passive: False
0.939	[*A*]HighEN Utils success ratio[*R*]ranging[*A*]from around 47 %[*A*]to 44 %	context()	negated: False ,passive: True
[LINE#215] This lowest performance of SF Cab trace [45] is due to it having the least repeating mobility patterns and thus not benefiting significantly from the nodes' ego network resources predictions for future forwarding.
0.948	[*A*]This lowest performance of SF Cab trace[*R*]having not benefiting significantly[*A*]from the nodes ' ego network resources predictions for future forwarding	context()	negated: True ,passive: True
0.952	[*A*]This lowest performance of SF Cab trace[*R*]is[*A*]due to it[*A*]having thus not benefiting significantly from the nodes ' ego network resources predictions for future forwarding	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]having[*A*]the least repeating mobility patterns	context()	negated: False ,passive: False
0.926	[*A*]This lowest performance of SF Cab trace[*R*]is[*A*]due to it having the least repeating mobility patterns	context()	negated: False ,passive: True
[LINE#216] So the most greedy approach of low EN Util and low Social works the best for SF Cab trace [45] while its performance it the worst for the other two social traces.
[LINE#217+218]  In the case of both social traces, HighEN Util performs better than LowEN Utilbut worse than higher SocialUtil version of CafRep.
0.949	[*A*]HighEN Util[*R*]performs better[*A*]In the case of both social traces	context()	negated: False ,passive: False
[LINE#219] This is expected as ego networks play a more important role in social traces.
0.903	[*A*]ego networks[*R*]play[*A*]a more important role in social traces	context()	negated: False ,passive: False
0.497	[*A*]This[*R*]is expected[*A*]as ego networks play a more important role in social traces	context()	negated: False ,passive: True
[LINE#220] In this section we first discuss our findings from the interest driven file casting application experiments across each of the three CRAWDAD datasets described in Section 4.1.
0.887	[*A*]the three CRAWDAD datasets[*R*]described[*A*]in Section 4.1	context()	negated: False ,passive: True
0.931	[*A*]the interest driven file[*R*]casting[*A*]application experiments[*A*]across each of the three CRAWDAD datasets	context()	negated: False ,passive: False
0.942	[*A*]interest[*R*]driven[*A*]file casting application experiments across each of the three CRAWDAD datasets	context()	negated: False ,passive: False
0.403	[*A*]we[*R*]discuss[*A*]our findings[*A*]from the interest driven file[*A*]In this section[*A*]first	context()	negated: False ,passive: False
[LINE#221+222]  We then briefly report on the observations from our Facebook application over RollerNet trace[21] that has highly challenging connectivity patterns due to the Accordion Effect described in [39].
0.831	[*A*]the Accordion Effect[*R*]described[*A*]in [39	context()	negated: False ,passive: True
0.782	[*A*]our Facebook application over RollerNet trace[*R*]has highly challenging[*A*]connectivity patterns due to the Accordion Effect	context()	negated: False ,passive: False
0.566	[*A*]We[*R*]briefly report[*A*]on the observations from our Facebook application over RollerNet trace[*A*]then	context()	negated: False ,passive: False
[LINE#223] For more consistent comparisons between the datasets, we use CafRepUtil for all of our experiments as defined in Section 3 with SocialUtil, node resource utilities and ego network resource utilities being equally weighted.
0.301	[*A*]we[*R*]use[*A*]CafRepUtil[*A*]for all of our experiments	context(node resource utilities and ego network resource utilities being equally weighted)	negated: False ,passive: False
0.796	[*A*]node resource utilities and ego network resource utilities[*R*]being equally weighted	context()	negated: False ,passive: False
[LINE#224] We show that CafRep adapts well to different mobility and connectivity patters and outperforms five major competitive and benchmark protocols.
0.902	[*A*]CafRep[*R*]outperforms[*A*]five major benchmark protocols	context(We show)	negated: False ,passive: False
0.278	[*A*]We[*R*]show[*A*]that CafRep outperforms five major benchmark protocols	context()	negated: False ,passive: False
0.902	[*A*]CafRep[*R*]outperforms[*A*]five major competitive protocols	context(We show)	negated: False ,passive: False
0.278	[*A*]We[*R*]show[*A*]that CafRep outperforms five major competitive protocols	context()	negated: False ,passive: False
0.902	[*A*]CafRep[*R*]adapts well[*A*]to different connectivity patters	context(We show)	negated: False ,passive: False
0.278	[*A*]We[*R*]show[*A*]that CafRep adapts well to different connectivity patters	context()	negated: False ,passive: False
0.902	[*A*]CafRep[*R*]adapts well[*A*]to different mobility patters	context(We show)	negated: False ,passive: False
0.278	[*A*]We[*R*]show[*A*]that CafRep adapts well to different mobility patters	context()	negated: False ,passive: False
[LINE#225] Compared to the traces we used in our earlier work [15,30,31,48], in this work, we use two new, very different data traces (social and vehicular) that are much sparser and have much less frequently recurring connectivity patterns (Sassy [44] and SF Cabs [45]).
0.448	[*A*]we[*R*]have recurring[*A*]connectivity patterns[*A*]much less frequently	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]use[*A*]two new , very different data traces	context()	negated: False ,passive: False
0.425	[*A*]we[*R*]use two new , very different data traces ( that are much sparser and have recurring[*A*]connectivity patterns[*A*]much less frequently	context(we use)	negated: False ,passive: False
0.271	[*A*]we[*R*]use[*A*]two new , very different data traces ( that are much sparser and[*A*]have much less frequently recurring connectivity patterns	context()	negated: False ,passive: False
0.927	[*A*]two new , very different data traces[*R*]have[*A*]much less frequently recurring connectivity patterns	context()	negated: False ,passive: False
0.927	[*A*]two new , very different data traces[*R*]are[*A*]much sparser	context()	negated: False ,passive: True
0.367	[*A*]we[*R*]use[*A*]two new , very different data traces ( that are much sparser and have much less frequently recurring connectivity patterns ( Sassy [ 44 ] )	context()	negated: False ,passive: False
[LINE#226]  It is interesting to see that CafRep performance is slightly worse for the new social trace (Sassy traces [44]) compared to the old social trace.
[LINE#227] Similarly, CafRep also performs on average worse for the new vehicular trace (SF Cab traces [45]) than for the old vehicular (DieselNet) traces.
0.740	[*A*]CafRep[*R*]performs	context()	negated: False ,passive: False
[LINE#228+229+230]  This is due to Sassy [44] and SF Cab traces [45] having much sparser topology and no infrastructure-like nodes that are taking part in the forwarding process.
0.873	[*A*]SF Cab traces[*R*]having[*A*]no infrastructure-like nodes that are taking part in the forwarding process	context()	negated: False ,passive: False
0.922	[*A*]SF Cab traces[*R*]having[*A*]much sparser topology	context()	negated: False ,passive: False
0.495	[*A*]This[*R*]is[*A*]due to SF Cab traces	context()	negated: False ,passive: True
0.897	[*A*]no infrastructure-like nodes[*R*]are taking[*A*]part[*A*]in the forwarding process	context()	negated: False ,passive: False
0.495	[*A*]This[*R*]is[*A*]due to Sassy [ 44	context()	negated: False ,passive: True
[LINE#231] Both Infocom 2006 [33] and DieselNet [3] traces had the motes and APs that were taking part in the forwarding decisions and were highly central nodes.
0.916	[*A*]the APs that were taking part[*R*]were[*A*]highly central nodes	context(Both DieselNet [ 3 ] traces had)	negated: False ,passive: True
0.916	[*A*]the motes that were taking part[*R*]were[*A*]highly central nodes	context(Both DieselNet [ 3 ] traces had)	negated: False ,passive: True
0.852	[*A*]Both DieselNet [ 3 ] traces[*R*]had	context()	negated: False ,passive: False
0.916	[*A*]the APs that were taking part[*R*]were[*A*]highly central nodes	context(Both Infocom 2006 [ 33 ] traces had)	negated: False ,passive: True
0.887	[*A*]the APs[*R*]were taking[*A*]part	context()	negated: False ,passive: False
0.916	[*A*]the motes that were taking part[*R*]were[*A*]highly central nodes	context(Both Infocom 2006 [ 33 ] traces had)	negated: False ,passive: True
0.864	[*A*]Both Infocom 2006 [ 33 ] traces[*R*]had	context()	negated: False ,passive: False
0.887	[*A*]the motes[*R*]were taking[*A*]part	context()	negated: False ,passive: False
0.991	[*A*]3 ] traces[*R*]had[*A*]the APs that were taking part in the forwarding decisions	context()	negated: False ,passive: False
0.935	[*A*]Both DieselNet [ 3 ] traces[*R*]had[*A*]the APs that were taking part in the forwarding decisions	context()	negated: False ,passive: False
0.991	[*A*]3 ] traces[*R*]had[*A*]the motes that were taking part in the forwarding decisions	context()	negated: False ,passive: False
0.935	[*A*]Both DieselNet [ 3 ] traces[*R*]had[*A*]the motes that were taking part in the forwarding decisions	context()	negated: False ,passive: False
0.887	[*A*]the APs[*R*]were taking[*A*]part[*A*]in the forwarding decisions	context()	negated: False ,passive: False
0.941	[*A*]Both Infocom 2006 [ 33 ] traces[*R*]had[*A*]the APs that were taking part in the forwarding decisions	context()	negated: False ,passive: False
0.887	[*A*]the motes[*R*]were taking[*A*]part[*A*]in the forwarding decisions	context()	negated: False ,passive: False
0.941	[*A*]Both Infocom 2006 [ 33 ] traces[*R*]had[*A*]the motes that were taking part in the forwarding decisions	context()	negated: False ,passive: False
[LINE#232] Without such nodes, CafRep's performance is lower but still better than for other comparative protocols.
0.949	[*A*]CafRep 's performance[*R*]is[*A*]still[*A*]better than for other comparative protocols	context()	negated: False ,passive: True
0.867	[*A*]CafRep 's performance[*R*]is[*A*]lower	context()	negated: False ,passive: True
[LINE#233] As expected, the non-adaptive benchmark Spay and Focus [37] and Prophet [23] protocols perform worse compared to other adaptive protocols across all the measures.
0.949	[*A*]the Prophet [ 23 ] protocols[*R*]perform worse[*A*]compared to other adaptive protocols across all the measures	context()	negated: False ,passive: False
0.927	[*A*]Focus protocols[*R*]perform worse[*A*]compared to other adaptive protocols across all the measures	context()	negated: False ,passive: False
0.964	[*A*]the non-adaptive benchmark Spay protocols[*R*]perform[*A*]worse compared to other adaptive protocols across all the measures	context()	negated: False ,passive: False
[LINE#234] Both of these protocols start dropping the packets at the congested nodes early into the simulation that results in higher delays and lower success ratios.
0.887	[*A*]the simulation[*R*]results[*A*]in lower success ratios	context()	negated: False ,passive: True
0.887	[*A*]the simulation[*R*]results[*A*]in higher delays	context()	negated: False ,passive: True
0.919	[*A*]Both of these protocols[*R*]start dropping[*A*]the packets[*A*]at the congested nodes[*A*]early into the simulation	context()	negated: False ,passive: False
[LINE#235] Prophet [23] performs worse than SnF [37] because it is a non-adaptive single copy protocol..
0.522	[*A*]it[*R*]is[*A*]a non-adaptive single copy protocol	context()	negated: False ,passive: True
0.814	[*A*]Prophet[*R*]performs worse[*A*]because it is a non-adaptive single copy protocol	context()	negated: False ,passive: False
[LINE#236] Success ratio and delayAcross all three data connectivity traces CafRep achieves higher success ratio than all other protocols as it more efficiently detects new parts of the networks that have more resources and avoids the parts of the network that are congesting.
0.698	[*A*]the network[*R*]are congesting	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]avoids[*A*]the parts of the network	context()	negated: False ,passive: False
0.862	[*A*]CafRep[*R*]achieves[*A*]higher success ratio than all other protocols[*A*]as it avoids the parts of the network	context()	negated: False ,passive: False
0.887	[*A*]the networks[*R*]have[*A*]more resources	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]more efficiently detects[*A*]new parts of the networks	context()	negated: False ,passive: False
0.920	[*A*]CafRep[*R*]achieves[*A*]higher success ratio than all other protocols	context()	negated: False ,passive: False
[LINE#237] 9 shows comparative success ratios across five protocols and three traces in the presence of increasing number of publishers.
0.567	[*A*]9[*R*]shows[*A*]comparative success ratios across three traces in the presence of increasing number of publishers	context()	negated: False ,passive: False
0.449	[*A*]9[*R*]shows[*A*]comparative success ratios across five protocols	context()	negated: False ,passive: False
[LINE#238] 9 shows that CafRep has on average 10-15% higher success ratio than RR [38] and EBR [26] and more than two times higher success ratios than for SnF [37] and Prophet [23] across all traces.
0.967	[*A*]CafRep[*R*]has[*A*]on average 10-15% higher success ratio than RR [38] and EBR [26] and more than two times higher success ratios than for SnF [37] and Prophet	context()	negated: False ,passive: False
[LINE#239] This is due to the combined CafRep utility, its ego network utilities in particular, that manage to predict resource availability in different regions of the network with good accuracy.
0.628	[*A*]its ego network utilities in particular[*R*]manage to predict[*A*]resource availability[*A*]in different regions of the network with good accuracy	context(its ego network utilities in particular manage)	negated: False ,passive: False
0.730	[*A*]its ego network utilities in particular[*R*]manage[*A*]to predict resource availability in different regions of the network with good accuracy	context()	negated: False ,passive: False
0.461	[*A*]This[*R*]is[*A*]due to the combined CafRep utility, its ego network utilities in particular	context()	negated: False ,passive: True
[LINE#240] Contrary to this, RR [38] is concerned with global congestion measures do not sufficiently account for varying regional behaviours and have negative impact on the success ratio when regional congestions arise.
0.732	[*A*]regional congestions[*R*]arise	context()	negated: False ,passive: False
0.869	[*A*]RR[*R*]is[*A*]concerned with global congestion measures	context()	negated: False ,passive: True
[LINE#241+242]  More specifically, RR [38] reacts to detected packet loss in a uniform way so that nodes that are congesting still receive packets(even though fewer copies) that they may drop and available nodes do not receive sufficient number of packets.
0.266	[*A*]they[*R*]may drop	context(nodes that are congesting receive)	negated: False ,passive: False
0.944	[*A*]RR [ 38 ] reacts[*R*]to detected[*A*]packet loss	context()	negated: False ,passive: False
0.618	[*A*]nodes[*R*]are congesting	context(nodes that are congesting receive)	negated: False ,passive: False
0.929	[*A*]nodes that are congesting[*R*]receive[*A*]packets[*A*]still	context()	negated: False ,passive: False
0.903	[*A*]available nodes[*R*]do not receive[*A*]sufficient number of packets	context()	negated: True ,passive: False
0.934	[*A*]RR [ 38 ] reacts[*R*]detected[*A*]packet loss in a uniform way	context()	negated: False ,passive: False
[LINE#243] This overutilisation and underutilisation of resources increases the delays and results in lower success ratios for RR [38].
0.925	[*A*]underutilisation of resources[*R*]increases[*A*]results in lower success ratios for RR [ 38	context()	negated: False ,passive: False
0.952	[*A*]underutilisation of resources[*R*]increases[*A*]the delays in lower success ratios for RR [ 38	context()	negated: False ,passive: False
0.918	[*A*]This overutilisation[*R*]increases[*A*]results in lower success ratios for RR [ 38	context()	negated: False ,passive: False
0.947	[*A*]This overutilisation[*R*]increases[*A*]the delays in lower success ratios for RR [ 38	context()	negated: False ,passive: False
[LINE#244] 9 shows success ratios ranging from 77% to 60% for Infocom2006, from 67% to 50% for Sassy, and from 46% to 39% for SFCab.
0.918	[*A*]success ratios[*R*]ranging[*A*]from 77 %[*A*]to 60 % for Infocom2006	context()	negated: False ,passive: True
[LINE#245] In EBR [26], the respective rates of encounter between two nodes determine the appropriate fraction of message replicas the nodes should exchange.
0.965	[*A*]the respective rates of encounter between two nodes[*R*]determine[*A*]the appropriate fraction of message[*A*]In EBR [26	context()	negated: False ,passive: False
[LINE#246] Because EBR [26] relies only on the prediction of the future rate of encounters for each node to decide on the probability of successful message delivery, EBR [26] does not detect congestion and results in highly central nodes congesting at even faster rate which causes increased delays (Fig. 10) and lower success ratios (Fig. 9).
0.897	[*A*]even faster rate[*R*]causes[*A*]lower success ratios	context()	negated: False ,passive: False
0.897	[*A*]even faster rate[*R*]causes[*A*]increased delays	context()	negated: False ,passive: False
0.751	[*A*]highly central nodes[*R*]congesting	context()	negated: False ,passive: False
0.922	[*A*]EBR [ 26[*R*]does not detect[*A*]results in highly central nodes	context()	negated: True ,passive: False
0.950	[*A*]EBR [ 26[*R*]relies only[*A*]on the prediction of the future rate of encounters[*A*]for each node to decide on the probability of successful message delivery	context()	negated: False ,passive: False
0.922	[*A*]EBR [ 26[*R*]does not detect[*A*]congestion	context()	negated: True ,passive: False
0.903	[*A*]each node[*R*]to decide[*A*]on the probability of successful message delivery	context()	negated: False ,passive: False
0.950	[*A*]EBR [ 26[*R*]relies only[*A*]on the prediction of the future rate of encounters for each node to decide on the probability of successful message delivery	context()	negated: False ,passive: False
[LINE#247] 9 shows success ratios ranging from 72% to 58% for Infocom2006, from 63.6% to 50% for Sassy, and from 44% to 37% for SFCab.
0.918	[*A*]success ratios[*R*]ranging[*A*]from 72 %[*A*]to 58 % for Infocom2006	context()	negated: False ,passive: True
[LINE#248] Non-adaptive protocols do not check for resource constrains but aggressively keep the most direct routes to the destination that leads to the nodes quickly getting congested, increasing delays and having low success ratios (Figs. 9 and 10).
0.887	[*A*]the destination[*R*]leads[*A*]to having low success ratios	context()	negated: False ,passive: False
0.887	[*A*]the destination[*R*]leads[*A*]to increasing delays	context()	negated: False ,passive: False
0.767	[*A*]the nodes[*R*]quickly getting[*A*]congested	context()	negated: False ,passive: True
0.887	[*A*]the destination[*R*]leads[*A*]to the nodes quickly getting congested	context()	negated: False ,passive: False
0.903	[*A*]Non-adaptive protocols[*R*]do not check[*A*]for resource constrains	context()	negated: True ,passive: False
[LINE#249] 9 shows that Prophet's success ratios ranges from 36% to 24% for Infocom2006, from 29% to 19% for Sassy, and from 33% to 13% for SFCab.
0.939	[*A*]Prophet 's success ratios[*R*]ranges[*A*]from 36 %[*A*]to 24 %	context()	negated: False ,passive: True
[LINE#250] Similarly, SnF ranges from 55% to 26% for Infocom2006, from 44% to 20% for Sassy, and from 38% to 21% for SFCab.
0.999	[*A*]SnF[*R*]ranges[*A*]21 %	context()	negated: False ,passive: False
0.877	[*A*]SnF[*R*]ranges[*A*]from 55 %[*A*]to 26 % for Infocom2006	context()	negated: False ,passive: True
[LINE#251] SnF [37] has higher success ratios than Prophet [23] because it is a replication based protocol.
0.177	[*A*]SnF[*R*]has higher success ratios of[*A*]23 ]	context()	negated: False ,passive: False
0.522	[*A*]it[*R*]is[*A*]a replication based protocol	context()	negated: False ,passive: True
0.812	[*A*]SnF[*R*]has[*A*]higher success ratios than Prophet[*A*]because it is a replication based protocol	context()	negated: False ,passive: False
[LINE#252] It is interesting to see that Caf has higher success ratios than SnF and Prophet - more that 50% higher that SnF and more than 200% higher than Prophet across all data traces.
[LINE#253] The only exception to this is at times of low levels of congestion in SF Cab Trace where the differences are down to 25%.Between the three connectivity data traces, CafRep achieves lowest success ratio in the SF Cab traces [45] (48-44%) due to three reasons: first due to the SF Cab [45] topology described in Section 5.1, the social utility in CafRep cannot identify nodes that are significantly more central; second as the isolation periods are very high, the nodes cannot offload their content for a very long time; and third as the connectivity periods are very short, the publishing nodes that generate data at a constant rate cause increased dropped packets.
0.769	[*A*]a constant rate cause[*R*]increased	context()	negated: False ,passive: False
0.783	[*A*]the connectivity periods[*R*]are[*A*]very short	context()	negated: False ,passive: True
0.894	[*A*]topology[*R*]described[*A*]in Section 5.1	context()	negated: False ,passive: True
0.975	[*A*]CafRep[*R*]achieves[*A*]lowest success ratio in the SF Cab traces [ 45 ] ( 48-44 % ) due to three reasons : first due to the SF Cab [ 45 ] topology[*A*]Between the three connectivity data traces	context()	negated: False ,passive: False
0.952	[*A*]the differences[*R*]are[*A*]down to 25 %[*A*]SF Cab Trace	context()	negated: False ,passive: True
0.716	[*A*]nodes[*R*]are[*A*]significantly more central	context()	negated: False ,passive: True
[LINE#254] It is interesting to see that CafRep achieves around 20% lower success ratio over SF Cab trace [45] than over the DieselNet [3] vehicular trace (that we used in our earlier work [48] and showed 70-65% success ratio).
0.309	[*A*]we[*R*]used[*A*]in our earlier work	context()	negated: False ,passive: False
[LINE#255+256]  This is due to DieselNet trace [3]having a few access points that take part in the forwarding of packets and also having significantly lower isolation periods than SF Cab trace [45] and longer connectivity durations.
0.905	[*A*]a few access points[*R*]having[*A*]significantly lower isolation periods than longer connectivity durations	context()	negated: False ,passive: False
0.455	[*A*]3[*R*]having[*A*]a few access points also having significantly lower isolation periods than longer connectivity durations	context()	negated: False ,passive: False
0.949	[*A*]a few access points[*R*]having[*A*]significantly lower isolation periods than SF Cab trace [ 45	context()	negated: False ,passive: False
0.501	[*A*]3[*R*]having[*A*]a few access points also having significantly lower isolation periods than SF Cab trace [ 45 ]	context()	negated: False ,passive: False
0.905	[*A*]a few access points[*R*]take[*A*]part[*A*]in the forwarding of packets	context()	negated: False ,passive: False
0.233	[*A*]3[*R*]having[*A*]a few access points that take part in the forwarding of packets	context()	negated: False ,passive: False
0.495	[*A*]This[*R*]is[*A*]due to DieselNet trace [ 3	context()	negated: False ,passive: True
[LINE#257]  SF Cab trace [45] that was generated for the purpose of tracking cabs in the SF Bay Area and has much sparser topology that covers a significantly wider area (400 and 1600 square miles) without using any access points (APs) or road-side units.
0.897	[*A*]much sparser topology[*R*]covers[*A*]a significantly wider area	context()	negated: False ,passive: True
0.930	[*A*]SF Cab trace [45[*R*]has[*A*]much sparser topology that covers a significantly wider area (400 and 1600 square miles) without using any access points (APs) or road-side units	context()	negated: False ,passive: False
0.965	[*A*]SF Cab trace [45[*R*]was generated[*A*]for the purpose of tracking cabs in the SF Bay Area	context()	negated: False ,passive: True
[LINE#258] We believe that is important that even with such challenging and sparse trace, CafRep manages to outperform other protocols.
0.898	[*A*]CafRep[*R*]manages to outperform[*A*]other protocols	context(We believe that is CafRep manages)	negated: False ,passive: False
0.309	[*A*]We[*R*]believe[*A*]that is important that even with sparse trace , CafRep manages to outperform other protocols	context()	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]manages to outperform[*A*]other protocols	context(We believe that is CafRep manages)	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]manages[*A*]to outperform other protocols	context(We believe that is)	negated: False ,passive: False
0.054	[*A*]that[*R*]is[*A*]important	context(We believe)	negated: False ,passive: True
0.309	[*A*]We[*R*]believe[*A*]that is important that even with such challenging , CafRep manages to outperform other protocols	context()	negated: False ,passive: False
[LINE#259] CafRep achieves higher success ratio over Sassy [44] data trace then with SF Cab trace [45] but much lower than when compared with Infocom data trace.
0.932	[*A*]CafRep[*R*]achieves[*A*]higher success ratio over Sassy	context()	negated: False ,passive: False
[LINE#260+261]  Sassy [44] trace is more challenging than Infocom 2006 because it does not include any infrastructure-like nodes (such as semi-static and static nodes such as those deployed during Infocom2006 [33])that participate in forwarding, has significantly shorter connectivity durations and sparser network.
0.949	[*A*]any infrastructure-like nodes ( such as static nodes such as those[*R*]participate[*A*]in forwarding	context()	negated: False ,passive: False
0.367	[*A*]it[*R*]does not include[*A*]any infrastructure-like nodes ( such as static nodes such as those deployed during Infocom2006 [ 33 ] ) that participate in forwarding	context()	negated: True ,passive: True
0.895	[*A*]Sassy [ 44 ] trace[*R*]is[*A*]more challenging than Infocom 2006[*A*]because it does not include any infrastructure-like nodes ( such as static nodes such as those	context()	negated: False ,passive: True
0.949	[*A*]any infrastructure-like nodes ( such as semi-static nodes such as those[*R*]participate[*A*]in forwarding	context()	negated: False ,passive: False
0.269	[*A*]those[*R*]deployed[*A*]during Infocom2006 [ 33	context()	negated: False ,passive: True
0.367	[*A*]it[*R*]does not include[*A*]any infrastructure-like nodes ( such as semi-static nodes such as those deployed during Infocom2006 [ 33 ] ) that participate in forwarding	context()	negated: True ,passive: True
0.895	[*A*]Sassy [ 44 ] trace[*R*]is[*A*]more challenging than Infocom 2006[*A*]because it does not include any infrastructure-like nodes ( such as semi-static nodes such as those	context()	negated: False ,passive: True
[LINE#262+263]  Because Sassy trace [44] does not contain nodes that are significantly better connected and has much less repetitive pattern than Infocom 2006 (where the participants used the lift or often came to the registration desk where the semi-static and static nodes were deployed)(as part fo CafRep) could not be as helpful as with this trace as with Infocom 2006 trace in identifying the most direct routes to destinations.
0.903	[*A*]the participants[*R*]used[*A*]the lift	context()	negated: False ,passive: False
0.965	[*A*]Sassy trace[*R*]has[*A*]much less repetitive pattern than Infocom 2006 (where the participants used the lift or often came to the registration desk where the semi-static and static nodes were deployed)(as part fo CafRep) could not be as helpful as with this trace as with Infocom 2006 trace in identifying the most direct routes to destinations	context()	negated: False ,passive: False
0.949	[*A*]the semi-static and static nodes[*R*]were deployed[*A*]the registration desk	context()	negated: False ,passive: True
0.716	[*A*]nodes[*R*]are[*A*]significantly better connected	context()	negated: False ,passive: True
0.934	[*A*]the participants[*R*]came[*A*]to the registration desk[*A*]often	context()	negated: False ,passive: True
0.796	[*A*]Sassy trace[*R*]does not contain[*A*]nodes that are significantly better connected	context()	negated: True ,passive: False
[LINE#264] However, Sassy is significantly more connected than SF Cab trace [45] and thus has much higher success ratios.
0.928	[*A*]Sassy[*R*]has[*A*]much higher success ratios	context()	negated: False ,passive: False
0.740	[*A*]Sassy[*R*]significantly more connected	context()	negated: False ,passive: False
0.948	[*A*]Sassy[*R*]is[*A*]significantly more connected than SF Cab trace [ 45	context()	negated: False ,passive: True
[LINE#265] Across all the three connectivity traces, CafRep manages to keep lower delays compared to the other protocols due to the following two reasons.
0.934	[*A*]CafRep[*R*]manages to keep[*A*]lower delays[*A*]compared to the other protocols due to the following two reasons	context(CafRep manages)	negated: False ,passive: False
0.962	[*A*]CafRep[*R*]manages[*A*]to keep lower delays compared to the other protocols due to the following two reasons[*A*]Across all the three connectivity traces	context()	negated: False ,passive: False
0.937	[*A*]lower delays[*R*]compared[*A*]to the other protocols due to the following two reasons	context()	negated: False ,passive: True
[LINE#266] First, CafRep is able to predict regional in-network delays with good accuracy because of checking for the in-network delays of both the nodes and their ego networks.
0.959	[*A*]CafRep[*R*]is[*A*]able to predict regional in-network delays with good accuracy[*A*]because of checking for the in-network delays of their ego networks[*A*]First	context()	negated: False ,passive: True
0.906	[*A*]CafRep[*R*]to predict[*A*]regional in-network delays with good accuracy	context()	negated: False ,passive: False
0.978	[*A*]CafRep[*R*]is[*A*]able to predict regional in-network delays with good accuracy[*A*]because of checking for the in-network delays of both the nodes[*A*]First	context()	negated: False ,passive: True
[LINE#267+268]  In this way CafRep is able to more quickly identify (potentially)longer but less congested paths with lower delays than the other protocols.
0.928	[*A*]CafRep[*R*]to more quickly identify[*A*]potentially ) less congested paths with lower delays than the other protocols	context()	negated: False ,passive: False
0.961	[*A*]CafRep[*R*]is[*A*]able to more quickly identify ( potentially ) less congested paths with lower delays than the other protocols	context()	negated: False ,passive: True
0.928	[*A*]CafRep[*R*]to more quickly identify[*A*]potentially ) longer congested paths with lower delays than the other protocols	context()	negated: False ,passive: False
0.961	[*A*]CafRep[*R*]is[*A*]able to more quickly identify ( potentially ) longer congested paths with lower delays than the other protocols	context()	negated: False ,passive: True
[LINE#269] Neither RR [38] nor EBR [26] are able to efficiently discover longer routes with smaller queue sizes but instead only decrease their replication rate and remain in the congested regions for longer periods of times.
0.829	[*A*]Neither RR [38] nor EBR[*R*]decrease[*A*]their replication rate	context()	negated: False ,passive: False
0.899	[*A*]Neither RR [38] nor EBR[*R*]to efficiently discover[*A*]longer routes with smaller queue sizes	context()	negated: False ,passive: False
0.935	[*A*]Neither RR [38] nor EBR[*R*]are[*A*]able to efficiently discover longer routes with smaller queue sizes	context()	negated: False ,passive: True
[LINE#270] 10 shows delays for RR ranging from 100 to 220s, 70-120min and 45-75h for CafRep across Infocom, Sassy [44] and SF Cab traces [45] respectively.
0.855	[*A*]RR[*R*]ranging[*A*]from 100[*A*]to 220 s	context()	negated: False ,passive: True
0.656	[*A*]10[*R*]shows[*A*]delays for RR	context()	negated: False ,passive: False
[LINE#271] For the majority of time this is about two times as high delay as for CafRep across the three traces.
0.612	[*A*]this[*R*]is[*A*]about two times as high delay as for CafRep across the three traces	context()	negated: False ,passive: True
[LINE#272] Non-adaptive protocols (Prophet [23] and SnF [37]) have aggressive forwarding strategy that quickly leads into congesting the en-route nodes that increase delays.
0.913	[*A*]the en - route nodes[*R*]increase[*A*]delays	context()	negated: False ,passive: False
0.897	[*A*]aggressive forwarding strategy[*R*]quickly leads[*A*]into congesting the en - route nodes	context()	negated: False ,passive: False
0.822	[*A*]Non-adaptive protocols[*R*]have[*A*]aggressive forwarding strategy that quickly leads into congesting the en - route nodes	context()	negated: False ,passive: False
[LINE#273] 10 shows delays for SnF and Prohpet ranging from 180 to 320s, 80-160min and 60-100h for the three traces respectively.
0.920	[*A*]Prohpet[*R*]ranging[*A*]from 180[*A*]to 320 s	context()	negated: False ,passive: True
0.656	[*A*]10[*R*]shows[*A*]delays for Prohpet	context()	negated: False ,passive: False
0.583	[*A*]10[*R*]shows respectively[*A*]delays for SnF	context()	negated: False ,passive: False
[LINE#274] This is between 1.5 and 4 times higher than the delays for CafRep.
0.495	[*A*]This[*R*]is[*A*]4 times higher than the delays for CafRep	context()	negated: False ,passive: True
0.495	[*A*]This[*R*]is[*A*]between 1.5 higher than the delays for CafRep	context()	negated: False ,passive: True
[LINE#275] Second, using Social utility as part of the CafRep utility, CafRep ensures best prediction of the most direct route to the destination especially for Sassy and Infocom 2006 traces.
0.957	[*A*]CafRep[*R*]ensures[*A*]best prediction of the most direct route to the destination especially for Infocom 2006 traces	context()	negated: False ,passive: False
0.957	[*A*]CafRep[*R*]ensures[*A*]best prediction of the most direct route to the destination especially for Sassy traces	context()	negated: False ,passive: False
[LINE#276] Neither of the RR [38], EBR [26], Prophet [23] and SnF [38] use social metrics and resource metrics together and are thus not able to adjust to the dynamics in both of these dimensions.
0.381	[*A*]EBR [ 26 ][*R*][is][*A*]Prophet	context()	negated: False ,passive: False
0.940	[*A*]Neither of the RR [ 38[*R*]to adjust[*A*]to the dynamics in both of these dimensions	context()	negated: False ,passive: True
0.939	[*A*]Neither of the RR [ 38[*R*]use together[*A*]social resource	context()	negated: False ,passive: False
0.962	[*A*]Neither of the RR [ 38[*R*]are[*A*]thus not able to adjust to the dynamics in both of these dimensions	context()	negated: False ,passive: True
0.939	[*A*]Neither of the RR [ 38[*R*]use together[*A*]social metrics	context()	negated: False ,passive: False
[LINE#277] Infocom 2006 delays are significantly lower than for the other two datasets across all protocols (seconds versus minutes and hours).
0.957	[*A*]Infocom 2006 delays[*R*]are[*A*]significantly lower than for the other two datasets across all protocols	context()	negated: False ,passive: True
[LINE#278+279]  This is due to topology characteristics such as short disconnection times, long connection times in Infocom 2006 [33], moderate connectivity sets and few infrastructure-like nodes that allow for more efficient data dissemination.
0.897	[*A*]few infrastructure-like nodes[*R*]allow[*A*]for more efficient data dissemination	context()	negated: False ,passive: False
0.449	[*A*]This[*R*]is[*A*]due to topology characteristics such as short disconnection times	context()	negated: False ,passive: True
0.567	[*A*]This[*R*]is[*A*]due to topology characteristics such as short disconnection times , , moderate connectivity sets	context()	negated: False ,passive: True
0.612	[*A*]This[*R*]is[*A*]due to topology characteristics such as short disconnection times , long connection times in Infocom 2006	context()	negated: False ,passive: True
[LINE#280] For similar reasons, delays across all protocols are significantly higher for SF Cab Traces [45] than for delays for Sassy [44] and Infocom 2006 traces.
[LINE#281] Still, because CafRep considers the relative in-network delays, it is able to maintain lower delays than the rest of the protocols.
0.411	[*A*]it[*R*]to maintain[*A*]lower delays than the rest of the protocols	context()	negated: False ,passive: False
0.637	[*A*]it[*R*]is[*A*]able to maintain lower delays than the rest of the protocols	context()	negated: False ,passive: True
0.920	[*A*]CafRep[*R*]considers[*A*]the relative in-network delays	context()	negated: False ,passive: False
[LINE#282+283]  Availability and packet lossAcross all three traces, CafRep sustains higher availability than other protocols.
0.920	[*A*]CafRep[*R*]sustains[*A*]higher availability than other protocols	context()	negated: False ,passive: False
0.953	[*A*]CafRep[*R*]sustains[*A*]higher availability than other protocols[*A*]packet	context()	negated: False ,passive: False
0.953	[*A*]CafRep[*R*]sustains[*A*]higher availability than other protocols[*A*]Availability	context()	negated: False ,passive: False
[LINE#284] This is because CafRep is able to make good predictions of node and ego network availability which avoid depleting the storage resources of frequently used nodes and regions in the network that drop packets.
0.899	[*A*]good predictions of ego network availability[*R*]avoid depleting[*A*]the storage resources of regions	context(good predictions of ego network availability avoid)	negated: False ,passive: False
0.899	[*A*]good predictions of ego network availability[*R*]avoid[*A*]depleting the storage resources of regions in the network	context()	negated: False ,passive: False
0.940	[*A*]CafRep[*R*]to make[*A*]good predictions of ego network availability which avoid depleting the storage resources of regions in the network	context()	negated: False ,passive: False
0.935	[*A*]good predictions of ego network availability[*R*]avoid depleting[*A*]the storage resources of frequently used nodes in the network	context(good predictions of ego network availability avoid)	negated: False ,passive: False
0.935	[*A*]good predictions of ego network availability[*R*]avoid[*A*]depleting the storage resources of frequently used nodes in the network	context()	negated: False ,passive: False
0.940	[*A*]CafRep[*R*]to make[*A*]good predictions of ego network availability which avoid depleting the storage resources of frequently used nodes in the network	context()	negated: False ,passive: False
0.938	[*A*]CafRep[*R*]is[*A*]able to make good predictions of ego network availability	context()	negated: False ,passive: True
0.612	[*A*]This[*R*]is[*A*]because CafRep is able to make good predictions of ego network availability	context()	negated: False ,passive: True
0.880	[*A*]good predictions of node[*R*]avoid depleting[*A*]the storage resources of regions	context(good predictions of node avoid)	negated: False ,passive: False
0.880	[*A*]good predictions of node[*R*]avoid[*A*]depleting the storage resources of regions in the network	context()	negated: False ,passive: False
0.940	[*A*]CafRep[*R*]to make[*A*]good predictions of node which avoid depleting the storage resources of regions in the network	context()	negated: False ,passive: False
0.922	[*A*]good predictions of node[*R*]avoid depleting[*A*]the storage resources of frequently used nodes in the network	context(good predictions of node avoid)	negated: False ,passive: False
0.922	[*A*]good predictions of node[*R*]avoid[*A*]depleting the storage resources of frequently used nodes in the network	context()	negated: False ,passive: False
0.940	[*A*]CafRep[*R*]to make[*A*]good predictions of node which avoid depleting the storage resources of frequently used nodes in the network	context()	negated: False ,passive: False
0.938	[*A*]CafRep[*R*]is[*A*]able to make good predictions of node	context()	negated: False ,passive: True
0.612	[*A*]This[*R*]is[*A*]because CafRep is able to make good predictions of node	context()	negated: False ,passive: True
[LINE#285]  11 shows CafRep availability ranging from 88% to 70% for Infocom 2006, 70-60% for Sassy [44] and 60-35% for Sf Cabs.
0.947	[*A*]11 shows[*R*]CafRep[*A*]availability ranging from 88 % to 70 % for Infocom 2006 , 60-35 % for Sf Cabs	context()	negated: False ,passive: False
0.894	[*A*]availability[*R*]ranging[*A*]from 88 %[*A*]to 70 %	context()	negated: False ,passive: True
0.947	[*A*]11 shows[*R*]CafRep[*A*]availability ranging from 88 % to 70 % for Infocom 2006 , 70-60 % for Sassy [ 44 ]	context()	negated: False ,passive: False
[LINE#286] EBR [26] results in lower availability as it congests the regions that are highly central and where the nodes cannot offload the traffic faster than the traffic is generated (that is the example application scenario we are considering).
0.903	[*A*]the example application scenario[*R*]are considering[*A*]we	context()	negated: False ,passive: True
0.102	[*A*]that[*R*]is[*A*]the example application scenario we are considering	context()	negated: False ,passive: True
0.849	[*A*]EBR [ 26 ] results in lower availability[*R*]is generated	context()	negated: False ,passive: False
0.901	[*A*]the nodes[*R*]can not offload faster[*A*]the regions	context()	negated: True ,passive: False
0.569	[*A*]it[*R*]congests[*A*]the regions where the nodes can not offload the traffic faster than the traffic	context()	negated: False ,passive: False
0.735	[*A*]the regions[*R*]are[*A*]highly central	context()	negated: False ,passive: True
0.231	[*A*]it[*R*]congests[*A*]the regions that are highly central	context()	negated: False ,passive: False
[LINE#287] 11 shows that EBR [26] manages only 70-20% availability over Infocom [33] and Sassy [44] traces and 40-20% for SFCabs trace [45].
0.656	[*A*]11[*R*]shows[*A*]40-20 % for SFCabs trace	context()	negated: False ,passive: False
0.857	[*A*]EBR[*R*]manages[*A*]only 70-20 % availability over Infocom [ 33	context()	negated: False ,passive: False
[LINE#288+289]  It is interesting to see in Fig.that RR [38] has higher packet loss rates than CafRep despite RR [38] tracking and adapting to the global packet loss congestion signals.
[LINE#290] We believe that this is due to RR [38] not being fast enough to detect sudden opportunities of longer but more available paths as it awaits for the global signs of increased packet loss to act locally.
0.558	[*A*]this[*R*]is[*A*]due to RR [ 38 ] not being fast enough to detect sudden opportunities of more available paths	context(We believe)	negated: False ,passive: True
0.317	[*A*]We[*R*]believe[*A*]that this is due to RR [ 38 ] not being fast enough to detect sudden opportunities of more available paths	context()	negated: False ,passive: False
0.569	[*A*]it[*R*]awaits[*A*]for the global signs of increased packet loss to act locally	context()	negated: False ,passive: True
0.558	[*A*]this[*R*]is[*A*]due to RR [ 38 ] not being fast enough to detect sudden opportunities of longer available paths	context(We believe)	negated: False ,passive: True
0.317	[*A*]We[*R*]believe[*A*]that this is due to RR [ 38 ] not being fast enough to detect sudden opportunities of longer available paths	context()	negated: False ,passive: False
[LINE#291]  RR [38] manages to keep availability levels at 80-20% for Infocom 2006 [33] and.
0.919	[*A*]RR [38[*R*]manages to keep[*A*]availability levels[*A*]at 80-20% for Infocom 2006 [33	context(RR [ 38 manages)	negated: False ,passive: False
0.948	[*A*]RR [38[*R*]manages[*A*]to keep availability levels at 80-20% for Infocom 2006 [33	context()	negated: False ,passive: False
[LINE#292]  Sassy traces [44] and only 45-30% for SF Cabs.
0.164	[*A*]traces[*R*]have sass of[*A*]44 ]	context()	negated: False ,passive: False
[LINE#293]  RR [38] maintains packet loss rates 33-63%, 49-83% and 75-95% for Infocom 2006 [33], Sassy [44] and SF Cabs.
0.999	[*A*]RR[*R*]maintains[*A*]38 ] maintains packet loss rates 75 -95 %	context()	negated: False ,passive: False
0.833	[*A*]RR[*R*]maintains[*A*]packet loss rates	context()	negated: False ,passive: False
0.922	[*A*]RR [ 38[*R*]maintains[*A*]packet loss rates	context()	negated: False ,passive: False
0.922	[*A*]RR [ 38[*R*]maintains[*A*]packet loss rates[*A*]49-83 %	context()	negated: False ,passive: False
0.922	[*A*]RR [ 38[*R*]maintains[*A*]packet loss rates[*A*]33-63 %	context()	negated: False ,passive: False
[LINE#294] RR is more suitable for even traffic distribution and connectivity patterns, such as constant bit rate traffic with a random way point mobility model, as the nodes in such networks become congested at a uniform rate.
0.903	[*A*]RR[*R*]is[*A*]more suitable for connectivity patterns , such as constant bit rate traffic with a random way point mobility model , as the nodes in such networks become congested at a uniform rate	context()	negated: False ,passive: True
0.814	[*A*]the nodes in such networks[*R*]become[*A*]congested	context()	negated: False ,passive: True
0.903	[*A*]RR[*R*]is[*A*]more suitable for even traffic distribution with a random way point mobility model[*A*]as the nodes in such networks become congested at a uniform rate	context()	negated: False ,passive: True
[LINE#295] In heterogeneous DTNs that we consider, uniformity is not common, so it is more likely that traffic hot spots trigger messages to be dropped while other areas of the network remain highly available.
0.814	[*A*]other areas of the network[*R*]remain[*A*]highly available	context()	negated: False ,passive: True
0.713	[*A*]messages[*R*]to be dropped	context()	negated: False ,passive: False
0.948	[*A*]uniformity[*R*]is not[*A*]common[*A*]In heterogeneous DTNs	context()	negated: True ,passive: True
0.912	[*A*]heterogeneous DTNs[*R*]consider[*A*]we	context()	negated: False ,passive: True
[LINE#296] For such scenarios, when RR [38] uniformly reduces the number of replicas entering the network, it results in underutilisation of existing network resources and overutilisation of some network parts.
0.740	[*A*]it[*R*]results[*A*]in underutilisation of overutilisation of some network parts[*A*]when RR [ 38 ] uniformly reduces the number of replicas	context()	negated: False ,passive: True
0.740	[*A*]it[*R*]results[*A*]in underutilisation of existing network resources of some network parts[*A*]when RR [ 38 ] uniformly reduces the number of replicas	context()	negated: False ,passive: True
0.894	[*A*]replicas[*R*]entering[*A*]the network	context()	negated: False ,passive: False
0.833	[*A*]RR[*R*]reduces[*A*]the number of replicas	context()	negated: False ,passive: False
[LINE#297+298]  The low availability of CafRep over[45] comes primarily from the very long node isolation periods combined with intense traffic generation during short connectivity durations.
0.932	[*A*]the very long node isolation periods[*R*]combined[*A*]with intense traffic generation[*A*]during short connectivity durations	context()	negated: False ,passive: True
0.950	[*A*]The low availability of CafRep over[45[*R*]comes[*A*]primarily[*A*]from the very long node isolation periods	context()	negated: False ,passive: True
[LINE#299] This means that, despite discovering more paths than other protocols can discover, with the increase of publishing nodes (above 70% congestion rate where most nodes are publishing), publishing nodes are forced into decreased availability and dropping the packets that they cannot offload.
0.884	[*A*]the packets[*R*]can not offload[*A*]they	context()	negated: True ,passive: True
0.224	[*A*]This[*R*]means[*A*]that , despite discovering more paths than other protocols can discover , with the increase of publishing nodes	context()	negated: False ,passive: False
0.732	[*A*]most nodes[*R*]are publishing	context()	negated: False ,passive: False
0.224	[*A*]This[*R*]means[*A*]that , despite discovering more paths than other protocols can discover , with the increase of publishing nodes ( above 70 % congestion rate where most nodes are publishing ) , publishing nodes are forced into decreased availability	context()	negated: False ,passive: False
[LINE#300] With increased congestion levels (above 50% of publishing nodes), Fig. 11 shows that CafRep manages to keep two times higher availability than EBR [26], and above 50% higher than RR [38].
0.914	[*A*]CafRep[*R*]manages to keep[*A*]two times higher availability than EBR	context(Fig . 11 shows CafRep manages)	negated: False ,passive: False
0.945	[*A*]CafRep[*R*]manages[*A*]to keep two times higher availability than EBR [26], and above 50% higher than RR [38	context(Fig . 11 shows)	negated: False ,passive: False
0.909	[*A*]Fig. 11[*R*]shows[*A*]that CafRep manages to keep two times higher availability than EBR [26], and above 50% higher than RR [38	context()	negated: False ,passive: False
[LINE#301] It is interesting to see that the differences in availability between the three adaptive protocols are smallest for low congesting rates in Sassy [44] and Infocom 2006 data traces [33], but as the congestion levels increase, CafRep starts to dominate over RR and EBR starts to fall behind more dramatically.
0.467	[*A*]It[*R*]is[*A*]CafRep starts to dominate over EBR	context()	negated: False ,passive: True
0.921	[*A*]CafRep[*R*]to dominate[*A*]over EBR	context()	negated: False ,passive: False
0.948	[*A*]CafRep[*R*]starts[*A*]as the congestion levels increase	context(It is)	negated: False ,passive: True
0.467	[*A*]It[*R*]is[*A*]CafRep starts to dominate over RR	context()	negated: False ,passive: True
0.921	[*A*]CafRep[*R*]to dominate[*A*]over RR	context()	negated: False ,passive: False
0.751	[*A*]the congestion levels[*R*]increase	context()	negated: False ,passive: False
0.214	[*A*]It[*R*]starts	context()	negated: False ,passive: False
0.278	[*A*]It[*R*]is[*A*]starts to fall behind more dramatically	context()	negated: False ,passive: True
[LINE#302] For SF traces [45], CafRep is significantly better than RR [38] and EBR [26] across all congestion levels.
0.948	[*A*]CafRep[*R*]is[*A*]significantly better than EBR	context()	negated: False ,passive: True
0.948	[*A*]CafRep[*R*]is[*A*]significantly better than RR	context()	negated: False ,passive: True
[LINE#303] This is because EBR [26] and RR [38] are slower to utilise already very infrequent opportunities to divert the traffic along diverse paths.
0.889	[*A*]RR[*R*]to utilise[*A*]already[*A*]very infrequent opportunities to divert the traffic along diverse paths	context()	negated: False ,passive: False
0.833	[*A*]RR[*R*]are[*A*]slower to utilise already very infrequent opportunities	context()	negated: False ,passive: True
0.612	[*A*]This[*R*]is[*A*]because RR [ 38 ] are slower to utilise already very infrequent opportunities	context()	negated: False ,passive: True
0.950	[*A*]EBR [ 26[*R*]to utilise[*A*]already[*A*]very infrequent opportunities to divert the traffic along diverse paths	context()	negated: False ,passive: False
0.922	[*A*]EBR [ 26[*R*]are[*A*]slower to utilise already very infrequent opportunities	context()	negated: False ,passive: True
0.612	[*A*]This[*R*]is[*A*]because EBR [ 26 ] are slower to utilise already very infrequent opportunities	context()	negated: False ,passive: True
[LINE#304+305]  All protocols manage highest availability over the Infocom 2006 trace [33] because this trace is highly social (allows repeating patterns of connectivity)that allows for accurate social/connectivity predictions that CafRep, EBR [26], RR [38] and SnF [37] use.
0.868	[*A*]All protocols[*R*]manage[*A*]highest availability over the Infocom 2006 trace[*A*]because this trace is highly social ( allows repeating patterns of connectivity ) that allows for accurate social / connectivity predictions that SnF [ 37 ] use	context()	negated: False ,passive: False
0.868	[*A*]All protocols[*R*]manage[*A*]highest availability over the Infocom 2006 trace[*A*]because this trace is highly social ( allows repeating patterns of connectivity ) that allows for accurate social / connectivity predictions that RR [ 38 ] [ 37 ] use	context()	negated: False ,passive: False
0.868	[*A*]All protocols[*R*]manage[*A*]highest availability over the Infocom 2006 trace[*A*]because this trace is highly social ( allows repeating patterns of connectivity ) that allows for accurate social / connectivity predictions that EBR [ 26 ] [ 37 ] use	context()	negated: False ,passive: False
0.908	[*A*]this trace[*R*]is[*A*]highly social ( allows repeating patterns of connectivity	context()	negated: False ,passive: True
0.868	[*A*]All protocols[*R*]manage[*A*]highest availability over the Infocom 2006 trace[*A*]because this trace is highly social ( allows repeating patterns of connectivity ) that allows for accurate social / connectivity predictions that CafRep [ 37 ] use	context()	negated: False ,passive: False
[LINE#306] In addition to this, this trace deploys infrastructure-like nodes that facilitate interaction among nodes, has longer contact times, shorter smaller isolation periods and bigger connectivity islands.
0.913	[*A*]this trace[*R*]has[*A*]longer contact times	context()	negated: False ,passive: False
0.887	[*A*]infrastructure-like nodes[*R*]facilitate[*A*]interaction among nodes	context()	negated: False ,passive: False
0.773	[*A*]this trace[*R*]deploys[*A*]infrastructure-like nodes that facilitate interaction among nodes	context()	negated: False ,passive: False
[LINE#307] Availability for both non-adaptive protocols, Prophet and SnF, is low across all the three traces and it ranges from 0.6 to 0.13, 0.6-0.14 and 0.3-0.1 across Infocom 2006, Sassy and SF Cab traces respectively.
0.498	[*A*]it[*R*]ranges[*A*]from 0.6 to 0.13 , 0.3-0.1 across Infocom 2006	context()	negated: False ,passive: True
0.614	[*A*]it[*R*]ranges[*A*]from 0.6 to 0.13 , 0.3-0.1 across Infocom 2006 , Sassy traces respectively	context()	negated: False ,passive: True
0.498	[*A*]it[*R*]ranges[*A*]from 0.6 to 0.13 , 0.6-0.14 across Infocom 2006	context()	negated: False ,passive: True
0.614	[*A*]it[*R*]ranges[*A*]from 0.6 to 0.13 , 0.6-0.14 across Infocom 2006 , Sassy traces respectively	context()	negated: False ,passive: True
0.933	[*A*]Availability for both non-adaptive protocols[*R*]is[*A*]low across all the three traces	context()	negated: False ,passive: True
[LINE#308] With the constant bit rate data transmission of the publishing nodes, these two protocols quickly saturate the en-route nodes that increase packet drop rates ranging from 0.59% to 98%. 0.71-96% and 0.62-95% across Infocom 2006, Sassy and SF Cabs trace respectively.
0.991	[*A*]two protocols[*R*]saturate[*A*]the en route nodes that increase packet drop rates ranging from 0.59 % to 98 %	context()	negated: False ,passive: False
0.911	[*A*]packet drop rates[*R*]ranging[*A*]from 0.59 %[*A*]to 98 %	context()	negated: False ,passive: True
0.944	[*A*]the en - route nodes[*R*]increase[*A*]packet drop rates ranging from 0.59 % to 98 %	context()	negated: False ,passive: False
0.857	[*A*]these two protocols[*R*]quickly saturate[*A*]the en - route nodes that increase packet drop rates	context()	negated: False ,passive: False
[LINE#309] Cafe, even though being a single packet protocol, maintains significantly better availability: up to twice the availability of and around three times lower packet loss rates than non-adaptive protocols.
0.864	[*A*]Cafe[*R*]even maintains[*A*]significantly better availability	context()	negated: False ,passive: False
0.906	[*A*]Cafe[*R*]being[*A*]a single packet protocol	context()	negated: False ,passive: True
[LINE#310] This is due to Cafe's adaptive forwarding that predicts identifies highly congesting nodes and regions, and avoids them. .
0.909	[*A*]Cafe 's adaptive forwarding[*R*]predicts[*A*]identifies highly congesting regions	context()	negated: False ,passive: False
0.909	[*A*]Cafe 's adaptive forwarding[*R*]predicts[*A*]identifies highly congesting nodes	context()	negated: False ,passive: False
0.495	[*A*]This[*R*]is[*A*]due to Cafe 's adaptive forwarding	context()	negated: False ,passive: True
[LINE#311] Performance costs: forwarded, replicated packets and delivery costWe assess performance costs in terms of total average number of delivered, forwarded and replicated packets.
0.698	[*A*]Performance costs[*R*]forwarded	context()	negated: False ,passive: False
[LINE#312] that even though CafRep may longer paths but less congested paths, it does not generate significantly more forwarded packets compared to the two adaptive replication protocols RR [38] and EBR [26].
[LINE#313] For example, we observe similar average numbers of forwarded packets for CafRep, EBR [26] and RR [38] across Infocom 2006 [33] and Sassy [44] but higher for CafRep over SF Cabs [45].
0.614	[*A*]we[*R*]observe[*A*]similar average numbers of forwarded packets for CafRep, EBR [26] and RR[*A*]across Infocom 2006	context()	negated: False ,passive: False
[LINE#314] This is due to the following two reasons.
0.449	[*A*]This[*R*]is[*A*]due to the following two reasons	context()	negated: False ,passive: True
[LINE#315] First, even though CafRep uses greater diversity of available paths, its Social Util allows it to keep as direct route to the destination as possible over the social traces.
0.388	[*A*]it[*R*]to keep[*A*]as direct route to the destination as possible	context(its Social Util allows)	negated: False ,passive: False
0.759	[*A*]its Social Util[*R*]allows[*A*]it to keep as direct route to the destination as possible over the social traces[*A*]First	context()	negated: False ,passive: False
[LINE#316] EBR and RR do not exploit more complex connectivity relationships and may thus result in long paths especially in the presence of increasing congestion.
0.861	[*A*]RR[*R*]may result[*A*]in long paths especially in the presence of increasing congestion	context()	negated: False ,passive: True
0.861	[*A*]EBR[*R*]may result[*A*]in long paths especially in the presence of increasing congestion	context()	negated: False ,passive: True
0.855	[*A*]RR[*R*]do not exploit[*A*]more complex connectivity relationships	context()	negated: True ,passive: False
0.855	[*A*]EBR[*R*]do not exploit[*A*]more complex connectivity relationships	context()	negated: True ,passive: False
[LINE#317] Since SF Can Trace is not a social trace and CafRep benefits less from the sophisticated contact relationship analysis, it results in marginally higher number of forwarded packets.
0.944	[*A*]SF Can Trace[*R*]is not[*A*]CafRep benefits less from the sophisticated contact relationship analysis	context()	negated: True ,passive: True
0.452	[*A*]it[*R*]results[*A*]in marginally higher number of forwarded packets	context()	negated: False ,passive: True
0.933	[*A*]SF Can Trace[*R*]is not[*A*]a social trace	context()	negated: True ,passive: True
[LINE#318] Second, even though EBR, RR and CafRep forward similar rates of packets, EBR and RR drop more packets as the forwarding is not appropriately distributed to match the non-uniform varying resources in the network.
0.732	[*A*]the forwarding[*R*]is not appropriately distributed	context()	negated: True ,passive: False
[LINE#319] The number of forwarded packets for Caf [15] and Prophet [23] is smaller than for the other protocols as they do not use replication.
0.894	[*A*]Prophet [ 23[*R*]is[*A*]smaller than for the other protocols[*A*]as they do not use replication	context()	negated: False ,passive: True
0.616	[*A*]they[*R*]do not use[*A*]replication	context()	negated: True ,passive: False
0.926	[*A*]The number of forwarded packets for Caf[*R*]is[*A*]smaller than for the other protocols[*A*]as they do not use replication	context()	negated: False ,passive: True
[LINE#320] As expected, SnF [37] forwards on average highest number of packets as it is non-adaptive replication-based protocol.
0.278	[*A*]it[*R*]is[*A*]non-adaptive	context()	negated: False ,passive: True
[LINE#321]  More interestingly, CafRep and RR replicate similar number of packets across Sassy trace [44] while CafRep replicates 15-30% more than RR [38] and EBR [26] for SF Cab trace [45].
0.919	[*A*]RR[*R*]replicate[*A*]similar number of packets across Sassy trace[*A*]while CafRep replicates 15-30 % more than RR EBR [ 26 ] for SF Cab trace	context()	negated: False ,passive: False
0.919	[*A*]RR[*R*]replicate[*A*]similar number of packets across Sassy trace[*A*]while CafRep replicates 15-30 % more than RR [ 38	context()	negated: False ,passive: False
0.957	[*A*]CafRep[*R*]replicates[*A*]15-30 % more than RR EBR [ 26 ] for SF Cab trace	context()	negated: False ,passive: True
0.957	[*A*]CafRep[*R*]replicate[*A*]similar number of packets across Sassy trace[*A*]while CafRep replicates 15-30 % more than RR EBR [ 26 ] for SF Cab trace	context()	negated: False ,passive: False
0.932	[*A*]CafRep[*R*]replicates[*A*]15-30 % more than RR [ 38	context()	negated: False ,passive: True
0.957	[*A*]CafRep[*R*]replicate[*A*]similar number of packets across Sassy trace[*A*]while CafRep replicates 15-30 % more than RR [ 38	context()	negated: False ,passive: False
[LINE#322] We believe that higher replication rates for CafRep in SF Cab trace [45] are due to CafRep discovering more forwarding opportunities that the other two adaptive replication protocols do not discover.
0.953	[*A*]higher replication rates for CafRep in SF Cab trace[*R*]are[*A*]due to CafRep discovering more forwarding opportunities	context(We believe)	negated: False ,passive: True
0.317	[*A*]We[*R*]believe[*A*]that higher replication rates for CafRep in SF Cab trace [45] are due to CafRep discovering more forwarding opportunities	context()	negated: False ,passive: False
0.939	[*A*]more forwarding opportunities[*R*]do not discover[*A*]the other two adaptive replication protocols	context()	negated: True ,passive: True
0.870	[*A*]CafRep[*R*]discovering[*A*]more forwarding opportunities that the other two adaptive replication protocols do not discover	context()	negated: False ,passive: False
[LINE#323] Compared to CafRep, EBR [26] replicates 15-20% more packets over Infocom 2006 trace [33] because that trace contains highly central nodes that EBR [26] uses heavily for the replication control and as EBR does not check for resource constraints this replication results in increased packet loss rates and lower availability.
0.878	[*A*]this replication[*R*]results[*A*]in lower availability	context(EBR does not check)	negated: False ,passive: True
0.855	[*A*]EBR[*R*]does not check[*A*]for resource constraints	context()	negated: True ,passive: False
0.897	[*A*]highly central nodes[*R*]uses heavily[*A*]for the replication control	context()	negated: False ,passive: True
0.868	[*A*]that trace[*R*]contains[*A*]highly central nodes that EBR [ 26 ] uses heavily for the replication control and	context()	negated: False ,passive: False
[LINE#324] 13c shows the cost of delivery that we define as the number of messages forwarded over the number of messages delivered across six protocols and over the three traces.
0.894	[*A*]messages[*R*]delivered[*A*]over the three traces	context()	negated: False ,passive: True
0.894	[*A*]messages[*R*]delivered[*A*]across six protocols	context()	negated: False ,passive: True
0.894	[*A*]messages[*R*]forwarded[*A*]over the number of messages	context()	negated: False ,passive: True
0.905	[*A*]the cost of delivery[*R*]define[*A*]as the number of messages	context()	negated: False ,passive: True
0.335	[*A*]13c[*R*]shows[*A*]the cost of delivery that we define as the number of messages	context()	negated: False ,passive: False
[LINE#325] This is a significant metric as it relates to the average number of hops required to deliver a message.
0.813	[*A*]hops[*R*]required[*A*]to deliver a message	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]relates[*A*]to the average number of hops	context()	negated: False ,passive: True
0.307	[*A*]This[*R*]is[*A*]a significant metric[*A*]as it relates to the average number of hops	context()	negated: False ,passive: True
[LINE#326] As expected, Caf [15] has the lowest cost of delivery across the three traces as it adaptively forwards to offload network hotspots in a delay-aware manner and does not include replication.
0.940	[*A*]Caf [ 15[*R*]has[*A*]the lowest cost of delivery across the three traces	context()	negated: False ,passive: False
0.388	[*A*]it[*R*]adaptively forwards to offload[*A*]network hotspots	context(it adaptively forwards)	negated: False ,passive: False
0.504	[*A*]it[*R*]adaptively forwards[*A*]to offload network hotspots in a delay - aware manner	context()	negated: False ,passive: False
0.931	[*A*]Caf [ 15[*R*]has[*A*]the lowest cost of delivery across the three traces[*A*]as it adaptively forwards to offload network hotspots in a delay - aware manner	context()	negated: False ,passive: False
[LINE#327] Out of the replication-based protocols, CafRep outperforms EBR [26], Prophet and SnF [37] across all the three data traces and is only marginally outperformed by RR [38] in the SF Cab dataset [45].
0.857	[*A*]SnF[*R*]is only marginally outperformed[*A*]by RR	context()	negated: False ,passive: True
0.921	[*A*]Prophet[*R*]is only marginally outperformed[*A*]by RR	context()	negated: False ,passive: True
0.999	[*A*]CafRep[*R*]outperforms[*A*]26 ]	context()	negated: False ,passive: False
0.932	[*A*]CafRep[*R*]outperforms[*A*]EBR	context()	negated: False ,passive: False
[LINE#328] As discussed in Section 3, we believe that this higher cost for CafRep in SF Cab trace [45] comes from high weighting of ego network resources and social utility in a trace that does not have node connectivity with good pattern of regularity.
0.942	[*A*]this higher cost for CafRep in SF Cab trace[*R*]comes[*A*]from high weighting of social utility in a trace	context(we believe)	negated: False ,passive: True
0.309	[*A*]we[*R*]believe[*A*]that this higher cost for CafRep in SF Cab trace [ 45 ] comes from high weighting of social utility in a trace	context()	negated: False ,passive: False
0.887	[*A*]a trace[*R*]does not have[*A*]node connectivity with good pattern of regularity	context()	negated: True ,passive: False
0.942	[*A*]this higher cost for CafRep in SF Cab trace[*R*]comes[*A*]from high weighting of ego network resources	context(we believe)	negated: False ,passive: True
0.309	[*A*]we[*R*]believe[*A*]that this higher cost for CafRep in SF Cab trace [ 45 ] comes from high weighting of ego network resources	context()	negated: False ,passive: False
[LINE#329] We expect better results for CafRep over this trace if we deployed low weighting of social utilities and ego network resources so that the results do not suffer from the poor quality for the ego networks formed in unstructured environments.
0.326	[*A*]we[*R*]deployed[*A*]low weighting of ego network resources[*A*]so that the results do not suffer from the poor quality for the ego networks	context()	negated: False ,passive: False
0.911	[*A*]the ego networks[*R*]formed[*A*]in unstructured environments	context()	negated: False ,passive: True
0.903	[*A*]the results[*R*]do not suffer[*A*]from the poor quality for the ego networks	context()	negated: True ,passive: False
0.326	[*A*]we[*R*]deployed[*A*]low weighting of social utilities[*A*]so that the results do not suffer from the poor quality for the ego networks	context()	negated: False ,passive: False
0.498	[*A*]We[*R*]expect[*A*]better results for CafRep over this trace	context()	negated: False ,passive: False
[LINE#330] Our results also show that SnF is consistently the worst performer with approximately double the cost of all the other algorithms, this is due to the static nature of SnF's [37] replication scheme, which under populates the network with traffic when demands are low and does not reduce the volume of traffic when contention is high.
0.798	[*A*]contention[*R*]is[*A*]high	context()	negated: False ,passive: True
0.906	[*A*]SnF[*R*]is[*A*]consistently[*A*]the worst performer with approximately double the cost of all the other algorithms	context(Our results show this is)	negated: False ,passive: True
0.518	[*A*]Our results[*R*]show[*A*]that SnF is consistently the worst performer with approximately double the cost of all the other algorithms	context(this is)	negated: False ,passive: False
0.548	[*A*]this[*R*]is[*A*]due to the static nature of SnF 's [ 37 ] replication scheme	context()	negated: False ,passive: True
0.749	[*A*]demands[*R*]are[*A*]low	context()	negated: False ,passive: True
[LINE#331] Across all the protocols, the cost of message delivery is the lowest for Infocom 2006 trace [33], followed by Sassy trace [44] and then SF Cab trace [45].
0.973	[*A*]the cost of message delivery[*R*]is[*A*]the lowest for Infocom 2006 trace[*A*]Across all the protocols	context()	negated: False ,passive: True
0.776	[*A*]Infocom 2006 trace[*R*]followed	context()	negated: False ,passive: False
0.967	[*A*]the cost of message delivery[*R*]is[*A*]the lowest[*A*]Across all the protocols	context()	negated: False ,passive: True
[LINE#332] This is due to significantly better connected Infocom 2006 trace than the other two traces, and most isolated and more random connectivity patterns for SF Cab trace [45]. .
0.612	[*A*]This[*R*]is[*A*]due to significantly better connected more random connectivity patterns for SF Cab trace	context()	negated: False ,passive: True
0.612	[*A*]This[*R*]is[*A*]due to significantly better connected most isolated connectivity patterns for SF Cab trace	context()	negated: False ,passive: True
0.612	[*A*]This[*R*]is[*A*]due to significantly better connected Infocom connectivity patterns for SF Cab trace	context()	negated: False ,passive: True
[LINE#333] Facebook applicationThis section explores the effects that real world social networking traffic usage patterns have on the performance of CafRep.
0.905	[*A*]the effects[*R*]have[*A*]on the performance of CafRep	context()	negated: False ,passive: True
0.907	[*A*]Facebook applicationThis section[*R*]explores[*A*]the effects that real world social networking traffic usage patterns have on the performance of CafRep	context()	negated: False ,passive: False
[LINE#334+335]  14 illustrates three experiments with different traffic profiles:low traffic profiles, randomly selected traffic profiles and high traffic profiles, which are indicated by 1, 2 and 3 respectively.
0.788	[*A*]randomly selected high traffic profiles[*R*]are indicated[*A*]by 3[*A*]respectively	context()	negated: False ,passive: True
0.788	[*A*]randomly selected high traffic profiles[*R*]are indicated[*A*]by 2[*A*]respectively	context()	negated: False ,passive: True
0.788	[*A*]randomly selected high traffic profiles[*R*]are indicated[*A*]by 1[*A*]respectively	context()	negated: False ,passive: True
0.771	[*A*]randomly selected traffic profiles[*R*]are indicated[*A*]by 3[*A*]respectively	context()	negated: False ,passive: True
0.771	[*A*]randomly selected traffic profiles[*R*]are indicated[*A*]by 2[*A*]respectively	context()	negated: False ,passive: True
0.771	[*A*]randomly selected traffic profiles[*R*]are indicated[*A*]by 1[*A*]respectively	context()	negated: False ,passive: True
0.544	[*A*]14[*R*]illustrates[*A*]three experiments with different traffic profiles:low traffic profiles	context()	negated: False ,passive: False
[LINE#336+337]  We compare CafRep with benchmark DTN protocols Direct Delivery (DD) [49] and Epidemic (EPI) [50], and the state-of-the-art competing congestion control algorithmwe evaluate the average number of seconds delay each algorithm experienced across the three different traffic profiles.
0.909	[*A*]the average number of seconds[*R*]delay[*A*]each algorithm experienced across the three different traffic profiles	context(Direct Delivery ( DD ) [ 49 ] and Epidemic ( EPI ) [ 50 ] , and the state - of - the - art competing congestion control algorithmwe evaluate)	negated: False ,passive: False
0.987	[*A*]Direct Delivery (DD) [49] and Epidemic (EPI) [50], and the state-of-the-art competing congestion control algorithmwe[*R*]evaluate[*A*]the average number of seconds delay each algorithm	context()	negated: False ,passive: False
0.903	[*A*]each algorithm[*R*]experienced[*A*]across the three different traffic profiles	context()	negated: False ,passive: True
0.498	[*A*]We[*R*]compare[*A*]CafRep[*A*]with benchmark DTN protocols	context()	negated: False ,passive: False
[LINE#338] We observe higher delays for less active profiles (that generate smaller messages at low frequencies) as delivery opportunities are low and message generation is infrequent.
0.777	[*A*]message generation[*R*]is[*A*]infrequent	context(We observe)	negated: False ,passive: True
0.279	[*A*]We[*R*]observe[*A*]higher delays for less active profiles ( that generate smaller messages at low frequencies	context()	negated: False ,passive: False
0.767	[*A*]delivery opportunities[*R*]are[*A*]low	context()	negated: False ,passive: True
0.326	[*A*]We[*R*]observe[*A*]higher delays for less active profiles ( that generate smaller messages at low frequencies[*A*]as delivery opportunities are low	context()	negated: False ,passive: False
[LINE#339] This in turn causes nodes to store their messages within their buffer for extended periods of time.
0.779	[*A*]nodes[*R*]to store[*A*]their messages[*A*]within their buffer for extended periods of time	context(This causes)	negated: False ,passive: False
0.258	[*A*]This[*R*]causes[*A*]nodes to store their messages within their buffer for extended periods of time	context()	negated: False ,passive: False
[LINE#340] These user profiles cause lower variance for the majority of algorithms which reflects the decreased contention in the network.
0.905	[*A*]the majority of algorithms[*R*]reflects[*A*]the decreased contention in the network	context()	negated: False ,passive: True
0.911	[*A*]These user profiles[*R*]cause[*A*]lower variance	context()	negated: False ,passive: False
[LINE#341] We observe that CafRep has lower delays than all other algorithms excluding epidemic for these profiles.
0.924	[*A*]CafRep[*R*]has[*A*]lower delays than all other algorithms	context(We observe)	negated: False ,passive: False
0.225	[*A*]We[*R*]observe[*A*]that CafRep has lower delays than all other algorithms	context()	negated: False ,passive: False
0.911	[*A*]all other algorithms[*R*]excluding[*A*]epidemic[*A*]for these profiles	context()	negated: False ,passive: False
[LINE#342] RR [38] is the exception to the reduced variance, as it displays high delay variance and much larger delays than other algorithms.
0.452	[*A*]it[*R*]displays[*A*]much larger delays than other algorithms	context()	negated: False ,passive: False
0.894	[*A*]RR [ 38[*R*]is[*A*]the exception to the reduced variance[*A*]as it displays much larger delays than other algorithms	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]displays[*A*]high delay variance	context()	negated: False ,passive: False
0.894	[*A*]RR [ 38[*R*]is[*A*]the exception to the reduced variance[*A*]as it displays high delay variance	context()	negated: False ,passive: True
[LINE#343] This is because RR [38] assumes that congestion is uniformly spread and do not identify congesting regions in the network, which occur more frequently when traffic patterns are less uniform.
0.903	[*A*]traffic patterns[*R*]are[*A*]less uniform	context()	negated: False ,passive: True
0.887	[*A*]the network[*R*]occur[*A*]more frequently[*A*]when traffic patterns are less uniform	context()	negated: False ,passive: True
0.944	[*A*]RR [ 38 ] assumes[*R*]do not identify[*A*]congesting regions[*A*]in the network	context()	negated: True ,passive: False
0.612	[*A*]This[*R*]is[*A*]because RR [ 38 ] assumes do not identify congesting regions in the network	context()	negated: False ,passive: True
0.687	[*A*]that congestion[*R*]is uniformly spread	context(RR [ 38 assumes)	negated: False ,passive: False
0.775	[*A*]RR [ 38[*R*]assumes[*A*]that congestion is uniformly spread	context()	negated: False ,passive: False
0.365	[*A*]This[*R*]is[*A*]because RR [ 38 ] assumes that congestion is uniformly spread	context()	negated: False ,passive: True
[LINE#344] As the message sending rates intensify the probability of a node having generated a message for an encountered destination increases, as a result message delays are consistently lower in comparison to the less active profiles.
0.878	[*A*]the message[*R*]sending[*A*]rates	context(the message sending rates intensify)	negated: False ,passive: False
0.933	[*A*]the message sending rates[*R*]intensify[*A*]the probability of a node[*A*]as a result message delays are consistently lower in comparison to the less active profiles	context()	negated: False ,passive: False
0.799	[*A*]a result message delays[*R*]are[*A*]consistently lower	context()	negated: False ,passive: True
0.903	[*A*]a node[*R*]having generated[*A*]a message for an encountered destination increases	context()	negated: False ,passive: False
[LINE#345] The increased traffic demands from these profiles lead to a higher level of contention in the network, which results in a higher variance in delays.
0.887	[*A*]the network[*R*]results[*A*]in a higher variance in delays	context()	negated: False ,passive: True
0.938	[*A*]The increased traffic demands from these profiles[*R*]lead[*A*]to a higher level of contention in the network	context()	negated: False ,passive: False
[LINE#346] This is best illustrated by the Direct Delivery [49] results that show significantly reduced delays and increased contention.
0.905	[*A*]results[*R*]show[*A*]increased contention	context()	negated: False ,passive: False
0.544	[*A*]significantly[*R*]reduced[*A*]delays	context()	negated: False ,passive: True
0.905	[*A*]results[*R*]show[*A*]significantly reduced delays	context()	negated: False ,passive: False
0.342	[*A*]This[*R*]best illustrated[*A*]by the Direct Delivery	context()	negated: False ,passive: True
0.449	[*A*]This[*R*]is[*A*]best illustrated by the Direct Delivery	context()	negated: False ,passive: True
[LINE#347] We also observe that in the high traffic experiments CafRep even outperforms Epidemic [50].
0.941	[*A*]CafRep[*R*]outperforms[*A*]Epidemic[*A*]in the high traffic experiments	context(We observe)	negated: False ,passive: False
0.274	[*A*]We[*R*]observe[*A*]that in the high traffic experiments CafRep even outperforms Epidemic [50	context()	negated: False ,passive: False
[LINE#348] This best illustrates the benefits CafRep offers by alleviating contention in the network through the use of multi-path forwarding.
0.944	[*A*]the benefits[*R*]offers[*A*]CafRep	context()	negated: False ,passive: True
0.718	[*A*]This best[*R*]illustrates[*A*]the benefits CafRep offers by alleviating contention in the network through the use of multi-path forwarding	context()	negated: False ,passive: False
[LINE#349] Our results show that in the mixed traffic profile experiments delays experienced are between the low and high traffic profiles, but the degree of variance is the highest of all three experiments.
0.937	[*A*]the degree of variance[*R*]is[*A*]the highest of all three experiments	context()	negated: False ,passive: True
0.523	[*A*]Our results[*R*]show[*A*]that in the mixed traffic profile experiments delays experienced are between the low and high traffic profiles	context()	negated: False ,passive: False
0.801	[*A*]the mixed traffic profile experiments delays[*R*]experienced	context()	negated: False ,passive: False
[LINE#350] This is due to the heterogeneity of the user activity, which leads to volatile traffic demands.
0.897	[*A*]the user activity[*R*]leads[*A*]to volatile traffic demands	context()	negated: False ,passive: False
0.449	[*A*]This[*R*]is[*A*]due to the heterogeneity of the user activity	context()	negated: False ,passive: True
[LINE#351] Despite the challenges presented by these mixed demands CafRep continues to outperform the other algorithms, while RR [38] experiences increased contention due to its assumption of homogeneous user patterns.
0.898	[*A*]CafRep[*R*]continues to outperform[*A*]the other algorithms	context(CafRep continues)	negated: False ,passive: False
0.902	[*A*]CafRep[*R*]continues[*A*]to outperform the other algorithms[*A*]while RR [38] experiences increased contention due to its assumption of homogeneous user patterns	context()	negated: False ,passive: False
0.902	[*A*]RR [38] experiences[*R*]increased[*A*]contention[*A*]due to its assumption of homogeneous user patterns	context()	negated: False ,passive: False
0.903	[*A*]the challenges[*R*]presented[*A*]by these mixed demands	context()	negated: False ,passive: True
[LINE#352] In Fig. 14b we show the success ratio of CafRep in comparison to DD [49], EPI [50] and RR [38].
0.568	[*A*]we[*R*]show[*A*]the success ratio of RR	context()	negated: False ,passive: False
0.568	[*A*]we[*R*]show[*A*]the success ratio of CafRep in comparison to DD	context()	negated: False ,passive: False
[LINE#353] We observe that CafRep supports real application traffic, as our results for real application traffic are consistent with our previous experiments.
0.902	[*A*]CafRep[*R*]supports[*A*]real application traffic	context(We observe)	negated: False ,passive: False
0.225	[*A*]We[*R*]observe[*A*]that CafRep supports real application traffic	context()	negated: False ,passive: False
0.585	[*A*]our results for real application traffic[*R*]are[*A*]consistent with our previous experiments	context()	negated: False ,passive: True
[LINE#354] CafRep has the highest success ratio in the less active profile experiments, in comparison with mixed and high traffic profiles as the levels of congestion are lower.
0.951	[*A*]CafRep[*R*]has[*A*]the highest success ratio in the less active profile experiments , in comparison with high traffic profiles as the levels of congestion	context()	negated: False ,passive: False
0.951	[*A*]CafRep[*R*]has[*A*]the highest success ratio in the less active profile experiments , in comparison with mixed traffic profiles as the levels of congestion	context()	negated: False ,passive: False
[LINE#355+356]  CafRep's success ratio decreases as the levels of contention increases and success ratio for low traffic profilesis higher than mixed, which is higher than the high traffic profile experiments.
0.818	[*A*]CafRep 's success ratio[*R*]decreases	context()	negated: False ,passive: False
0.913	[*A*]contention increases[*R*]is[*A*]higher than the high traffic profile experiments	context()	negated: False ,passive: True
0.939	[*A*]CafRep 's success ratio[*R*]decreases[*A*]as the levels of contention increases	context()	negated: False ,passive: True
[LINE#357] However, CafRep always has higher success ratio than all other protocols excluding direct delivery [49], which has 100% success ratio as it only forwards messages directly to the destination nodes.
0.313	[*A*]it[*R*]forwards directly[*A*]to the destination nodes	context()	negated: False ,passive: False
0.901	[*A*]direct delivery[*R*]has[*A*]100% success ratio[*A*]as it only forwards messages directly to the destination nodes	context()	negated: False ,passive: False
0.943	[*A*]all other protocols[*R*]excluding[*A*]direct delivery [49], which has 100% success ratio	context()	negated: False ,passive: False
0.958	[*A*]CafRep[*R*]has[*A*]higher success ratio than all other protocols[*A*]always	context()	negated: False ,passive: False
[LINE#358] Evaluation methodologyWe perform extensive evaluations of CafRep against state of the art DTN protocols across a range of metrics, three realistic topologies, and two application scenarios.
0.944	[*A*]the art[*R*]protocols[*A*]DTN	context()	negated: False ,passive: True
0.698	[*A*]the art[*R*]protocols	context()	negated: False ,passive: False
0.918	[*A*]Evaluation methodologyWe[*R*]perform[*A*]extensive evaluations of CafRep[*A*]against state of the art	context()	negated: False ,passive: False
[LINE#359+360]  As mobility and connectivity patterns of nodes have major impact on the performance of communication protocols in DTNs, we choose three real-life connectivity and GPS traces from CRAWDAD[1] to ensure sensible transmission ranges and realistic movement patterns of mobile users and vehicles.
0.355	[*A*]we[*R*]choose three real GPS traces from CRAWDAD [ 1 to ensure[*A*]realistic movement patterns of mobile vehicles	context(we choose)	negated: False ,passive: False
0.355	[*A*]we[*R*]choose three real GPS traces from CRAWDAD [ 1 to ensure[*A*]realistic movement patterns of mobile users	context(we choose)	negated: False ,passive: False
0.388	[*A*]we[*R*]choose three real - life connectivity to ensure[*A*]realistic movement patterns of mobile vehicles	context(we choose)	negated: False ,passive: False
0.388	[*A*]we[*R*]choose three real - life connectivity to ensure[*A*]realistic movement patterns of mobile users	context(we choose)	negated: False ,passive: False
0.355	[*A*]we[*R*]choose three real GPS traces from CRAWDAD [ 1 to ensure[*A*]realistic movement patterns of mobile vehicles	context(we choose)	negated: False ,passive: False
0.433	[*A*]we[*R*]choose[*A*]three real GPS traces from CRAWDAD [ 1[*A*]to ensure realistic movement patterns of mobile vehicles	context()	negated: False ,passive: False
0.355	[*A*]we[*R*]choose three real GPS traces from CRAWDAD [ 1 to ensure[*A*]realistic movement patterns of mobile users	context(we choose)	negated: False ,passive: False
0.433	[*A*]we[*R*]choose[*A*]three real GPS traces from CRAWDAD [ 1[*A*]to ensure realistic movement patterns of mobile users	context()	negated: False ,passive: False
0.388	[*A*]we[*R*]choose three real - life connectivity to ensure[*A*]realistic movement patterns of mobile vehicles	context(we choose)	negated: False ,passive: False
0.388	[*A*]we[*R*]choose[*A*]three real - life connectivity[*A*]to ensure realistic movement patterns of mobile vehicles	context()	negated: False ,passive: False
0.388	[*A*]we[*R*]choose three real - life connectivity to ensure[*A*]realistic movement patterns of mobile users	context(we choose)	negated: False ,passive: False
0.388	[*A*]we[*R*]choose[*A*]three real - life connectivity[*A*]to ensure realistic movement patterns of mobile users	context()	negated: False ,passive: False
0.355	[*A*]we[*R*]choose three real GPS traces from CRAWDAD [ 1 to ensure[*A*]sensible transmission ranges	context(we choose)	negated: False ,passive: False
0.388	[*A*]we[*R*]choose three real - life connectivity to ensure[*A*]sensible transmission ranges	context(we choose)	negated: False ,passive: False
0.956	[*A*]connectivity patterns of nodes[*R*]have[*A*]major impact on the performance of communication protocols in DTNs	context()	negated: False ,passive: False
0.355	[*A*]we[*R*]choose three real GPS traces from CRAWDAD [ 1 to ensure[*A*]sensible transmission ranges	context(we choose)	negated: False ,passive: False
0.433	[*A*]we[*R*]choose[*A*]three real GPS traces from CRAWDAD [ 1[*A*]to ensure sensible transmission ranges	context()	negated: False ,passive: False
0.388	[*A*]we[*R*]choose three real - life connectivity to ensure[*A*]sensible transmission ranges	context(we choose)	negated: False ,passive: False
0.388	[*A*]we[*R*]choose[*A*]three real - life connectivity[*A*]to ensure sensible transmission ranges	context()	negated: False ,passive: False
0.956	[*A*]mobility patterns of nodes[*R*]have[*A*]major impact on the performance of communication protocols in DTNs	context()	negated: False ,passive: False
[LINE#361+362]  Our selected traces exhibit vastly different connectivity patterns and we describe them in Section 4.1.
0.309	[*A*]we[*R*]describe[*A*]them	context()	negated: False ,passive: False
0.660	[*A*]Our selected traces[*R*]exhibit[*A*]vastly different connectivity patterns	context()	negated: False ,passive: False
[LINE#363] We use two different application scenarios that have different traffic patterns: publish subscribe podcasting application where publishers publish messages with fixed sizes at constant bit rate, and Facebook social networking application that has heterogeneous users that generate content at a variety of different rates and sizes.
0.887	[*A*]heterogeneous users[*R*]generate[*A*]content[*A*]at a variety of sizes	context()	negated: False ,passive: False
0.910	[*A*]Facebook social networking application[*R*]has[*A*]heterogeneous users that generate content at a variety of sizes	context()	negated: False ,passive: False
0.887	[*A*]heterogeneous users[*R*]generate[*A*]content[*A*]at a variety of different rates	context()	negated: False ,passive: False
0.910	[*A*]Facebook social networking application[*R*]has[*A*]heterogeneous users that generate content at a variety of different rates	context()	negated: False ,passive: False
0.905	[*A*]two different application scenarios[*R*]have[*A*]different traffic patterns	context()	negated: False ,passive: False
0.938	[*A*]publishers[*R*]publish[*A*]messages[*A*]application	context()	negated: False ,passive: False
0.367	[*A*]We[*R*]use[*A*]two different application scenarios that have different traffic patterns[*A*]publish subscribe podcasting application where publishers publish messages with fixed sizes at constant bit rate , and Facebook social networking application	context()	negated: False ,passive: False
[LINE#364] We induce varying levels of congestion by increasing the percentage of randomly chosen publishers for the podcasting application and by decreasing buffer sizes for the Facebook application.
0.452	[*A*]We[*R*]induce[*A*]varying levels of congestion	context()	negated: False ,passive: False
[LINE#365] Increasing the number of randomly chosen publishers allows us to have non-uniform temporal and spatial congestion rates across the network topology.
0.397	[*A*]us[*R*]to have[*A*]non-uniform spatial congestion rates across the network topology	context(Increasing the number of randomly chosen publishers allows)	negated: False ,passive: False
0.913	[*A*]Increasing the number of randomly chosen publishers[*R*]allows[*A*]us to have non-uniform spatial congestion rates across the network topology	context()	negated: False ,passive: False
0.397	[*A*]us[*R*]to have[*A*]non-uniform temporal congestion rates across the network topology	context(Increasing the number of randomly chosen publishers allows)	negated: False ,passive: False
0.913	[*A*]Increasing the number of randomly chosen publishers[*R*]allows[*A*]us to have non-uniform temporal congestion rates across the network topology	context()	negated: False ,passive: False
[LINE#366+367]  This example podcasting application is appropriate for the realistic photo/video uploading application scenarios that were shown to have a larger number of publishers than subscribers [ 41].We compare CafRep to two benchmark DTN routing protocols and three competitive (adaptive).
0.433	[*A*]We[*R*]compare[*A*]CafRep[*A*]to three competitive ( adaptive	context()	negated: False ,passive: False
0.934	[*A*]the realistic photo / video uploading application scenarios[*R*]to have[*A*]a larger number of publishers than subscribers	context()	negated: False ,passive: False
0.805	[*A*]the realistic photo / video uploading application scenarios[*R*]were shown	context()	negated: False ,passive: False
0.949	[*A*]This example podcasting application[*R*]is[*A*]appropriate for the realistic photo / video uploading application scenarios	context(We compare)	negated: False ,passive: True
0.433	[*A*]We[*R*]compare[*A*]CafRep[*A*]to two benchmark DTN routing protocols	context()	negated: False ,passive: False
[LINE#368] All our experiments are done in the ONE simulator [20] and our performance metrics include: success ratio, end to end delay, node buffer availability, number of forwarded packets, packet loss rates, number of delivered packets and number of replicated packets.
0.618	[*A*]our performance metrics[*R*]include[*A*]success ratio	context()	negated: False ,passive: True
0.660	[*A*]All our experiments[*R*]are done[*A*]in the ONE simulator	context()	negated: False ,passive: True
[LINE#369] We aim to show that CafRep adapts well to the topologically different networks and two applications while being efficient in terms of network resources..
0.902	[*A*]CafRep[*R*]adapts well[*A*]to the two applications[*A*]while being efficient in terms of network resources	context(We aim to show)	negated: False ,passive: False
0.225	[*A*]We[*R*]aim to show[*A*]that CafRep adapts well to the two applications	context(We aim)	negated: False ,passive: False
0.317	[*A*]We[*R*]aim[*A*]to show that CafRep adapts well to the two applications	context()	negated: False ,passive: False
0.902	[*A*]CafRep[*R*]adapts well[*A*]to the topologically different networks[*A*]while being efficient in terms of network resources	context(We aim to show)	negated: False ,passive: False
0.225	[*A*]We[*R*]aim to show[*A*]that CafRep adapts well to the topologically different networks	context(We aim)	negated: False ,passive: False
0.317	[*A*]We[*R*]aim[*A*]to show that CafRep adapts well to the topologically different networks	context()	negated: False ,passive: False
[LINE#370+371+372]  -life connectivity and GPS trace datasetsTo evaluate CafRep in topologically different networks , we choose to use three real world connectivity and GPS traces from CRAWDAD:.
0.938	[*A*]trace datasetsTo[*R*]evaluate[*A*]CafRep[*A*]in topologically different networks	context()	negated: False ,passive: False
[LINE#373+374]  Infocom 2006 [33], Sassy 2011 [44] and San Francisco Taxi Cabs 2011[45] that have different mobility and connectivity patterns.
0.503	[*A*]45[*R*]have[*A*]different connectivity patterns	context()	negated: False ,passive: False
0.503	[*A*]45[*R*]have[*A*]different mobility	context()	negated: False ,passive: False
[LINE#375] We show that CafRep is successful independently of the connectivity patterns of the underlying networks.
0.924	[*A*]CafRep[*R*]is[*A*]successful[*A*]independently of the connectivity patterns of the underlying networks	context(We show)	negated: False ,passive: True
0.382	[*A*]We[*R*]show[*A*]that CafRep is successful independently of the connectivity patterns of the underlying networks	context()	negated: False ,passive: False
[LINE#376+377]  The connectivity and GPS traces we use are briefly described below:.
0.423	[*A*]GPS traces we use[*R*]are described[*A*]briefly	context()	negated: False ,passive: True
0.884	[*A*]GPS traces[*R*]use[*A*]we	context()	negated: False ,passive: True
0.732	[*A*]The connectivity[*R*]are briefly described	context()	negated: False ,passive: False
[LINE#378] Infocom 2006 trace [33] consists of a 4-day long trace that is based on a human mobility experiment conducted at Infocom 2006.
0.931	[*A*]a human mobility experiment[*R*]conducted[*A*]at Infocom 2006	context()	negated: False ,passive: True
0.921	[*A*]a 4-day long trace[*R*]is based[*A*]on a human mobility experiment	context()	negated: False ,passive: True
0.922	[*A*]Infocom 2006 trace[*R*]consists[*A*]of a 4-day long trace	context()	negated: False ,passive: True
[LINE#379] A total of 78 volunteers joined the experiment and each was given an iMote device capable of connecting to other Bluetooth-capable devices.
0.896	[*A*]A total[*R*]has [number of] volunteers[*A*]78	context()	negated: False ,passive: False
0.698	[*A*]each[*R*]was given[*A*]an iMote device capable of connecting to other Bluetooth-capable devices	context()	negated: False ,passive: True
0.926	[*A*]A total of 78 volunteers[*R*]joined[*A*]the experiment	context()	negated: False ,passive: False
[LINE#380] In addition 20 static long-range iMote devices were placed at various locations of the conference venue; three of these were semi-static as they were placed in the building lifts.
0.921	[*A*]20 static long-range iMote devices[*R*]were placed[*A*]at various locations of the conference venue	context(three of these were)	negated: False ,passive: True
0.377	[*A*]three of these[*R*]were[*A*]semi-static[*A*]as they were placed in the building lifts	context()	negated: False ,passive: True
0.616	[*A*]they[*R*]were placed[*A*]in the building lifts	context()	negated: False ,passive: True
[LINE#381+382]  This dataset has been shown to exhibit strong community structure [16].Sassy trace [44] consists of a 79day long trace that is based on a human mobility experiment conducted at St. Andrews in 2011.
[LINE#383] A total of 27 volunteers joined the experiment and each was given a TMote Invent sensor mote and encounters were tracked in their day-to-day activates for a period of 79days.
0.590	[*A*]each[*R*]was given[*A*]a TMote Invent sensor mote and encounters	context()	negated: False ,passive: True
0.926	[*A*]A total of 27 volunteers[*R*]joined[*A*]the experiment	context()	negated: False ,passive: False
[LINE#384] The rage of these devices was about 10m and encounters were uploaded to a base station regularly (but the base station did not have any role in forwarding).
0.913	[*A*]The rage of these devices[*R*]were uploaded[*A*]to the base station	context()	negated: False ,passive: True
0.943	[*A*]The rage of these devices[*R*]was[*A*]about encounters	context()	negated: False ,passive: True
0.891	[*A*]about 10 m[*R*]were uploaded[*A*]to the base station	context(The rage of these devices was)	negated: False ,passive: True
0.930	[*A*]The rage of these devices[*R*]was[*A*]about 10 m were uploaded to the base station	context()	negated: False ,passive: True
0.943	[*A*]The rage of these devices[*R*]was[*A*]about encounters were uploaded to a base station regularly	context()	negated: False ,passive: True
0.891	[*A*]about 10 m[*R*]were uploaded[*A*]to a base station[*A*]regularly	context(The rage of these devices was)	negated: False ,passive: True
0.955	[*A*]The rage of these devices[*R*]was[*A*]about 10 m were uploaded to a base station regularly	context()	negated: False ,passive: True
[LINE#385] Similarly to Infocom 2006, this dataset has some social structure but unlike Infocom 2006, it has no infrastructure-like nodes, is much sparser and results in much longer disconnection periods.
0.613	[*A*]Similarly[*R*]is[*A*]much sparser in much longer disconnection periods	context()	negated: False ,passive: True
0.522	[*A*]it[*R*]has[*A*]no infrastructure-like nodes	context()	negated: False ,passive: False
0.925	[*A*]this dataset[*R*]has[*A*]some social structure	context()	negated: False ,passive: False
[LINE#386] San Francisco Cab Trace [45] are live traces that record the GPS coordinates of 550 cabs, logged approximately every 10s, over a period of 30days, in the San Francisco Bay Area.
0.833	[*A*]the GPS[*R*]coordinates[*A*]of 550 cabs	context(live traces record)	negated: False ,passive: False
0.921	[*A*]live traces[*R*]record[*A*]the GPS coordinates of 550 cabs, logged approximately every 10s, over a period of 30days, in the San Francisco Bay Area	context()	negated: False ,passive: False
0.901	[*A*]San Francisco Cab Trace[*R*]are[*A*]live traces that record the GPS coordinates of 550 cabs, logged approximately every 10s, over a period of 30days, in the San Francisco Bay Area	context()	negated: False ,passive: True
[LINE#387] We have downloaded the most recent at the time of writing traces for the period of September 20th 2011 to October 20th 2011 via the Cabspoting.org API.
0.614	[*A*]We[*R*]have downloaded[*A*]the most recent[*A*]at the time of writing traces for the period of September 20th 2011 to October 20th 2011 via the Cabspoting.org API	context()	negated: False ,passive: False
[LINE#388] These traces are part of the Cabspotting project [45] that aimed to infer and visualise Taxi Cab collocation information from GPS coordinates in the San Francisco Bay Area.
0.483	[*A*]45[*R*]aimed to visualise[*A*]Taxi Cab collocation information[*A*]from GPS coordinates in the San Francisco Bay Area	context(45 aimed)	negated: False ,passive: False
0.600	[*A*]45[*R*]aimed[*A*]to visualise Taxi Cab collocation information from GPS coordinates in the San Francisco Bay Area	context()	negated: False ,passive: False
0.776	[*A*]the Cabspotting project[*R*]to infer	context()	negated: False ,passive: False
0.806	[*A*]the Cabspotting project[*R*]aimed[*A*]to infer	context()	negated: False ,passive: False
0.918	[*A*]These traces[*R*]are[*A*]part of the Cabspotting project	context()	negated: False ,passive: True
[LINE#389] We have assumed that two cabs are collocated if their physical distance is less than 50m, furthermore, as cab clocks are not synchronised we have assumed a 60s interval during which, if the distance between two cabs is less than 50m, those cabs are assumed to be collocated.
0.862	[*A*]two cabs[*R*]are collocated[*A*]if their physical distance is less than 50m, furthermore	context(We have assumed we have assumed)	negated: False ,passive: True
0.168	[*A*]We[*R*]have assumed[*A*]that two cabs are collocated if their physical distance is less than 50m, furthermore	context(we have assumed)	negated: False ,passive: False
0.271	[*A*]we[*R*]have assumed[*A*]a 60s interval[*A*]during which, if the distance between two cabs is less than 50m, those cabs are assumed to be collocated	context()	negated: False ,passive: False
0.732	[*A*]cab clocks[*R*]are not synchronised	context()	negated: True ,passive: False
0.698	[*A*]those cabs[*R*]to be collocated	context()	negated: False ,passive: False
0.720	[*A*]their physical distance[*R*]is[*A*]less than 50m, furthermore	context()	negated: False ,passive: True
0.732	[*A*]those cabs[*R*]are assumed	context()	negated: False ,passive: False
0.943	[*A*]the distance between two cabs[*R*]is[*A*]less than 50m	context()	negated: False ,passive: True
[LINE#390] We use 100 taxis that where logging their location data most frequently for higher confidence and accuracy of the GPS traces.
0.240	[*A*]We[*R*]use[*A*]100 taxis that where logging their location data most frequently for higher accuracy of the GPS traces	context()	negated: False ,passive: False
0.999	[*A*]We[*R*]use[*A*]100 taxis	context()	negated: False ,passive: False
0.240	[*A*]We[*R*]use[*A*]100 taxis that where logging their location data most frequently for higher confidence of the GPS traces	context()	negated: False ,passive: False
[LINE#391] This trace has shown to exhibit long periods of disconnections, short periods of connectivity and islands of connectivity that are rarely populated by more than two nodes.
0.923	[*A*]This trace[*R*]has shown to exhibit[*A*]long periods of disconnections , short periods of islands of connectivity	context(This trace has shown)	negated: False ,passive: False
0.923	[*A*]This trace[*R*]has shown[*A*]to exhibit long periods of disconnections , short periods of islands of connectivity	context()	negated: False ,passive: False
0.910	[*A*]islands of connectivity[*R*]are populated[*A*]by more than two nodes[*A*]rarely	context()	negated: False ,passive: True
0.882	[*A*]This trace[*R*]has shown to exhibit[*A*]long periods of disconnections , short periods of connectivity	context(This trace has shown)	negated: False ,passive: False
0.923	[*A*]This trace[*R*]has shown[*A*]to exhibit long periods of disconnections , short periods of connectivity	context()	negated: False ,passive: False
0.918	[*A*]short periods of connectivity[*R*]are populated[*A*]by more than two nodes[*A*]rarely	context()	negated: False ,passive: True
[LINE#392+393]  7 draws a comparison between the three described mobility[33], Sassy [44], and SF Cabs [45], highlighting their topological differences.
0.749	[*A*]SF Cabs[*R*]highlighting[*A*]their topological differences	context()	negated: False ,passive: False
0.449	[*A*]7[*R*]draws[*A*]a comparison between the three described mobility	context()	negated: False ,passive: False
[LINE#394] 7 shows that SF Cab trace [45] is the most challenging trace with very short connectivity durations, very high disconnections and low number of connected nodes during connected times.
0.962	[*A*]SF Cab trace[*R*]is[*A*]the most challenging trace with low number of connected nodes[*A*]during connected times	context()	negated: False ,passive: True
0.940	[*A*]SF Cab trace[*R*]is[*A*]the most challenging trace with very high disconnections[*A*]during connected times	context()	negated: False ,passive: True
0.940	[*A*]SF Cab trace[*R*]is[*A*]the most challenging trace with very short connectivity durations[*A*]during connected times	context()	negated: False ,passive: True
[LINE#395] Both Sassy [44] and SF Cabs [45] are significantly more challenging compared to Infocom 2006 [33] both due to the smaller numbers of neighbours during connectivity times (connectivity sets), and short connections combined with long disconnections.
0.903	[*A*]short connections[*R*]combined[*A*]with long disconnections	context()	negated: False ,passive: True
0.914	[*A*]SF Cabs[*R*]are[*A*]significantly more challenging compared to Infocom 2006 [ 33 ] both due to the smaller numbers of neighbours during connectivity times short connections	context()	negated: False ,passive: True
0.914	[*A*]SF Cabs[*R*]are[*A*]significantly more challenging compared to Infocom 2006 [ 33 ] both due to the smaller numbers of neighbours during connectivity times	context()	negated: False ,passive: True
0.970	[*A*]33 ] both due to the smaller numbers of neighbours during connectivity times short connections[*R*]combined[*A*]with long disconnections	context()	negated: False ,passive: True
0.962	[*A*]Both Sassy [ 44[*R*]are[*A*]significantly more challenging compared to Infocom 2006 [ 33 ] both due to the smaller numbers of neighbours during connectivity times short connections	context()	negated: False ,passive: True
0.887	[*A*]connectivity sets[*R*]combined[*A*]with long disconnections	context()	negated: False ,passive: True
0.962	[*A*]Both Sassy [ 44[*R*]are[*A*]significantly more challenging compared to Infocom 2006 [ 33 ] both due to the smaller numbers of neighbours during connectivity times	context()	negated: False ,passive: True
[LINE#396+397]  7a shows that both Sassy [44] and SF Cab [45] traces exhibit predominantly short contact durations (a mean of 33s and 31s, a median of 27s and 24s and a maximum of 2.3min and 4min respectively) while Infocom 2006 displays substantially longer contact durations (a mean of 3min, a median of 2.5min and a maximum value of 7min).Fig.7b illustrates three different trends regarding node isolation periods.
0.964	[*A*]both Sassy [44] and SF Cab [45] traces[*R*]exhibit[*A*]predominantly short contact durations	context(7a shows)	negated: False ,passive: False
0.472	[*A*]7a[*R*]shows[*A*]that both Sassy [44] and SF Cab [45] traces exhibit predominantly short contact durations (a mean of 33s and 31s, a median of 27s and 24s and a maximum of 2.3min and 4min respectively) while Infocom 2006 displays substantially longer contact durations (a mean of 3min, a median of 2.5min and a maximum value of 7min).Fig.7b illustrates three different trends regarding node isolation periods	context()	negated: False ,passive: False
0.920	[*A*]Fig.7b[*R*]illustrates[*A*]three different trends regarding node isolation periods	context()	negated: False ,passive: False
[LINE#398+399]  SF Cabs trace suffers the longest periods of isolation (a mean of 10h, a median of 6.5h and a maximum value of 4.5days); while Sassy is significantly more disconnected than Infocom 2006 but much more connected than SF with mean 1.5h, median 14min and maximum 11h; and Infocom 2006 experiences substantially lower periods of isolation (a mean of 5.5min, a median of 6.4min and a maximum value of 1.5h).Fig.7c displays the difference in node connectivity between the three datasets.
0.915	[*A*]SF Cabs trace[*R*]suffers[*A*]the longest periods of isolation	context(1.5 h , median 14min and maximum 11 h ; and Infocom 2006 experiences substantially lower periods of isolation ( a mean of 5.5min displays)	negated: False ,passive: False
0.986	[*A*]1.5h, median 14min and maximum 11h; and Infocom 2006 experiences substantially lower periods of isolation (a mean of 5.5min[*R*]displays[*A*]the difference in node connectivity between the three datasets	context()	negated: False ,passive: False
0.260	[*A*]more[*R*]connected	context()	negated: False ,passive: False
0.967	[*A*]Sassy[*R*]is[*A*]significantly more disconnected than Infocom 2006 but much more connected than SF with mean	context()	negated: False ,passive: True
[LINE#400] This is calculated as the number of active connections a node has at the time a new connection is established.
0.939	[*A*]a new connection[*R*]is established[*A*]the time	context()	negated: False ,passive: True
0.961	[*A*]the number of active connections[*R*]has[*A*]a node	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]is calculated[*A*]as the number of active connections[*A*]at the time	context()	negated: False ,passive: True
[LINE#401]  SF Cabs trace has the lowest observed node connectivity (a mean of 2, a median of 1.9 and a maximum value of 4.47 connections), Infocom 2006 has the highest observed node connectivity (a mean of 6.19, a median of 6.44 and a maximum value of 10 connections) and Sassy experiences a mean of 2.95, a median of 2.23 and a maximum value of 7.57 connections).Each of these datasets provides a different and challenging environment for the algorithms to perform in:.
0.068	[*A*]Sassy[*R*]has a mean of[*A*]2.95	context()	negated: False ,passive: False
0.937	[*A*]SF Cabs trace[*R*]has[*A*]the lowest observed node connectivity	context(Infocom 2006 has Sassy experiences)	negated: False ,passive: False
0.963	[*A*]Infocom 2006[*R*]has[*A*]the highest observed node connectivity (a mean of 6.19, a median of 6.44 and a maximum value of 10 connections) and Sassy experiences a mean of 2.95, a median of 2.23 and a maximum value of 7.57 connections	context(Sassy experiences)	negated: False ,passive: False
0.902	[*A*]Sassy[*R*]experiences[*A*]a mean of 2.95	context()	negated: False ,passive: False
0.767	[*A*]the algorithms[*R*]to perform[*A*]in	context()	negated: False ,passive: False
0.919	[*A*]Each of these datasets[*R*]provides[*A*]a different and challenging environment	context()	negated: False ,passive: False
[LINE#402] SF Cabs due to the very long periods of isolation, short periods of connectivity and small connectivity sets; Infocom 2006 due to the longer periods of connectivity, moderate isolation periods and larger connectivity sets.
[LINE#403] Sassy due to short connectivity periods, longer isolation periods and small connectivity sets.
[LINE#404] In Section 5 we show that CafRep adapts well to the dynamics of all three datasets as it keeps high success ratio and availability, low delay and packet loss rates, and outperforms the other protocols across all datasets.
0.898	[*A*]CafRep[*R*]adapts well[*A*]to the dynamics of all three datasets[*A*]low packet loss rates	context(we show)	negated: False ,passive: False
0.365	[*A*]we[*R*]show[*A*]that CafRep adapts well to the dynamics of all three datasets as it keeps high availability , low packet loss rates[*A*]In Section 5	context()	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]adapts well[*A*]to the dynamics of all three datasets[*A*]low delay	context(we show)	negated: False ,passive: False
0.365	[*A*]we[*R*]show[*A*]that CafRep adapts well to the dynamics of all three datasets as it keeps high availability , low delay[*A*]In Section 5	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]keeps[*A*]high availability	context()	negated: False ,passive: False
0.827	[*A*]CafRep[*R*]adapts well[*A*]to the dynamics of all three datasets[*A*]as it keeps high success ratio	context(we show)	negated: False ,passive: False
0.452	[*A*]it[*R*]keeps[*A*]high success ratio	context()	negated: False ,passive: False
0.898	[*A*]CafRep[*R*]adapts well[*A*]to the dynamics of all three datasets	context(we show)	negated: False ,passive: False
0.514	[*A*]we[*R*]show[*A*]that CafRep adapts well to the dynamics of all three datasets[*A*]In Section 5	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]outperforms[*A*]the other protocols across all datasets	context()	negated: False ,passive: False
[LINE#405] We compare the performance of CafRep against benchmark protocols: Prophet [23], Spray and Focus (SF) [37] and competitive adaptive protocols Caf [15], Encounter Based Routing (EBR) [26] and Retiring Replicas (RRs) [38].
0.452	[*A*]We[*R*]compare[*A*]competitive adaptive protocols	context()	negated: False ,passive: False
0.498	[*A*]We[*R*]compare[*A*]the performance of CafRep against benchmark protocols	context()	negated: False ,passive: False
[LINE#406] Prophet has become a prevalent benchmark forwarding algorithm, SF as it is a prominent fixed replication forwarding algorithm, EBR due to replication placement being variable and RR because of its distinct adaptive replication capping. .
0.534	[*A*]it[*R*]is[*A*]a prominent fixed replication forwarding algorithm , EBR due to replication placement being RR because of its distinct adaptive replication capping	context()	negated: False ,passive: True
0.859	[*A*]replication placement[*R*]being[*A*]RR[*A*]because of its distinct adaptive replication capping	context()	negated: False ,passive: True
0.923	[*A*]Prophet[*R*]has become[*A*]a prevalent benchmark forwarding algorithm[*A*]as it is a prominent fixed replication forwarding algorithm , EBR due to replication placement being RR because of its distinct adaptive replication capping	context()	negated: False ,passive: True
0.534	[*A*]it[*R*]is[*A*]a prominent fixed replication forwarding algorithm , EBR due to replication placement being variable because of its distinct adaptive replication capping	context()	negated: False ,passive: True
0.894	[*A*]benchmark[*R*]forwarding[*A*]algorithm	context()	negated: False ,passive: True
0.835	[*A*]replication placement[*R*]being[*A*]variable[*A*]because of its distinct adaptive replication capping	context()	negated: False ,passive: True
0.923	[*A*]Prophet[*R*]has become[*A*]a prevalent benchmark forwarding algorithm[*A*]as it is a prominent fixed replication forwarding algorithm , EBR due to replication placement being variable because of its distinct adaptive replication capping	context()	negated: False ,passive: True
[LINE#407+408]  Application modelsIn order to evaluate CafRep in the presence of congestion at different rates and locations, we have designed and built a fully distributed, interest driven overlay file casting application as described in Section 3.
[LINE#409] We randomly assign topic interest and choose varying number of publishers and subscribers.
0.452	[*A*]We[*R*]randomly assign[*A*]topic interest	context()	negated: False ,passive: False
[LINE#410] The data is published by the publishers at the constant bit rate (5Mb/s) and messages of uniform sizes (1MB) are sent to the neighbours.
0.905	[*A*]messages of uniform sizes[*R*]are sent[*A*]to the neighbours	context()	negated: False ,passive: True
0.903	[*A*]The data[*R*]is published[*A*]by the publishers[*A*]at the constant bit rate	context()	negated: False ,passive: True
[LINE#411] We assume fixed, limited buffer 1GB for this set of experiments.
0.170	[*A*]We[*R*]fixed	context()	negated: False ,passive: False
0.225	[*A*]We[*R*]assume[*A*]fixed	context()	negated: False ,passive: False
[LINE#412] We run eight increments of congestion levels induced by increasing number of publishers ranging from 1/9 to 8/9 of total number of nodes in that connectivity dataset.
0.832	[*A*]publishers[*R*]ranging[*A*]from 1/9[*A*]to 8/9 of total number of nodes in that connectivity dataset	context()	negated: False ,passive: True
0.903	[*A*]congestion levels[*R*]induced[*A*]by increasing number of publishers	context()	negated: False ,passive: True
0.522	[*A*]We[*R*]run[*A*]eight increments of congestion levels	context()	negated: False ,passive: False
[LINE#413] All simulations are repeated a ten times with different random subscribers and publishers.
0.903	[*A*]All simulations[*R*]are repeated[*A*]a ten times	context()	negated: False ,passive: True
[LINE#414] Related work on publish-subscribe data dissemination in DTNs in [43] explicitly relies on detecting communities and does not consider congestion control.
0.903	[*A*]Related work[*R*]does not consider[*A*]congestion control	context()	negated: True ,passive: False
0.969	[*A*]Related work on publish - subscribe data dissemination in DTNs in [ 43[*R*]explicitly relies[*A*]on detecting communities	context()	negated: False ,passive: False
[LINE#415] [19] proposes content-based forwarding and buffer management based on content popularity, adding explicit application hints to messages that are visible to each intermediary node, allowing them to cache content, act as distributed storage, or perform application-specific forwarding, but they do not consider congestion awareness or multiple sources.
0.616	[*A*]they[*R*]do not consider[*A*]congestion awareness or multiple sources	context()	negated: True ,passive: False
0.350	[*A*]them[*R*]to perform[*A*]application-specific forwarding	context()	negated: False ,passive: False
0.877	[*A*]messages[*R*]are[*A*]visible to each intermediary[*A*]node	context()	negated: False ,passive: True
0.350	[*A*]them[*R*]to act[*A*]as distributed storage	context()	negated: False ,passive: False
0.503	[*A*]19[*R*]proposes[*A*]content-based forwarding and buffer management	context()	negated: False ,passive: False
[LINE#416] [27] allows generic functions such as bundle routing to be performed differently per application, operation, or resource, but particularly enables application support by means of caching or distributed storage, but does not consider congestion aware forwarding.
[LINE#417] In order to consider the impact of the real world social application on the behaviour of CafRep, we designed our Facebook Application that allows us to model the traffic typical of communication in social networking applications.
0.388	[*A*]us[*R*]to model[*A*]the traffic typical of communication in social networking applications	context(our Facebook Application allows)	negated: False ,passive: False
0.599	[*A*]our Facebook Application[*R*]allows[*A*]us to model the traffic typical of communication in social networking applications	context()	negated: False ,passive: False
0.350	[*A*]we[*R*]designed[*A*]our Facebook Application	context()	negated: False ,passive: False
[LINE#418] We extracted the friendship graphs and statistical data regarding the size and frequency of posts for every user from the Facebook application and used it to drive the publish and subscribe application on the top of CafRep.
0.614	[*A*]We[*R*]extracted[*A*]the statistical data regarding the frequency of posts for every user from the Facebook application	context()	negated: False ,passive: False
0.614	[*A*]We[*R*]extracted[*A*]the statistical data regarding the size of posts for every user from the Facebook application	context()	negated: False ,passive: False
0.433	[*A*]We[*R*]used it to subscribe[*A*]application on the top of CafRep	context(We used)	negated: False ,passive: False
0.293	[*A*]We[*R*]used[*A*]it[*A*]to subscribe application on the top of CafRep	context()	negated: False ,passive: False
0.388	[*A*]We[*R*]used it to drive[*A*]the publish	context(We used)	negated: False ,passive: False
0.256	[*A*]We[*R*]used[*A*]it[*A*]to drive the publish	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]extracted[*A*]the friendship graphs	context()	negated: False ,passive: False
[LINE#419] We have sampled the usage patterns of 95 Facebook users and extracted list of friends associated with each user, their 20 most recent wall post messages and their list of interests.
0.894	[*A*]friends[*R*]associated[*A*]with each user	context()	negated: False ,passive: True
0.452	[*A*]We[*R*]have sampled[*A*]the extracted list of friends	context()	negated: False ,passive: False
0.498	[*A*]We[*R*]have sampled[*A*]the usage patterns of 95 Facebook users	context()	negated: False ,passive: False
[LINE#420+421]  The size of a wall post is calculated as the total download cost (e.g. if a message contains a http link or a photo then this is measured and appended to the message size).Fig.8a shows the non-uniform sizes of messages generated for each user with the Mean size of 1MB, a Median size of 82KB and a maximum size of 268MB.
0.918	[*A*]Fig.8a[*R*]shows[*A*]the non-uniform sizes of messages	context()	negated: False ,passive: False
0.481	[*A*]this[*R*]appended[*A*]to the message size[*A*]then	context()	negated: False ,passive: True
0.244	[*A*]this[*R*]is measured[*A*]then	context()	negated: False ,passive: True
0.911	[*A*]messages[*R*]generated[*A*]for each user with the Mean size of 1MB	context()	negated: False ,passive: True
[LINE#422] We observe three types of message, text, picture and link that are posted at different frequencies: text messages are the most commonly posted (78%), followed by posts containing pictures (19%), with only 3% of posts encompassing links.
0.278	[*A*]We[*R*]observe[*A*]three types of link that are posted at different frequencies	context(text messages are)	negated: False ,passive: False
0.905	[*A*]three types of link[*R*]are posted[*A*]at different frequencies	context()	negated: False ,passive: True
0.278	[*A*]We[*R*]observe[*A*]three types of picture that are posted at different frequencies	context(text messages are)	negated: False ,passive: False
0.905	[*A*]three types of picture[*R*]are posted[*A*]at different frequencies	context()	negated: False ,passive: True
0.278	[*A*]We[*R*]observe[*A*]three types of text that are posted at different frequencies	context(text messages are)	negated: False ,passive: False
0.905	[*A*]three types of text[*R*]are posted[*A*]at different frequencies	context()	negated: False ,passive: True
0.278	[*A*]We[*R*]observe[*A*]three types of message that are posted at different frequencies	context(text messages are)	negated: False ,passive: False
0.686	[*A*]text messages[*R*]are	context()	negated: False ,passive: False
0.813	[*A*]posts[*R*]encompassing[*A*]links	context()	negated: False ,passive: False
0.905	[*A*]three types of message[*R*]are posted[*A*]at different frequencies	context()	negated: False ,passive: True
0.875	[*A*]posts[*R*]containing[*A*]pictures ( 19 % ) , with only 3 % of posts	context()	negated: False ,passive: False
[LINE#423] We found that the most frequent message types (text) formed a small proportion of total traffic (153KB in total and 82B on average out of total 2.3GB observed data) while the remainder of the data was almost equally split between picture messages (1.2GB in total and 3MB on average) and links (1.1GB in total and 18MB on average).
0.942	[*A*]the most frequent message types[*R*]formed[*A*]a small proportion of total traffic (153KB in total and 82B on average	context(We found)	negated: False ,passive: False
0.317	[*A*]We[*R*]found[*A*]that the most frequent message types (text) formed a small proportion of total traffic (153KB in total and 82B on average out of total 2.3GB	context()	negated: False ,passive: False
0.944	[*A*]the remainder of the data[*R*]almost equally split[*A*]between picture messages (1.2GB in total and 3MB on average) and links	context()	negated: False ,passive: True
0.964	[*A*]the remainder of the data[*R*]was[*A*]almost equally split between picture messages (1.2GB in total and 3MB on average) and links	context()	negated: False ,passive: True
[LINE#424] 8b illustrates the duration of time between posts for each users.
0.381	[*A*]8b[*R*]illustrates[*A*]the duration of time between posts for each users	context()	negated: False ,passive: False
[LINE#425] The most prolific participant posted every 3min on average, whilst the most inactive profile posted content once every 25days on average.
0.919	[*A*]the most inactive profile[*R*]posted[*A*]content[*A*]once[*A*]every 25days on average	context()	negated: False ,passive: False
0.919	[*A*]The most prolific participant[*R*]posted[*A*]every 3min	context()	negated: False ,passive: False
[LINE#426] We observed that nodes are connected to three friends on average and at most 2% of all other nodes.
0.665	[*A*]nodes[*R*]are connected	context(We observed)	negated: False ,passive: False
0.279	[*A*]We[*R*]observed[*A*]that nodes are connected to three friends on average and at most 2% of all other nodes	context()	negated: False ,passive: False
[LINE#427] We define "user profile" that contains statistical information such as: the ratio of text, picture and link messages, the average and standard deviation of message sizes for each message type and the average and standard deviation of message frequency information.
0.887	[*A*]user profile[*R*]contains[*A*]statistical information	context()	negated: False ,passive: False
0.287	[*A*]We[*R*]define[*A*]user profile" that contains statistical information such as: the ratio of text, picture and link messages, the average and standard deviation of message sizes for each message type and the average and standard deviation of message frequency information	context()	negated: False ,passive: False
[LINE#428] Formula (9) illustrates how we use the average and standard deviation values in order to generate a new and meaningful value for the next message generation time and message size.
0.399	[*A*]we[*R*]use the average and standard deviation values to generate[*A*]a new and meaningful value for the next message generation time and message size	context(Formula ( 9 illustrates we use)	negated: False ,passive: False
0.388	[*A*]we[*R*]use[*A*]the average and standard deviation values[*A*]in order	context(Formula ( 9 illustrates)	negated: False ,passive: False
0.887	[*A*]Formula (9[*R*]illustrates[*A*]how we use the average and standard deviation values in order	context()	negated: False ,passive: False
[LINE#429+430+431+432]   is the average of x,  is the standard deviation of x and W is a normally distributed random number between -1 and 1.(9)P(x)=0.5+(x)+((x)W)When a message is generated (or as the application starts)the next message is scheduled for generation.
0.732	[*A*]a message[*R*]is generated	context()	negated: False ,passive: False
0.926	[*A*]W[*R*]is[*A*]a normally distributed random number between -1 and 1	context()	negated: False ,passive: True
0.911	[*A*]the next message[*R*]is scheduled[*A*]for generation	context()	negated: False ,passive: True
0.784	[*A*]the application[*R*]starts	context()	negated: False ,passive: False
[LINE#433] When a new message is generated a message type is assigned, as per the observed message type distribution.
0.751	[*A*]a message type[*R*]is assigned	context()	negated: False ,passive: False
0.751	[*A*]a new message[*R*]is generated	context()	negated: False ,passive: False
[LINE#434] When the message type has been selected the message size can be assigned based on the relevant statistics.
0.948	[*A*]the message size[*R*]can be assigned[*A*]based on the relevant statistics[*A*]When the message type has been selected	context()	negated: False ,passive: True
0.751	[*A*]the message type[*R*]has been selected	context()	negated: False ,passive: False
[LINE#435] We run ten increments of congestion levels, decreasing the size of buffers from 100MB down to 10MB at 10MB increments.
0.678	[*A*]We[*R*]run[*A*]ten increments of congestion levels[*A*]decreasing the size of buffers from 100MB down to 10MB at 10MB increments	context()	negated: False ,passive: False
[LINE#436] We randomly select traffic profiles for the nodes to follow and simulate multiple runs with different random traffic profiles.
0.903	[*A*]the nodes[*R*]to simulate[*A*]multiple runs with different random traffic profiles	context()	negated: False ,passive: False
0.569	[*A*]We[*R*]randomly select[*A*]traffic profiles for the nodes to simulate multiple runs with different random traffic profiles	context()	negated: False ,passive: False
0.698	[*A*]traffic profiles[*R*]to follow	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]randomly select[*A*]traffic profiles for the nodes to follow	context()	negated: False ,passive: False
[LINE#437] Each experiment is emulated over 10 runs, with each run having a different random seed.
0.903	[*A*]each run[*R*]having[*A*]a different random seed	context()	negated: False ,passive: False
[LINE#438] Over the recent years the pervasiveness of mobile computing devices has increased significantly and the possibility of communication without an existing network infrastructure has become a reality.
0.948	[*A*]the possibility of communication without an existing network infrastructure[*R*]has become[*A*]a reality	context()	negated: False ,passive: True
0.961	[*A*]the pervasiveness of mobile computing devices[*R*]has increased[*A*]significantly[*A*]Over the recent years	context()	negated: False ,passive: True
[LINE#439+440]  Hsu and Helmy [18] showed that real world traces of different university campus wireless networksnode encounters are sufficient to build a connected relationship graph that can be successfully used for data transmission despite the absence of contemporaneous end-to-end paths.
0.942	[*A*]real world traces of different university campus wireless networksnode encounters[*R*]are[*A*]sufficient to build a connected relationship graph	context(Helmy showed)	negated: False ,passive: True
0.820	[*A*]Helmy[*R*]showed[*A*]that real world traces of different university campus wireless networksnode encounters are sufficient to build a connected relationship graph	context()	negated: False ,passive: False
0.942	[*A*]real world traces of different university campus wireless networksnode encounters[*R*]are[*A*]sufficient to build a connected relationship graph	context(Hsu showed)	negated: False ,passive: True
0.701	[*A*]Hsu[*R*]showed[*A*]that real world traces of different university campus wireless networksnode encounters are sufficient to build a connected relationship graph	context()	negated: False ,passive: False
0.939	[*A*]a connected relationship graph[*R*]can be successfully used[*A*]for data transmission[*A*]despite the absence of contemporaneous end - to - end paths	context()	negated: False ,passive: True
0.909	[*A*]real world traces of different university campus wireless networksnode encounters[*R*]to build[*A*]a connected relationship graph that can be successfully used for data transmission despite the absence of contemporaneous end - to - end paths	context()	negated: False ,passive: False
[LINE#441] Routing in these networks is a challenging problem and has been primarily concerned with providing maximum throughput and minimal delays while typically assuming unlimited storage and transfer bandwidth i.e. using forwarding algorithms that greedily select best connected nodes as their next hop [14,28].
0.164	[*A*]their hop[*R*]has next of[*A*]1428 ]	context()	negated: False ,passive: False
0.810	[*A*]forwarding algorithms[*R*]greedily select[*A*]best connected nodes[*A*]as their next hop	context()	negated: False ,passive: False
0.905	[*A*]Routing in these networks[*R*]concerned[*A*]with providing maximum throughput	context()	negated: False ,passive: True
0.919	[*A*]Routing in these networks[*R*]has been[*A*]primarily concerned with providing maximum throughput	context()	negated: False ,passive: True
0.937	[*A*]Routing in these networks[*R*]is[*A*]a challenging problem	context()	negated: False ,passive: True
[LINE#442] As mobile devices have limited resources, key nodes in the network quickly become congested and unusable and cause even more disconnections and even lower delivery rates.
0.903	[*A*]mobile devices[*R*]cause[*A*]even lower delivery rates	context()	negated: False ,passive: False
0.903	[*A*]mobile devices[*R*]cause[*A*]even more disconnections	context()	negated: False ,passive: False
0.814	[*A*]key nodes in the network[*R*]quickly become[*A*]unusable	context()	negated: False ,passive: True
0.814	[*A*]key nodes in the network[*R*]quickly become[*A*]congested	context()	negated: False ,passive: True
0.903	[*A*]mobile devices[*R*]have limited[*A*]resources	context()	negated: False ,passive: False
[LINE#443] Newly emerging work on congestion control in DTNs attempts to rectify this by proposing adaptive forwarding [14,31,15,30] or adaptive replication management [39,38,26,36,37] techniques.
0.164	[*A*]forwarding or replication management[*R*]has adaptive of[*A*]14311530	context()	negated: False ,passive: False
0.969	[*A*]Newly emerging work on congestion control[*R*]attempts[*A*]to rectify this by proposing adaptive forwarding [14,31,15,30] or adaptive replication management [39,38,26,36,37] techniques[*A*]in DTNs	context()	negated: False ,passive: False
[LINE#444] In our earlier work we proposed an adaptive forwarding protocol, Caf [14,31,15,30], that diverts the load away from its conventional centrality-driven path by considering congestion heuristics that route the traffic away from the congesting areas.
0.887	[*A*]congestion heuristics[*R*]route[*A*]the traffic[*A*]away from the congesting areas	context()	negated: False ,passive: False
0.838	[*A*]an adaptive forwarding protocol[*R*]diverts[*A*]the load[*A*]away from its conventional centrality-driven path	context()	negated: False ,passive: False
0.360	[*A*]we[*R*]proposed[*A*]an adaptive forwarding protocol, Caf [14,31,15,30], that diverts the load away from its conventional centrality-driven path by considering congestion heuristics[*A*]In our earlier work	context()	negated: False ,passive: False
[LINE#445] This approach is particularly suitable to social opportunistic networks as they have been shown to exhibit the path explosion phenomenon [9].
0.575	[*A*]they[*R*]to exhibit[*A*]the path explosion phenomenon	context()	negated: False ,passive: False
0.320	[*A*]they[*R*]have been shown	context()	negated: False ,passive: False
0.915	[*A*]This approach[*R*]is[*A*]particularly suitable to social opportunistic networks[*A*]as they have been shown to exhibit the path explosion phenomenon	context()	negated: False ,passive: True
[LINE#446] The main drawback of adaptive forwarding is that it does not decrease the total level of traffic in the network but only redirects it.
0.397	[*A*]it[*R*]does not decrease[*A*]the total level of traffic in the network	context(The main drawback of adaptive forwarding is)	negated: True ,passive: False
0.822	[*A*]The main drawback of adaptive forwarding[*R*]is[*A*]that it does not decrease the total level of traffic in the network but only redirects it	context()	negated: False ,passive: True
[LINE#447] This is suboptimal at times when finding alternative non-congested parts of the network is not possible.
0.967	[*A*]when finding alternative non-congested parts of the network[*R*]is not[*A*]possible[*A*]at times	context()	negated: True ,passive: True
0.223	[*A*]This[*R*]is[*A*]suboptimal	context()	negated: False ,passive: True
[LINE#448] Adaptive replication management techniques [39,38] can decrease the traffic in response to congestion, but they cannot adaptively offload the traffic from more congested to less congested parts of the network.
0.720	[*A*]they[*R*]can not adaptively offload[*A*]the traffic[*A*]from more congested to less congested parts of the network	context()	negated: True ,passive: False
0.905	[*A*]Adaptive replication management techniques[*R*]can decrease[*A*]the traffic[*A*]in response to congestion	context()	negated: False ,passive: False
[LINE#449+450]  This means that they cannot efficiently deal with scenarios when congestion affects some regions of the network (e.g. hotspots, roadside units) and not the others.
0.562	[*A*]they[*R*]can not efficiently deal[*A*]with scenarios	context(This means)	negated: True ,passive: False
0.089	[*A*]This[*R*]means[*A*]that they can not efficiently deal with scenarios	context()	negated: False ,passive: False
0.894	[*A*]congestion[*R*]affects not[*A*]the others	context()	negated: True ,passive: False
0.562	[*A*]they[*R*]can not efficiently deal[*A*]with scenarios[*A*]when congestion affects some regions of the network	context(This means)	negated: True ,passive: False
0.135	[*A*]This[*R*]means[*A*]that they can not efficiently deal with scenarios when congestion affects some regions of the network ( e.g. hotspots , roadside units	context()	negated: False ,passive: False
0.894	[*A*]congestion[*R*]affects[*A*]some regions of the network	context()	negated: False ,passive: False
[LINE#451] In this work we propose to unify adaptive forwarding and adaptive replication into a common congestion control framework for DTNs (CafRep) that manages to both decrease the load on the network and offload the traffic to the parts of the network that are less congested.
0.639	[*A*]we[*R*]propose[*A*]to adaptive replication[*A*]into a common congestion control framework for DTNs[*A*]In this work	context()	negated: False ,passive: False
0.788	[*A*]the parts of the network[*R*]are[*A*]less congested	context()	negated: False ,passive: True
0.945	[*A*]a common congestion control framework for DTNs[*R*]offload[*A*]the traffic[*A*]to the parts of the network	context()	negated: False ,passive: False
0.935	[*A*]a common congestion control framework for DTNs[*R*]manages[*A*]the load on the network	context()	negated: False ,passive: False
0.639	[*A*]we[*R*]propose[*A*]to unify adaptive forwarding[*A*]into a common congestion control framework for DTNs[*A*]In this work	context()	negated: False ,passive: False
[LINE#452] We achieve this by using a local based implicit heuristic based on contact and resource statistics that extends our previous work on adaptive forwarding [10-12].
0.168	[*A*]We[*R*]achieve this by using[*A*]a local based implicit heuristic based on resource statistics that extends our previous work on adaptive forwarding [ 10-12 ]	context(We achieve)	negated: False ,passive: False
0.894	[*A*]a local based implicit heuristic based on resource statistics[*R*]extends[*A*]our previous work on adaptive forwarding	context()	negated: False ,passive: True
0.168	[*A*]We[*R*]achieve this by using[*A*]a local based implicit heuristic based on contact statistics that extends our previous work on adaptive forwarding [ 10-12 ]	context(We achieve)	negated: False ,passive: False
0.183	[*A*]We[*R*]achieve[*A*]this	context()	negated: False ,passive: False
0.894	[*A*]a local based implicit heuristic based on contact statistics[*R*]extends[*A*]our previous work on adaptive forwarding	context()	negated: False ,passive: True
[LINE#453] More specifically, we propose to dynamically combine three types of heuristics: node centrality and contact analysis driven heuristics that exploits contact relationships to allow optimal directionality and delivery probability of a node; node resource driven and ego network driven heuristics to adapt to the nodes and parts of the network's buffer availability, delays or congesting rates.
0.920	[*A*]heuristics[*R*]exploits[*A*]contact relationships[*A*]to allow optimal directionality and delivery probability of a node; node resource driven and ego network driven heuristics	context()	negated: False ,passive: False
0.737	[*A*]three types of heuristics[*R*]driven	context()	negated: False ,passive: False
0.920	[*A*]ego network[*R*]driven heuristics to adapt[*A*]to the nodes and parts of the network's buffer availability, delays or congesting rates	context(ego network driven)	negated: False ,passive: False
0.920	[*A*]ego network[*R*]driven[*A*]heuristics[*A*]to adapt to the nodes and parts of the network's buffer availability, delays or congesting rates	context()	negated: False ,passive: False
[LINE#454] As a result, our new framework adaptively changes forwarding and replication behaviour to best manage tradeoffs across multiple contact and resource attributes of nodes in real network scenarios with different mobility, and connectivity patterns.
0.903	[*A*]replication behaviour[*R*]to best manage[*A*]tradeoffs	context()	negated: False ,passive: False
0.903	[*A*]replication behaviour[*R*]to best manage[*A*]tradeoffs across multiple contact	context()	negated: False ,passive: False
0.406	[*A*]our new framework[*R*]adaptively changes[*A*]forwarding	context()	negated: False ,passive: False
[LINE#455] aware DTN protocols has either focused on the homogeneous networks where the authors assumed nodes to have the same amount of resources on their devices [51] or looked at only one connectivity trace [15,39].
0.796	[*A*]the authors[*R*]assumed nodes to have[*A*]the same amount of resources on their devices	context(the authors assumed)	negated: False ,passive: False
0.918	[*A*]the authors[*R*]assumed[*A*]nodes[*A*]to have the same amount of resources on their devices[*A*]the homogeneous networks	context()	negated: False ,passive: False
0.887	[*A*]the authors[*R*]looked[*A*]at only one connectivity trace	context()	negated: False ,passive: False
0.901	[*A*]aware DTN protocols[*R*]has focused[*A*]on the homogeneous networks	context()	negated: False ,passive: False
[LINE#456] However, it is not realistic to assume network homogeneity as mobile devices can be used in different ways, move in different ways and do not consume their resources at the same rates.
0.835	[*A*]mobile devices[*R*]do not consume[*A*]their resources	context()	negated: True ,passive: False
0.732	[*A*]mobile devices[*R*]can be used	context()	negated: False ,passive: False
[LINE#457] In this paper we explore how a more intelligent resource aware model, reflective of the heterogeneity of devices' resources, and non-uniform connectivity patterns, and application demands can improve data delivery and dissemination in the network.
0.905	[*A*]a more intelligent application demands[*R*]can improve[*A*]data dissemination	context(we explore)	negated: False ,passive: False
0.645	[*A*]we[*R*]explore[*A*]how a more intelligent application demands can improve data dissemination in the network[*A*]In this paper	context()	negated: False ,passive: False
0.905	[*A*]a more intelligent application demands[*R*]can improve[*A*]data delivery in the network	context(we explore)	negated: False ,passive: False
0.645	[*A*]we[*R*]explore[*A*]how a more intelligent application demands can improve data delivery in the network[*A*]In this paper	context()	negated: False ,passive: False
0.888	[*A*]non-uniform connectivity patterns[*R*]can improve[*A*]data dissemination	context(we explore)	negated: False ,passive: False
0.645	[*A*]we[*R*]explore[*A*]how non-uniform connectivity patterns can improve data dissemination in the network[*A*]In this paper	context()	negated: False ,passive: False
0.888	[*A*]non-uniform connectivity patterns[*R*]can improve[*A*]data delivery in the network	context(we explore)	negated: False ,passive: False
0.645	[*A*]we[*R*]explore[*A*]how non-uniform connectivity patterns can improve data delivery in the network[*A*]In this paper	context()	negated: False ,passive: False
0.962	[*A*]a more intelligent resource aware model , reflective of the heterogeneity of devices ' resources[*R*]can improve[*A*]data dissemination	context(we explore)	negated: False ,passive: False
0.645	[*A*]we[*R*]explore[*A*]how a more intelligent resource aware model , reflective of the heterogeneity of devices ' resources can improve data dissemination in the network[*A*]In this paper	context()	negated: False ,passive: False
0.962	[*A*]a more intelligent resource aware model , reflective of the heterogeneity of devices ' resources[*R*]can improve[*A*]data delivery in the network	context(we explore)	negated: False ,passive: False
0.645	[*A*]we[*R*]explore[*A*]how a more intelligent resource aware model , reflective of the heterogeneity of devices ' resources can improve data delivery in the network[*A*]In this paper	context()	negated: False ,passive: False
[LINE#458+459]  Section 2 discusses the lessons learned and shortcomings of DTN forwarding, replication, load distribution and congestion control approaches further, together with state of the art work from related areas such as MANET congestion control, resource pooling, Peer-to-Peer(P2P), as well as an algorithmic game theory perspective of selfish forwarding and routing.
0.947	[*A*]Section 2[*R*]discusses[*A*]the lessons learned , together with state of the art work from related areas such as MANET congestion control , resource pooling , Peer - to an algorithmic game theory perspective of selfish routing	context()	negated: False ,passive: False
0.947	[*A*]Section 2[*R*]discusses[*A*]the lessons learned , together with state of the art work from related areas such as MANET congestion control , resource pooling , Peer - to an algorithmic game theory perspective of selfish forwarding	context()	negated: False ,passive: False
0.903	[*A*]Section 2[*R*]discusses[*A*]the lessons shortcomings of congestion control approaches further	context()	negated: False ,passive: False
0.903	[*A*]Section 2[*R*]discusses[*A*]the lessons shortcomings of load distribution	context()	negated: False ,passive: False
0.903	[*A*]Section 2[*R*]discusses[*A*]the lessons shortcomings of replication	context()	negated: False ,passive: False
0.918	[*A*]Section 2[*R*]discusses[*A*]the lessons shortcomings of DTN forwarding	context()	negated: False ,passive: False
0.732	[*A*]the lessons[*R*]learned	context()	negated: False ,passive: False
0.947	[*A*]Section 2[*R*]discusses[*A*]the lessons learned , together with state of the art work from related areas such as MANET congestion control , resource pooling	context()	negated: False ,passive: False
[LINE#460] Section 3 specifies the particular challenges in opportunistic delay-tolerant networks that prevent successful data delivery and identifies our criteria that guide our proposal for congestion control framework for adaptive replication and forwarding - CafRep.
0.610	[*A*]our criteria[*R*]guide[*A*]our proposal for congestion control framework for forwarding - CafRep	context()	negated: False ,passive: False
0.781	[*A*]Section 3[*R*]identifies[*A*]our criteria that guide our proposal for congestion control framework for forwarding - CafRep	context()	negated: False ,passive: False
0.447	[*A*]our criteria[*R*]guide[*A*]our proposal for congestion control framework for adaptive replication	context()	negated: False ,passive: False
0.748	[*A*]Section 3[*R*]identifies[*A*]our criteria that guide our proposal for congestion control framework for adaptive replication	context()	negated: False ,passive: False
0.913	[*A*]opportunistic delay - tolerant networks[*R*]prevent[*A*]successful data delivery	context()	negated: False ,passive: False
0.903	[*A*]Section 3[*R*]specifies[*A*]the particular challenges in opportunistic delay - tolerant networks	context()	negated: False ,passive: False
[LINE#461] We present an analytical model that identifies fundamental problems regarding traffic distribution and shortest path forwarding heuristics in relation to the traffic flow and the price of anarchy.
0.903	[*A*]shortest path[*R*]forwarding[*A*]heuristics in relation to the price of anarchy	context()	negated: False ,passive: False
0.903	[*A*]shortest path[*R*]forwarding[*A*]heuristics in relation to the traffic flow	context()	negated: False ,passive: False
0.897	[*A*]an analytical model[*R*]identifies[*A*]fundamental problems regarding shortest path	context()	negated: False ,passive: False
0.326	[*A*]We[*R*]present[*A*]an analytical model that identifies fundamental problems regarding shortest path	context()	negated: False ,passive: False
0.897	[*A*]an analytical model[*R*]identifies[*A*]fundamental problems regarding traffic distribution	context()	negated: False ,passive: False
0.326	[*A*]We[*R*]present[*A*]an analytical model that identifies fundamental problems regarding traffic distribution	context()	negated: False ,passive: False
[LINE#462] Modelling the behaviour of opportunistic networks is a challenging because of time varying network topology and congestion, and thus we integrate the concepts of a time varying networks [12,35] and dynamic flows [13].
0.452	[*A*]we[*R*]integrate[*A*]the concepts of a time	context()	negated: False ,passive: False
0.894	[*A*]time[*R*]varying[*A*]network congestion	context()	negated: False ,passive: True
0.948	[*A*]Modelling the behaviour of opportunistic networks[*R*]is[*A*]a challenging[*A*]because of time varying network congestion	context()	negated: False ,passive: True
0.894	[*A*]time[*R*]varying[*A*]network topology	context()	negated: False ,passive: True
0.948	[*A*]Modelling the behaviour of opportunistic networks[*R*]is[*A*]a challenging[*A*]because of time varying network topology	context()	negated: False ,passive: True
[LINE#463] We describe the design space of our proposal, give multi-layer architectural overview of our conceptual model and CafRep pseudo code.
0.456	[*A*]We[*R*]give[*A*]multi-layer[*A*]architectural overview of CafRep pseudo code	context()	negated: False ,passive: False
0.274	[*A*]We[*R*]give[*A*]multi-layer[*A*]architectural overview of our conceptual model	context()	negated: False ,passive: False
0.309	[*A*]We[*R*]describe[*A*]the design space of our proposal	context()	negated: False ,passive: False
[LINE#464+465]  We identify and describe the core congestion signals, heuristics and techniques that are at the core of our proposal and allow adaptive dissemination of messages throughout the network such that we address our criteriai.e. allow spreading the traffic across multiple paths whilst avoiding congested regions and minimising delays and network overheads.
0.810	[*A*]the techniques[*R*]are[*A*]at the core of our proposal	context()	negated: False ,passive: True
0.810	[*A*]the heuristics[*R*]are[*A*]at the core of our proposal	context()	negated: False ,passive: True
0.838	[*A*]the core congestion signals[*R*]are[*A*]at the core of our proposal	context()	negated: False ,passive: True
0.301	[*A*]We[*R*]identify such that we address our criteriai.e allow spreading[*A*]the traffic[*A*]across multiple paths	context(We identify)	negated: False ,passive: False
0.116	[*A*]We[*R*]identify[*A*]such that we address our criteriai.e	context()	negated: False ,passive: False
0.309	[*A*]we[*R*]address[*A*]our criteriai.e	context()	negated: False ,passive: False
[LINE#466] We extend our previous work by discussing the impact of a number of different CafRep utility weighting schemes on the protocol performance over varying network topologies.
0.550	[*A*]We[*R*]extend our previous work by discussing[*A*]the impact of a number of different CafRep utility weighting schemes on the protocol performance over varying network topologies	context(We extend)	negated: False ,passive: False
0.399	[*A*]We[*R*]extend[*A*]our previous work[*A*]by discussing the impact of a number of different CafRep utility weighting schemes on the protocol performance over varying network topologies	context()	negated: False ,passive: False
[LINE#467] Section 4 describes our evaluation methodology.
0.835	[*A*]Section 4[*R*]describes[*A*]our evaluation methodology	context()	negated: False ,passive: False
[LINE#468] As nodes' encounter patterns can greatly differ for social and vehicular networks, it is important to evaluate our CafRep protocol across different real traces from CRAWDAD [1] in order to gain better understanding of our protocol performance.
0.769	[*A*]nodes ' encounter patterns[*R*]can greatly differ	context()	negated: False ,passive: False
[LINE#469] Section 4 begins by discussing the heterogeneity of the three chosen real connectivity and GPS traces.
0.918	[*A*]Section 4[*R*]begins[*A*]by discussing the heterogeneity of the GPS traces	context()	negated: False ,passive: True
0.937	[*A*]Section 4[*R*]begins[*A*]by discussing the heterogeneity of the three chosen real connectivity	context()	negated: False ,passive: True
[LINE#470] We then motivate the use of two different application scenarios: publish subscribe podcasting and real Facebook application.
0.535	[*A*]publish[*R*]subscribe[*A*]real Facebook application	context()	negated: False ,passive: False
0.499	[*A*]We[*R*]motivate[*A*]the use of two different application scenarios[*A*]then	context(publish subscribe)	negated: False ,passive: False
0.489	[*A*]publish[*R*]subscribe[*A*]podcasting	context()	negated: False ,passive: False
[LINE#471]  Section 5 discussed our extensive evaluation of CafRep against some of the major state of the art.
0.859	[*A*]Section 5[*R*]discussed[*A*]our extensive evaluation of CafRep	context()	negated: False ,passive: False
[LINE#472]  DTN protocols including a benchmark DTN forwarding algorithm Prophet [23], an adaptive forwarding algorithm Caf [31], a fixed replication algorithm Spray and Focus (SF) [37] and two adaptive replication algorithms Encounter.
[LINE#473] Based Routing (EBR) [26] and Retiring Replicants (RRs) [38].
[LINE#474] We consider seven different metrics for the performance analysis of the protocols including success ratio, delay, buffer availability, packet loss rates, number of forwarded and replicated packets, and delivery cost.
0.569	[*A*]We[*R*]consider[*A*]seven different metrics for the performance analysis of the protocols including number of replicated packets	context()	negated: False ,passive: False
0.569	[*A*]We[*R*]consider[*A*]seven different metrics for the performance analysis of the protocols including number of forwarded	context()	negated: False ,passive: False
0.569	[*A*]We[*R*]consider[*A*]seven different metrics for the performance analysis of the protocols including delivery cost	context()	negated: False ,passive: False
0.569	[*A*]We[*R*]consider[*A*]seven different metrics for the performance analysis of the protocols including packet loss rates	context()	negated: False ,passive: False
0.569	[*A*]We[*R*]consider[*A*]seven different metrics for the performance analysis of the protocols including buffer availability	context()	negated: False ,passive: False
0.569	[*A*]We[*R*]consider[*A*]seven different metrics for the performance analysis of the protocols including delay	context()	negated: False ,passive: False
0.569	[*A*]We[*R*]consider[*A*]seven different metrics for the performance analysis of the protocols including success ratio	context()	negated: False ,passive: False
[LINE#475] We show that our protocol outperforms all four other algorithms across majority of metrics across the three chosen heterogeneous traces that have different mobility and connectivity patterns.
0.913	[*A*]the three chosen heterogeneous traces[*R*]have[*A*]different connectivity patterns	context()	negated: False ,passive: False
0.694	[*A*]our protocol[*R*]outperforms[*A*]all four other algorithms across majority of metrics across the three chosen heterogeneous traces	context(We show)	negated: False ,passive: False
0.218	[*A*]We[*R*]show[*A*]that our protocol outperforms all four other algorithms across majority of metrics across the three chosen heterogeneous traces	context()	negated: False ,passive: False
0.913	[*A*]the three chosen heterogeneous traces[*R*]have[*A*]different mobility	context()	negated: False ,passive: False
[LINE#476] We identify differences in protocols' performances across the different traces and discuss multiple reasons for causing that.
0.452	[*A*]We[*R*]identify[*A*]differences in protocols ' performances across the different traces	context()	negated: False ,passive: False
[LINE#477] We briefly describe the results with the different Facebook traffic types that show that regardless of the type of traffic CafRep aims to deliver, it reduces congestion and improves forwarding performance in the network.
0.934	[*A*]the different Facebook traffic types[*R*]improves[*A*]forwarding performance in the network	context()	negated: False ,passive: False
0.730	[*A*]CafRep[*R*]aims to deliver to deliver	context(CafRep aims)	negated: False ,passive: False
0.764	[*A*]CafRep[*R*]aims[*A*]to deliver	context()	negated: False ,passive: False
0.388	[*A*]it[*R*]reduces[*A*]congestion	context(the different Facebook traffic types show)	negated: False ,passive: False
0.848	[*A*]the different Facebook traffic types[*R*]show[*A*]that regardless of the type of traffic CafRep aims to deliver , it reduces congestion	context()	negated: False ,passive: False
0.498	[*A*]We[*R*]briefly describe[*A*]the results with the different Facebook traffic types	context()	negated: False ,passive: False
[LINE#478] Section 6 concludes the work and presents the open questions for future work.
0.903	[*A*]Section 6[*R*]presents[*A*]the open questions for future work	context()	negated: False ,passive: False
0.903	[*A*]Section 6[*R*]concludes[*A*]the work	context()	negated: False ,passive: False
[LINE#479] N forwarding, replication, load distribution and congestion controlThis section discusses the most recent advances in message replication and forwarding for DTNs.
0.938	[*A*]controlThis section[*R*]discusses[*A*]the most recent advances in message forwarding for DTNs	context()	negated: False ,passive: False
0.927	[*A*]controlThis section[*R*]discusses[*A*]the most recent advances in message replication	context()	negated: False ,passive: False
0.911	[*A*]congestion[*R*]discusses[*A*]the most recent advances in message forwarding for DTNs	context()	negated: False ,passive: False
0.894	[*A*]congestion[*R*]discusses[*A*]the most recent advances in message replication	context()	negated: False ,passive: False
0.918	[*A*]load distribution[*R*]discusses[*A*]the most recent advances in message forwarding for DTNs	context()	negated: False ,passive: False
0.903	[*A*]load distribution[*R*]discusses[*A*]the most recent advances in message replication	context()	negated: False ,passive: False
0.911	[*A*]replication[*R*]discusses[*A*]the most recent advances in message forwarding for DTNs	context()	negated: False ,passive: False
0.894	[*A*]replication[*R*]discusses[*A*]the most recent advances in message replication	context()	negated: False ,passive: False
0.943	[*A*]the most recent advances in message[*R*]forwarding[*A*]for DTNs	context()	negated: False ,passive: False
0.918	[*A*]N forwarding[*R*]discusses[*A*]the most recent advances in message forwarding for DTNs	context()	negated: False ,passive: False
0.903	[*A*]N forwarding[*R*]discusses[*A*]the most recent advances in message replication	context()	negated: False ,passive: False
[LINE#480] Early work in this area focuses primarily on the challenge of reducing the delivery latency and cost with the underlying assumption of unlimited transfer and storage capacity [40,23,17,8,36,37,25].
0.952	[*A*]Early work in this area[*R*]focuses primarily[*A*]on the challenge of reducing the cost with the underlying assumption of unlimited storage capacity	context()	negated: False ,passive: False
0.952	[*A*]Early work in this area[*R*]focuses primarily[*A*]on the challenge of reducing the cost with the underlying assumption of unlimited transfer capacity	context()	negated: False ,passive: False
0.952	[*A*]Early work in this area[*R*]focuses primarily[*A*]on the challenge of reducing the delivery latency with the underlying assumption of unlimited storage capacity	context()	negated: False ,passive: False
0.952	[*A*]Early work in this area[*R*]focuses primarily[*A*]on the challenge of reducing the delivery latency with the underlying assumption of unlimited transfer capacity	context()	negated: False ,passive: False
[LINE#481]  The majority of research in congestion control for DTNs is concerned with buffer management [6,22,24,34], but recent developments have been concerned with replication management [34,39,30] and distribution [26,28,15].Encounter.
0.932	[*A*]6,22,24,34 ] , but recent developments[*R*]have been concerned[*A*]with replication management	context()	negated: False ,passive: True
0.903	[*A*]recent developments[*R*]have been concerned[*A*]with replication management	context()	negated: False ,passive: True
0.961	[*A*]The majority of research in congestion control for DTNs[*R*]is concerned[*A*]with buffer management	context()	negated: False ,passive: True
[LINE#482] Based Routing (EBR) proposed in [26] is a quota based replication protocol that aims to forward more copies of a message to nodes that are better connected.
0.890	[*A*]a quota based replication protocol[*R*]aims to forward[*A*]more copies of a message[*A*]to nodes	context(a quota based replication protocol aims)	negated: False ,passive: False
0.890	[*A*]a quota based replication protocol[*R*]aims[*A*]to forward more copies of a message to nodes	context()	negated: False ,passive: False
0.892	[*A*]Based Routing[*R*]is[*A*]a quota based replication protocol that aims to forward more copies of a message to nodes	context()	negated: False ,passive: True
0.716	[*A*]nodes[*R*]are[*A*]better connected	context()	negated: False ,passive: True
0.790	[*A*]Based Routing[*R*]proposed[*A*]in [26	context()	negated: False ,passive: True
[LINE#483] The introduction of limited resources and increasing traffic demands cause key components in the network to become congested, which in turn leads to messages being dropped.
0.754	[*A*]increasing traffic demands[*R*]to become[*A*]congested	context()	negated: False ,passive: True
0.911	[*A*]increasing traffic demands[*R*]cause[*A*]key components in the network	context()	negated: False ,passive: False
0.713	[*A*]messages[*R*]being dropped	context()	negated: False ,passive: False
0.814	[*A*]key components in the network[*R*]to become[*A*]congested	context()	negated: False ,passive: True
0.926	[*A*]The introduction of limited resources[*R*]cause[*A*]key components in the network	context()	negated: False ,passive: False
[LINE#484] Retiring Replicas (RRs) [38] is an adaptive replication protocol that adjusts a nodes' copy limit based on the locally perceived global level of congestion.
0.905	[*A*]an adaptive replication protocol[*R*]adjusts[*A*]a nodes' copy limit	context()	negated: False ,passive: False
0.892	[*A*]Retiring Replicas[*R*]is[*A*]an adaptive replication protocol that adjusts a nodes' copy limit based on the locally perceived global level of congestion	context()	negated: False ,passive: True
[LINE#485+486]  RR proposes the nodes to create their own congestion viewas the ratio of drops and duplicate deliveries and compare it to the congestion threshold.
0.711	[*A*]RR[*R*]proposes the nodes to create[*A*]their own congestion viewas the duplicate deliveries	context(RR proposes)	negated: False ,passive: False
0.711	[*A*]RR[*R*]proposes[*A*]the nodes[*A*]to create their own congestion	context()	negated: False ,passive: False
[LINE#487] Depending on the comparison the copy limit for new messages is lowered or raised following a back-off algorithm.
0.921	[*A*]the copy limit for new messages[*R*]raised[*A*]following a back-off algorithm	context()	negated: False ,passive: True
0.801	[*A*]the copy limit for new messages[*R*]is lowered	context()	negated: False ,passive: False
[LINE#488] This work assumes a uniform network with random waypoint mobility.
0.903	[*A*]This work[*R*]assumes[*A*]a uniform network with random waypoint mobility	context()	negated: False ,passive: False
[LINE#489] In reality the networks are likely to be non-uniform and the level of congestion may vary between different regions of the network.
0.769	[*A*]the level of congestion[*R*]may vary	context()	negated: False ,passive: False
0.735	[*A*]the networks[*R*]to be[*A*]non-uniform	context()	negated: False ,passive: True
0.943	[*A*]the networks[*R*]are[*A*]likely to be non-uniform[*A*]In reality	context()	negated: False ,passive: True
[LINE#490] This work has not proposed how the network adjustments would compensate for differing local conditions.
0.888	[*A*]the network adjustments[*R*]would compensate[*A*]for differing local conditions	context(This work has not proposed)	negated: False ,passive: False
0.920	[*A*]This work[*R*]has not proposed[*A*]how the network adjustments would compensate for differing local conditions	context()	negated: True ,passive: False
[LINE#491] In Cafe [15] we proposed and examined several combined social and resources heuristics in order to detect congested parts of the network and move the traffic away towards less congested parts.
0.639	[*A*]we[*R*]examined[*A*]several combined resources heuristics[*A*]in order[*A*]In Cafe [ 15	context()	negated: False ,passive: False
0.639	[*A*]we[*R*]examined[*A*]several combined social heuristics[*A*]in order[*A*]In Cafe [ 15	context()	negated: False ,passive: False
0.596	[*A*]we[*R*]proposed[*A*]In Cafe [ 15	context()	negated: False ,passive: False
[LINE#492] These heuristics include social, delay and buffer metric of nodes and their ego networks.
0.835	[*A*]These heuristics[*R*]include[*A*]buffer metric of their ego networks	context()	negated: False ,passive: True
0.903	[*A*]These heuristics[*R*]include[*A*]buffer metric of nodes	context()	negated: False ,passive: True
0.835	[*A*]These heuristics[*R*]include[*A*]delay metric of their ego networks	context()	negated: False ,passive: True
0.903	[*A*]These heuristics[*R*]include[*A*]delay metric of nodes	context()	negated: False ,passive: True
0.835	[*A*]These heuristics[*R*]include[*A*]social metric of their ego networks	context()	negated: False ,passive: True
0.903	[*A*]These heuristics[*R*]include[*A*]social metric of nodes	context()	negated: False ,passive: True
[LINE#493] The total combined utility function we propose is at the core of our adaptive forwarding protocol that is dynamic and flexible as it operates as a pure social (contact driven) protocol at times of low congestion but is highly resource driven at times of high congestion.
0.195	[*A*]it[*R*]operates	context()	negated: False ,passive: False
0.458	[*A*]our adaptive forwarding protocol[*R*]is[*A*]dynamic and flexible	context()	negated: False ,passive: True
0.673	[*A*]The total combined utility function we propose[*R*]is[*A*]at the core of our adaptive forwarding protocol	context()	negated: False ,passive: True
0.911	[*A*]The total combined utility function[*R*]propose[*A*]we	context()	negated: False ,passive: True
0.876	[*A*]contact[*R*]driven[*A*]protocol at times of low congestion	context()	negated: False ,passive: False
[LINE#494] We show that our single copy adaptive forwarding protocol achieves better performance in comparison to multi-copy protocols such as spray and wait (SW) [36], Spray and Focus (SF) [37], Prophet [20] and epidemic protocols in terms of decreased delays, higher availability of nodes and higher success ratios.
0.285	[*A*]We[*R*]show[*A*]that higher availability of higher success ratios	context()	negated: False ,passive: False
0.285	[*A*]We[*R*]show[*A*]that higher availability of nodes	context()	negated: False ,passive: False
0.243	[*A*]We[*R*]show	context()	negated: False ,passive: False
0.999	[*A*]We[*R*]show[*A*]36 ] prophet [ 20 ] protocols	context()	negated: False ,passive: False
0.435	[*A*]We[*R*]show[*A*]that wait ( SW ) [ 36 ] Prophet [ 20 ] protocols in terms of decreased delays	context()	negated: False ,passive: False
0.999	[*A*]We[*R*]show[*A*]36 ] focus protocols	context()	negated: False ,passive: False
0.435	[*A*]We[*R*]show[*A*]that wait ( SW ) [ 36 ] Focus protocols in terms of decreased delays	context()	negated: False ,passive: False
0.902	[*A*]Spray[*R*]protocols[*A*]in terms of decreased delays	context(We show)	negated: False ,passive: False
0.278	[*A*]We[*R*]show[*A*]that wait ( SW ) [ 36	context()	negated: False ,passive: False
0.675	[*A*]our single copy adaptive forwarding protocol[*R*]achieves[*A*]better performance[*A*]in comparison to multi-copy protocols such as spray	context(We show)	negated: False ,passive: False
0.218	[*A*]We[*R*]show[*A*]that our single copy adaptive forwarding protocol achieves better performance in comparison to multi-copy protocols such as spray	context()	negated: False ,passive: False
[LINE#495] In [30] we built an interest-driven P2P content dissemination overlay on the top of our congestion aware forwarding protocol.
0.490	[*A*]we[*R*]built[*A*]an interest-driven P2P content dissemination overlay[*A*]on the top of our congestion aware forwarding protocol[*A*]In [30	context()	negated: False ,passive: False
[LINE#496] Both caching and forwarding policies are decided based on the interest, availability, social closeness and numbers of interested nodes.
0.903	[*A*]forwarding policies[*R*]are decided[*A*]based on the numbers of interested nodes	context()	negated: False ,passive: True
0.903	[*A*]forwarding policies[*R*]are decided[*A*]based on the social closeness	context()	negated: False ,passive: True
0.903	[*A*]forwarding policies[*R*]are decided[*A*]based on the availability	context()	negated: False ,passive: True
0.903	[*A*]forwarding policies[*R*]are decided[*A*]based on the interest	context()	negated: False ,passive: True
0.911	[*A*]Both caching policies[*R*]are decided[*A*]based on the numbers of interested nodes	context()	negated: False ,passive: True
0.911	[*A*]Both caching policies[*R*]are decided[*A*]based on the social closeness	context()	negated: False ,passive: True
0.911	[*A*]Both caching policies[*R*]are decided[*A*]based on the availability	context()	negated: False ,passive: True
0.911	[*A*]Both caching policies[*R*]are decided[*A*]based on the interest	context()	negated: False ,passive: True
[LINE#497] Our results show that our adaptive overlay manages to maintain high success ratio of answered queries, high availability of intermediary nodes and short download times for a P2P file casting application running in the face of increasing number of file publishers and topic popularity.
0.933	[*A*]a P2P file[*R*]casting[*A*]application	context()	negated: False ,passive: False
0.609	[*A*]our adaptive overlay[*R*]manages to maintain[*A*]high success ratio of answered queries	context(Our results show our adaptive overlay manages)	negated: False ,passive: False
0.609	[*A*]our adaptive overlay[*R*]manages[*A*]to maintain high success ratio of answered queries	context(Our results show)	negated: False ,passive: False
0.373	[*A*]Our results[*R*]show[*A*]that our adaptive overlay manages to maintain high success ratio of answered queries	context()	negated: False ,passive: False
[LINE#498] FairRoute [28] argues that considering only contact histories to define contact duration, frequency and interaction strength cannot achieve balanced traffic distribution.
0.930	[*A*]considering only contact histories to define interaction strength[*R*]can not achieve[*A*]balanced traffic distribution	context(FairRoute argues)	negated: True ,passive: False
0.820	[*A*]FairRoute[*R*]argues[*A*]that considering only contact histories to define interaction strength can not achieve balanced traffic distribution	context()	negated: False ,passive: False
0.911	[*A*]only contact histories[*R*]to define[*A*]interaction strength	context()	negated: False ,passive: False
0.924	[*A*]considering only contact histories to define frequency[*R*]can not achieve[*A*]balanced traffic distribution	context(FairRoute argues)	negated: True ,passive: False
0.820	[*A*]FairRoute[*R*]argues[*A*]that considering only contact histories to define frequency can not achieve balanced traffic distribution	context()	negated: False ,passive: False
0.911	[*A*]only contact histories[*R*]to define[*A*]frequency	context()	negated: False ,passive: False
0.930	[*A*]considering only contact histories to define contact duration[*R*]can not achieve[*A*]balanced traffic distribution	context(FairRoute argues)	negated: True ,passive: False
0.820	[*A*]FairRoute[*R*]argues[*A*]that considering only contact histories to define contact duration can not achieve balanced traffic distribution	context()	negated: False ,passive: False
0.911	[*A*]only contact histories[*R*]to define[*A*]contact duration	context()	negated: False ,passive: False
[LINE#499] FairRoute proposes nodes queue length to be evaluated in order to allow nodes to only forward to contacts with a bigger queue size, but this does not avoid congesting popular nodes and leads to packets being dropped.
0.713	[*A*]packets[*R*]being dropped	context()	negated: False ,passive: False
0.920	[*A*]FairRoute[*R*]leads[*A*]to packets being dropped	context()	negated: False ,passive: False
0.321	[*A*]this[*R*]does not avoid congesting[*A*]popular nodes	context(this does not avoid)	negated: True ,passive: False
0.321	[*A*]this[*R*]does not avoid[*A*]congesting popular nodes	context()	negated: True ,passive: False
0.911	[*A*]nodes queue length[*R*]to be evaluated[*A*]in order	context()	negated: False ,passive: True
0.920	[*A*]FairRoute[*R*]proposes[*A*]nodes queue length	context()	negated: False ,passive: False
[LINE#500] Storage Routing (SR) [34] avoids congested nodes dropping packets by sending a set of messages out to neighbours with available storage, when buffer capacity is free these are retrieved.
0.878	[*A*]congested nodes[*R*]dropping packets by sending[*A*]a set of messages[*A*]out	context(congested nodes dropping)	negated: False ,passive: False
0.878	[*A*]congested nodes[*R*]dropping[*A*]packets	context()	negated: False ,passive: False
0.260	[*A*]these[*R*]are retrieved	context()	negated: False ,passive: False
0.813	[*A*]buffer capacity[*R*]is[*A*]free	context()	negated: False ,passive: True
[LINE#501] This protocol only temporarily alleviates congestion as it relies on contacts that are present not suffering from congestion themselves.
0.716	[*A*]contacts[*R*]are[*A*]present	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]relies[*A*]on contacts	context()	negated: False ,passive: False
0.884	[*A*]This protocol[*R*]alleviates[*A*]congestion[*A*]as it relies on contacts[*A*]only temporarily	context()	negated: False ,passive: False
[LINE#502+503]  Autonomous Congestion Control (ACC)[6] implements congestion control by apply a financial model to buffer space management, in order to propagate buffer utilisation stress backwards through the network to the source nodes.
0.922	[*A*]Autonomous Congestion Control[*R*]by apply[*A*]a financial model[*A*]to buffer space management	context()	negated: False ,passive: False
[LINE#504+505]  This work does not overcome intermediary/source nodes filling their own buffers and isolating peripheral nodes.[38]propose DA-SW (Density-Aware Spray-and-Wait), that is a measurement-oriented variant of the spray-and-wait [36] algorithm that dynamically determines the number of a messages disseminated in the network in order to achieve constant delay.
0.878	[*A*]This work[*R*]does not overcome[*A*]intermediary / source nodes isolating peripheral nodes	context(that is)	negated: True ,passive: False
0.919	[*A*]intermediary / source nodes[*R*]isolating[*A*]peripheral nodes	context()	negated: False ,passive: False
0.903	[*A*]This work[*R*]does not overcome[*A*]intermediary / source nodes isolating peripheral nodes	context()	negated: True ,passive: False
0.802	[*A*]This work[*R*]does not overcome[*A*]intermediary / source nodes filling their own buffers	context(that is)	negated: True ,passive: False
0.999	[*A*]This work[*R*]does not overcome[*A*]38 ]	context()	negated: False ,passive: False
0.136	[*A*]that[*R*]dynamically determines[*A*]the number of a messages	context()	negated: False ,passive: False
0.173	[*A*]that[*R*]is[*A*]a measurement - oriented variant of the - wait	context()	negated: False ,passive: True
0.835	[*A*]This work[*R*]does not overcome[*A*]intermediary / source nodes filling their own buffers	context()	negated: True ,passive: False
0.943	[*A*]the spray - [ 36 ] algorithm that[*R*]dynamically determines[*A*]the number of a messages	context()	negated: False ,passive: False
0.796	[*A*]This work[*R*]does not overcome[*A*]intermediary / source nodes filling their own buffers	context(that is)	negated: True ,passive: False
0.086	[*A*]that[*R*]is[*A*]a measurement - oriented variant of the spray - [ 36 ] algorithm that dynamically determines the number of a messages	context()	negated: False ,passive: True
0.860	[*A*]intermediary / source nodes[*R*]filling[*A*]their own buffers	context()	negated: False ,passive: False
0.903	[*A*]a messages[*R*]disseminated[*A*]in the network[*A*]in order	context()	negated: False ,passive: True
[LINE#506] DA-SW relies on the current average node degree in the roller tour.
0.920	[*A*]DA-SW[*R*]relies[*A*]on the current average node degree in the roller tour	context()	negated: False ,passive: False
[LINE#507] Whenever a node has a bundle to transmit, it computes its current connectivity degree and refers to the abacus to determine the exact number of copies that is expected to lead to some expected delay.
0.877	[*A*]copies[*R*]to lead[*A*]to some expected delay	context()	negated: False ,passive: False
0.677	[*A*]copies[*R*]is expected	context()	negated: False ,passive: False
0.903	[*A*]a node[*R*]refers[*A*]to the abacus	context()	negated: False ,passive: False
0.444	[*A*]it[*R*]computes[*A*]its current connectivity degree[*A*]Whenever a node has a bundle	context()	negated: False ,passive: False
0.732	[*A*]a bundle[*R*]to transmit	context()	negated: False ,passive: False
0.925	[*A*]a node[*R*]has[*A*]a bundle to transmit	context()	negated: False ,passive: False
[LINE#508] The authors did not address the impact of their static measurement window (30s) on the performance of their system.
0.890	[*A*]The authors[*R*]did not address[*A*]the impact of their static measurement window (30s) on the performance of their system	context()	negated: True ,passive: False
[LINE#509] This work does not consider dealing with resource constraints such as node buffers, bandwidth and energy consumption. .
0.878	[*A*]This work[*R*]does not consider dealing[*A*]with resource constraints such as energy consumption	context(This work does not consider)	negated: True ,passive: False
0.878	[*A*]This work[*R*]does not consider[*A*]dealing with resource constraints such as energy consumption	context()	negated: True ,passive: False
0.878	[*A*]This work[*R*]does not consider dealing[*A*]with resource constraints such as bandwidth	context(This work does not consider)	negated: True ,passive: False
0.878	[*A*]This work[*R*]does not consider[*A*]dealing with resource constraints such as bandwidth	context()	negated: True ,passive: False
0.878	[*A*]This work[*R*]does not consider dealing[*A*]with resource constraints such as node buffers	context(This work does not consider)	negated: True ,passive: False
0.878	[*A*]This work[*R*]does not consider[*A*]dealing with resource constraints such as node buffers	context()	negated: True ,passive: False
[LINE#510] Resource pooling[42] believe that the natural evolution of the Internet should be to harness multipath-capable end systems in order to achieve resource pooling.
0.771	[*A*]Resource[*R*]pooling	context()	negated: False ,passive: False
[LINE#511] [9] show that opportunistic networks typically exhibit the path explosion phenomenon.
0.863	[*A*]opportunistic networks[*R*]exhibit[*A*]the path explosion phenomenon	context(9 show)	negated: False ,passive: False
0.168	[*A*]9[*R*]show[*A*]that opportunistic networks typically exhibit the path explosion phenomenon	context()	negated: False ,passive: False
[LINE#512] In our work, the nodes benefit from pooling the capacity of their many and varied contacts, making effective use of the network resources available to them.
0.900	[*A*]the nodes[*R*]benefit[*A*]from pooling the capacity of their varied contacts[*A*]In our work	context()	negated: False ,passive: True
0.900	[*A*]the nodes[*R*]benefit[*A*]from pooling the capacity of their many contacts[*A*]In our work	context()	negated: False ,passive: True
[LINE#513] If traffic is spread across the resources of a node's many and varied contacts in the right way, with the right reaction to the right congestion signals from the network, then traffic can quickly move away from congested regions. .
0.931	[*A*]traffic[*R*]is spread[*A*]across the resources of a node 's varied contacts in the right way , with the right reaction to the right congestion signals from the network	context()	negated: False ,passive: True
0.938	[*A*]traffic[*R*]can quickly move[*A*]away from congested regions[*A*]then	context()	negated: False ,passive: True
0.931	[*A*]traffic[*R*]is spread[*A*]across the resources of a node 's many contacts in the right way , with the right reaction to the right congestion signals from the network	context()	negated: False ,passive: True
[LINE#514] replication strategiesWe observe the similarities between content dissemination in opportunistic networks and in the related field of peer-to-peer (P2P) content dissemination and storage systems.
0.947	[*A*]replication strategiesWe[*R*]observe[*A*]the similarities between content dissemination in opportunistic networks and in the related field of peer - to - peer ( P2P ) storage systems	context()	negated: False ,passive: False
0.947	[*A*]replication strategiesWe[*R*]observe[*A*]the similarities between content dissemination in opportunistic networks and in the related field of peer - to - peer ( P2P ) content dissemination systems	context()	negated: False ,passive: False
[LINE#515] Although P2P networks operate in the application level we believe lessons can be learned from the work in this area.
0.867	[*A*]lessons[*R*]can be learned[*A*]from the work in this area	context(we believe)	negated: False ,passive: True
0.504	[*A*]we[*R*]believe[*A*]lessons can be learned from the work in this area	context()	negated: False ,passive: False
0.927	[*A*]P2P networks[*R*]operate[*A*]in the application level	context()	negated: False ,passive: True
[LINE#516] In applications such as BitTorrent, peers replicate each other's data in order to increase data availability [32], also resulting in the pooling of the upload capacity of many network nodes [42].[32] studied the problem of replica placement in a P2P system intending to optimise availability and/or the number of replicas.
0.933	[*A*]a P2P system[*R*]intending[*A*]to optimise availability	context()	negated: False ,passive: False
0.549	[*A*]42[*R*]studied[*A*]the problem of replica placement in a P2P system	context()	negated: False ,passive: False
0.967	[*A*]peers[*R*]replicate[*A*]each other 's data in order[*A*]also resulting in the pooling of the upload capacity of many network nodes[*A*]In applications such as BitTorrent	context()	negated: False ,passive: False
[LINE#517] [32] show that centralised control of resource placement is a NP-hard problem and that if the control is fully decentralised the peers selfishness can greatly alter the results leading to performance inequities that can render the system unreliable and thus ultimately unusable [32,29].
0.735	[*A*]performance inequities[*R*]can render thus[*A*]ultimately unusable [ 32,29	context()	negated: False ,passive: True
0.887	[*A*]performance inequities[*R*]can render[*A*]the system unreliable	context()	negated: False ,passive: False
0.903	[*A*]the results[*R*]leading[*A*]to performance inequities	context()	negated: False ,passive: False
0.641	[*A*]the control[*R*]is decentralised	context()	negated: False ,passive: False
0.941	[*A*]centralised control of resource placement[*R*]is[*A*]a NP - hard problem	context(32 show)	negated: False ,passive: True
0.431	[*A*]32[*R*]show[*A*]that centralised control of resource placement is a NP - hard problem	context()	negated: False ,passive: False
[LINE#518] The most common approach to P2P replication is the random distribution of copies [7,5].
0.964	[*A*]The most common approach to P2P replication[*R*]is[*A*]the random distribution of copies	context()	negated: False ,passive: True
[LINE#519] [4] analyse how many randomly placed replicas are required to achieve a desired level of availability.
0.913	[*A*]how many randomly placed replicas[*R*]to achieve[*A*]a desired level of availability	context()	negated: False ,passive: False
0.926	[*A*]how many randomly placed replicas[*R*]are required[*A*]to achieve a desired level of availability	context()	negated: False ,passive: True
[LINE#520] [32] argue that replication should not be random, but be based on cliques of peers replicating each other's data, limiting the selfishness of the participants.
0.894	[*A*]peers[*R*]replicating[*A*]each other 's data	context()	negated: False ,passive: False
[LINE#521] Table 1 presents a summary of the techniques discussed in this section in terms of seven criteria.
0.903	[*A*]the techniques[*R*]discussed[*A*]in this section	context()	negated: False ,passive: True
0.927	[*A*]Table 1[*R*]presents[*A*]a summary of the techniques	context()	negated: False ,passive: False
[LINE#522] Note that none of the existing approaches have support for adaptive forwarding and replication, fully localised, social and resource aware congestion control in DTNs.
0.698	[*A*]adaptive replication[*R*]localised	context()	negated: False ,passive: False
0.698	[*A*]adaptive forwarding[*R*]localised	context()	negated: False ,passive: False
