[LINE#0] This paper presents an approach for the automated debugging of reactive and concurrent Java programs, combining model checking and runtime monitoring.
0.947	[*A*]This paper[*R*]presents[*A*]an approach for the automated debugging of concurrent Java programs	context()	negated: False ,passive: False
0.947	[*A*]This paper[*R*]presents[*A*]an approach for the automated debugging of reactive Java programs	context()	negated: False ,passive: False
[LINE#1] Runtime monitoring is used to transform the Java execution traces into the input for the model checker, the purpose of which is twofold.
0.769	[*A*]the purpose of which[*R*]is twofold	context()	negated: False ,passive: False
0.905	[*A*]Runtime monitoring[*R*]to transform[*A*]the Java execution traces[*A*]into the input for the model checker	context()	negated: False ,passive: False
0.947	[*A*]Runtime monitoring[*R*]is used[*A*]to transform the Java execution traces into the input for the model checker	context()	negated: False ,passive: True
[LINE#2] First, it checks these execution traces against properties written in linear temporal logic (LTL), which represent desirable or undesirable behaviors.
0.897	[*A*]linear temporal logic[*R*]represent[*A*]desirable or undesirable behaviors	context()	negated: False ,passive: False
0.894	[*A*]properties[*R*]written[*A*]in linear temporal logic	context()	negated: False ,passive: True
0.522	[*A*]it[*R*]checks[*A*]these execution traces	context()	negated: False ,passive: False
[LINE#3] Second, it produces several execution traces for a single Java program by generating test inputs and exploring different schedulings in multithreaded programs.
0.452	[*A*]it[*R*]produces[*A*]several execution traces	context()	negated: False ,passive: False
[LINE#4] As state explosion is the main drawback to model checking, we propose two abstraction approaches to reduce the memory requirements when storing Java states.
0.452	[*A*]we[*R*]propose[*A*]two abstraction approaches to reduce the memory requirements	context()	negated: False ,passive: False
0.925	[*A*]state explosion[*R*]is[*A*]the main drawback to model checking	context()	negated: False ,passive: True
[LINE#5] We also present the formal framework to clarify which kinds of LTL safety and liveness formulas can be correctly analysed with each abstraction for both finite and infinite program executions.
0.528	[*A*]We[*R*]present[*A*]the formal framework to clarify which kinds of liveness formulas can be correctly analysed with each abstraction for both infinite program executions	context()	negated: False ,passive: False
0.528	[*A*]We[*R*]present[*A*]the formal framework to clarify which kinds of liveness formulas can be correctly analysed with each abstraction for both finite	context()	negated: False ,passive: False
0.573	[*A*]We[*R*]present[*A*]the formal framework to clarify which kinds of LTL safety formulas can be correctly analysed with each abstraction for both infinite program executions	context()	negated: False ,passive: False
0.573	[*A*]We[*R*]present[*A*]the formal framework to clarify which kinds of LTL safety formulas can be correctly analysed with each abstraction for both finite	context()	negated: False ,passive: False
[LINE#6] A major advantage of our approach comes from the model checker, which stores the trace of each failed execution, allowing the programmer to replay these executions to locate the bugs.
0.897	[*A*]the model checker[*R*]stores[*A*]the trace of each failed execution	context()	negated: False ,passive: False
0.722	[*A*]A major advantage of our approach[*R*]comes[*A*]from the model checker	context()	negated: False ,passive: True
[LINE#7] Our current implementation, the tool TJT, uses Spin as the model checker and the Java Debug Interface (JDI) for runtime monitoring.
0.664	[*A*]Our current implementation[*R*]uses[*A*]Spin[*A*]as the Java Debug Interface	context()	negated: False ,passive: False
0.664	[*A*]Our current implementation[*R*]uses[*A*]Spin[*A*]as the model checker	context()	negated: False ,passive: False
[LINE#8] TJT is presented as an Eclipse plug-in and it has been successfully applied to debug complex public Java programs.
0.498	[*A*]it[*R*]has been successfully applied[*A*]to debug complex public Java programs	context()	negated: False ,passive: True
0.877	[*A*]TJT[*R*]is presented[*A*]as an Eclipse plug - in	context()	negated: False ,passive: True
[LINE#9] this section we formalize the Java state abstractions mentioned in previous section and which enable the analysis of infinite Java execution traces..
0.939	[*A*]the Java state abstractions[*R*]mentioned[*A*]in previous section	context()	negated: False ,passive: True
0.639	[*A*]we[*R*]formalize[*A*]the Java state abstractions[*A*]this section	context()	negated: False ,passive: False
[LINE#10] A Java trace t, as defined in Section 2.2, represents a possible Java execution of a given program.
0.940	[*A*]A Java trace t[*R*]represents[*A*]a possible Java execution of a given program	context()	negated: False ,passive: False
[LINE#11] However, sometimes we do not intend for Spin to analyze complete Java traces.
0.877	[*A*]Spin[*R*]to analyze[*A*]complete Java traces	context()	negated: False ,passive: False
0.639	[*A*]we[*R*]do not intend[*A*]for Spin to analyze complete Java traces[*A*]sometimes	context()	negated: True ,passive: False
[LINE#12] Instead, Spin will be given projections of traces, some Java states are discarded, and the states that are transferred are simplified.
0.785	[*A*]the states that are transferred[*R*]are simplified	context()	negated: False ,passive: False
0.698	[*A*]the states[*R*]are transferred	context()	negated: False ,passive: False
0.803	[*A*]some Java states[*R*]are discarded	context()	negated: False ,passive: False
0.855	[*A*]Spin[*R*]will be given[*A*]projections of traces	context()	negated: False ,passive: True
[LINE#13] Only the part of the state that is involved in the evaluation of the formula is transferred to the model checker.
0.921	[*A*]Only the part of the state[*R*]is transferred[*A*]to the model checker	context()	negated: False ,passive: True
0.887	[*A*]the state[*R*]is involved[*A*]in the evaluation of the formula	context()	negated: False ,passive: True
[LINE#14] We now describe how the projection of Java states is constructed and the correctness relation between the evaluation results regarding the original traces, and the projected ones on Spin.
0.554	[*A*]We[*R*]describe[*A*]the projected ones[*A*]now	context()	negated: False ,passive: False
0.706	[*A*]We[*R*]describe[*A*]the correctness relation between the evaluation results regarding the original traces on Spin[*A*]now	context()	negated: False ,passive: False
0.940	[*A*]the projection of Java states[*R*]is constructed[*A*]on Spin	context(We describe)	negated: False ,passive: True
0.649	[*A*]We[*R*]describe[*A*]how the projection of Java states is constructed on Spin[*A*]now	context()	negated: False ,passive: False
[LINE#15] In order to simplify the presentation below, we assume that the set of possible data values of program variables, AS contains the integer numbers.
0.820	[*A*]AS[*R*]contains[*A*]the integer numbers	context(we assume)	negated: False ,passive: False
0.309	[*A*]we[*R*]assume[*A*]that the set of possible data values of program variables, AS contains the integer numbers	context()	negated: False ,passive: False
[LINE#16] Given a subset of variables VVar, we define the projection of a state  onto V as the function V():VAS such that vV.V()(v)=(v).
0.452	[*A*]we[*R*]define[*A*]the projection of a state[*A*]as the function V	context()	negated: False ,passive: False
[LINE#17+18]  Now, given a Java trace t=012, we define the projection of t onto VVar as(5)V(t)=V(0)V(1)V(2)Fig. 10 shows the projection V of a trace.
0.586	[*A*]we[*R*]define[*A*]the projection of t onto VVar[*A*]Now	context(10 shows)	negated: False ,passive: False
0.559	[*A*]10[*R*]shows[*A*]the projection V of a trace	context()	negated: False ,passive: False
[LINE#19+20]  Observe that V divides each state i into two parts: the part concerning the variables of V in state.
[LINE#21] The projection simply takes the first part from each state and ignores the rest.
0.887	[*A*]The projection[*R*]ignores[*A*]the rest	context()	negated: False ,passive: False
0.887	[*A*]The projection[*R*]takes[*A*]the first part from each state	context()	negated: False ,passive: False
[LINE#22] The effect of this projection is similar to that of the "cone of influence" technique (Clarke et al., 1999).
0.921	[*A*]The effect of this projection[*R*]is[*A*]similar to that of the "cone of influence" technique (Clarke et al., 1999	context()	negated: False ,passive: True
[LINE#23]  However, while this technique simplifies the code to include only variables which are on the set V (or which influence them) before executing it, we execute the program as is and then simplify (i.e. project).
0.873	[*A*]only variables[*R*]are[*A*]on which influence them ) then simplify ( i.e. project	context()	negated: False ,passive: True
0.882	[*A*]this technique[*R*]simplifies[*A*]the code to include only variables	context()	negated: False ,passive: False
0.810	[*A*]only variables[*R*]are[*A*]on which influence them	context()	negated: False ,passive: True
0.810	[*A*]this technique[*R*]to include[*A*]only variables which are on which influence them	context()	negated: False ,passive: True
0.903	[*A*]this technique[*R*]simplifies[*A*]the code	context()	negated: False ,passive: False
0.887	[*A*]only variables[*R*]are[*A*]on the set V	context()	negated: False ,passive: True
0.452	[*A*]we[*R*]execute[*A*]the program[*A*]as is	context()	negated: False ,passive: False
0.882	[*A*]the code[*R*]to include[*A*]only variables which are on the set V	context(this technique simplifies)	negated: False ,passive: True
0.867	[*A*]this technique[*R*]simplifies[*A*]the code to include only variables which are on the set V ( ) before executing it	context()	negated: False ,passive: False
[LINE#24] We do not automatically include variables not in V, though.
0.452	[*A*]We[*R*]do not automatically include[*A*]variables not in V[*A*]though	context()	negated: True ,passive: True
[LINE#25] As a general result of this definition of projection, if all the variables required for evaluating an LTL formula are present in the projection, the evaluation of the formula is not affected.
0.785	[*A*]the evaluation of the formula[*R*]is not affected	context()	negated: True ,passive: False
0.961	[*A*]all the variables required for evaluating an LTL formula[*R*]are[*A*]present in the projection	context()	negated: False ,passive: True
0.925	[*A*]all the variables[*R*]required[*A*]for evaluating an LTL formula	context()	negated: False ,passive: True
[LINE#26+27]  Let f be an LTL formula and let us denote the set of variables in f as var(f).Proposition 1Given a Java trace t, a temporal formula f and a subset of program variables.
[LINE#28] VVar, if var(f)V then(6)tfV(t)f,As described in Section 3, temporal formulas can be used in debugging with different use cases.
0.903	[*A*]temporal formulas[*R*]can be used[*A*]in debugging with different use cases	context()	negated: False ,passive: True
[LINE#29] In contrast to model checking, testing works with a subset of program traces instead of every possible trace.
0.918	[*A*]testing[*R*]works[*A*]with a subset of program traces	context()	negated: False ,passive: False
[LINE#30] Test cases may pass when a property is checked in all, some or none of the given traces.
0.767	[*A*]a property[*R*]is checked[*A*]in all	context()	negated: False ,passive: True
0.953	[*A*]Test cases[*R*]may pass[*A*]when a property is checked in all, some or none of the given traces	context()	negated: False ,passive: True
[LINE#31] Thus we extend  for sets of traces and the  and  quantifier operators.
0.452	[*A*]we[*R*]extend[*A*]for sets of the and quantifier operators	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]extend[*A*]for sets of traces	context()	negated: False ,passive: False
[LINE#32] a temporal formula f and a set of traces T,(7)TftT.tf(8)TftT.tf(9)TftT.tf .
[LINE#33] Dealing with cyclesDue to the elimination of most program variables in the projected states, it is very likely that a projected trace V(t) contains many consecutive repeated states.
[LINE#34] This represents a problem for the model checker since it can erroneously deduce that the original trace has a cycle due to the double depth search (DDS) algorithm used by Spin to check properties.
0.953	[*A*]the original trace[*R*]has[*A*]a cycle[*A*]due to the double depth search (DDS) algorithm	context(it can erroneously deduce)	negated: False ,passive: False
0.309	[*A*]it[*R*]can erroneously deduce[*A*]that the original trace has a cycle due to the double depth search (DDS) algorithm	context()	negated: False ,passive: False
0.964	[*A*]the double depth search (DDS) algorithm[*R*]used[*A*]by Spin[*A*]to check properties	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]represents[*A*]a problem for the model checker	context()	negated: False ,passive: False
[LINE#35] Note that this does not contradict Proposition 1, since in this result we do not assume any particular algorithm to evaluate the property on the projected trace.
0.911	[*A*]any particular algorithm[*R*]to evaluate[*A*]the property on the projected trace	context()	negated: False ,passive: False
0.569	[*A*]we[*R*]do not assume[*A*]any particular algorithm to evaluate the property on the projected trace	context()	negated: True ,passive: False
[LINE#36] In the following sections, we use relation s to distinguish between the LTL evaluation carried out by Spin through the DDS algorithm, and the satisfaction relation  defined above.
0.550	[*A*]we[*R*]use relation s to distinguish[*A*]between the LTL evaluation carried out by Spin through the DDS algorithm, and the satisfaction relation	context(we use)	negated: False ,passive: False
0.686	[*A*]we[*R*]use[*A*]relation s[*A*]to distinguish between the LTL evaluation carried out by Spin through the DDS algorithm, and the satisfaction relation[*A*]In the following sections	context()	negated: False ,passive: False
0.783	[*A*]the satisfaction relation[*R*]defined[*A*]above	context()	negated: False ,passive: True
0.944	[*A*]the LTL evaluation[*R*]carried out[*A*]by Spin[*A*]through the DDS algorithm	context()	negated: False ,passive: True
[LINE#37] To correctly eliminate consecutive repeated states in traces, we propose two different techniques that we discuss in the following subsections, along with the corresponding preservation results..
0.897	[*A*]two different techniques[*R*]discuss[*A*]in the following subsections	context()	negated: False ,passive: True
0.208	[*A*]we[*R*]propose[*A*]two different techniques that we discuss in the following subsections, along with the corresponding preservation results	context()	negated: False ,passive: False
[LINE#38]  State countingA simple solution is to add a new counter variable count to the set of visible variables.
0.960	[*A*]State countingA simple solution[*R*]is[*A*]to add a new counter variable count to the set of visible variables	context()	negated: False ,passive: True
[LINE#39] This counter is increased for every new state, thus removing the possibility that Spin erroneously finds a non-existing cycle.
0.855	[*A*]Spin[*R*]erroneously finds[*A*]a non-existing cycle	context()	negated: False ,passive: False
0.868	[*A*]This counter[*R*]is increased[*A*]for every new state[*A*]thus removing the possibility that Spin erroneously finds a non-existing cycle	context()	negated: False ,passive: True
[LINE#40] Observe that this also precludes Spin from detecting real cycles present in the Java program.
0.877	[*A*]Spin[*R*]from detecting[*A*]real cycles present in the Java program	context()	negated: False ,passive: False
[LINE#41] This case will be discussed in the following subsection.
0.903	[*A*]This case[*R*]will be discussed[*A*]in the following subsection	context()	negated: False ,passive: True
[LINE#42]  We extend the notion of trace projection given in Definition 1, by adding the state counter variable as follows:Definition 3[Counter projection of states and traces].
0.614	[*A*]We[*R*]extend[*A*]the notion of trace projection given in Definition 1 , by adding the state counter variable as follows:Definition 3 [ Counter projection of traces	context()	negated: False ,passive: False
0.918	[*A*]trace projection[*R*]given[*A*]in Definition 1	context()	negated: False ,passive: True
0.614	[*A*]We[*R*]extend[*A*]the notion of trace projection given in Definition 1 , by adding the state counter variable as follows:Definition	context()	negated: False ,passive: False
[LINE#43+44]  Given a subset of visible variables VVar and a fresh variable countVar, we define the ith counter projection of a state :VASas Vi():V{count}AS defined as Vi()(v)=V()(v), for all vV, and Vi()(count)=i.
0.907	[*A*]AS[*R*]defined[*A*]as Vi[*A*]V { count	context()	negated: False ,passive: False
0.907	[*A*]AS[*R*]defined[*A*]as Vi ( ) ( count ) =i[*A*]V { count	context()	negated: False ,passive: False
0.388	[*A*]we[*R*]define[*A*]the ith counter projection of a state	context(AS defined)	negated: False ,passive: False
0.388	[*A*]we[*R*]define[*A*]the ith counter projection of a state	context(AS defined)	negated: False ,passive: False
0.940	[*A*]AS[*R*]defined[*A*]as Vi ( ) ( v ) =V ( ) ( v[*A*]V { count	context()	negated: False ,passive: False
[LINE#45] Variable count is called state counter of Vi().
0.918	[*A*]Variable count[*R*]is called[*A*]state counter of Vi	context()	negated: False ,passive: True
[LINE#46] Sometimes, we will represent function Vi() as the pair V(), i.
0.639	[*A*]we[*R*]will represent[*A*]function Vi[*A*]as the pair V[*A*]Sometimes	context()	negated: False ,passive: False
[LINE#47+48+49]  Now, given a Java trace t=01 we define the counter projection of t onto V, Vc, by projecting each state i with the i-th counter projection, that is, Vc(t)=V0(0)V1(1).It is worth noting that there is a slight difference in the notation of the counter projection of a trace and the counter projection of a state.
0.360	[*A*]we[*R*]define[*A*]the counter projection of t onto V , Vc , by projecting each state i with the i - th counter projection , that is , Vc ( t ) =V0 ( 0 ) V1 ( 1 ) . It is worth noting that there is a slight difference in the notation of the counter projection of the counter projection of a state[*A*]Now	context()	negated: False ,passive: False
0.360	[*A*]we[*R*]define[*A*]the counter projection of t onto V , Vc , by projecting each state i with the i - th counter projection , that is , Vc ( t ) =V0 ( 0 ) V1 ( 1 ) . It is worth noting that there is a slight difference in the notation of the counter projection of a trace[*A*]Now	context()	negated: False ,passive: False
[LINE#50] Notice that the former includes a c superscript, while the latter includes the value of the counter itself as a superscript.
0.417	[*A*]the latter[*R*]includes[*A*]the value of the counter itself as a superscript	context()	negated: False ,passive: True
[LINE#51] 11 shows the projection of a trace with the addition of the state counter. .
0.718	[*A*]11[*R*]shows[*A*]the projection of a trace with the addition of the state counter	context()	negated: False ,passive: False
[LINE#52] this section, we assume that Java states have a canonical representation, which makes it possible to safely check whether two states are equal.
0.841	[*A*]Java states[*R*]have[*A*]a canonical representation, which makes it possible	context(we assume)	negated: False ,passive: False
0.332	[*A*]we[*R*]assume[*A*]that Java states have a canonical representation[*A*]this section	context()	negated: False ,passive: False
0.883	[*A*]a canonical representation[*R*]makes[*A*]it possible to safely check whether two states are equal	context()	negated: False ,passive: False
[LINE#53] We know that canonical representation of states in languages that make an intensive use of dynamic memory is not trivial.
0.766	[*A*]canonical representation of states in languages[*R*]is not[*A*]trivial	context(We know)	negated: True ,passive: True
0.339	[*A*]We[*R*]know[*A*]that canonical representation of states in languages that make an intensive use of dynamic memory is not trivial	context()	negated: False ,passive: False
0.877	[*A*]languages[*R*]make[*A*]an intensive use of dynamic memory	context()	negated: False ,passive: False
[LINE#54] We are currently evaluating an extension of the memory representation described in (Gallardo et al., 2009).
0.925	[*A*]the memory representation[*R*]described[*A*]in (Gallardo et al., 2009	context()	negated: False ,passive: True
0.490	[*A*]We[*R*]are evaluating[*A*]an extension of the memory representation[*A*]currently	context()	negated: False ,passive: False
[LINE#55] But a detailed explanation of this extension would exceed the goals of this paper.
0.932	[*A*]a detailed explanation of this extension[*R*]would exceed[*A*]the goals of this paper	context()	negated: False ,passive: False
[LINE#56] Besides, in this section, the actual representation is not relevant for the results obtained.
0.732	[*A*]the results[*R*]obtained	context()	negated: False ,passive: False
0.948	[*A*]the actual representation[*R*]is not[*A*]relevant for the results[*A*]in this section	context()	negated: True ,passive: True
[LINE#57] We only need to assume that given two logically equal Java states 1 and 2, there exists a matching algorithm able to check that they are equal.
0.806	[*A*]two logically equal Java[*R*]states[*A*]2	context(We need to assume)	negated: False ,passive: False
0.170	[*A*]We[*R*]need to assume[*A*]that given two logically equal Java states 2 , there exists a matching algorithm able to check that they are equal	context(We need)	negated: False ,passive: False
0.170	[*A*]We[*R*]need[*A*]to assume that given two logically equal Java states 2 , there exists a matching algorithm able to check that they are equal	context()	negated: False ,passive: False
0.806	[*A*]two logically equal Java[*R*]states[*A*]1	context(We need to assume)	negated: False ,passive: False
0.170	[*A*]We[*R*]need to assume[*A*]that given two logically equal Java states 1 , there exists a matching algorithm able to check that they are equal	context(We need)	negated: False ,passive: False
0.170	[*A*]We[*R*]need[*A*]to assume that given two logically equal Java states 1 , there exists a matching algorithm able to check that they are equal	context()	negated: False ,passive: False
[LINE#58] We use a proper hash function h:Stateint to represent each state in the projected trace.
0.569	[*A*]We[*R*]use[*A*]a proper hash function h:Stateint to represent each state in the projected trace	context()	negated: False ,passive: False
[LINE#59+60]  It is worth noting that as not all of the Java states  have to be stored(we only project the visible part V()), we may assume that function h is very precise, producing a minimum number of collisions.
0.822	[*A*]not all of the Java states[*R*]to be stored	context()	negated: False ,passive: False
0.887	[*A*]function h[*R*]producing[*A*]a minimum number of collisions	context()	negated: False ,passive: False
0.905	[*A*]function h[*R*]is[*A*]very precise[*A*]producing a minimum number of collisions	context(we may assume)	negated: False ,passive: True
0.229	[*A*]It[*R*]is[*A*]worth noting	context(we project we may assume)	negated: False ,passive: True
0.349	[*A*]we[*R*]project[*A*]the visible part V	context(we may assume)	negated: False ,passive: False
0.271	[*A*]we[*R*]may assume[*A*]that function h is very precise, producing a minimum number of collisions	context()	negated: False ,passive: False
[LINE#61] That is, h(1)=h(2)1=2, with a high degree of probability.
[LINE#62] To put this into perspective, we present a very brief study of the MD5 hash function, which we used in our implementation.
0.433	[*A*]we[*R*]present[*A*]a very brief study of the MD5 hash function	context()	negated: False ,passive: False
0.875	[*A*]the MD5 hash function[*R*]used[*A*]in our implementation	context()	negated: False ,passive: True
[LINE#63] This function transforms the given input (in this case a string representation of the Java state) into a 128-bit digest.
0.903	[*A*]This function[*R*]transforms[*A*]the given input (in this case[*A*]into a 128-bit digest	context()	negated: False ,passive: False
[LINE#64] Thus, there are 2128 (or about 3.31038) possible values of this function.
[LINE#65] We are interested in the likelyhood of a birthday attack (Schneier, 1995), i.e. the probability of a collision between any two states belonging to the same trace or, conversely, in the number of different states that could be generated before a collision is found with a given probability.
0.732	[*A*]a collision[*R*]is found	context()	negated: False ,passive: False
0.887	[*A*]different states[*R*]could be generated[*A*]before a collision is found with a given probability	context()	negated: False ,passive: False
0.911	[*A*]any two states[*R*]belonging[*A*]to the same trace or, conversely	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]are[*A*]interested in the likelyhood of a birthday attack	context()	negated: False ,passive: True
[LINE#66] For instance, if we assume that a probability 10-12 is enough for our analysis, this number is approximately 2.61013.
0.888	[*A*]instance[*R*]has this number of[*A*]approximately 2.61013	context()	negated: False ,passive: False
0.855	[*A*]a probability 10-12[*R*]is[*A*]enough for our analysis	context(we assume)	negated: False ,passive: True
0.116	[*A*]we[*R*]assume[*A*]that a probability 10-12 is enough for our analysis	context()	negated: False ,passive: False
0.813	[*A*]this number[*R*]is[*A*]approximately 2.61013	context()	negated: False ,passive: True
[LINE#67] Given a state size of 64 bytes (a reasonable assumption, see Table 2 in Section 5), about 1.5106 gigabytes of memory would be required to store this number of states.
[LINE#68] This is well beyond what current computers carry, and therefore computationally unfeasible.
0.223	[*A*]This[*R*]is[*A*]therefore[*A*]computationally unfeasible	context()	negated: False ,passive: True
0.732	[*A*]current computers[*R*]carry	context()	negated: False ,passive: False
0.449	[*A*]This[*R*]is[*A*]well beyond what current computers carry	context()	negated: False ,passive: True
[LINE#69] Thus, we conclude that such a hash function is adequate for our uses.
0.862	[*A*]such a hash function[*R*]is[*A*]adequate for our uses	context(we conclude)	negated: False ,passive: True
0.168	[*A*]we[*R*]conclude[*A*]that such a hash function is adequate for our uses	context()	negated: False ,passive: False
[LINE#70]  Now, we extend the notion of state projection given in Definition 1, by adding the codification of the whole state (including the non-visible part) as follows:.
0.399	[*A*]we[*R*]extend the notion of state projection by adding[*A*]the codification of the whole state (including the non-visible part	context(we extend)	negated: False ,passive: False
0.531	[*A*]we[*R*]extend[*A*]the notion of state projection[*A*]Now	context()	negated: False ,passive: False
0.918	[*A*]state projection[*R*]given[*A*]in Definition 1	context()	negated: False ,passive: True
[LINE#71] Given a subset of visible variables VVar, and a fresh variable hashVar, we define the hash projection Vh() of a state  onto V using the hash function h as Vh():V{hash}SA as follows.
0.807	[*A*]V { hash } SA[*R*]follows	context()	negated: False ,passive: False
0.498	[*A*]we[*R*]define[*A*]the hash projection Vh ( ) of a state[*A*]onto V	context()	negated: False ,passive: False
[LINE#72] Vh()(v)=V()(v), for all vV, and Vh()(hash)=h().
[LINE#73] We usually represent function Vh() as pair V(), h().
0.554	[*A*]We[*R*]represent[*A*]function[*A*]as pair V[*A*]usually	context()	negated: False ,passive: False
[LINE#74+75+76]  Now, given a Java trace t=01 we define the hash projection of t onto V, Vh, by projecting each state i with the hash projection, that is, Vh(t)=Vh(0)Vh(1).Fig.12 shows the projection of a trace with the addition of the state hash.
0.947	[*A*]Fig.12[*R*]shows[*A*]the projection of a trace with the addition of the state hash	context()	negated: False ,passive: False
0.607	[*A*]we[*R*]define[*A*]the hash projection of t onto V, Vh, by projecting each state i with the hash projection[*A*]Now	context()	negated: False ,passive: False
[LINE#77] Only projected states Vh() are transferred to Spin.
0.857	[*A*]Vh[*R*]are transferred[*A*]to Spin	context()	negated: False ,passive: True
[LINE#78] If the model checker detects that two states Vh(1) and Vh(2) are equal, then we can infer that the original states 1 and 2 are equal with a high degree of probability. .
0.870	[*A*]the original states[*R*]are[*A*]equal with a high degree of probability	context(we can infer)	negated: False ,passive: True
0.631	[*A*]Vh ( 2[*R*]are[*A*]equal	context(the model checker detects)	negated: False ,passive: True
0.783	[*A*]the model checker[*R*]detects[*A*]that Vh ( 2 ) are equal	context()	negated: False ,passive: False
0.385	[*A*]2[*R*]are equal with[*A*]a high degree	context()	negated: False ,passive: False
0.271	[*A*]we[*R*]can infer[*A*]that the original states 2 are equal with a high degree of probability	context()	negated: False ,passive: False
0.385	[*A*]1[*R*]are equal with[*A*]a high degree	context()	negated: False ,passive: False
0.870	[*A*]the original states[*R*]are[*A*]equal with a high degree of probability	context(we can infer)	negated: False ,passive: True
0.271	[*A*]we[*R*]can infer[*A*]that the original states 1 are equal with a high degree of probability	context()	negated: False ,passive: False
0.768	[*A*]two states Vh[*R*]are[*A*]equal	context(the model checker detects)	negated: False ,passive: True
0.783	[*A*]the model checker[*R*]detects[*A*]that two states Vh ( 1 ) are equal	context()	negated: False ,passive: False
[LINE#79] Preservation of resultsWe now discuss how the results are preserved regarding the satisfaction of temporal properties in Java and in the projected traces.
0.920	[*A*]the results[*R*]are preserved[*A*]regarding the satisfaction of temporal properties in the projected traces	context(Preservation of resultsWe discuss)	negated: False ,passive: True
0.963	[*A*]Preservation of resultsWe[*R*]discuss[*A*]how the results are preserved regarding the satisfaction of temporal properties in the projected traces[*A*]now	context()	negated: False ,passive: False
0.896	[*A*]the results[*R*]are preserved[*A*]regarding the satisfaction of temporal properties in Java	context(Preservation of resultsWe discuss)	negated: False ,passive: True
0.969	[*A*]Preservation of resultsWe[*R*]discuss[*A*]how the results are preserved regarding the satisfaction of temporal properties in Java[*A*]now	context()	negated: False ,passive: False
[LINE#80] Here we assume that the algorithm for checking the satisfaction of a property uses the double depth search algorithm as implemented by Spin.
0.944	[*A*]the algorithm for checking the satisfaction of a property[*R*]uses[*A*]the double depth search algorithm[*A*]as implemented by Spin	context(we assume)	negated: False ,passive: False
0.444	[*A*]we[*R*]assume[*A*]that the algorithm for checking the satisfaction of a property uses the double depth search algorithm as implemented by Spin[*A*]Here	context()	negated: False ,passive: False
[LINE#81] We focus on the preservation of results using the counter and hash projections as described in Definitions 3 and 4, respectively, which were introduced to deal with cycles as required by the model checking algorithm implemented by Spin.
0.872	[*A*]the hash projections as described in Definitions 4 , respectively[*R*]were introduced	context()	negated: False ,passive: False
0.872	[*A*]the hash projections as described in Definitions 3 , respectively[*R*]were introduced	context()	negated: False ,passive: False
0.872	[*A*]the counter projections as described in Definitions 4 , respectively[*R*]were introduced	context()	negated: False ,passive: False
0.942	[*A*]results[*R*]using[*A*]the counter projections as described in Definitions 4 , respectively , which were introduced	context()	negated: False ,passive: False
0.872	[*A*]the counter projections as described in Definitions 3 , respectively[*R*]were introduced	context()	negated: False ,passive: False
0.931	[*A*]the model checking algorithm[*R*]implemented[*A*]by Spin	context()	negated: False ,passive: True
0.942	[*A*]results[*R*]using[*A*]the counter projections as described in Definitions 3 , respectively , which were introduced	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]focus[*A*]on the preservation of results	context()	negated: False ,passive: False
[LINE#82]  a temporal formula f using only the eventually "" and until "U" temporal operators, if V=var(f)Var.
0.956	[*A*]a temporal formula f[*R*]using only[*A*]the eventually "" and until "U" temporal operators, if V=var(f)Var	context()	negated: False ,passive: False
[LINE#83] Counter projection Vc does not permit Spin to detect cycles in the projected trace.
0.855	[*A*]Spin[*R*]to detect[*A*]cycles[*A*]in the projected trace	context()	negated: False ,passive: False
0.944	[*A*]Counter projection Vc[*R*]does not permit[*A*]Spin[*A*]to detect cycles in the projected trace	context()	negated: True ,passive: False
[LINE#84] Thus, properties that do not require the detection of cycles (i.e. those that use only operators eventually "" and until "U") can be properly checked over this projection.
0.492	[*A*]i.e. those[*R*]use[*A*]Thus, properties that do not require the detection of cycles (i.e. those that use only operators eventually "" and until "U") can be properly checked over this projection.	context()	negated: False ,passive: False
0.877	[*A*]properties[*R*]do not require[*A*]the detection of cycles	context()	negated: True ,passive: False
[LINE#85+86]  In contrast, since properties that use the always "" temporal operator are checked by Spin by searching for cycles, they cannot be analyzed over Vc(t).Proposition 3Given a temporal formula f and a set of variables V, if V=var(f)Varthen(11)Vh(t)sftfwith the degree of probability allowed by h, and(12)tfVh(t)sf.
0.658	[*A*]they[*R*]can not be analyzed[*A*]over Vc[*A*]if ( 12 ) tfVh ( t ) sf	context()	negated: True ,passive: True
0.931	[*A*]the degree of probability[*R*]allowed[*A*]by h tfVh ( t ) sf	context()	negated: False ,passive: True
0.658	[*A*]they[*R*]can not be analyzed[*A*]over Vc	context()	negated: True ,passive: True
0.887	[*A*]temporal operator[*R*]by searching[*A*]for cycles	context()	negated: False ,passive: False
0.952	[*A*]temporal operator[*R*]are checked[*A*]by Spin[*A*]since properties[*A*]always	context()	negated: False ,passive: True
0.716	[*A*]properties[*R*]use[*A*]the	context()	negated: False ,passive: False
[LINE#87] This theorem asserts that any temporal formula which is satisfied in the original Java trace t, is also satisfied in the hash projection of the trace.
0.968	[*A*]any temporal formula which is satisfied in the original Java trace t[*R*]is[*A*]also[*A*]satisfied in the hash projection of the trace	context(This theorem asserts)	negated: False ,passive: True
0.840	[*A*]This theorem[*R*]asserts[*A*]that any temporal formula which is satisfied in the original Java trace t, is also satisfied in the hash projection of the trace	context()	negated: False ,passive: False
0.933	[*A*]any temporal formula[*R*]is[*A*]satisfied in the original Java trace t	context()	negated: False ,passive: True
[LINE#88] The converse, while generally true for practical purposes, is limited by the quality of the hash function h.
0.939	[*A*]The converse, while generally true for practical purposes[*R*]is limited[*A*]by the quality of the hash function	context()	negated: False ,passive: True
[LINE#89] In addition to projecting the variables in f, as established in Proposition 1, the hash projection includes a variable computed by h that identifies the global state and is used to detect cycles in the trace. .
0.786	[*A*]h[*R*]is used[*A*]to detect cycles in the trace	context()	negated: False ,passive: True
0.786	[*A*]h[*R*]identifies[*A*]the global state	context()	negated: False ,passive: False
0.911	[*A*]the hash projection[*R*]includes[*A*]a variable computed by h	context()	negated: False ,passive: True
[LINE#90] Folding consecutive repeated statesIn this section we propose an optimization approach to minimize the number of states of the projected trace that need to be generated and transferred to Spin.
0.913	[*A*]the projected trace[*R*]to be transferred[*A*]to Spin	context()	negated: False ,passive: True
0.913	[*A*]the projected trace[*R*]need[*A*]to be transferred to Spin	context()	negated: False ,passive: False
0.911	[*A*]an optimization approach[*R*]to minimize[*A*]the number of states of the projected trace	context()	negated: False ,passive: False
0.504	[*A*]we[*R*]propose[*A*]an optimization approach to minimize the number of states of the projected trace	context()	negated: False ,passive: False
0.718	[*A*]the projected trace[*R*]to be generated	context()	negated: False ,passive: False
0.754	[*A*]the projected trace[*R*]need[*A*]to be generated	context()	negated: False ,passive: False
[LINE#91] To do this, we slightly modify transition relation  defined above by labeling transitions as follows.
0.388	[*A*]we[*R*]slightly modify[*A*]transition relation  defined above by labeling transitions[*A*]as follows	context()	negated: False ,passive: False
0.903	[*A*]transition relation[*R*]defined above[*A*]by labeling transitions	context()	negated: False ,passive: True
[LINE#92]  A Java trace is now given by a sequence of states(13)t=0M11M22M3.
0.942	[*A*]A Java trace[*R*]is given[*A*]by a sequence of states(13)t=0M11M22M3[*A*]now	context()	negated: False ,passive: True
[LINE#93] MiVar is the set of variables which are modified by the Java sentence that produced the transition.
0.922	[*A*]the Java sentence[*R*]produced[*A*]the transition	context()	negated: False ,passive: False
0.896	[*A*]variables[*R*]are modified[*A*]by the Java sentence	context()	negated: False ,passive: True
0.938	[*A*]MiVar[*R*]is[*A*]the set of variables	context()	negated: False ,passive: True
[LINE#94+95]  Recall that counter and hash projections of Java traces t (Vc(t) and Vh(t))discard all program variables except the ones in V, which are the only ones needed to check a temporal formula f, (V=var(f)), while the rest of the state is collapsed into a single variable.
0.940	[*A*]hash projections of Vh ( t[*R*]discard[*A*]all program variables except the ones in V	context()	negated: False ,passive: False
0.926	[*A*]the rest of the state[*R*]is collapsed[*A*]into a single variable	context()	negated: False ,passive: True
0.919	[*A*]the only ones needed[*R*]to check[*A*]a temporal formula f	context()	negated: False ,passive: False
0.911	[*A*]the only ones[*R*]needed[*A*]to check a temporal formula f	context()	negated: False ,passive: True
0.905	[*A*]the ones in V[*R*]are[*A*]the only ones needed	context()	negated: False ,passive: True
0.940	[*A*]hash projections of Java traces t[*R*]discard[*A*]all program variables except the ones in V	context()	negated: False ,passive: False
[LINE#96] However, Spin does not need to know about states in which none of the variables in V change as they do not affect the evaluation of temporal formulas as described in Propositions 2 and 3.
0.820	[*A*]Spin[*R*]does not need to know[*A*]about states	context(Spin does not need)	negated: True ,passive: False
0.820	[*A*]Spin[*R*]does not need[*A*]to know about states	context()	negated: True ,passive: False
0.616	[*A*]they[*R*]do not affect[*A*]the evaluation of temporal formulas	context()	negated: True ,passive: False
[LINE#97] Thus, we propose removing these states from the final projection given to Spin.
0.388	[*A*]we[*R*]propose removing[*A*]these states[*A*]from the final projection	context(we propose)	negated: False ,passive: False
0.388	[*A*]we[*R*]propose[*A*]removing these states from the final projection	context()	negated: False ,passive: False
0.925	[*A*]the final projection[*R*]given[*A*]to Spin	context()	negated: False ,passive: True
[LINE#98] We call this removed states folded states.
0.891	[*A*]this removed states[*R*]folded[*A*]states	context(We call)	negated: False ,passive: False
0.467	[*A*]We[*R*]call[*A*]this removed states folded states	context()	negated: False ,passive: False
[LINE#99]  Definition 5[Folded projection].
[LINE#100+101+102+103]  Given a Java trace t=0M11M2 as defined in (13), we define the folded counter/hash projection of t onto VVar as(14)Vc(t)=V0(i0)V1(i1)V2(i2)and(15)Vh(t)=Vh(i0)Vh(i1)Vh(i2) such that:1index i0=0,2for all k0, ik<ik+13for all k1, MikV.4if there exists j>0 such that k0, ikj,we only project to Spin those states where some visible variable has just been modified.
0.239	[*A*]we[*R*]project to Spin[*A*]those states where some visible variable has just been modified	context(we project)	negated: False ,passive: False
0.062	[*A*]there[*R*]exists	context()	negated: False ,passive: False
0.760	[*A*]some visible variable[*R*]has been modified[*A*]j > 0 such that k0 , ikj , we only project to Spin those states	context()	negated: False ,passive: True
0.614	[*A*]we[*R*]define[*A*]the folded counter / hash projection of t onto VVar	context()	negated: False ,passive: False
0.239	[*A*]we[*R*]project to Spin[*A*]those states where some visible variable has just been modified	context(we project)	negated: False ,passive: False
0.164	[*A*]we[*R*]project[*A*]to Spin those states	context()	negated: False ,passive: False
[LINE#104] However, this definition of folding is not enough to allow a precise cycle detection, which was the main reason for introducing the hash projection.
0.927	[*A*]a precise cycle detection[*R*]was[*A*]the main reason for introducing the hash projection	context()	negated: False ,passive: True
0.939	[*A*]this definition of folding[*R*]to allow[*A*]a precise cycle detection, which was the main reason for introducing the hash projection	context()	negated: False ,passive: False
0.919	[*A*]this definition of folding[*R*]is not[*A*]enough to allow a precise cycle detection	context()	negated: True ,passive: True
[LINE#105] If an infinite cycle is located in the folded states, Spin will not be informed of any new Java state, and thus Spin will not be aware that the Java program is going to loop endlessly in those states.
0.811	[*A*]the Java program[*R*]to loop endlessly[*A*]in those states	context()	negated: False ,passive: True
0.806	[*A*]Spin[*R*]will not be[*A*]aware that the Java program is going to loop endlessly in those states	context()	negated: True ,passive: True
0.877	[*A*]Spin[*R*]will not be informed[*A*]of any new Java state	context()	negated: True ,passive: True
0.911	[*A*]an infinite cycle[*R*]is located[*A*]in the folded states	context()	negated: False ,passive: True
[LINE#106] To avoid this, we define the limited folding of a hash projection, where the word limited means that the folding between two non-folded states is never greater than a given limit.
0.913	[*A*]the folding between two non-folded states[*R*]is never[*A*]greater than a given limit	context(the word limited means)	negated: True ,passive: True
0.822	[*A*]the word limited[*R*]means[*A*]that the folding between two non-folded states is never greater than a given limit	context()	negated: False ,passive: False
0.388	[*A*]we[*R*]define[*A*]the limited folding of a hash projection	context()	negated: False ,passive: False
[LINE#107+108]  After a specified number of folded Java states, we project the next Java state, even that state did not change any ofthe variables vV.An implementation may choose to use a timer as a limit instead of a state counter, which may be more practical and would not affect the results given below.
0.767	[*A*]the results[*R*]given[*A*]below	context()	negated: False ,passive: True
0.897	[*A*]a state counter[*R*]would not affect[*A*]the results given below	context()	negated: True ,passive: False
0.911	[*A*]even that state[*R*]did not change[*A*]any ofthe variables	context()	negated: True ,passive: False
0.577	[*A*]we[*R*]project[*A*]the next Java state[*A*]After a specified number of folded Java states	context()	negated: False ,passive: False
0.754	[*A*]a state counter[*R*]may be[*A*]more practical	context()	negated: False ,passive: True
[LINE#109] This projection may be further refined in the implementation with an adaptive limit, e.g. a limit which decreases progressively.
0.718	[*A*]e.g. a limit[*R*]decreases progressively	context()	negated: False ,passive: False
0.859	[*A*]This projection[*R*]may be refined[*A*]in the implementation with an adaptive limit	context()	negated: False ,passive: True
[LINE#110]  Definition 6[Limited folded hash projection].
[LINE#111+112+113+114]  Given a Java trace t=0M11M2 as defined in (13) and a limit l>0, we define the limited folded hash projection of t onto VVar as(16)V,lh(t)=Vh(j0)Vh(j1)Vh(j2) such that:1index j0=0,2for all k0, jk<jk+1, and3for all k1, either MjkV, or, the distance between jk and jk-1 is l,4if there exists j>0 such that k0, jkj, then MjV=.Althoughwe could define a limited folded counter projection in a similar fashion, there would be no benefit in doing so, since the counter prevents any kind of cycle from being detected.
0.882	[*A*]as ( 16 ) V , lh ( t ) =Vh[*R*]from being detected	context()	negated: False ,passive: False
0.979	[*A*]as defined in ( 13 ) as ( 16 ) V , lh ( t ) =Vh ( j0 ) the distance between jk - 1[*R*]is[*A*]l j	context()	negated: False ,passive: True
0.980	[*A*]lh ( t ) =Vh ( j0 ) either MjkV j > 0 such that k0 , jkj , then MjV= . Althoughwe[*R*]could define[*A*]a limited folded counter projection in a similar fashion	context()	negated: False ,passive: False
0.443	[*A*]we[*R*]define[*A*]the limited folded hash projection of t onto VVar	context(either MjkV j)	negated: False ,passive: False
0.798	[*A*]either MjkV[*R*]j[*A*]0	context()	negated: False ,passive: False
0.831	[*A*]all k1[*R*]j	context()	negated: False ,passive: False
0.498	[*A*]we[*R*]define[*A*]the limited folded hash projection of t onto VVar	context()	negated: False ,passive: False
0.855	[*A*]either MjkV[*R*]j[*A*]> 0	context()	negated: False ,passive: False
0.855	[*A*]all k1[*R*]j[*A*]> 0	context()	negated: False ,passive: False
0.769	[*A*]any kind of cycle[*R*]from being detected	context()	negated: False ,passive: False
0.920	[*A*]Althoughwe[*R*]could define[*A*]a limited folded counter projection in a similar fashion	context()	negated: False ,passive: False
0.903	[*A*]the counter[*R*]prevents[*A*]any kind of cycle[*A*]from being detected	context()	negated: False ,passive: False
0.723	[*A*]=Vh ( j0 ) Vh[*R*]j	context()	negated: False ,passive: False
[LINE#115] 13 shows an example of a limited folded hash projection, with limit l=1.
0.718	[*A*]13[*R*]shows[*A*]an example of a limited folded hash projection, with limit l=1	context()	negated: False ,passive: False
[LINE#116] This limit ensures that only one state can be folded consecutively.
0.707	[*A*]only one state[*R*]can be folded consecutively	context(This limit ensures)	negated: False ,passive: False
0.731	[*A*]This limit[*R*]ensures[*A*]that only one state can be folded consecutively	context()	negated: False ,passive: False
[LINE#117] In the figure, a bold Mi label indicates that MiV, i.e. that transition modifies one or more variables of the set V.
0.937	[*A*]a bold Mi label[*R*]indicates[*A*]that MiV, i.e. that transition modifies one or more variables of the set[*A*]In the figure	context()	negated: False ,passive: False
[LINE#118] In this example, the limit forces the projection of states 4 and 6, which should have been folded, resulting in the projected states i2 and i3..
0.937	[*A*]the limit[*R*]forces[*A*]the projection of states 6 , which should have been folded[*A*]resulting in the projected states i3	context()	negated: False ,passive: False
0.737	[*A*]the projection of states[*R*]should have been folded	context()	negated: False ,passive: False
0.937	[*A*]the limit[*R*]forces[*A*]the projection of states 6 , which should have been folded[*A*]resulting in the projected states i2	context()	negated: False ,passive: False
0.903	[*A*]the limit[*R*]forces[*A*]the projection of states[*A*]resulting in the projected states i3	context()	negated: False ,passive: False
0.903	[*A*]the limit[*R*]forces[*A*]the projection of states[*A*]resulting in the projected states i2	context()	negated: False ,passive: False
[LINE#119] Preservation of resultsWe now show how the results are preserved with these projections.
0.678	[*A*]the results[*R*]are preserved	context(Preservation of resultsWe show)	negated: False ,passive: False
0.955	[*A*]Preservation of resultsWe[*R*]show[*A*]how the results are preserved with these projections[*A*]now	context()	negated: False ,passive: False
[LINE#120] a temporal formula f using the eventually "" and until "U" temporal operators, and a set of variables V, if var(f)VVar then(17)tfVc(t)sf.
0.956	[*A*]a temporal formula f[*R*]using[*A*]the eventually , and a set of variables V , if var ( f ) VVar then ( 17 ) tfVc ( t ) sf	context()	negated: False ,passive: False
[LINE#121+122+123]  This result is not affected by the folding in the projection, because (i) the folded states are not required to evaluate the boolean tests of the temporal formula, and (ii) cycle detection is not affected since it is not supported by the counter projection, as discussed in Section 4.2.3.Proposition 5Given a temporal formula f and a set of variables V, if var(f)VVarthen(18)V,lh(t)sftfwith the degree of probability allowed by h, and(19)tfV,lh(t)sf.
0.890	[*A*]This result[*R*]is not affected[*A*]by the folding in the projection[*A*]because (i) the folded states are not required ( ii ) cycle detection is not affected since it is not supported by the counter projection , as discussed in Section 4.2.3.Proposition 5Given a temporal formula	context()	negated: True ,passive: True
0.919	[*A*]the degree of probability[*R*]allowed[*A*]by h	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]is not supported[*A*]by the counter projection	context()	negated: True ,passive: True
0.895	[*A*]the folded states[*R*]are not required[*A*]cycle detection	context()	negated: True ,passive: True
0.937	[*A*]This result[*R*]is not affected[*A*]by the folding in the projection[*A*]because (i) the folded states are not required ( ii ) cycle detection is not affected	context()	negated: True ,passive: True
0.897	[*A*]the folded states[*R*]to evaluate[*A*]the boolean tests of the temporal formula	context()	negated: False ,passive: False
0.911	[*A*]the folded states[*R*]are not required[*A*]to evaluate the boolean tests of the temporal formula	context()	negated: True ,passive: True
0.937	[*A*]This result[*R*]is not affected[*A*]by the folding in the projection[*A*]because (i) the folded states are not required to evaluate the boolean tests of the temporal formula	context()	negated: True ,passive: True
[LINE#124] Again, this result is not affected by the folding in the projection thanks to the limit, which covers the detection of cycles in (otherwise) folded states.
0.927	[*A*]the limit[*R*]covers[*A*]the detection of cycles in (otherwise) folded states	context()	negated: False ,passive: True
0.943	[*A*]this result[*R*]is not affected[*A*]by the folding in the projection[*A*]Again	context()	negated: True ,passive: True
[LINE#125] If there is a cycle in an infinite sequence of states the transition labels of which are MiV=, the limited folding only removes a subset of the states.
0.833	[*A*]MiV=[*R*]removes[*A*]a subset of the states	context()	negated: False ,passive: False
[LINE#126] Since a cycle is by definition a finite sequence of states, it is guaranteed that eventually two equal states will be projected, and thus the cycle will be detected.
0.732	[*A*]the cycle[*R*]will be detected	context()	negated: False ,passive: False
0.925	[*A*]a cycle[*R*]is[*A*]by definition	context()	negated: False ,passive: True
[LINE#127] Comparison with related workThe most notable tools for analyzing Java programs using some variant of full-state model checking are Bandera (Corbett et al., 2000) and Java PathFinder (Visser et al., 2003).
0.968	[*A*]Comparison with related workThe most notable tools for analyzing Java programs[*R*]are[*A*]Bandera (Corbett et al	context()	negated: False ,passive: True
[LINE#128] Bandera is a model extraction based tool that requires the Java program to be transformed into a model composed by pure Promela plus embedded C code.
0.918	[*A*]a model[*R*]composed[*A*]by pure Promela plus embedded C code	context()	negated: False ,passive: True
0.933	[*A*]the Java program[*R*]to be transformed[*A*]into a model	context()	negated: False ,passive: True
0.896	[*A*]tool[*R*]requires[*A*]the Java program	context()	negated: False ,passive: False
0.751	[*A*]a model extraction[*R*]based	context()	negated: False ,passive: False
0.938	[*A*]Bandera[*R*]is[*A*]a model extraction based	context()	negated: False ,passive: True
[LINE#129] This model is optimized by applying a data abstraction mechanism that provides an approximation of the execution traces.
0.905	[*A*]a data abstraction mechanism[*R*]provides[*A*]an approximation of the execution traces	context()	negated: False ,passive: False
0.732	[*A*]This model[*R*]is optimized	context()	negated: False ,passive: False
[LINE#130] As Bandera uses Spin as the model checker, it can check LTL on infinite traces and preserve correction results according to the approximation of the traces.
0.498	[*A*]it[*R*]can check[*A*]LTL	context()	negated: False ,passive: False
0.932	[*A*]Bandera[*R*]uses[*A*]Spin[*A*]as the model checker	context()	negated: False ,passive: False
[LINE#131] Compared with Bandera, TJT only checks a set of traces.
0.869	[*A*]TJT[*R*]checks[*A*]a set of traces	context()	negated: False ,passive: False
[LINE#132] However the use of runtime monitoring to avoid model transformation, and the two abstraction methods guarantee the correctness of the results.
0.919	[*A*]the two abstraction methods[*R*]guarantee[*A*]the correctness of the results	context()	negated: False ,passive: False
0.926	[*A*]the use of runtime monitoring[*R*]to avoid[*A*]model transformation	context()	negated: False ,passive: False
[LINE#133] Java PathFinder (Havelund and Pressburger, 2000) (JPF) is a complete model checker for Java programs that performs a complete coverage of a program, while our testing tool does a partial analysis of the program.
0.660	[*A*]our testing tool[*R*]does[*A*]a partial analysis of the program	context()	negated: False ,passive: False
0.938	[*A*]a complete model checker for Java programs[*R*]performs[*A*]a complete coverage of a program[*A*]while our testing tool does a partial analysis of the program	context()	negated: False ,passive: False
0.945	[*A*]Java PathFinder[*R*]is[*A*]a complete model checker for Java programs	context()	negated: False ,passive: True
[LINE#134] In addition, thanks to a matching mechanism, JPF does not revisit the same execution path twice, while TJT analyzes each trace in isolation without checking whether several traces share already visited states.
0.855	[*A*]TJT[*R*]analyzes[*A*]each trace	context()	negated: False ,passive: False
0.919	[*A*]JPF[*R*]does not revisit[*A*]the same execution path[*A*]twice[*A*]while TJT analyzes each trace in isolation without checking whether several traces share already visited states	context()	negated: True ,passive: False
[LINE#135] However due to our integration approach, we can still gain some advantages from reusing the well known model checker Spin, instead of building a new one from scratch.
0.490	[*A*]we[*R*]can gain[*A*]some advantages[*A*]from reusing the well known model checker[*A*]still	context()	negated: False ,passive: False
[LINE#136] Some realistic Java examples of reactive software are not suitable for verification by JPF.
0.961	[*A*]Some realistic Java examples of reactive software[*R*]are not[*A*]suitable for verification by JPF	context()	negated: True ,passive: True
[LINE#137] For instance, we tried analyzing our elevator problem with JPF, but it ran out of memory after 58 minutes.
0.452	[*A*]it[*R*]ran out[*A*]of memory[*A*]after 58 minutes	context()	negated: False ,passive: False
0.293	[*A*]we[*R*]tried analyzing[*A*]our elevator problem with JPF	context(we tried)	negated: False ,passive: False
0.293	[*A*]we[*R*]tried[*A*]analyzing our elevator problem with JPF	context()	negated: False ,passive: False
[LINE#138] The verification of LTL with JPF-LTL in JPF is still under development and has a limited visibility of the program elements for writing the formula.
0.952	[*A*]The verification[*R*]has[*A*]a limited visibility of the program elements for writing the formula	context()	negated: False ,passive: False
0.949	[*A*]The verification of LTL with JPF - LTL in JPF[*R*]is[*A*]still[*A*]under development	context()	negated: False ,passive: True
[LINE#139] At the time of writing, JPF-LTL only considers entry to methods in the propositions, and it requires the user to explicitly declare whether the formula should be evaluated for infinite or finite traces.
0.878	[*A*]the formula[*R*]should be evaluated[*A*]for infinite or finite traces	context(the user to explicitly declare)	negated: False ,passive: True
0.920	[*A*]the user[*R*]to explicitly declare[*A*]whether the formula should be evaluated for infinite or finite traces	context()	negated: False ,passive: False
0.569	[*A*]it[*R*]requires[*A*]the user[*A*]to explicitly declare whether the formula should be evaluated for infinite or finite traces	context()	negated: False ,passive: False
0.915	[*A*]JPF-LTL[*R*]considers[*A*]entry to methods in the propositions[*A*]At the time of writing	context()	negated: False ,passive: False
[LINE#140] TJT allows a richer set of propositions to be used in the formulas and, due to the stuttering semantics used by Spin, the user does not need to declare whether the trace is finite or not.
0.770	[*A*]the trace[*R*]is[*A*]finite	context(the user does not need to declare)	negated: False ,passive: True
0.878	[*A*]the user[*R*]does not need to declare[*A*]whether the trace is finite or not	context(the user does not need)	negated: True ,passive: False
0.878	[*A*]the user[*R*]does not need[*A*]to declare whether the trace is finite or not	context()	negated: True ,passive: False
0.909	[*A*]a richer set of propositions[*R*]to be used[*A*]in the formulas	context(TJT allows)	negated: False ,passive: True
0.883	[*A*]TJT[*R*]allows[*A*]a richer set of propositions to be used in the formulas	context()	negated: False ,passive: False
0.925	[*A*]the stuttering semantics[*R*]used[*A*]by Spin	context()	negated: False ,passive: True
[LINE#141] The specification of LTL properties to analyze programming languages at runtime has been proposed by other authors, which we discuss in the rest of this section.
0.887	[*A*]other authors[*R*]discuss[*A*]in the rest of this section	context()	negated: False ,passive: True
0.894	[*A*]runtime[*R*]has been proposed[*A*]by other authors	context()	negated: False ,passive: True
0.944	[*A*]The specification of LTL properties[*R*]to analyze[*A*]programming languages at	context()	negated: False ,passive: False
[LINE#142] Probably, the most complete overview of the approaches can be found in a paper by Bauer et.
0.948	[*A*]the most complete overview of the approaches[*R*]can be found[*A*]in a paper by Bauer et	context()	negated: False ,passive: True
[LINE#143] al consider the runtime verification of LTL and tLTL (timed LTL) with a three-valued semantics (with truth values true, false, inconclusive) suitable to check whether or not a partial observation of a running system meets a property.
0.919	[*A*]al[*R*]consider[*A*]the runtime verification of LTL and tLTL (timed LTL	context()	negated: False ,passive: False
[LINE#144] They generate deterministic monitors to decide the satisfaction (or not satisfaction) of a property as early as possible.
0.903	[*A*]deterministic monitors[*R*]to decide[*A*]not satisfaction[*A*]as early as possible	context()	negated: False ,passive: False
0.720	[*A*]They[*R*]generate[*A*]deterministic monitors to decide not satisfaction ) of a property as early as possible	context()	negated: False ,passive: False
0.456	[*A*]They[*R*]generate to decide[*A*]the satisfaction ( of a property[*A*]as early as possible	context(They generate)	negated: False ,passive: False
0.673	[*A*]They[*R*]generate[*A*]deterministic monitors to decide the satisfaction ( of a property as early as possible	context()	negated: False ,passive: False
[LINE#145] They use these three-values as a way to adapt the semantics of LTL to the evaluation of finite traces.
0.492	[*A*]They[*R*]use these three-values to adapt[*A*]the semantics of LTL[*A*]to the evaluation of finite traces	context(They use)	negated: False ,passive: False
0.552	[*A*]They[*R*]use[*A*]these three-values[*A*]as a way	context()	negated: False ,passive: False
[LINE#146] The authors write that "the set of monitorable properties does not only encompass the safety and cosafety properties but is strictly larger".
0.867	[*A*]the set of monitorable properties[*R*]does encompass[*A*]cosafety properties	context(The authors write)	negated: False ,passive: False
0.814	[*A*]The authors[*R*]write[*A*]that " the set of monitorable properties does not only encompass cosafety properties	context()	negated: False ,passive: False
0.867	[*A*]the set of monitorable properties[*R*]does encompass[*A*]the safety	context(The authors write)	negated: False ,passive: False
0.814	[*A*]The authors[*R*]write[*A*]that " the set of monitorable properties does not only encompass the safety	context()	negated: False ,passive: False
0.777	[*A*]the set[*R*]is[*A*]strictly larger	context(The authors write)	negated: False ,passive: True
0.731	[*A*]The authors[*R*]write[*A*]that " the set is strictly larger	context()	negated: False ,passive: False
[LINE#147] However, the general case of liveness properties for infinite traces is not considered.
0.843	[*A*]the general case of liveness properties for infinite traces[*R*]is not considered	context()	negated: True ,passive: False
[LINE#148] Compared with our work, they develop the foundations to create monitors to support the new semantics of LTL for infinite traces, while our work relies on the already existing algorithms and tools to check Bchi automata for infinite traces.
0.620	[*A*]our work[*R*]relies on the tools to check[*A*]Bchi automata for infinite traces	context(our work relies)	negated: False ,passive: False
0.620	[*A*]our work[*R*]relies[*A*]on the tools[*A*]to check Bchi automata for infinite traces	context()	negated: False ,passive: False
0.620	[*A*]our work[*R*]relies on the already existing algorithms to check[*A*]Bchi automata for infinite traces	context(our work relies)	negated: False ,passive: False
0.620	[*A*]our work[*R*]relies[*A*]on the already existing algorithms[*A*]to check Bchi automata for infinite traces	context()	negated: False ,passive: False
0.704	[*A*]they[*R*]develop the foundations to create[*A*]monitors to support the new semantics of LTL for infinite traces	context(they develop)	negated: False ,passive: False
0.552	[*A*]they[*R*]develop[*A*]the foundations	context()	negated: False ,passive: False
0.911	[*A*]monitors[*R*]to support[*A*]the new semantics of LTL	context()	negated: False ,passive: False
[LINE#149] Java PathExplorer, developed by Havelund and Rou (Havelund and Rou, 2004), uses the rewriting-logic based model checker Maude to check LTL on finite execution traces of Java programs.
0.928	[*A*]Java PathExplorer[*R*]developed[*A*]by Rou Rou	context()	negated: False ,passive: True
0.908	[*A*]Java PathExplorer[*R*]uses the rewriting - logic based model checker Maude to check[*A*]LTL	context(Java PathExplorer uses)	negated: False ,passive: False
0.928	[*A*]Java PathExplorer[*R*]developed[*A*]by Rou	context()	negated: False ,passive: True
0.928	[*A*]Java PathExplorer[*R*]developed[*A*]by Havelund Rou	context()	negated: False ,passive: True
0.908	[*A*]Java PathExplorer[*R*]uses the rewriting - logic based model checker Maude to check[*A*]LTL	context(Java PathExplorer uses)	negated: False ,passive: False
0.941	[*A*]Java PathExplorer[*R*]uses[*A*]the rewriting - logic based model checker Maude[*A*]to check LTL on finite execution traces of Java programs	context()	negated: False ,passive: False
0.928	[*A*]Java PathExplorer[*R*]developed[*A*]by Havelund	context()	negated: False ,passive: True
[LINE#150] The authors provide different semantics for LTL formulas in order to avoid cycle detection.
0.903	[*A*]The authors[*R*]provide[*A*]different semantics	context()	negated: False ,passive: False
[LINE#151] Java PathExplorer also supports the generation of a variant of Bchi automata for finite traces developed by Giannakopoulou and Havelund (Giannakopoulou and Havelund, 2001).
0.918	[*A*]finite traces[*R*]developed[*A*]by Havelund	context()	negated: False ,passive: True
0.918	[*A*]finite traces[*R*]developed[*A*]by Giannakopoulou	context()	negated: False ,passive: True
0.954	[*A*]Java PathExplorer[*R*]supports[*A*]the generation of a variant of Bchi automata for finite traces	context()	negated: False ,passive: False
[LINE#152] We share with Java PathExplorer the idea of using the model checker to process the stream of states produced by Java.
0.911	[*A*]states[*R*]produced[*A*]by Java	context()	negated: False ,passive: True
0.614	[*A*]We[*R*]share[*A*]with Java PathExplorer[*A*]the idea of using the model checker to process the stream of states	context()	negated: False ,passive: False
[LINE#153] However, our use of Spin allows us to check infinite execution traces.
0.388	[*A*]us[*R*]to check[*A*]infinite execution traces	context(our use of Spin allows)	negated: False ,passive: False
0.548	[*A*]our use of Spin[*R*]allows[*A*]us to check infinite execution traces	context()	negated: False ,passive: False
[LINE#154] The tool Temporal Rover (Drusinsky, 2000) can check temporal logic assertions against reactive systems (with non-terminating loops) at runtime.
0.927	[*A*]The tool[*R*]can check[*A*]temporal logic assertions against reactive systems (with non-terminating loops	context()	negated: False ,passive: False
[LINE#155] The author considers that both finite and infinite traces are possible.
0.724	[*A*]infinite traces[*R*]are[*A*]possible	context(The author considers)	negated: False ,passive: True
0.731	[*A*]The author[*R*]considers[*A*]that infinite traces are possible	context()	negated: False ,passive: False
0.743	[*A*]both finite traces[*R*]are[*A*]possible	context(The author considers)	negated: False ,passive: True
0.731	[*A*]The author[*R*]considers[*A*]that both finite traces are possible	context()	negated: False ,passive: False
[LINE#156] However, only finite traces are evaluated, and a default fail value is returned for formulas like p when p has not been satisfied at the end of the trace and there is no evidence that the program has terminated.
0.732	[*A*]the program[*R*]has terminated	context()	negated: False ,passive: False
0.813	[*A*]p[*R*]has not been[*A*]satisfied at the end of the trace	context()	negated: True ,passive: True
0.769	[*A*]a default fail value[*R*]is returned	context()	negated: False ,passive: False
0.751	[*A*]only finite traces[*R*]are evaluated	context()	negated: False ,passive: False
[LINE#157] TJT can provide a conclusive verdict when inspecting the infinite trace.
0.855	[*A*]TJT[*R*]can provide[*A*]a conclusive verdict when inspecting the infinite trace	context()	negated: False ,passive: False
[LINE#158] Bodden (Bodden, 2004) uses AspectJ to implement a method to evaluate LTL, inserting pieces of Java code to be executed at points where the behavior specified by the formula is relevant and must be evaluated.
0.746	[*A*]pieces of Java code[*R*]must be evaluated	context(Bodden ( Bodden uses inserting)	negated: False ,passive: False
0.946	[*A*]Bodden ( Bodden[*R*]uses[*A*]AspectJ[*A*]to implement a method to evaluate LTL , inserting pieces of Java code to be executed at points must be evaluated	context()	negated: False ,passive: False
0.939	[*A*]pieces of Java code[*R*]to be executed[*A*]at points	context()	negated: False ,passive: True
0.970	[*A*]the behavior specified by the formula[*R*]is[*A*]relevant[*A*]points	context()	negated: False ,passive: True
0.903	[*A*]the behavior[*R*]specified[*A*]by the formula	context()	negated: False ,passive: True
0.877	[*A*]Bodden ( Bodden[*R*]uses AspectJ inserting[*A*]pieces of Java code	context(Bodden ( Bodden uses)	negated: False ,passive: False
0.946	[*A*]Bodden ( Bodden[*R*]uses[*A*]AspectJ[*A*]to implement a method to evaluate LTL , inserting pieces of Java code	context()	negated: False ,passive: False
[LINE#159] This method is useful to check only safety properties.
0.887	[*A*]This method[*R*]to check[*A*]only safety properties	context()	negated: False ,passive: False
0.925	[*A*]This method[*R*]is[*A*]useful to check only safety properties	context()	negated: False ,passive: True
[LINE#160] (d'Amorim and Havelund, 2005) have developed the tool HAWK for the runtime verification of Java programs, which allows the definition of temporal properties with the logic EAGLE.
0.921	[*A*]Havelund[*R*]have developed[*A*]the tool[*A*]for the runtime verification of Java programs	context()	negated: False ,passive: False
0.914	[*A*]Java programs[*R*]allows[*A*]the definition of temporal properties with the logic	context()	negated: False ,passive: False
0.921	[*A*]d'Amorim[*R*]have developed[*A*]the tool[*A*]for the runtime verification of Java programs	context()	negated: False ,passive: False
[LINE#161] In addition, the user must supply a method that must be called when the program terminates in order to produce a finite trace.
0.903	[*A*]the program[*R*]terminates[*A*]in order	context()	negated: False ,passive: True
0.887	[*A*]a method[*R*]must be called[*A*]when the program terminates in order	context()	negated: False ,passive: True
0.773	[*A*]the user[*R*]must supply[*A*]a method that must be called	context()	negated: False ,passive: False
[LINE#162] FiLM (Finite LTL runtime Monitor) (Zhang et al., 2009) also gives a specific semantics to LTL to check both safety and liveness in finite traces.
0.897	[*A*]a specific semantics[*R*]to check[*A*]both liveness	context()	negated: False ,passive: False
0.833	[*A*]FiLM[*R*]gives[*A*]a specific semantics[*A*]to LTL to check both liveness in finite traces	context()	negated: False ,passive: False
0.897	[*A*]a specific semantics[*R*]to check[*A*]both safety	context()	negated: False ,passive: False
0.833	[*A*]FiLM[*R*]gives[*A*]a specific semantics[*A*]to LTL to check both safety in finite traces	context()	negated: False ,passive: False
[LINE#163] However, in the case of liveness, manual inspection is required when the tool reports a potential liveness violation.
0.903	[*A*]the tool[*R*]reports[*A*]a potential liveness violation	context()	negated: False ,passive: False
0.943	[*A*]manual inspection[*R*]is required[*A*]when the tool reports a potential liveness violation[*A*]in the case of liveness	context()	negated: False ,passive: True
[LINE#164] All these tools for runtime monitoring of LTL are focused on finite traces.
0.958	[*A*]All these tools for runtime monitoring of LTL[*R*]are focused[*A*]on finite traces	context()	negated: False ,passive: True
[LINE#165] The main difference with TJT is the support of cycle detection due to the way in which the states are abstracted and stored, and the use of Bchi automata.
0.903	[*A*]the states[*R*]are stored[*A*]the use of Bchi automata	context()	negated: False ,passive: False
0.732	[*A*]the states[*R*]are abstracted	context()	negated: False ,passive: False
0.957	[*A*]The main difference with TJT[*R*]is[*A*]the support of cycle detection due to the way	context()	negated: False ,passive: True
[LINE#166] Note that we have not included further experimental comparison of TJT with some of these runtime monitoring tools due to the lack of comparable public examples, or of the tools themselves.
[LINE#167] Conclusions and future workWe have presented the foundations of TJT, a tool for checking temporal logic properties on Java programs.
0.918	[*A*]future workWe[*R*]have presented[*A*]the foundations of TJT	context()	negated: False ,passive: False
0.911	[*A*]Conclusions[*R*]have presented[*A*]the foundations of TJT	context()	negated: False ,passive: False
[LINE#168] This tool is useful for testing functional properties on both sequential and concurrent programs.
0.925	[*A*]This tool[*R*]is[*A*]useful for testing functional properties on both concurrent programs	context()	negated: False ,passive: True
0.925	[*A*]This tool[*R*]is[*A*]useful for testing functional properties on both sequential programs	context()	negated: False ,passive: True
[LINE#169] In particular, we explained how the use of Bchi automata combined with storing the states from runtime monitoring can be used to check liveness properties in non-terminating executions of reactive programs.
0.550	[*A*]we[*R*]explained[*A*]how the use of Bchi automata combined with storing the states from runtime monitoring can be used to check liveness properties in non-terminating executions of reactive programs	context()	negated: False ,passive: False
0.927	[*A*]Bchi automata[*R*]combined[*A*]with storing the states from runtime monitoring	context()	negated: False ,passive: True
[LINE#170] Our tool chain includes the model checker Spin and JDI, which are integrated in the well known development environment Eclipse.
0.789	[*A*]Our tool chain[*R*]includes[*A*]the model checker JDI , which are integrated in the well known development environment Eclipse	context()	negated: False ,passive: True
0.897	[*A*]the model checker[*R*]are integrated[*A*]in the well known development environment	context()	negated: False ,passive: True
0.789	[*A*]Our tool chain[*R*]includes[*A*]the model checker Spin , which are integrated in the well known development environment Eclipse	context()	negated: False ,passive: True
[LINE#171] The use of JDI instead of instrumented code makes it possible to detect deadlocks and provides wider access to events in the execution of the program, while being completely transparent.
0.937	[*A*]The use[*R*]provides[*A*]wider access to events in the execution of the program[*A*]while being completely transparent	context()	negated: False ,passive: False
0.924	[*A*]The use of JDI instead of instrumented code[*R*]makes[*A*]it possible to detect deadlocks	context()	negated: False ,passive: False
[LINE#172] Our current work follows several paths.
0.660	[*A*]Our current work[*R*]follows[*A*]several paths	context()	negated: False ,passive: True
[LINE#173] One is to apply static influence analysis to automatically select the variables relevant to the given property, as we proposed in (de la Cmara et al., 2006).
0.498	[*A*]we[*R*]proposed[*A*]in (de la Cmara et al	context()	negated: False ,passive: False
0.624	[*A*]One[*R*]is[*A*]to apply static influence analysis to automatically select the variables relevant to the given property, as we proposed in (de la Cmara et al	context()	negated: False ,passive: True
[LINE#174] The second one is to implement methods to produce more schedulling in multithreaded programs for the same initial state.
0.956	[*A*]The second one[*R*]is[*A*]to implement methods to produce more schedulling in multithreaded programs for the same initial state	context()	negated: False ,passive: True
[LINE#175] Finally, we plan to take advantage of multicore architectures to speed up the analysis, due to the already decoupled interaction between Spin and JDI modules.
0.293	[*A*]we[*R*]plan to take advantage to speed up[*A*]the analysis	context(we plan to take)	negated: False ,passive: False
0.550	[*A*]we[*R*]plan to take[*A*]advantage[*A*]of multicore architectures[*A*]to speed up the analysis, due to the already decoupled interaction between Spin and JDI modules	context(we plan)	negated: False ,passive: False
0.744	[*A*]we[*R*]plan[*A*]to take advantage of multicore architectures to speed up the analysis, due to the already decoupled interaction between Spin and JDI modules[*A*]Finally	context()	negated: False ,passive: False
[LINE#176] Experimental resultsTJT has been successfully used with real Java applications.
0.918	[*A*]Experimental resultsTJT[*R*]has been successfully used[*A*]with real Java applications	context()	negated: False ,passive: True
[LINE#177] In this section, we show some example properties evaluated on public open source Java projects, some of which were also evaluated in (Fu et al., 2005).
0.532	[*A*]some of which[*R*]were evaluated[*A*]in (Fu et al., 2005	context()	negated: False ,passive: True
0.911	[*A*]some example properties[*R*]evaluated[*A*]on public open source	context()	negated: False ,passive: True
0.790	[*A*]we[*R*]show[*A*]some example properties evaluated on public open source Java projects[*A*]In this section	context()	negated: False ,passive: False
[LINE#178] These applications include three servers: FTP, NFS and HTTP.
0.903	[*A*]These applications[*R*]include[*A*]three servers	context()	negated: False ,passive: True
[LINE#179] It is worth noting that, in order to test these servers, we had to implement mock clients to simulate the behavior required by each test.
0.411	[*A*]we[*R*]to implement[*A*]mock clients[*A*]to simulate the behavior	context()	negated: False ,passive: False
0.903	[*A*]the behavior[*R*]required[*A*]by each test	context()	negated: False ,passive: True
0.903	[*A*]mock clients[*R*]to simulate[*A*]the behavior required by each test	context()	negated: False ,passive: False
[LINE#180] In addition, we studied the elevator problem, a typical example of control software.
0.452	[*A*]we[*R*]studied[*A*]the elevator problem	context()	negated: False ,passive: False
[LINE#181] The temporal formulas used in each test have been gathered together in Table 1.
0.948	[*A*]The temporal formulas used in each test[*R*]have been gathered[*A*]together[*A*]in Table 1	context()	negated: False ,passive: True
0.911	[*A*]The temporal formulas[*R*]used[*A*]in each test	context()	negated: False ,passive: True
[LINE#182+183]  Note that all formulas, with the exception of F4 and F6, represent liveness properties, and, in the case of programs with infinite executions, they can only be analyzed with runtime checkers that implement mechanisms like the cycle detection considered in this paper (see Vardi and Wolper (1986)).FTPD server (http://peter.sorotokin.com/ftpd).
0.911	[*A*]the cycle detection[*R*]considered[*A*]in this paper	context()	negated: False ,passive: True
0.887	[*A*]runtime checkers[*R*]implement[*A*]mechanisms like the cycle detection	context()	negated: False ,passive: False
0.609	[*A*]they[*R*]can be analyzed[*A*]in the case of programs with infinite executions	context()	negated: False ,passive: True
[LINE#184] The first application is the FTP server described in Section 2.1.
0.933	[*A*]the FTP server[*R*]described[*A*]in Section 2.1	context()	negated: False ,passive: True
0.942	[*A*]The first application[*R*]is[*A*]the FTP server	context()	negated: False ,passive: True
[LINE#185] We tested the three formulas from Section 2.1, shown in Table 1 as formulas F1, F2 and F3, and two additional ones.
0.926	[*A*]Section 2.1[*R*]shown[*A*]in Table 1[*A*]as two additional ones	context()	negated: False ,passive: True
0.926	[*A*]Section 2.1[*R*]shown[*A*]in Table 1[*A*]as F3	context()	negated: False ,passive: True
0.926	[*A*]Section 2.1[*R*]shown[*A*]in Table 1[*A*]as F2	context()	negated: False ,passive: True
0.452	[*A*]We[*R*]tested[*A*]the three formulas[*A*]from Section 2.1	context()	negated: False ,passive: False
0.526	[*A*]We[*R*]shown[*A*]in Table 1[*A*]as formulas F1	context()	negated: False ,passive: True
0.498	[*A*]We[*R*]tested[*A*]the three formulas[*A*]from Section 2.1[*A*]shown in Table 1 as formulas F1	context()	negated: False ,passive: False
[LINE#186] Of all these formulas, F2 was prepared to uncover a manually introduced bug, while the rest were analyzed over the normal server.
0.903	[*A*]the rest[*R*]were analyzed[*A*]over the normal server	context()	negated: False ,passive: True
0.833	[*A*]F2[*R*]to uncover[*A*]a manually introduced bug	context()	negated: False ,passive: False
0.887	[*A*]F2[*R*]was[*A*]prepared to uncover a manually introduced bug[*A*]while the rest were analyzed over the normal server	context()	negated: False ,passive: True
[LINE#187] F4 deals with security in the server, checking that no user is able to perform a STOR operation without being authenticated first.
0.950	[*A*]no user[*R*]is[*A*]able to perform a STOR operation without being authenticated first	context(F4 deals with security in the server checking)	negated: False ,passive: True
0.878	[*A*]F4 deals with security in the server[*R*]checking[*A*]that no user is able to perform a STOR operation without being authenticated first	context()	negated: False ,passive: False
0.905	[*A*]no user[*R*]to perform[*A*]a STOR operation	context()	negated: False ,passive: False
[LINE#188] Finally, formula F5 is a twist on F1, but using the temporal operator "until".
0.495	[*A*]formula F5[*R*]is a twist on[*A*]F1	context()	negated: False ,passive: False
0.928	[*A*]a twist on F1[*R*]using[*A*]the temporal operator[*A*]until	context()	negated: False ,passive: False
0.973	[*A*]formula F5[*R*]is[*A*]a twist on F1[*A*]Finally	context()	negated: False ,passive: True
[LINE#189] Using this formula we check that, at some point, the variable incoming, which holds the socket just opened for attending the client, should be non-null until a specific thread is created for attending that client.
0.962	[*A*]the variable incoming, which holds the socket[*R*]opened[*A*]for attending the client[*A*]at some point	context()	negated: False ,passive: True
0.920	[*A*]the variable incoming[*R*]holds[*A*]the socket	context()	negated: False ,passive: False
0.789	[*A*]a specific thread[*R*]is created[*A*]for attending that client	context()	negated: False ,passive: True
0.098	[*A*]we[*R*]check[*A*]that	context()	negated: False ,passive: False
[LINE#190] The next application is a typical example of concurrency: a shared resource (an elevator) and several clients trying to use it at the same time.
0.831	[*A*]a shared several clients[*R*]trying to use[*A*]it[*A*]at the same time	context(a shared several clients trying)	negated: False ,passive: False
0.916	[*A*]The next application[*R*]is[*A*]a typical example of concurrency	context(a shared several clients trying)	negated: False ,passive: True
0.831	[*A*]a shared several clients[*R*]trying[*A*]to use it at the same time	context()	negated: False ,passive: False
0.932	[*A*]The next application[*R*]is[*A*]a typical example of concurrency	context()	negated: False ,passive: True
[LINE#191] This example has been implemented in Java using locks and conditions.
0.918	[*A*]This example[*R*]has been implemented[*A*]in Java[*A*]using conditions	context()	negated: False ,passive: True
0.918	[*A*]This example[*R*]has been implemented[*A*]in Java	context()	negated: False ,passive: True
[LINE#192] 14 and 15 show part of the elevator and client code, respectively.
0.613	[*A*]15[*R*]show[*A*]part of the client code[*A*]respectively	context()	negated: False ,passive: False
0.613	[*A*]15[*R*]show[*A*]part of the elevator code[*A*]respectively	context()	negated: False ,passive: False
0.613	[*A*]14[*R*]show[*A*]part of the client code[*A*]respectively	context()	negated: False ,passive: False
0.613	[*A*]14[*R*]show[*A*]part of the elevator code[*A*]respectively	context()	negated: False ,passive: False
[LINE#193]  We can use a temporal formula to check that the elevator does not wait for clients if it is not free.
0.796	[*A*]the elevator[*R*]does not wait[*A*]for clients[*A*]if it is not free	context(We can use to check)	negated: True ,passive: True
0.168	[*A*]We[*R*]can use a temporal formula to check[*A*]that the elevator does not wait for clients if it is not free	context(We can use)	negated: False ,passive: False
0.271	[*A*]We[*R*]can use[*A*]a temporal formula[*A*]to check that the elevator does not wait for clients	context()	negated: False ,passive: False
0.225	[*A*]it[*R*]is not[*A*]free	context()	negated: True ,passive: True
[LINE#194]  For the sake of illustration, we tested this formula to debug an incorrect implementation, where the wait condition of the server is wrong (line 3 in Fig..
0.550	[*A*]we[*R*]tested this formula to debug[*A*]an incorrect implementation, where the wait condition of the server is wrong (line 3 in Fig	context(we tested)	negated: False ,passive: False
0.531	[*A*]we[*R*]tested[*A*]this formula[*A*]to debug an incorrect implementation[*A*]For the sake of illustration	context()	negated: False ,passive: False
0.865	[*A*]the wait condition of the server[*R*]is[*A*]wrong	context()	negated: False ,passive: True
[LINE#195] We also used this incorrect implementation to test the opposite condition (F7).
0.349	[*A*]We[*R*]used this incorrect implementation to test[*A*]the opposite condition	context(We used)	negated: False ,passive: False
0.349	[*A*]We[*R*]used[*A*]this incorrect implementation[*A*]to test the opposite condition	context()	negated: False ,passive: False
[LINE#196] In both cases, the generated traces led us to this manually introduced error.
0.930	[*A*]the generated traces[*R*]led[*A*]us[*A*]to this manually introduced error[*A*]In both cases	context()	negated: False ,passive: False
[LINE#197] NFS server (http://www.void.org/ steven/jnfs/).
[LINE#198] We have also debugged an NFS server implemented in Java using a client that tries to mount a directory provided by the server.
0.858	[*A*]a client[*R*]tries to mount[*A*]a directory provided by the server	context(a client tries)	negated: False ,passive: False
0.858	[*A*]a client[*R*]tries[*A*]to mount a directory	context()	negated: False ,passive: False
0.131	[*A*]We[*R*]have debugged an NFS server using[*A*]a client that tries to mount a directory	context(We have debugged)	negated: False ,passive: False
0.333	[*A*]We[*R*]have debugged[*A*]an NFS server	context()	negated: False ,passive: False
0.944	[*A*]an NFS server[*R*]implemented[*A*]in Java	context()	negated: False ,passive: True
0.903	[*A*]a directory[*R*]provided[*A*]by the server	context()	negated: False ,passive: True
[LINE#199+200]  We can test some conditions related to an incorrect or unauthorized request, by checking whether some internal error fields are updated(F8) or specific exceptions are thrown (F9, F10).Jibble Web Server (http://www.jibble.org/jibblewebserver.php).
0.732	[*A*]specific exceptions[*R*]are thrown	context()	negated: False ,passive: False
0.903	[*A*]some conditions[*R*]related[*A*]to an incorrect or unauthorized request	context()	negated: False ,passive: True
0.452	[*A*]We[*R*]can test[*A*]some conditions related to an incorrect or unauthorized request	context()	negated: False ,passive: False
[LINE#201] Finally, we also studied a Java web server that manages HTTP requests.
0.940	[*A*]a Java web server[*R*]manages[*A*]HTTP requests	context()	negated: False ,passive: False
0.599	[*A*]we[*R*]studied[*A*]a Java web server[*A*]Finally	context()	negated: False ,passive: False
[LINE#202]  One possible condition to check would be that the server throws the right exception if it is launched from an incorrect root directory.
0.838	[*A*]the server[*R*]throws[*A*]the right exception[*A*]if it is launched from an incorrect root directory	context(One possible condition to check would be)	negated: False ,passive: False
0.753	[*A*]One possible condition to check[*R*]would be[*A*]that the server throws the right exception if it is launched from an incorrect root directory	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]is launched[*A*]from an incorrect root directory	context()	negated: False ,passive: True
[LINE#203] In addition, we can test whether the server fails to start on any port from a given range, which can be specified as a test input parameter.
0.897	[*A*]a given range[*R*]can be specified[*A*]as a test input parameter	context()	negated: False ,passive: True
0.887	[*A*]the server[*R*]to start[*A*]on any port	context()	negated: False ,passive: True
0.903	[*A*]the server[*R*]fails[*A*]to start on any port from a given range	context()	negated: False ,passive: True
0.569	[*A*]we[*R*]can test[*A*]whether the server fails to start on any port from a given range	context()	negated: False ,passive: False
[LINE#204] All executions should thus avoid the location of the exception that would be thrown in this case (F12)..
0.887	[*A*]the exception[*R*]would be thrown[*A*]in this case	context()	negated: False ,passive: True
0.859	[*A*]All executions[*R*]should avoid[*A*]the location of the exception	context()	negated: False ,passive: False
[LINE#205] Counter projectionWe performed some the aforementioned tests using the folded counter projection.
0.919	[*A*]some the aforementioned tests[*R*]using[*A*]the folded counter projection	context()	negated: False ,passive: False
0.927	[*A*]Counter projectionWe[*R*]performed[*A*]some the aforementioned tests using the folded counter projection	context()	negated: False ,passive: False
[LINE#206] It is worth noting that not all of the proposed tests can be carried out using this projection.
0.390	[*A*]It[*R*]is[*A*]worth noting that not all of the proposed tests can be carried out	context()	negated: False ,passive: True
[LINE#207] Formulas that would require cycle detection cannot be checked, as per Proposition 2.
0.801	[*A*]Formulas that would require cycle detection[*R*]can not be checked	context()	negated: True ,passive: False
0.877	[*A*]Formulas[*R*]would require[*A*]cycle detection	context()	negated: False ,passive: False
[LINE#208] However, formulas where the cycle that Spin's stuttering mechanism creates using the last state is enough for detecting every accepting cycle in the never claim automata generated from the formula.
0.976	[*A*]the cycle that Spin's stuttering mechanism creates[*R*]is[*A*]enough for detecting every accepting cycle in the never claim automata	context()	negated: False ,passive: True
0.919	[*A*]the never claim automata[*R*]generated[*A*]from the formula	context()	negated: False ,passive: True
0.909	[*A*]Spin's stuttering mechanism[*R*]using[*A*]the last state	context(the cycle creates)	negated: False ,passive: False
0.929	[*A*]the cycle[*R*]creates[*A*]Spin's stuttering mechanism	context()	negated: False ,passive: True
[LINE#209] Most of the programs we are debugging are infinite, i.e. they are servers with an infinite reactive loop, and this cannot be checked with finite resources and this projection.
0.381	[*A*]this[*R*]can not be checked[*A*]with this projection	context()	negated: True ,passive: True
0.381	[*A*]this[*R*]can not be checked[*A*]with finite resources	context()	negated: True ,passive: True
0.722	[*A*]Most of the programs[*R*]are[*A*]infinite	context(they are)	negated: False ,passive: True
0.552	[*A*]they[*R*]are[*A*]servers with an infinite reactive loop	context()	negated: False ,passive: True
0.884	[*A*]the programs[*R*]are debugging[*A*]we	context()	negated: False ,passive: True
[LINE#210] We modified these programs to produce finite versions that could de checked with both projections, for the purpose of comparison.
0.271	[*A*]We[*R*]modified these programs to produce[*A*]finite versions that could de checked with both projections, for the purpose of comparison	context(We modified)	negated: False ,passive: False
0.388	[*A*]We[*R*]modified[*A*]these programs[*A*]to produce finite versions	context()	negated: False ,passive: False
0.887	[*A*]finite versions[*R*]could de checked[*A*]with both projections, for the purpose of comparison	context()	negated: False ,passive: False
[LINE#211] The results are summarized on the left hand side of Table 2, averaged over a series of test executions.
0.918	[*A*]The results[*R*]are summarized[*A*]on the left hand side of Table 2	context()	negated: False ,passive: True
[LINE#212] The third column shows the number of projected Java states, while the fourth column indicates the number of state transitions in Spin.
0.925	[*A*]the fourth column[*R*]indicates[*A*]the number of state transitions in Spin	context()	negated: False ,passive: False
0.942	[*A*]The third column[*R*]shows[*A*]the number of projected Java states	context()	negated: False ,passive: False
[LINE#213] The next two columns show the size of a Spin state and the total time of analysis.
0.967	[*A*]The next two columns[*R*]show[*A*]the size of a Spin state and the total time of analysis	context()	negated: False ,passive: False
[LINE#214] The last column of the table shows an approximation of the size of the Java states, before any projection.
0.956	[*A*]The last column of the table[*R*]shows[*A*]an approximation of the size of the Java states	context()	negated: False ,passive: False
[LINE#215] This number only takes into account the size of objects allocated in the heap.
0.894	[*A*]objects[*R*]allocated[*A*]in the heap	context()	negated: False ,passive: True
0.887	[*A*]This number[*R*]takes[*A*]into account[*A*]the size of objects	context()	negated: False ,passive: False
[LINE#216] Since the size of the heap changes dynamically, we report the maximum value the we observed during the execution of each program.
0.897	[*A*]the maximum value[*R*]observed[*A*]during the execution of each program	context()	negated: False ,passive: True
0.562	[*A*]we[*R*]report[*A*]the maximum value the we observed during the execution of each program[*A*]Since the size of the heap changes dynamically	context()	negated: False ,passive: False
[LINE#217] The size of states in Spin after the projection is influenced by several factors.
0.903	[*A*]the projection[*R*]is influenced[*A*]by several factors	context()	negated: False ,passive: True
[LINE#218] First, Spin has an overhead of 16B for a Promela specification with a single process, and a Bchi automata adds another 8B.
0.957	[*A*]a Bchi automata[*R*]adds[*A*]another 8B	context()	negated: False ,passive: False
0.964	[*A*]Spin[*R*]has[*A*]an overhead of 16B for a Promela specification with a single process[*A*]First	context()	negated: False ,passive: False
[LINE#219] Then, a step integer variable is added to track the Java state that is retrieved in each state (see Section 3.1.3).
0.922	[*A*]the Java state[*R*]is retrieved[*A*]in each state	context()	negated: False ,passive: True
0.920	[*A*]a step integer variable[*R*]to track[*A*]the Java state	context()	negated: False ,passive: False
0.934	[*A*]a step integer variable[*R*]is added[*A*]to track the Java state that is retrieved in each state (see Section 3.1.3[*A*]Then	context()	negated: False ,passive: True
[LINE#220] The variables used for generating test inputs, if any, are added to the global state as well.
0.934	[*A*]The variables used for generating test inputs,[*R*]are added[*A*]to the global state[*A*]as well	context()	negated: False ,passive: True
0.903	[*A*]The variables[*R*]used[*A*]for generating test inputs	context()	negated: False ,passive: True
[LINE#221] Furthermore, the counter projection requires an additional variable as described in Section 4.2.1.
0.897	[*A*]an additional variable[*R*]described[*A*]in Section 4.2.1	context()	negated: False ,passive: True
0.911	[*A*]the counter projection[*R*]requires[*A*]an additional variable as described in Section 4.2.1	context()	negated: False ,passive: False
[LINE#222] It is worth noting that the variables being monitored are not part of the global state, but are kept in a separate data structure, in order to support backtracking with minimal impact in the size of Spin states.
0.390	[*A*]It[*R*]is[*A*]worth noting that the variables are kept in a separate data structure , in order	context()	negated: False ,passive: True
0.732	[*A*]the variables[*R*]being monitored	context()	negated: False ,passive: False
0.390	[*A*]It[*R*]is[*A*]worth noting that the variables being monitored are not part of the global state	context()	negated: False ,passive: True
[LINE#223] TJT also has a deadlock detection algorithm.
0.869	[*A*]TJT[*R*]has[*A*]a deadlock detection algorithm	context()	negated: False ,passive: False
[LINE#224] Although the purpose of formula F7 was to detect the incorrect wait condition, it uncovered a deadlock in each execution of the program detected by the monitoring module.
0.903	[*A*]the program[*R*]detected[*A*]by the monitoring module	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]uncovered[*A*]a deadlock in each execution of the program	context()	negated: False ,passive: False
0.957	[*A*]the purpose of formula F7[*R*]was[*A*]to detect the incorrect wait condition	context()	negated: False ,passive: True
[LINE#225] Although deadlocks may be detected while using any property, omitting the temporal formula is recommended when specifically searching for them in order to prevent the trace being terminated early due to a specified property. .
0.903	[*A*]the trace[*R*]being terminated[*A*]early due to a specified property	context()	negated: False ,passive: True
0.894	[*A*]deadlocks[*R*]may be detected[*A*]while using any property	context()	negated: False ,passive: True
[LINE#226] Hash projectionWe also evaluated the hash projection, using all the properties described above.
0.783	[*A*]all the properties[*R*]described[*A*]above	context()	negated: False ,passive: True
0.897	[*A*]the hash projection[*R*]using[*A*]all the properties described above	context()	negated: False ,passive: False
0.914	[*A*]Hash projectionWe[*R*]evaluated[*A*]the hash projection, using all the properties	context()	negated: False ,passive: False
[LINE#227] Thanks to its cycle detection capabilities, we could use it for more tests than the counter projection.
0.309	[*A*]we[*R*]could use[*A*]it[*A*]for more tests than the counter projection	context()	negated: False ,passive: False
[LINE#228] The right hand side of Table 2 shows these results.
0.964	[*A*]The right hand side of Table 2[*R*]shows[*A*]these results	context()	negated: False ,passive: False
[LINE#229] The table shows that, compared with the counter projection, the hash projection is generally slower, due to the computation penalty associated with visiting the whole Java program state and computing its hash.
0.848	[*A*]the computation penalty[*R*]associated[*A*]with computing its hash	context()	negated: False ,passive: True
0.793	[*A*]the hash projection[*R*]is[*A*]generally slower	context(The table shows)	negated: False ,passive: True
0.853	[*A*]The table[*R*]shows[*A*]that , compared with the counter projection , the hash projection is generally slower , due to the computation penalty	context()	negated: False ,passive: False
0.925	[*A*]the computation penalty[*R*]associated[*A*]with visiting the whole Java program state	context()	negated: False ,passive: True
[LINE#230] As these results suggest the tests with more Java states are the ones where the test time increases the most.
0.948	[*A*]the test time[*R*]increases[*A*]the most[*A*]the ones	context()	negated: False ,passive: False
0.918	[*A*]these results[*R*]suggest[*A*]the tests with more Java states	context()	negated: False ,passive: False
[LINE#231] Also, the difference between the size of Spin states between the counter and the hash projections is constant: the hash projection adds a variable to store the hash of each state, but removes the counter variable.
0.903	[*A*]the difference[*R*]removes[*A*]the counter variable	context()	negated: False ,passive: False
0.943	[*A*]the difference between the size of Spin states between the counter and the hash projections[*R*]is[*A*]constant	context(the hash projection adds)	negated: False ,passive: True
0.916	[*A*]the hash projection[*R*]adds[*A*]a variable to store the hash of each state	context()	negated: False ,passive: False
[LINE#232] Although the size of the hash proper is 16B, in our implementation it is stored as a 32B character array, which explains the total difference of 28B.Furthermore, we included some additional tests that required true cycle detection, which is only possible under the hash projection.
0.933	[*A*]some additional tests[*R*]required[*A*]true cycle detection, which is only possible under the hash projection	context()	negated: False ,passive: False
0.231	[*A*]we[*R*]included[*A*]some additional tests that required true cycle detection,	context()	negated: False ,passive: True
0.940	[*A*]a 32B character array[*R*]explains[*A*]the total difference of 28B.Furthermore	context()	negated: False ,passive: False
0.490	[*A*]it[*R*]is stored[*A*]as a 32B character array[*A*]16B[*A*]in our implementation	context()	negated: False ,passive: True
0.920	[*A*]true cycle detection[*R*]is[*A*]only possible[*A*]under the hash projection	context()	negated: False ,passive: True
0.956	[*A*]the size of the hash proper[*R*]is[*A*]16B	context()	negated: False ,passive: True
[LINE#233] First, we tested Formula 3 from Section 2.1 (F3) on the FTP server.
0.639	[*A*]we[*R*]tested[*A*]Formula 3[*A*]from Section 2.1[*A*]on the FTP server[*A*]First	context()	negated: False ,passive: False
[LINE#234] In addition, we also tested a simple Java program that deals with lists in an infinite loop.
0.456	[*A*]we[*R*]tested[*A*]a simple Java program	context()	negated: False ,passive: False
[LINE#235] The program adds elements to the list and then removes them, and we checked that the list ended up with exactly one element an infinite number of times (F13).To end our experiments, we performed a small comparison between TJT and the LTL extension for JPF, using the hash projection.
0.355	[*A*]we[*R*]performed a small comparison between TJT and the LTL extension for JPF using[*A*]the hash projection	context(we performed)	negated: False ,passive: False
0.550	[*A*]we[*R*]performed[*A*]a small comparison between TJT and the LTL extension for JPF	context()	negated: False ,passive: False
0.231	[*A*]we[*R*]checked[*A*]that the list ended up with exactly one element	context()	negated: False ,passive: False
0.355	[*A*]we[*R*]performed a small comparison between TJT and the LTL extension for JPF using[*A*]the hash projection	context(we performed)	negated: False ,passive: False
0.355	[*A*]we[*R*]performed a small comparison between TJT and the LTL extension for JPF using[*A*]the hash projection	context(we performed)	negated: False ,passive: False
0.905	[*A*]The program[*R*]adds[*A*]elements[*A*]to the list	context(we performed)	negated: False ,passive: False
0.550	[*A*]we[*R*]performed[*A*]a small comparison between TJT and the LTL extension for JPF[*A*]using the hash projection	context()	negated: False ,passive: False
[LINE#236] Although both tools are based on model checking and can test LTL properties, their scopes are different.
0.383	[*A*]their scopes[*R*]are[*A*]different	context()	negated: False ,passive: True
0.903	[*A*]both tools[*R*]are based[*A*]on model checking	context()	negated: False ,passive: True
[LINE#237] JPF performs an exhaustive search over the complete space state of the program, while TJT analyzes a range of execution traces.
0.855	[*A*]TJT[*R*]analyzes[*A*]a range of execution traces	context()	negated: False ,passive: False
0.919	[*A*]JPF[*R*]performs[*A*]an exhaustive search over the complete space state of the program[*A*]while TJT analyzes a range of execution traces	context()	negated: False ,passive: False
[LINE#238] We compared both tools with some examples available with JPF-LTL, summarizing the results in Table 3.
0.333	[*A*]We[*R*]compared both tools summarizing[*A*]the results in Table 3	context(We compared)	negated: False ,passive: False
0.433	[*A*]We[*R*]compared[*A*]both tools[*A*]with some examples available with JPF-LTL[*A*]summarizing the results in Table 3	context()	negated: False ,passive: False
[LINE#239] In this table, the first two columns show the name of the example and the formula being analyzed, "Transitions" are the number of state transitions traversed, and "Time" the total time required to check the formula against the program.
0.790	[*A*]the name of the example and the formula[*R*]being analyzed	context(the first two columns show Transitions are)	negated: False ,passive: False
0.971	[*A*]the first two columns[*R*]show[*A*]the name of the example and the formula being analyzed[*A*]In this table	context(Transitions are)	negated: False ,passive: False
0.914	[*A*]Transitions[*R*]are[*A*]the number of state transitions traversed, and "Time	context()	negated: False ,passive: True
0.751	[*A*]the total time[*R*]required	context()	negated: False ,passive: False
0.785	[*A*]the number of state transitions[*R*]traversed	context()	negated: False ,passive: False
0.897	[*A*]the total time[*R*]to check[*A*]the formula against the program	context()	negated: False ,passive: False
[LINE#240] It is worth noting the disparity in time and space required for the analysis of the second formula with TJT, compared to the other two.
0.911	[*A*]space[*R*]required[*A*]for the analysis of the second formula with TJT	context()	negated: False ,passive: True
0.678	[*A*]It[*R*]is[*A*]worth noting the disparity in space required for the analysis of the second formula with TJT , compared to the other two	context()	negated: False ,passive: True
0.931	[*A*]the disparity in time[*R*]required[*A*]for the analysis of the second formula with TJT[*A*]compared to the other two	context()	negated: False ,passive: True
0.522	[*A*]It[*R*]is[*A*]worth noting the disparity in time	context()	negated: False ,passive: True
[LINE#241] This program deals with random number generators, and the property requires cycle detection.
0.903	[*A*]the property[*R*]requires[*A*]cycle detection	context()	negated: False ,passive: False
0.903	[*A*]This program[*R*]deals[*A*]with random number generators	context()	negated: False ,passive: False
[LINE#242] Although checking whether or not a single trace violates the property is relatively quick, the first few traces generated and analyzed by TJT did not violate the property.
0.920	[*A*]the first few traces[*R*]analyzed[*A*]by TJT	context()	negated: False ,passive: True
0.769	[*A*]the first few traces[*R*]generated	context()	negated: False ,passive: False
0.904	[*A*]checking whether or not a single trace violates the property[*R*]is[*A*]relatively quick	context()	negated: False ,passive: True
0.961	[*A*]the first few traces generated and analyzed by TJT[*R*]did not violate[*A*]the property	context()	negated: True ,passive: False
[LINE#243] Thus, when a violating trace was generated, the cost of the analysis had accumulated the analysis of the previous traces.
0.957	[*A*]the cost of the analysis[*R*]had accumulated[*A*]the analysis of the previous traces[*A*]when a violating trace was generated	context()	negated: False ,passive: False
0.751	[*A*]a violating trace[*R*]was generated	context()	negated: False ,passive: False
[LINE#244] The complexity of current software development is pushing programmers towards more automated analysis techniques, instead of the traditional interactive or postmortem debuggers.
0.932	[*A*]The complexity of current software development[*R*]is pushing[*A*]programmers[*A*]towards more automated analysis techniques	context()	negated: False ,passive: False
[LINE#245] For instance, unit testing allows the execution of test cases against a program, checking parts of the code such as single methods or classes in isolation (Runeson, 2006; JUnit testing and framework, xxxx; Beust and Suleiman, 2007; CppUnit framework, xxxx).
0.927	[*A*]test cases[*R*]checking[*A*]parts of the code such as single methods or classes in isolation	context()	negated: False ,passive: False
0.903	[*A*]unit testing[*R*]allows[*A*]the execution of test cases against a program	context()	negated: False ,passive: False
[LINE#246] Runtime monitoring tools usually carry out some controlled executions of instrumented code on real or emulated target platforms (Run-time Monitoring and Checking, (MaC), xxxx; Kraft et al., 2010).
0.961	[*A*]Runtime monitoring tools[*R*]carry out[*A*]some controlled executions of instrumented code on real or emulated target platforms[*A*]usually	context()	negated: False ,passive: False
[LINE#247] Model checking can produce and inspect all possible execution traces of a program, checking the presence or absence of failures along each trace (Clarke et al., 1999; Havelund and Pressburger, 2000; Beyer et al., 2007).
0.945	[*A*]Model checking[*R*]inspect[*A*]all possible execution traces of a program[*A*]checking the presence or absence of failures along each trace	context()	negated: False ,passive: False
0.788	[*A*]Model checking[*R*]can produce	context()	negated: False ,passive: False
[LINE#248] In the case of a failure, this technique records a trace to replay the failed execution.
0.943	[*A*]this technique[*R*]records[*A*]a trace to replay the failed execution[*A*]In the case of a failure	context()	negated: False ,passive: False
[LINE#249] To overcome some of the shortcomings of these automatic methods when used in isolation and to extend their domain of application, there have been several proposals that combine a few of them (Peled, 2003; Artho et al., 2003; Havelund and Rou, 2004).
0.810	[*A*]several proposals[*R*]combine[*A*]a few of them	context()	negated: False ,passive: False
[LINE#250] This paper discusses an approach to automated software debugging by the combination of model checking and runtime monitoring.
0.937	[*A*]This paper[*R*]discusses[*A*]an approach to automated software debugging by the combination of runtime monitoring	context()	negated: False ,passive: False
0.937	[*A*]This paper[*R*]discusses[*A*]an approach to automated software debugging by the combination of model checking	context()	negated: False ,passive: False
[LINE#251] We focus on its application to analyze the (infinite) executions of a given reactive and/or concurrent Java program.
0.309	[*A*]We[*R*]focus[*A*]on its application	context()	negated: False ,passive: False
[LINE#252] Model checking allows the software developer to describe correctness properties with specification languages such as Temporal Logic (Manna and Pnueli, 1992).
0.908	[*A*]the software developer[*R*]to describe[*A*]correctness properties[*A*]with specification languages such as Temporal Logic	context(Model checking allows)	negated: False ,passive: False
0.951	[*A*]Model checking[*R*]allows[*A*]the software developer to describe correctness properties with specification languages such as Temporal Logic	context()	negated: False ,passive: False
[LINE#253+254]  The properties could represent safety requirements, like p ("p is always true") and p U q ("q will be true, and p will be true in all previous states"), or liveness properties expressed with formulas such as p ("eventually p will be true"), p ("eventually p will be true forever"), and (p("p will always be followed by q"), p and p being any kind of proposition or even temporal formulas.
0.732	[*A*]liveness properties[*R*]expressed	context()	negated: False ,passive: False
0.813	[*A*]p[*R*]will be[*A*]true[*A*]in all previous states	context()	negated: False ,passive: True
0.835	[*A*]p[*R*]will be followed[*A*]by q[*A*]always	context()	negated: False ,passive: True
0.605	[*A*]q[*R*]will be[*A*]true	context()	negated: False ,passive: True
0.610	[*A*]p[*R*]is[*A*]always[*A*]true	context(p will be)	negated: False ,passive: True
0.641	[*A*]p[*R*]will be[*A*]true[*A*]forever[*A*]eventually	context()	negated: False ,passive: True
0.903	[*A*]The properties[*R*]could represent[*A*]safety requirements	context()	negated: False ,passive: False
[LINE#255] The most common use of LTL is to express complex liveness behaviors of infinite traces, which are the traces produced by reactive and/or concurrent software (Manna and Pnueli, 1992).In order to check whether or not a program satisfies an LTL formula, model checking algorithms were designed to produce the whole execution graph in a concurrent program and to efficiently detect execution traces violating a formula, presenting these traces as counter-examples.
0.897	[*A*]model checking algorithms[*R*]to produce[*A*]the whole execution graph[*A*]in a concurrent program	context()	negated: False ,passive: False
0.972	[*A*]model checking algorithms[*R*]were designed[*A*]to produce the whole execution graph in a concurrent program[*A*]the traces produced by reactive and/or concurrent software (Manna and Pnueli, 1992).	context()	negated: False ,passive: True
0.938	[*A*]infinite traces[*R*]are[*A*]the traces produced by reactive and/or concurrent software (Manna and Pnueli, 1992).In order to check whether or not a program satisfies an LTL formula, model checking algorithms were designed to produce the whole execution graph in a concurrent program and to efficiently detect execution traces violating a formula,	context()	negated: False ,passive: True
0.897	[*A*]model checking algorithms[*R*]to efficiently detect[*A*]execution traces violating a formula	context()	negated: False ,passive: False
0.903	[*A*]execution traces[*R*]violating[*A*]a formula	context()	negated: False ,passive: False
0.961	[*A*]The most common use of LTL[*R*]is[*A*]to express complex liveness behaviors of infinite traces	context()	negated: False ,passive: True
[LINE#256] Counter-examples provide the sequence of instructions to the error, and they are the main source of information used to debug the program.
0.894	[*A*]information[*R*]used[*A*]to debug the program	context()	negated: False ,passive: True
0.616	[*A*]they[*R*]are[*A*]the main source of information	context()	negated: False ,passive: True
0.894	[*A*]Counter-examples[*R*]provide[*A*]the sequence of instructions[*A*]to the error	context()	negated: False ,passive: False
[LINE#257] When we do not wish to produce all traces or check liveness properties, other less-expensive approaches, like the use of runtime monitors can be used to check only the subset of LTL representing safety properties.
0.961	[*A*]other less-expensive approaches, like the use of runtime monitors[*R*]to check[*A*]only the subset of LTL representing safety properties	context()	negated: False ,passive: False
0.979	[*A*]other less-expensive approaches, like the use of runtime monitors[*R*]can be used[*A*]to check only the subset of LTL representing safety properties	context()	negated: False ,passive: True
0.855	[*A*]LTL[*R*]representing[*A*]safety properties	context()	negated: False ,passive: False
0.444	[*A*]we[*R*]do not wish to check[*A*]liveness properties, other less-expensive approaches, like the use of runtime monitors can be used to check only the subset of LTL representing safety properties	context(we do not wish)	negated: True ,passive: False
0.388	[*A*]we[*R*]do not wish to produce[*A*]all traces	context(we do not wish)	negated: True ,passive: False
0.388	[*A*]we[*R*]do not wish[*A*]to produce all traces or check liveness properties	context()	negated: True ,passive: False
[LINE#258] Other monitor based approaches adapt the semantics of full LTL to finite executions, as done by Java PathExplorer (Havelund and Rou, 2004).
0.931	[*A*]Other monitor based approaches[*R*]adapt[*A*]the semantics of full LTL[*A*]to finite executions[*A*]as done by Java PathExplorer	context()	negated: False ,passive: False
[LINE#259] The original design of Java PathExplorer only considered finite executions, and to the best of our knowledge, the extension for infinite traces is still not available.
0.837	[*A*]the extension for infinite traces[*R*]is not[*A*]available[*A*]still	context()	negated: True ,passive: True
0.940	[*A*]The original design of Java PathExplorer[*R*]considered[*A*]finite executions	context()	negated: False ,passive: False
[LINE#260] Tools such as Verisoft (Godefroid, 1997) and CMC (Stoller, 2002) avoid storing the states of the program during monitoring, so they can perform a partial analysis of very large systems with little memory consumption.
0.909	[*A*]Tools such as CMC[*R*]avoid storing[*A*]the states of the program	context(Tools such as CMC avoid)	negated: False ,passive: False
0.897	[*A*]Tools such as CMC[*R*]avoid[*A*]storing the states of the program during monitoring[*A*]so they can perform a partial analysis of very large systems with little memory consumption	context()	negated: False ,passive: False
0.909	[*A*]Tools such as Verisoft[*R*]avoid storing[*A*]the states of the program	context(Tools such as Verisoft avoid)	negated: False ,passive: False
0.897	[*A*]Tools such as Verisoft[*R*]avoid[*A*]storing the states of the program during monitoring[*A*]so they can perform a partial analysis of very large systems with little memory consumption	context()	negated: False ,passive: False
0.720	[*A*]they[*R*]can perform[*A*]a partial analysis of very large systems with little memory consumption	context()	negated: False ,passive: False
[LINE#261] Unfortunately, this stateless approach does not permit the analysis of LTL for infinite traces.
0.925	[*A*]this stateless approach[*R*]does not permit[*A*]the analysis of LTL	context()	negated: True ,passive: False
[LINE#262] The analysis of an LTL formula along one or several potential infinite execution paths cannot be carried out with standard monitors, but requires storing the states of the program and the use of algorithms based on automata to recognize special cycles, like Bchi automata (Clarke et al., 1999).
0.971	[*A*]The analysis of an LTL formula along one or several potential infinite execution paths[*R*]requires[*A*]storing the states of the program	context()	negated: False ,passive: False
0.922	[*A*]The analysis of an LTL formula along one or several potential infinite execution paths[*R*]can not be carried out	context()	negated: True ,passive: False
[LINE#263+264]  Stateful approaches, like the one implemented in Java PathFinder(JPF) keep a stack with the current execution trace to control backtracking, to produce counter-examples and to check cycles, so they could check LTL on infinite traces.
0.921	[*A*]Stateful approaches , like the one[*R*]keep[*A*]a stack[*A*]with the current execution trace	context()	negated: False ,passive: False
0.918	[*A*]the one[*R*]implemented[*A*]in Java PathFinder	context()	negated: False ,passive: True
[LINE#265] However, at the time of writing this paper, the extension for checking LTL formulas can only detect a few program events.
0.956	[*A*]the extension for checking LTL formulas[*R*]can detect[*A*]a few program events[*A*]at the time of writing this paper	context()	negated: False ,passive: False
[LINE#266] In the following sections we expand on the current status of LTL verification with JPF in a comparison with our proposal.
0.350	[*A*]we[*R*]expand[*A*]on the current status of LTL verification with JPF[*A*]in a comparison with our proposal	context()	negated: False ,passive: False
[LINE#267] In this paper we propose a method to convert a Java execution trace into a sequence of states that can be analyzed by the model checker Spin (Holzmann, 2003).
0.905	[*A*]a sequence of states[*R*]can be analyzed[*A*]by the model checker	context()	negated: False ,passive: True
0.740	[*A*]we[*R*]propose[*A*]a method to convert a Java execution trace into a sequence of states[*A*]In this paper	context()	negated: False ,passive: False
[LINE#268] We use runtime monitoring to generate just the Spin oriented execution paths from real software, thereby allowing the formulas to be evaluated by Spin.
0.896	[*A*]the formulas[*R*]to be evaluated[*A*]by Spin	context(the Spin oriented allowing)	negated: False ,passive: True
0.884	[*A*]the Spin[*R*]oriented execution paths allowing[*A*]the formulas to be evaluated by Spin	context(the Spin oriented)	negated: False ,passive: False
0.921	[*A*]the Spin[*R*]oriented[*A*]execution paths[*A*]from real software[*A*]thereby allowing the formulas to be evaluated by Spin	context()	negated: False ,passive: False
0.157	[*A*]We[*R*]use runtime monitoring to generate	context(We use)	negated: False ,passive: False
0.388	[*A*]We[*R*]use[*A*]runtime monitoring[*A*]to generate	context()	negated: False ,passive: False
[LINE#269] Our work focuses on two major issues of software model checking, analysis of infinite executions and efficient abstraction of execution paths.
0.739	[*A*]Our work[*R*]focuses[*A*]on two major issues of software model checking , analysis of efficient abstraction of execution paths	context()	negated: False ,passive: False
0.739	[*A*]Our work[*R*]focuses[*A*]on two major issues of software model checking , analysis of infinite executions	context()	negated: False ,passive: False
[LINE#270] As Spin implements the analysis of LTL formulas by translation to Bchi automata, thanks to our method to feed Java executions to Spin as input, we can check the formulas on Java programs with infinite cycles.
0.498	[*A*]we[*R*]can check[*A*]the formulas on Java programs with infinite cycles	context()	negated: False ,passive: False
0.788	[*A*]Java executions[*R*]to Spin	context()	negated: False ,passive: False
0.794	[*A*]Spin[*R*]implements[*A*]the analysis of LTL formulas[*A*]thanks to our method	context()	negated: False ,passive: False
[LINE#271] Furthermore, the Spin stuttering mechanism for dealing with finite execution traces allows us to deal with any kind of program without redefining the original LTL semantics.
0.388	[*A*]us[*R*]to deal[*A*]with any kind of program	context(the Spin stuttering mechanism for dealing with finite execution traces allows)	negated: False ,passive: False
0.957	[*A*]the Spin stuttering mechanism for dealing with finite execution traces[*R*]allows[*A*]us to deal with any kind of program without redefining the original LTL semantics	context()	negated: False ,passive: False
[LINE#272] In order to address the second issue, the abstraction of execution paths, our conversion of Java traces into Spin oriented traces is based on two efficient abstraction methods of the full state of the program.
0.944	[*A*]the abstraction of execution paths[*R*]is based[*A*]on two efficient abstraction methods of the full state of the program	context()	negated: False ,passive: True
[LINE#273] The counter projection abstracts the Java state by preserving the variables which appear in the LTL formula and adding a counter to distinguish the rest of the state.
0.905	[*A*]the variables[*R*]appear[*A*]in the LTL formula	context()	negated: False ,passive: True
0.925	[*A*]The counter projection[*R*]abstracts[*A*]the Java state	context()	negated: False ,passive: False
[LINE#274] As we do not keep all the information, the counter projection is very efficient at the cost of being useful only for finite executions.
0.828	[*A*]the counter projection[*R*]is[*A*]very efficient	context()	negated: False ,passive: True
0.452	[*A*]we[*R*]do not keep[*A*]all the information	context()	negated: True ,passive: False
[LINE#275] The hash projection abstracts each Java state with the variables in the formula plus a hash of the whole state.
0.952	[*A*]The hash projection[*R*]abstracts[*A*]each Java state[*A*]with the variables in a hash of the whole state	context()	negated: False ,passive: False
0.925	[*A*]The hash projection[*R*]abstracts[*A*]each Java state[*A*]with the variables in the formula	context()	negated: False ,passive: False
[LINE#276] The way of constructing the hash makes the probability of conflict for two different states negligible, so we can rely on the Spin algorithm to check LTL based on cycle detection.
0.433	[*A*]we[*R*]can rely on the Spin algorithm to check[*A*]LTL	context(we can rely)	negated: False ,passive: False
0.433	[*A*]we[*R*]can rely[*A*]on the Spin algorithm[*A*]to check LTL based on cycle detection	context()	negated: False ,passive: False
0.932	[*A*]The way of constructing the hash[*R*]makes[*A*]the probability of conflict	context()	negated: False ,passive: False
[LINE#277] The paper provides a formal study of the correctness of both abstraction methods.
0.937	[*A*]The paper[*R*]provides[*A*]a formal study of the correctness of both abstraction methods	context()	negated: False ,passive: False
[LINE#278] We have implemented the proposed approach in TJT, a tool that combines runtime monitoring and model checking and allows Java application developers to debug programs by checking complex requirements represented with temporal logic in a transparent way: the actual Java program is analyzed on the final target platform without additional modifications by the user, while the test execution is managed in the usual integrated development environment.
0.433	[*A*]We[*R*]have implemented[*A*]the proposed approach in TJT	context(the actual Java program is analyzed)	negated: False ,passive: False
0.887	[*A*]a tool[*R*]combines[*A*]runtime model checking	context()	negated: False ,passive: False
0.433	[*A*]We[*R*]have implemented[*A*]the proposed approach in TJT	context(the actual Java program is analyzed)	negated: False ,passive: False
0.887	[*A*]a tool[*R*]combines[*A*]runtime monitoring	context()	negated: False ,passive: False
0.732	[*A*]complex requirements[*R*]represented	context()	negated: False ,passive: False
0.950	[*A*]Java application developers[*R*]by checking[*A*]complex requirements represented with temporal logic in a transparent way	context()	negated: False ,passive: False
0.905	[*A*]a tool[*R*]allows[*A*]Java application developers	context()	negated: False ,passive: False
0.911	[*A*]the test execution[*R*]is managed[*A*]in the usual integrated development environment	context()	negated: False ,passive: True
0.433	[*A*]We[*R*]have implemented[*A*]the proposed approach in TJT	context(the actual Java program is analyzed)	negated: False ,passive: False
0.950	[*A*]the actual Java program[*R*]is analyzed[*A*]on the final target platform[*A*]while the test execution is managed in the usual integrated development environment	context()	negated: False ,passive: True
[LINE#279+280]  Specifically, we combine the Spin model checker (Holzmann, 2003) and the runtime debugging API Java Debug Interface(JDI) (Java Platform Debugger Architecture, xxxx).
0.918	[*A*]the runtime[*R*]debugging[*A*]API Java Debug Interface	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]combine[*A*]the Spin model checker	context()	negated: False ,passive: False
[LINE#281] Checking each execution means evaluating a temporal formula representing a failure, over the observable states in the program.
0.911	[*A*]a temporal formula[*R*]representing[*A*]a failure	context()	negated: False ,passive: False
0.911	[*A*]Checking each execution[*R*]means[*A*]evaluating a temporal formula	context()	negated: False ,passive: False
[LINE#282] Such observable states are provided for Spin by a runtime monitoring module built on top of the JDI support in the Java virtual machine.
0.956	[*A*]a runtime monitoring module[*R*]built[*A*]on top of the JDI support in the Java virtual machine	context()	negated: False ,passive: True
0.925	[*A*]Such observable states[*R*]are provided[*A*]for Spin[*A*]by a runtime monitoring module	context()	negated: False ,passive: True
[LINE#283+284]  Both modules are integrated as a new Eclipse (Eclipse development environment, xxxx)plug-in for automatic debugging.
0.918	[*A*]Both modules[*R*]are integrated[*A*]as a new Eclipse (Eclipse development environment	context()	negated: False ,passive: True
[LINE#285] TJT stores the failed executions, so that the programmer can later replay them in Eclipse to locate and fix the bugs.
0.824	[*A*]the programmer[*R*]can replay them to fix[*A*]the bugs	context(the programmer can replay)	negated: False ,passive: False
0.845	[*A*]the programmer[*R*]can replay[*A*]them[*A*]in Eclipse[*A*]to fix the bugs[*A*]later	context()	negated: False ,passive: False
0.876	[*A*]the programmer[*R*]can replay[*A*]them[*A*]in Eclipse[*A*]to locate[*A*]later	context()	negated: False ,passive: False
[LINE#286] In summary, our method for combining Spin with runtime monitoring offers several advantages to Java developers:Linear time temporal logic (LTL) is a compact and rich formalism to represent both failures and desirable behaviors regarding a temporally ordered sequence of events and/or conditions to be checked along one execution.
0.911	[*A*]a rich formalism[*R*]to represent[*A*]conditions to be checked along one execution	context()	negated: False ,passive: False
0.913	[*A*]temporal logic[*R*]is[*A*]a rich formalism to represent conditions	context()	negated: False ,passive: True
0.911	[*A*]a rich formalism[*R*]to represent[*A*]desirable behaviors	context()	negated: False ,passive: False
0.913	[*A*]temporal logic[*R*]is[*A*]a rich formalism to represent desirable behaviors	context()	negated: False ,passive: True
0.911	[*A*]a rich formalism[*R*]to represent[*A*]both failures	context()	negated: False ,passive: False
0.913	[*A*]temporal logic[*R*]is[*A*]a rich formalism to represent both failures	context()	negated: False ,passive: True
0.911	[*A*]a compact formalism[*R*]to represent[*A*]conditions to be checked along one execution	context()	negated: False ,passive: False
0.913	[*A*]temporal logic[*R*]is[*A*]a compact formalism to represent conditions	context()	negated: False ,passive: True
0.713	[*A*]conditions[*R*]to be checked	context()	negated: False ,passive: False
0.911	[*A*]a compact formalism[*R*]to represent[*A*]desirable behaviors	context()	negated: False ,passive: False
0.913	[*A*]temporal logic[*R*]is[*A*]a compact formalism to represent desirable behaviors	context()	negated: False ,passive: True
0.911	[*A*]a compact formalism[*R*]to represent[*A*]both failures	context()	negated: False ,passive: False
0.913	[*A*]temporal logic[*R*]is[*A*]a compact formalism to represent both failures	context()	negated: False ,passive: True
0.902	[*A*]our method for combining Spin with runtime monitoring[*R*]offers[*A*]several advantages[*A*]to Java[*A*]d evelopers:Linear time[*A*]In summary	context()	negated: False ,passive: False
[LINE#287] Checking the LTL formula naturally considers the history of the execution, providing clear advantages compared with the isolated evaluation of invariants, assertions or just the values returned by methods.Model checking algorithms record the history of the failed execution, which we then use to implement a controlled replay to locate and fix the bugs.The support for model checking permits the analysis of potentially infinite executions, which may have two origins.
0.751	[*A*]just the values[*R*]returned	context()	negated: False ,passive: False
0.360	[*A*]we[*R*]to implement to fix[*A*]the bugs.The support for model checking permits the analysis of potentially infinite executions	context(the failed execution we use to implement)	negated: False ,passive: False
0.462	[*A*]we[*R*]to implement[*A*]a controlled replay to locate and fix the bugs.The support for model checking permits the analysis of potentially infinite executions,	context(the failed execution use)	negated: False ,passive: False
0.923	[*A*]the failed execution[*R*]use[*A*]to implement a controlled replay[*A*]then	context()	negated: False ,passive: True
0.751	[*A*]a controlled replay[*R*]to locate	context()	negated: False ,passive: False
0.921	[*A*]the analysis of potentially infinite executions[*R*]may have[*A*]two origins	context()	negated: False ,passive: False
0.929	[*A*]the history of the execution[*R*]providing[*A*]clear advantages[*A*]compared with the isolated evaluation of invariants, assertions or just the values	context(Checking the LTL formula considers)	negated: False ,passive: False
0.951	[*A*]Checking the LTL formula[*R*]considers[*A*]the history of the execution, providing clear advantages compared with the isolated evaluation of invariants, assertions or just the values returned by methods.Model checking algorithms record the history of the failed execution,	context()	negated: False ,passive: False
0.920	[*A*]methods.Model[*R*]checking[*A*]algorithms	context()	negated: False ,passive: False
[LINE#288] On the one hand, they are produced by reactive software like servers or daemons (e.g. FTP servers and web proxies) which are always in execution responding to interactions with an environment (for instance, client processes).
0.894	[*A*]execution[*R*]responding[*A*]to interactions with an environment	context()	negated: False ,passive: False
0.887	[*A*]web proxies[*R*]are[*A*]always[*A*]in execution	context()	negated: False ,passive: True
0.616	[*A*]they[*R*]are produced[*A*]by reactive software like servers or daemons	context()	negated: False ,passive: True
[LINE#289] On the other hand, bugs may introduce infinite loops that should not happen.
0.698	[*A*]infinite loops[*R*]should not happen	context()	negated: True ,passive: False
0.614	[*A*]bugs[*R*]may introduce[*A*]infinite loops that should not happen	context()	negated: False ,passive: False
[LINE#290] In both situations, model checking can be used to locate the cycles and to decide whether they should be considered as failures.The use of runtime techniques removes the extra work required to produce model checking oriented models and makes it possible to start the debugging work directly on the programmer's code.
0.911	[*A*]the extra work[*R*]required[*A*]to produce model	context()	negated: False ,passive: True
0.894	[*A*]model[*R*]checking[*A*]oriented models	context()	negated: False ,passive: False
0.846	[*A*]model checking[*R*]to decide[*A*]whether they should be considered as failures.The use of runtime techniques	context()	negated: False ,passive: False
0.935	[*A*]model checking[*R*]can be used[*A*]to decide whether they should be considered as failures.The use of runtime techniques removes the extra work[*A*]In both situations	context()	negated: False ,passive: True
0.943	[*A*]model checking[*R*]can be used[*A*]to locate the cycles[*A*]In both situations	context()	negated: False ,passive: True
[LINE#291] We do not intend to perform "full" model checking of Java programs, like Java PathFinder.
0.505	[*A*]We[*R*]do not intend to perform[*A*]full" model checking of Java programs, like Java PathFinder	context(We do not intend)	negated: True ,passive: False
0.388	[*A*]We[*R*]do not intend[*A*]to perform "full" model	context()	negated: True ,passive: False
[LINE#292] Full model checking requires a specific virtual machine to control the Java execution in order to carry out the exploration of all possible execution paths, which is time- and memory-consuming.
0.919	[*A*]a specific virtual machine[*R*]to control[*A*]memory - consuming	context()	negated: False ,passive: False
0.911	[*A*]Full model checking[*R*]requires[*A*]a specific virtual machine to control memory - consuming	context()	negated: False ,passive: False
0.919	[*A*]a specific virtual machine[*R*]to control[*A*]time	context()	negated: False ,passive: False
0.911	[*A*]Full model checking[*R*]requires[*A*]a specific virtual machine to control time	context()	negated: False ,passive: False
0.931	[*A*]a specific virtual machine[*R*]to control[*A*]the Java execution	context()	negated: False ,passive: False
0.925	[*A*]Full model checking[*R*]requires[*A*]a specific virtual machine[*A*]to control the Java execution	context()	negated: False ,passive: False
[LINE#293] Our approach consists of using only some features of model checking to have a light automated debugging method that helps the programmer to locate errors.
0.773	[*A*]a light[*R*]automated[*A*]debugging method that helps the programmer to locate errors	context()	negated: False ,passive: False
0.878	[*A*]the programmer[*R*]to locate[*A*]errors	context(a light automated debugging method helps)	negated: False ,passive: False
0.915	[*A*]a light automated debugging method[*R*]helps[*A*]the programmer to locate errors	context()	negated: False ,passive: False
0.638	[*A*]Our approach[*R*]consists[*A*]of using only some features of model	context()	negated: False ,passive: True
[LINE#294] Potential errors are described with temporal logic and we use the capability of model checking to check the temporal logic formula in "one execution path", even if the execution path corresponds to the infinite behavior of a reactive program.
0.569	[*A*]we[*R*]use[*A*]the capability of model checking to check the temporal logic formula in " one execution path "[*A*]even if the execution path corresponds to the infinite behavior of a reactive program	context()	negated: False ,passive: False
0.903	[*A*]Potential errors[*R*]are described[*A*]with temporal logic	context()	negated: False ,passive: True
[LINE#295] This execution path is naturally produced by the execution of the program in the real environment, with the standard Java virtual machine.
0.915	[*A*]This execution path[*R*]is produced[*A*]by the execution of the program in the real environment	context()	negated: False ,passive: True
[LINE#296] This is a cost-effective application of model checking to program traces that is nevertheless useful for finding faults in concurrent programs and debugging their causes.
0.850	[*A*]program traces[*R*]is[*A*]nevertheless useful for debugging their causes	context()	negated: False ,passive: True
0.913	[*A*]program traces[*R*]is[*A*]nevertheless useful for finding faults in concurrent programs	context()	negated: False ,passive: True
0.938	[*A*]a cost - effective application of model[*R*]checking[*A*]to program traces	context()	negated: False ,passive: False
0.567	[*A*]This[*R*]is[*A*]a cost - effective application of model checking to program traces	context()	negated: False ,passive: True
[LINE#297] The use of LTL formulas and a reduced set of variables of interest produces traces as counterexamples, which are very valuable when locating bugs (Clarke et al., 2009).
0.938	[*A*]a reduced set of variables of interest[*R*]produces[*A*]traces	context()	negated: False ,passive: False
0.932	[*A*]counterexamples[*R*]are[*A*]very valuable[*A*]when locating bugs ( Clarke et al . , 2009	context()	negated: False ,passive: True
0.944	[*A*]The use of LTL formulas[*R*]produces[*A*]traces as counterexamples	context()	negated: False ,passive: False
[LINE#298] This is specially relevant in concurrent programs where it is usually more important and difficult to find interleaving of actions that produce faults, than failure-inducing test inputs (Baiardi et al., 1986).
0.877	[*A*]actions[*R*]produce[*A*]faults	context()	negated: False ,passive: False
0.449	[*A*]This[*R*]is[*A*]specially relevant in concurrent programs	context()	negated: False ,passive: True
[LINE#299] While the analysis of the traces for finding the root cause is still a manual process, the formulas and the selected variables of interest significantly reduce the size of the traces to analyze (Alipour, 2012).This paper is an extension of previous work of ours presented in (Adalid et al., 2012).
0.964	[*A*]the analysis of the traces for finding the root cause[*R*]is[*A*]still[*A*]the selected variables of interest	context()	negated: False ,passive: True
0.489	[*A*]significantly[*R*]reduce[*A*]the size of the traces	context(This paper is)	negated: False ,passive: True
0.489	[*A*]significantly[*R*]reduce[*A*]the size of the traces	context(This paper is)	negated: False ,passive: True
0.964	[*A*]the analysis of the traces for finding the root cause[*R*]is[*A*]still[*A*]the formulas	context()	negated: False ,passive: True
0.489	[*A*]significantly[*R*]reduce[*A*]the size of the traces	context(This paper is)	negated: False ,passive: True
0.908	[*A*]This paper[*R*]is[*A*]an extension of previous work of ours	context()	negated: False ,passive: True
0.964	[*A*]the analysis of the traces for finding the root cause[*R*]is[*A*]still[*A*]a manual process	context()	negated: False ,passive: True
0.749	[*A*]ours[*R*]presented[*A*]in	context()	negated: False ,passive: True
[LINE#300] In particular, the description of our approach, its implementation, the experimental results and comparison with related work have been significantly expanded.
0.838	[*A*]the description of comparison with related work[*R*]have been expanded[*A*]significantly	context()	negated: False ,passive: True
0.824	[*A*]the description of the experimental results[*R*]have been expanded[*A*]significantly	context()	negated: False ,passive: True
0.447	[*A*]the description of its implementation[*R*]have been expanded[*A*]significantly	context()	negated: False ,passive: True
0.447	[*A*]the description of our approach[*R*]have been expanded[*A*]significantly	context()	negated: False ,passive: True
[LINE#301] The rest of the paper is organized as follows.
0.814	[*A*]The rest of the paper[*R*]is organized[*A*]as follows	context()	negated: False ,passive: True
[LINE#302] Section 2 introduces the use of model checking for debugging Java programs using a real example.
0.918	[*A*]Section 2[*R*]introduces[*A*]the use of model checking for debugging Java programs	context()	negated: False ,passive: False
[LINE#303] Section 3 presents the architecture of TJT for combining model checking and Java runtime monitoring.
0.918	[*A*]Section 3[*R*]presents[*A*]the architecture of TJT[*A*]for combining Java runtime monitoring	context()	negated: False ,passive: False
0.918	[*A*]Section 3[*R*]presents[*A*]the architecture of TJT[*A*]for combining model checking	context()	negated: False ,passive: False
[LINE#304] The formalization of the abstraction approach and the preservation results are presented in Section 4.
0.932	[*A*]The formalization of the preservation results[*R*]are presented[*A*]in Section 4	context()	negated: False ,passive: True
0.932	[*A*]The formalization of the abstraction approach[*R*]are presented[*A*]in Section 4	context()	negated: False ,passive: True
[LINE#305] Experimental results of the case studies are summarized in Section 5.
0.932	[*A*]Experimental results of the case studies[*R*]are summarized[*A*]in Section 5	context()	negated: False ,passive: True
[LINE#306] In Section 6 we compare our tool with related proposals.
0.444	[*A*]we[*R*]compare[*A*]our tool[*A*]with related proposals[*A*]In Section 6	context()	negated: False ,passive: False
[LINE#307] Finally, Section 7 presents some conclusions and points of interest for future work.
0.903	[*A*]Section 7[*R*]presents[*A*]some points of interest for future work	context()	negated: False ,passive: False
0.903	[*A*]Section 7[*R*]presents[*A*]some conclusions	context()	negated: False ,passive: False
[LINE#308+309]  Model checking for debuggingIn this sectionwe outline how model checking can be applied for the debugging of real Java programs, as the motivation for the development of our tool.
0.918	[*A*]model checking[*R*]can be applied[*A*]for the debugging of real Java programs	context()	negated: False ,passive: True
0.932	[*A*]Model[*R*]checking[*A*]for debuggingIn[*A*]this sectionwe outline	context()	negated: False ,passive: False
[LINE#310] We introduce a real example (an open source FTP server) and show several tests where the use of LTL formulas would be useful.
0.968	[*A*]the use of LTL formulas[*R*]would be[*A*]useful[*A*]several tests	context()	negated: False ,passive: True
0.452	[*A*]We[*R*]introduce[*A*]a real example	context()	negated: False ,passive: False
[LINE#311] Then we introduce the semantics of the LTL formulas that we consider in our approach, i.e. the usual one for infinite traces.
0.865	[*A*]the LTL formulas[*R*]consider[*A*]in our approach	context()	negated: False ,passive: True
0.639	[*A*]we[*R*]introduce[*A*]the semantics of the LTL formulas[*A*]Then	context()	negated: False ,passive: False
[LINE#312] Finally, we discuss how Spin performs the analysis of LTL formulas, translated into Bchi automata..
0.845	[*A*]Spin[*R*]performs[*A*]the analysis of LTL formulas	context(we discuss)	negated: False ,passive: False
0.577	[*A*]we[*R*]discuss[*A*]how Spin performs the analysis of LTL formulas[*A*]Finally	context()	negated: False ,passive: False
0.928	[*A*]LTL formulas[*R*]translated[*A*]into Bchi automata	context()	negated: False ,passive: True
[LINE#313] Motivating exampleTo illustrate our proposal we use an FTP server (Sorotokin, xxxx).
0.443	[*A*]we[*R*]use[*A*]an FTP server	context(Motivating exampleTo illustrate)	negated: False ,passive: False
0.846	[*A*]Motivating exampleTo[*R*]illustrate[*A*]our proposal	context()	negated: False ,passive: False
[LINE#314] This server understands the usual commands and can handle several concurrent user connections.
0.903	[*A*]This server[*R*]can handle[*A*]several concurrent user connections	context()	negated: False ,passive: False
0.903	[*A*]This server[*R*]understands[*A*]the usual commands	context()	negated: False ,passive: False
[LINE#315] We show several tests that a programmer may want to perform on the code of the server, using LTL formulas where the variables and events of the program can be referenced.
0.785	[*A*]the events of the program[*R*]can be referenced	context()	negated: False ,passive: False
0.849	[*A*]a programmer[*R*]may want using[*A*]LTL formulas	context(a programmer may want)	negated: False ,passive: False
0.878	[*A*]a programmer[*R*]may want to perform[*A*]on the code of the server	context(a programmer may want)	negated: False ,passive: False
0.878	[*A*]a programmer[*R*]may want[*A*]to perform on the code of the server	context()	negated: False ,passive: False
0.732	[*A*]the variables[*R*]can be referenced	context()	negated: False ,passive: False
0.390	[*A*]We[*R*]show[*A*]several tests that a programmer may want to perform on the code of the server	context()	negated: False ,passive: False
[LINE#316] The formulas are presented in a formal notation, but using helper functions, such as "loc()" for checking the program counter location, that are available in our tool.
0.810	[*A*]helper functions[*R*]are[*A*]available in our tool	context()	negated: False ,passive: True
0.715	[*A*]The formulas[*R*]using[*A*]helper functions, such as "loc()" for checking the program counter location, that are available in our tool	context()	negated: False ,passive: False
[LINE#317+318]  It is worth noting that the following three formulas represent liveness properties to be evaluated on potentially infinite executions, and they cannot be handled by other runtime checkers cited in Sections 1 and 6.The code in Fig.1 corresponds to the main loop in the server.
0.552	[*A*]they[*R*]can not be handled[*A*]by other runtime checkers	context()	negated: True ,passive: True
0.925	[*A*]other runtime checkers[*R*]cited[*A*]in 6.The code in Fig.1	context()	negated: False ,passive: True
0.925	[*A*]other runtime checkers[*R*]cited[*A*]in Sections 1	context()	negated: False ,passive: True
0.903	[*A*]liveness properties[*R*]to be evaluated[*A*]on potentially infinite executions	context()	negated: False ,passive: True
[LINE#319] The programmer may want check if the program variables in the loop are correctly cleared between client connections.
0.932	[*A*]the program variables in the loop[*R*]are correctly cleared[*A*]between client connections	context()	negated: False ,passive: True
0.937	[*A*]The programmer[*R*]may want[*A*]check[*A*]if the program variables in the loop are correctly cleared between client connections	context()	negated: False ,passive: False
[LINE#320+321+322]  For instance, to check that the incoming variable is set to null after each iteration we could use the following formula:(1)  (loc("FTPServer:285)(incoming=formula states that, after reaching line 285 of the FTPServer.java file in Fig. 1), the incoming variable should be null at some point in the future.
0.452	[*A*]we[*R*]could use[*A*]the following formula	context()	negated: False ,passive: False
0.897	[*A*]the incoming variable[*R*]to null[*A*]after each iteration	context()	negated: False ,passive: True
0.713	[*A*]incoming=formula[*R*]states	context()	negated: False ,passive: False
[LINE#323]  2 shows the method that handles CWD.
0.905	[*A*]the method[*R*]handles[*A*]CWD	context()	negated: False ,passive: False
0.264	[*A*]2[*R*]shows[*A*]the method that handles CWD	context()	negated: False ,passive: False
[LINE#324] If a client performs an erroneous request the operation should fail, but the server should recover from the exception and return the appropriate error code (line 471).
0.903	[*A*]the server[*R*]should recover[*A*]from the exception	context()	negated: False ,passive: True
0.732	[*A*]the operation[*R*]should fail	context()	negated: False ,passive: False
0.903	[*A*]a client[*R*]performs[*A*]an erroneous request the operation should fail	context()	negated: False ,passive: False
[LINE#325+326+327+328]  The programmer may want to check if this code is reachable when a client misbehaves, using the following formula:(2) (streq(FTPDConnection.status,"CDUP) (loc("FTPDConnection:470)))Testingthese and other properties requires the use of controlled mock clients as part of the test fixture.
0.905	[*A*]this code[*R*]is[*A*]reachable[*A*]when a client misbehaves	context(The programmer may want to check using the following formula requires)	negated: False ,passive: True
0.878	[*A*]The programmer[*R*]may want to check[*A*]if this code is reachable when a client misbehaves	context(The programmer may want using the following formula requires)	negated: False ,passive: False
0.878	[*A*]The programmer[*R*]may want[*A*]to check if this code is reachable	context(using the following formula requires)	negated: False ,passive: False
0.732	[*A*]a client[*R*]misbehaves	context()	negated: False ,passive: False
0.905	[*A*]this code[*R*]is[*A*]reachable[*A*]when a client misbehaves	context(The programmer may want to check using the following formula requires)	negated: False ,passive: True
0.878	[*A*]The programmer[*R*]may want to check[*A*]if this code is reachable when a client misbehaves	context(The programmer may want using the following formula requires)	negated: False ,passive: False
0.878	[*A*]The programmer[*R*]may want[*A*]to check if this code is reachable	context(using the following formula requires)	negated: False ,passive: False
0.922	[*A*]using the following formula[*R*]requires[*A*]the use of controlled mock clients as part of the test fixture	context()	negated: False ,passive: False
[LINE#329] In this case, the client tries to send several CDUP commands (change to parent directory), which are executed as CWD commands in the server and should lead to the behavior described above.
0.767	[*A*]the behavior[*R*]described[*A*]above	context()	negated: False ,passive: True
0.922	[*A*]several CDUP commands[*R*]should lead[*A*]to the behavior	context()	negated: False ,passive: False
0.896	[*A*]the client[*R*]tries to send[*A*]several CDUP commands	context(the client tries)	negated: False ,passive: False
0.939	[*A*]the client[*R*]tries[*A*]to send several CDUP commands[*A*]In this case	context()	negated: False ,passive: False
0.934	[*A*]several CDUP commands[*R*]are executed[*A*]as CWD commands[*A*]in the server	context()	negated: False ,passive: True
[LINE#330] The final condition that we want to check deals with thread scheduling and fairness.
0.397	[*A*]we[*R*]want to check[*A*]deals with fairness	context(we want)	negated: False ,passive: False
0.467	[*A*]we[*R*]want[*A*]to check deals with fairness	context()	negated: False ,passive: False
0.397	[*A*]we[*R*]want to check[*A*]deals with thread scheduling	context(we want)	negated: False ,passive: False
0.467	[*A*]we[*R*]want[*A*]to check deals with thread scheduling	context()	negated: False ,passive: False
[LINE#331] In addition to synchronization problems, multithreaded programs are prone to fairness issues: some of the threads may take all the CPU time, leaving others starving.
0.850	[*A*]some of the threads[*R*]may take all the CPU time leaving[*A*]others[*A*]starving	context(some of the threads may take)	negated: False ,passive: False
0.878	[*A*]multithreaded programs[*R*]are[*A*]prone to fairness issues	context(some of the threads may take)	negated: False ,passive: True
0.897	[*A*]some of the threads[*R*]may take[*A*]all the CPU time[*A*]leaving others starving	context()	negated: False ,passive: False
[LINE#332] The programmer may want to check whether this is a possible outcome under the default scheduling employed by the JVM or under other schedulings that may be forced in the execution.
0.386	[*A*]this[*R*]is[*A*]a possible outcome under the default scheduling	context(The programmer may want to check)	negated: False ,passive: True
0.920	[*A*]The programmer[*R*]may want to check[*A*]whether this is a possible outcome under the default scheduling	context(The programmer may want)	negated: False ,passive: False
0.920	[*A*]The programmer[*R*]may want[*A*]to check whether this is a possible outcome under the default scheduling	context()	negated: False ,passive: False
0.887	[*A*]other schedulings[*R*]may be forced[*A*]in the execution	context()	negated: False ,passive: True
0.925	[*A*]the default scheduling[*R*]employed[*A*]by the JVM or under other schedulings	context()	negated: False ,passive: True
[LINE#333+334]  For instance, we can check the fairness between two clients that compete with each other to interact with the FTP server in a loop.(3)(req2resp2))For clarity, in the previous formula we used boolean propositions, such as req1, instead of referencing program variables like in the first two formulas.
0.879	[*A*]two clients[*R*]compete with each other to interact[*A*]with the FTP server[*A*]in a loop	context(two clients compete)	negated: False ,passive: False
0.921	[*A*]two clients[*R*]compete[*A*]with each other[*A*]to interact with the FTP server in a loop.(3)(req2resp2))For clarity, in the previous formula	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]used[*A*]boolean propositions	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]can check[*A*]the fairness between two clients	context()	negated: False ,passive: False
[LINE#335] These propositions refer to auxiliary boolean variables in the FTP clients, i.e. the clientFTP and clientFTP2 classes. .
0.918	[*A*]These propositions[*R*]refer[*A*]to auxiliary boolean variables in the FTP clients	context()	negated: False ,passive: False
[LINE#336] this section, we give a formal characterization of LTL formulas for Java, like the three examples used above.
0.783	[*A*]the three examples[*R*]used[*A*]above	context()	negated: False ,passive: True
0.639	[*A*]we[*R*]give[*A*]a formal characterization of LTL formulas for Java[*A*]this section	context()	negated: False ,passive: False
[LINE#337] Let Prog be a Java program and Var an enumerable set of variable names used by Prog.
0.918	[*A*]variable names[*R*]used[*A*]by Prog	context()	negated: False ,passive: True
[LINE#338] The variables' names may be recursively constructed by appending the name of class members to object identifiers.
0.769	[*A*]The variables' names[*R*]may be recursively constructed	context()	negated: False ,passive: False
[LINE#339] For instance, if o is a reference to an object of class C, and f is an instance variable of C, o.f is the name of the variable recording the value of field f in the object instance o.
0.385	[*A*]o.f[*R*]is the name of[*A*]the variable recording	context()	negated: False ,passive: False
0.937	[*A*]the value of field[*R*]f[*A*]in the object instance	context()	negated: False ,passive: True
0.852	[*A*]o.f[*R*]is[*A*]the name of the variable recording	context()	negated: False ,passive: True
0.495	[*A*]f[*R*]is[*A*]an instance variable of C	context()	negated: False ,passive: True
[LINE#340] Values of Java variables may belong to a Java primitive data type (int, char, ) or may be a reference if the variable is an object.
0.925	[*A*]the variable[*R*]is[*A*]an object	context()	negated: False ,passive: True
0.928	[*A*]Values of Java variables[*R*]may be[*A*]a reference if the variable is an object	context()	negated: False ,passive: True
0.949	[*A*]Values of Java variables[*R*]may belong[*A*]to a Java primitive data type	context()	negated: False ,passive: False
[LINE#341] Let A and S be the set of possible memory references and the set of all possible values of Java primitive data types.
[LINE#342]  A state of a Java program is a function :.
0.961	[*A*]A state of a Java program[*R*]is[*A*]a function	context()	negated: False ,passive: True
[LINE#343] VarAS that associates each variable with its value.
0.840	[*A*]VarAS[*R*]associates[*A*]each variable[*A*]with its value	context()	negated: False ,passive: False
[LINE#344] Let us denote with States the set of possible states of a Java program Prog.
[LINE#345] Assume that if h is a variable referencing a thread, then (h.cp)int represents the position of the program counter of h in .
0.568	[*A*]a variable[*R*]referencing[*A*]a thread	context()	negated: False ,passive: False
0.852	[*A*]h[*R*]is[*A*]a variable referencing a thread	context()	negated: False ,passive: True
[LINE#346] Each possible execution of Prog may be represented as an infinite sequence of states11If the sequence is finite, we assume that the last state is infinitely repeated.(4)t=012StatesStates being the set of all possible infinite sequences of elements from States, called traces.
0.929	[*A*]t=012StatesStates[*R*]being[*A*]the set of all possible infinite sequences of elements from States	context(we assume)	negated: False ,passive: True
0.706	[*A*]the last state[*R*]is infinitely repeated	context(we assume)	negated: False ,passive: False
0.777	[*A*]the sequence[*R*]is[*A*]finite	context(we assume)	negated: False ,passive: True
0.162	[*A*]we[*R*]assume	context()	negated: False ,passive: False
0.962	[*A*]the set of all possible infinite sequences of elements from States[*R*]called[*A*]traces	context()	negated: False ,passive: True
0.953	[*A*]Each possible execution of Prog[*R*]may be represented[*A*]as an infinite sequence of states11If	context()	negated: False ,passive: True
[LINE#347] We now recall the syntax and semantics of LTL.
0.599	[*A*]We[*R*]recall[*A*]the semantics of LTL[*A*]now	context()	negated: False ,passive: False
0.599	[*A*]We[*R*]recall[*A*]the syntax of LTL[*A*]now	context()	negated: False ,passive: False
[LINE#348] Let Prop be a set of atomic propositions.
[LINE#349] The set of LTL temporal formulas may be inductively built using the elements of Prop, the standard Boolean operators, and the temporal operators: next "", always "", eventually "", and until "U".
0.781	[*A*]The set of LTL temporal formulas[*R*]may be inductively built always	context()	negated: False ,passive: False
0.781	[*A*]The set of LTL temporal formulas[*R*]may be inductively built next always	context()	negated: False ,passive: False
[LINE#350]  We assume that given a Java state , and an atomic proposition pProp, p represents the result of evaluating p on , that is, p holds iff  satisfies.
0.522	[*A*]p[*R*]holds[*A*]iff satisfies	context()	negated: False ,passive: False
0.813	[*A*]p[*R*]represents[*A*]the result of evaluating p on	context()	negated: False ,passive: False
0.467	[*A*]p[*R*]holds[*A*]iff satisfies	context(We assume)	negated: False ,passive: False
0.202	[*A*]We[*R*]assume[*A*]that given a Java state , that is , p holds iff satisfies	context()	negated: False ,passive: False
[LINE#351] In what follows, given a (possibly infinite) Java trace t=01, we denote with ti=i the suffix of t starting at state i.
0.639	[*A*]we[*R*]denote[*A*]with ti=i[*A*]In what follows	context()	negated: False ,passive: False
[LINE#352] Consider pProp, and f and g two LTL formulas.
[LINE#353+354+355]  We inductively define  over traces and LTL formulas as follows.1tip iff ip.2tip iff ip.3tipq iff tip or tiq.4ti f.6tif iff ji.(tjf).7tif U g iff ji.(tjg and ik<j.[tkf]).Note that the operator implies "" is usually omitted in these rules and transformed into a combination of negation and disjunction.
0.904	[*A*]U[*R*]g[*A*]iff ji	context()	negated: False ,passive: False
0.524	[*A*]We[*R*]inductively define[*A*]as follows.1tip iff ip.2tip iff ip.3tipq iff tip or tiq.4ti f.6tif iff ji.(tjf	context()	negated: False ,passive: False
[LINE#356] In what follows, we use the same LTL semantics as Spin, without the next operator as usual.
0.498	[*A*]we[*R*]use[*A*]the same LTL semantics[*A*]as Spin	context()	negated: False ,passive: False
[LINE#357] Note that in tf, t may be a prefix of a complete Java trace, i.e. it may not be necessary to generate the whole trace in order to check the satisfaction of a property. .
0.840	[*A*]t[*R*]may be[*A*]a prefix of a complete Java trace	context()	negated: False ,passive: True
[LINE#358] Checking LTL with SPINSpin is a well known model checker for analyzing models of software and other complex systems, defined with the Promela language.
0.913	[*A*]other complex systems[*R*]defined[*A*]with the Promela language	context()	negated: False ,passive: True
0.944	[*A*]Checking LTL with SPINSpin[*R*]is[*A*]a well known model checker for analyzing models of other complex systems	context()	negated: False ,passive: True
0.944	[*A*]Checking LTL with SPINSpin[*R*]is[*A*]a well known model checker for analyzing models of software	context()	negated: False ,passive: True
[LINE#359] Promela contains constructions for describing concurrent and non-deterministic behavior which, combined with the right tool, makes it easier to discover unexpected events or interactions which could be difficult to find in the traditional debugging tools available for programming languages.
0.939	[*A*]unexpected events or interactions[*R*]could be[*A*]difficult to find in the traditional debugging tools available for programming languages	context()	negated: False ,passive: True
0.838	[*A*]concurrent and non-deterministic behavior[*R*]makes[*A*]it easier to discover unexpected events or interactions	context()	negated: False ,passive: False
0.920	[*A*]Promela[*R*]contains[*A*]constructions for describing concurrent and non-deterministic behavior	context()	negated: False ,passive: False
[LINE#360] A Promela model produces a set of possible executions called execution traces or paths.
0.903	[*A*]possible executions[*R*]called[*A*]execution traces or paths	context()	negated: False ,passive: True
0.933	[*A*]A Promela model[*R*]produces[*A*]a set of possible executions	context()	negated: False ,passive: False
[LINE#361] The role of Spin is to look for traces that satisfy or violate a given set of properties.
0.877	[*A*]traces[*R*]violate[*A*]a given set of properties	context()	negated: False ,passive: False
0.677	[*A*]traces[*R*]satisfy	context()	negated: False ,passive: False
0.953	[*A*]The role of Spin[*R*]is[*A*]to look for traces	context()	negated: False ,passive: True
[LINE#362] Properties include deadlocks, assertions, code reachability or non-progress loops.
0.894	[*A*]Properties[*R*]include[*A*]deadlocks, assertions, code reachability or non-progress loops	context()	negated: False ,passive: True
[LINE#363+364]  However, the most interesting set of properties are complex requirements described with linear temporal logic (LTL)(Manna and Pnueli, 1992).Spin implements the algorithms by Vardi and Wolper (1986) to check LTL properties, which are based in the translation of the negated LTL formula into a Bchi automaton.
0.845	[*A*]Spin[*R*]implements[*A*]the algorithms[*A*]by Wolper ( 1986[*A*]to check LTL properties	context()	negated: False ,passive: False
0.781	[*A*]Spin[*R*]implements the algorithms to check[*A*]LTL properties	context(Spin implements)	negated: False ,passive: False
0.845	[*A*]Spin[*R*]implements[*A*]the algorithms[*A*]by Vardi ( 1986[*A*]to check LTL properties	context()	negated: False ,passive: False
0.781	[*A*]Spin[*R*]implements the algorithms to check[*A*]LTL properties	context(Spin implements)	negated: False ,passive: False
0.845	[*A*]Spin[*R*]implements[*A*]the algorithms[*A*]to check LTL properties	context()	negated: False ,passive: False
0.954	[*A*]LTL properties[*R*]are based[*A*]in the translation of the negated LTL formula into a Bchi automaton	context()	negated: False ,passive: True
[LINE#365+366]  A Bchi automaton is defined as a standard automaton that recognizes states in a programm to be analysed, but with the addition of final states (also called "accepting states")that restrict the number of executions allowed by the automaton.
0.732	[*A*]a programm[*R*]to be analysed	context()	negated: False ,passive: False
0.894	[*A*]executions[*R*]allowed[*A*]by the automaton	context()	negated: False ,passive: True
0.897	[*A*]a standard automaton[*R*]recognizes[*A*]states	context()	negated: False ,passive: False
0.934	[*A*]final states (also called "accepting states[*R*]restrict[*A*]the number of executions	context()	negated: False ,passive: False
0.933	[*A*]A Bchi automaton[*R*]is defined[*A*]as a standard automaton	context()	negated: False ,passive: True
[LINE#367] In particular, we say that one execution of the program violates the original LTL formula if the corresponding Bchi automaton visits, at least, one of the accepting states infinitely often.
0.920	[*A*]one execution of the program[*R*]violates[*A*]the original LTL formula	context(we say)	negated: False ,passive: False
0.309	[*A*]we[*R*]say[*A*]that one execution of the program violates the original LTL formula	context()	negated: False ,passive: False
[LINE#368] This method is well suited to check LTL liveness properties in infinite program executions, and has been adapted in Spin to be used for finite executions as well.
0.884	[*A*]This method[*R*]to be used as well[*A*]for finite executions	context()	negated: False ,passive: True
0.918	[*A*]This method[*R*]has been adapted[*A*]in Spin[*A*]to be used for finite executions as well	context()	negated: False ,passive: True
0.905	[*A*]This method[*R*]to check[*A*]LTL liveness properties in infinite program executions	context()	negated: False ,passive: False
0.960	[*A*]This method[*R*]is[*A*]well suited to check LTL liveness properties in infinite program executions	context()	negated: False ,passive: True
[LINE#369] 4 contains a simplified graphical representation of the Bchi automaton generated from Formula (3), from the examples above.
0.944	[*A*]the Bchi automaton[*R*]generated[*A*]from Formula	context()	negated: False ,passive: True
0.425	[*A*]4[*R*]contains[*A*]a simplified graphical representation of the Bchi automaton	context()	negated: False ,passive: False
[LINE#370] This automaton is executed synchronously with the Java trace, inspecting the Java states to decide which transition (or transitions) must be taken, and stopping when no transition is possible.
0.851	[*A*]transitions[*R*]must be stopping[*A*]when no transition is possible	context(the Java states to decide)	negated: False ,passive: False
0.947	[*A*]the Java states[*R*]to decide[*A*]which transitions ) must be stopping when no transition is possible	context()	negated: False ,passive: False
0.947	[*A*]the Java states[*R*]to decide[*A*]which transition ( must be stopping when no transition is possible	context()	negated: False ,passive: False
0.813	[*A*]no transition[*R*]is[*A*]possible	context()	negated: False ,passive: True
0.918	[*A*]the Java states[*R*]to decide[*A*]which transitions ) must be taken	context()	negated: False ,passive: False
0.918	[*A*]the Java states[*R*]to decide[*A*]which transition ( must be taken	context()	negated: False ,passive: False
0.903	[*A*]This automaton[*R*]is executed synchronously[*A*]inspecting the Java states	context()	negated: False ,passive: True
[LINE#371] A trace is accepted if it contains a finite sequence of states (a cycle) including an accepting state, which repeats infinitely often.
0.754	[*A*]an accepting state[*R*]repeats[*A*]infinitely often	context()	negated: False ,passive: True
0.569	[*A*]it[*R*]contains[*A*]a finite sequence of states (a cycle) including an accepting state	context()	negated: False ,passive: False
0.890	[*A*]A trace[*R*]is accepted[*A*]if it contains a finite sequence of states (a cycle) including an accepting state	context()	negated: False ,passive: True
[LINE#372] Accepting states are represented with a double circle in the figure.
0.732	[*A*]Accepting states[*R*]are represented	context()	negated: False ,passive: False
[LINE#373] Using this automata to recognize a given Java execution trace, Spin could find a violation of that formula, i.e. an execution where one client makes the other starve.
0.903	[*A*]one client[*R*]makes[*A*]the other starve	context()	negated: False ,passive: False
0.683	[*A*]Spin[*R*]could find[*A*]a violation of that formula	context()	negated: False ,passive: False
[LINE#374] The violation would include the instructions executed in the program, up to the point where the error was found.
0.933	[*A*]the error[*R*]was found[*A*]the point	context()	negated: False ,passive: True
0.903	[*A*]the instructions[*R*]executed[*A*]in the program	context()	negated: False ,passive: True
0.937	[*A*]The violation[*R*]would include[*A*]the instructions executed in the program, up to the point	context()	negated: False ,passive: True
[LINE#375+376]  For instance, a simplified trace for a violation of this formula, only including the locations where the variables from the formula change their value, is shown in Fig. 3(cycle between steps 8 and 10).
0.949	[*A*]a simplified trace for a violation of this formula[*R*]is shown[*A*]in Fig	context()	negated: False ,passive: True
0.923	[*A*]the variables from the formula[*R*]change[*A*]their value[*A*]the locations	context()	negated: False ,passive: False
[LINE#377] These variables are initialized on line 25 on both files, they change on line 270 to indicate that a request has been issued, and change again in lines 275 and 280 (of classes clientFTP and clientFTP2, respectively), when said request has been satisfied.
0.446	[*A*]they[*R*]change to indicate[*A*]change[*A*]again[*A*]in 280	context(they change)	negated: False ,passive: False
0.878	[*A*]These variables[*R*]are initialized[*A*]on line 25 on both files	context(they change)	negated: False ,passive: True
0.507	[*A*]they[*R*]change[*A*]to indicate change again in 280	context()	negated: False ,passive: False
0.445	[*A*]they[*R*]change to indicate[*A*]change[*A*]again[*A*]in lines 275	context(they change when said request has been satisfied)	negated: False ,passive: False
0.877	[*A*]These variables[*R*]are initialized[*A*]on line 25 on both files	context(they change when said request has been satisfied)	negated: False ,passive: True
0.506	[*A*]they[*R*]change[*A*]to indicate change again in lines 275	context(when said request has been satisfied)	negated: False ,passive: False
0.698	[*A*]when said request[*R*]has been satisfied	context()	negated: False ,passive: False
0.678	[*A*]a request[*R*]has been issued	context(they change to indicate request has been satisfied)	negated: False ,passive: False
0.227	[*A*]they[*R*]change to indicate[*A*]that a request has been issued	context(they change request has been satisfied)	negated: False ,passive: False
0.878	[*A*]These variables[*R*]are initialized[*A*]on line 25 on both files	context(they change request has been satisfied)	negated: False ,passive: True
0.273	[*A*]they[*R*]change[*A*]to indicate that a request has been issued	context(request has been satisfied)	negated: False ,passive: False
0.774	[*A*]request[*R*]has been satisfied[*A*]when said	context()	negated: False ,passive: True
[LINE#378] Others variables can be included in the trace if requested, as well.
0.903	[*A*]Others variables[*R*]can be included[*A*]in the trace[*A*]if requested, as well	context()	negated: False ,passive: True
[LINE#379] Given a Promela model, Spin performs an exhaustive exploration of its state space.
0.381	[*A*]Spin[*R*][is] model [of][*A*]Promela	context()	negated: False ,passive: False
0.762	[*A*]Spin[*R*]performs[*A*]an exhaustive exploration of its state space	context()	negated: False ,passive: False
[LINE#380]  Full-state on-the-fly explicit model checking, as implemented in Spin, requires two main data structures to manage model states (see Fig. 5):.
0.931	[*A*]two main data structures[*R*]to manage[*A*]model states[*A*]see Fig	context()	negated: False ,passive: False
0.976	[*A*]Full-state on-the-fly explicit model checking, as implemented in Spin[*R*]requires[*A*]to manage model states (see Fig	context()	negated: False ,passive: False
[LINE#381+382]  While performing a depth-first search, Spin storesthe states of the current path in the stack.
0.890	[*A*]Spin[*R*]storesthe[*A*]states of the current path in the stack[*A*]While performing a depth-first search	context()	negated: False ,passive: False
[LINE#383] This allows Spin to backtrack to a previous state and also to find cycles, both in the model under verification and in the Bchi automaton which represents the temporal property.
0.922	[*A*]the Bchi automaton[*R*]represents[*A*]the temporal property	context()	negated: False ,passive: False
0.236	[*A*]This[*R*]allows to find[*A*]cycles	context(This allows)	negated: False ,passive: False
0.321	[*A*]This[*R*]allows[*A*]also[*A*]to find cycles	context()	negated: False ,passive: False
0.825	[*A*]Spin[*R*]to backtrack[*A*]to a previous state	context(This allows)	negated: False ,passive: True
0.372	[*A*]This[*R*]allows[*A*]Spin to backtrack to a previous state	context()	negated: False ,passive: False
[LINE#384] The hash table is used to store all unique states visited while exploring the model, so that Spin does not explore the same path twice.
0.855	[*A*]Spin[*R*]does not explore[*A*]the same path[*A*]twice	context()	negated: True ,passive: False
0.905	[*A*]all unique states visited[*R*]exploring[*A*]the model	context()	negated: False ,passive: False
0.911	[*A*]all unique states[*R*]visited[*A*]while exploring the model	context()	negated: False ,passive: True
0.911	[*A*]The hash table[*R*]is used[*A*]to store all unique states	context()	negated: False ,passive: True
[LINE#385] The model checking algorithm requires the full representation of each state to be included in both data structures (stack and hash table).
0.917	[*A*]the full representation of each state[*R*]to be included[*A*]in both data structures	context(The model checking algorithm requires)	negated: False ,passive: True
0.936	[*A*]The model checking algorithm[*R*]requires[*A*]the full representation of each state to be included in both data structures	context()	negated: False ,passive: False
0.903	[*A*]The model[*R*]checking[*A*]algorithm	context()	negated: False ,passive: False
[LINE#386] This might pose a problem for large models, where the number of states to be stored can be higher than 1020.
0.945	[*A*]the number of states[*R*]can be[*A*]higher than 1020[*A*]large models	context()	negated: False ,passive: True
0.769	[*A*]the number of states[*R*]to be stored	context()	negated: False ,passive: False
0.381	[*A*]This[*R*]might pose[*A*]a problem[*A*]for large models	context()	negated: False ,passive: False
[LINE#387] In order to deal with such large models, Spin has been extended with several optimization techniques, some of which can be used in TJT.
0.636	[*A*]some of which[*R*]can be used[*A*]in TJT	context()	negated: False ,passive: True
0.855	[*A*]Spin[*R*]has been extended[*A*]with several optimization techniques	context()	negated: False ,passive: True
[LINE#388] Hash-compact (Wolper et al., 1993) reduces the use of memory by compressing the representation of the states without losing information.
0.953	[*A*]Hash-compact (Wolper et al[*R*]reduces[*A*]the use of memory[*A*]by compressing the representation of the states without losing information	context()	negated: False ,passive: False
[LINE#389] Bit-state hashing (Holzmann, 1995) represents states as single bits in a hash table, which may lead to a partial analysis of the model in some cases.
0.933	[*A*]a hash table[*R*]may lead[*A*]to a partial analysis of the model in some cases	context()	negated: False ,passive: False
0.905	[*A*]Bit-state hashing[*R*]represents[*A*]states[*A*]as single bits[*A*]in a hash table	context()	negated: False ,passive: False
[LINE#390] Currently, work is being carried out in order to obtain parallel versions of Spin that preserve most of these optimizations (Holzmann and Bosnacki, 2007).
0.928	[*A*]parallel versions of Spin[*R*]preserve[*A*]most of these optimizations	context()	negated: False ,passive: False
0.886	[*A*]work[*R*]is being carried out[*A*]in order[*A*]Currently	context()	negated: False ,passive: True
[LINE#391] Finally, there are other strategies that deal with scalability, such as the automatic transformation of the models to implement abstraction methods (Gallardo et al., 2004) or the abstract matching proposed in (de la Cmara et al., 2010).
0.927	[*A*]other strategies[*R*]deal[*A*]with scalability, such as the automatic transformation of the models	context()	negated: False ,passive: False
[LINE#392] T approach for debugging Java executionsThis section gives an overview of our approach for debugging Java programs using model checking and runtime monitoring.
0.930	[*A*]T approach for debugging Java executionsThis section[*R*]gives[*A*]an overview of our approach for debugging Java programs	context()	negated: False ,passive: False
[LINE#393] The main idea is to make Spin handle the states produced by Java instead of the states produced by a regular Promela model.
0.918	[*A*]the states[*R*]produced[*A*]by a regular Promela model	context()	negated: False ,passive: True
0.918	[*A*]the states[*R*]produced[*A*]by Java	context()	negated: False ,passive: True
0.942	[*A*]The main idea[*R*]is[*A*]to make Spin handle the states	context()	negated: False ,passive: True
[LINE#394] In the standard use of Spin, states are produced by the execution of Promela specifications.
0.948	[*A*]states[*R*]are produced[*A*]by the execution of Promela specifications[*A*]In the standard use of Spin	context()	negated: False ,passive: True
[LINE#395] Such states include all the local and global variables in the Promela specification and other information, such as the program counters of the processes or the contents of the communications channels.
0.947	[*A*]Such states[*R*]include[*A*]all the local and global variables in the Promela specification and other information, such as the program counters of the processes or the contents of the communications channels	context()	negated: False ,passive: True
[LINE#396] The entire space state generated from the Promela code is managed with the stack and hash table in order to check properties such as deadlocks and LTL formulas.
0.962	[*A*]The entire space state generated from the Promela code[*R*]to check[*A*]properties such as LTL formulas	context()	negated: False ,passive: False
0.955	[*A*]The entire space state generated from the Promela code[*R*]to check[*A*]properties such as deadlocks	context()	negated: False ,passive: False
0.954	[*A*]The entire space state generated from the Promela code[*R*]is managed[*A*]in order	context()	negated: False ,passive: True
0.931	[*A*]The entire space state[*R*]generated[*A*]from the Promela code	context()	negated: False ,passive: True
[LINE#397] In our particular use of Spin, states are produced by the execution of Java programs.
0.908	[*A*]states[*R*]are produced[*A*]by the execution of Java programs[*A*]In our particular use of Spin	context()	negated: False ,passive: True
[LINE#398] However, in order to reuse Spin features transparently, we still use a special Promela specification that is able to transform sequences of Java states into sequences of Promela-like states.
0.971	[*A*]a special Promela specification[*R*]is[*A*]able to transform sequences of Java states into sequences of Promela-like states	context()	negated: False ,passive: True
0.599	[*A*]we[*R*]use[*A*]a special Promela specification[*A*]still	context()	negated: False ,passive: False
[LINE#399] Thereby, we can check complex correctness requirements, like LTL properties, on the Java execution.
0.614	[*A*]we[*R*]can check[*A*]complex correctness requirements, like LTL properties, on the Java execution	context()	negated: False ,passive: False
[LINE#400] 6 shows an overview of the architecture and the workflow of our tool TJT, which is divided into three modules: the model checking module, the runtime monitoring module and the Eclipse plug-in.
0.918	[*A*]the runtime[*R*]monitoring[*A*]the Eclipse plug - in	context()	negated: False ,passive: False
0.385	[*A*]TJT[*R*][is] tool [of][*A*]ours	context()	negated: False ,passive: False
0.598	[*A*]our tool[*R*]is divided[*A*]into three modules	context()	negated: False ,passive: True
0.307	[*A*]6[*R*]shows[*A*]the workflow of our tool	context()	negated: False ,passive: False
0.449	[*A*]6[*R*]shows[*A*]an overview of the architecture	context()	negated: False ,passive: False
[LINE#401] The programmer must supply two inputs in this workflow (to the left of the figure): the main entrypoint of the Java program being analyzed and an XML file with the test specification.
0.803	[*A*]the Java program[*R*]being analyzed	context()	negated: False ,passive: False
0.937	[*A*]The programmer[*R*]must supply[*A*]two inputs in this workflow ( to the left of the figure	context()	negated: False ,passive: False
[LINE#402] This main entrypoint may be the real one from the program, or a specific main method associated with a particular test scenario.
0.919	[*A*]a specific main method[*R*]associated[*A*]with a particular test scenario	context()	negated: False ,passive: True
0.943	[*A*]This main entrypoint[*R*]may be[*A*]the real one from the program, or a specific main method	context()	negated: False ,passive: True
[LINE#403] The test specification includes the correctness requirement: a complex behavior described in a formalism supported by Spin, such as an LTL formula.
0.918	[*A*]a formalism[*R*]supported[*A*]by Spin, such as an LTL formula	context()	negated: False ,passive: True
0.911	[*A*]a complex behavior[*R*]described[*A*]in a formalism	context()	negated: False ,passive: True
0.911	[*A*]The test specification[*R*]includes[*A*]the correctness requirement	context()	negated: False ,passive: True
[LINE#404] The user must also declare the objective of the formula, i.e. whether it represents a behavior that should be checked for all traces (desired behavior), none (undesired behavior) or if it is enough for any trace to satisfy it (whether that is desired or undesired behavior is up to the programmer).
0.278	[*A*]it[*R*]is[*A*]enough	context()	negated: False ,passive: True
0.925	[*A*]undesired behavior[*R*]is[*A*]up to the programmer	context()	negated: False ,passive: True
0.887	[*A*]a behavior[*R*]should be checked[*A*]for all traces	context()	negated: False ,passive: True
0.036	[*A*]that[*R*]is desired	context(any trace to satisfy)	negated: False ,passive: False
0.802	[*A*]any trace[*R*]to satisfy[*A*]it	context()	negated: False ,passive: False
0.767	[*A*]The user[*R*]must declare[*A*]the objective of the formula[*A*]i.e. whether it represents a behavior	context()	negated: False ,passive: False
[LINE#405] This specification also contains additional information for carrying out the tests, like the program parameters, and their ranges, for generating test inputs.
0.873	[*A*]This specification[*R*]contains[*A*]additional information for carrying out their ranges , for generating test inputs	context()	negated: False ,passive: False
0.927	[*A*]This specification[*R*]contains[*A*]additional information for carrying out the tests , like the program parameters , for generating test inputs	context()	negated: False ,passive: False
[LINE#406] The model checking module, implemented with Spin and a special Promela template, creates a series of Java Virtual Machines (JVMs) to execute the Java program with all the values considered for the configuration variables.
0.968	[*A*]The model checking module , implemented with a special Promela template[*R*]creates[*A*]a series of Java Virtual Machines	context()	negated: False ,passive: False
0.920	[*A*]The model checking module[*R*]implemented[*A*]with a special Promela template	context()	negated: False ,passive: True
0.751	[*A*]all the values[*R*]considered	context()	negated: False ,passive: False
0.958	[*A*]The model checking module , implemented with Spin[*R*]creates[*A*]a series of Java Virtual Machines	context()	negated: False ,passive: False
0.920	[*A*]The model checking module[*R*]implemented[*A*]with Spin	context()	negated: False ,passive: True
[LINE#407] The executions are actually launched and monitored by the runtime monitoring module, which detects the events that are relevant for checking the LTL formula.
0.905	[*A*]the events[*R*]are[*A*]relevant for checking the LTL formula	context()	negated: False ,passive: True
0.871	[*A*]the runtime monitoring module[*R*]detects[*A*]the events that are relevant for checking the LTL formula	context()	negated: False ,passive: False
0.641	[*A*]The executions[*R*]are launched	context()	negated: False ,passive: False
[LINE#408] Each event provokes the creation of a Java state that is sent to the model checking module.
0.922	[*A*]a Java state[*R*]is sent[*A*]to the model checking module	context()	negated: False ,passive: True
0.918	[*A*]Each event[*R*]provokes[*A*]the creation of a Java state	context()	negated: False ,passive: False
[LINE#409] Spin processes the information reported by the monitoring module for each execution of the program, and checks the LTL formula.
0.874	[*A*]Spin[*R*]checks[*A*]the LTL formula	context()	negated: False ,passive: False
0.985	[*A*]by the monitoring module for each execution of the program[*R*]reported[*A*]the information	context()	negated: False ,passive: False
0.875	[*A*]Spin[*R*]processes[*A*]the information reported by the monitoring module for each execution of the program	context()	negated: False ,passive: False
[LINE#410] When Spin detects that a Java execution does not match an LTL formula and objective (desired/undesired), it sends information to the Eclipse plug-in in order to show the steps that have led to the failed execution.
0.579	[*A*]it[*R*]sends[*A*]information[*A*]to the Eclipse plug - in[*A*]in order[*A*]When Spin detects that a Java execution does not match objective	context()	negated: False ,passive: False
0.677	[*A*]objective[*R*]desired	context()	negated: False ,passive: False
0.666	[*A*]Spin[*R*]detects[*A*]that a Java execution does not match objective	context()	negated: False ,passive: False
0.579	[*A*]it[*R*]sends[*A*]information[*A*]to the Eclipse plug - in[*A*]in order[*A*]When Spin detects that a Java execution does not match an LTL formula	context()	negated: False ,passive: False
0.776	[*A*]an LTL formula[*R*]desired	context()	negated: False ,passive: False
0.887	[*A*]the steps[*R*]have led[*A*]to the failed execution	context()	negated: False ,passive: False
0.759	[*A*]a Java execution[*R*]does not match	context(Spin detects)	negated: True ,passive: False
0.762	[*A*]Spin[*R*]detects[*A*]that a Java execution does not match an LTL formula	context()	negated: False ,passive: False
[LINE#411] In the following section we discuss model checking in detail, focusing on efficient methods for abstracting the Java states.
0.333	[*A*]we[*R*]discuss model checking in detail focusing[*A*]on efficient methods for abstracting the Java states	context(we discuss)	negated: False ,passive: False
0.577	[*A*]we[*R*]discuss[*A*]model checking in detail[*A*]focusing on efficient methods for abstracting the Java states[*A*]In the following section	context()	negated: False ,passive: False
0.894	[*A*]model[*R*]checking[*A*]in detail	context()	negated: False ,passive: True
[LINE#412] Each Java execution is carried out in the target platform under the control of our runtime monitoring module, which has been implemented in Java using JDI (Java Platform Debugger Architecture, xxxx).
0.685	[*A*]our runtime monitoring module[*R*]has been implemented[*A*]in Java	context()	negated: False ,passive: True
0.924	[*A*]Each Java execution[*R*]is carried out[*A*]in the target platform under the control of our runtime monitoring module	context()	negated: False ,passive: True
[LINE#413] The monitor and the program being tested run in different JVMs.
0.926	[*A*]the program[*R*]run[*A*]in different JVMs	context()	negated: False ,passive: True
0.918	[*A*]the program[*R*]being tested[*A*]run in different JVMs	context()	negated: False ,passive: True
[LINE#414] JDI offers an event based framework, where the application can be notified of certain events in a remote JVM, such as breakpoints, exceptions, changes in object fields or thread states.
0.947	[*A*]the application[*R*]can be notified[*A*]of certain events in a remote JVM, such as breakpoints, exceptions, changes in object fields or thread states	context()	negated: False ,passive: True
0.919	[*A*]JDI[*R*]offers[*A*]an event based framework, where the application can be notified of certain events in a remote JVM, such as breakpoints, exceptions, changes in object fields or thread states	context()	negated: False ,passive: False
[LINE#415] The monitoring module watches the events relevant to the specified property and sends the information to the model checking module.
0.932	[*A*]The monitoring module[*R*]sends[*A*]the information[*A*]to the model checking module	context()	negated: False ,passive: False
0.911	[*A*]The monitoring module[*R*]watches[*A*]the events relevant to the specified property	context()	negated: False ,passive: False
[LINE#416] At present, our tool can check LTL properties on finite and infinite traces, asserts, and deadlocks.
0.791	[*A*]our tool[*R*]can check[*A*]LTL properties[*A*]At present	context()	negated: False ,passive: False
[LINE#417] The LTL property can reference class variables present in the Java program, thrown exceptions or breakpoints set at specific locations in the code.
0.964	[*A*]The LTL property[*R*]can reference[*A*]class variables present in the Java program, thrown exceptions or breakpoints	context()	negated: False ,passive: False
[LINE#418] When Java executions are finite, we take advantage of the stuttering mechanism implemented in Spin (Holzmann, 2003), and we assume the semantics derived from considering the last state of the trace repeated forever.
0.767	[*A*]the trace[*R*]repeated[*A*]forever	context()	negated: False ,passive: True
0.903	[*A*]the semantics[*R*]derived[*A*]from considering the last state of the trace	context()	negated: False ,passive: True
0.569	[*A*]we[*R*]assume[*A*]the semantics derived from considering the last state of the trace	context()	negated: False ,passive: False
0.925	[*A*]the stuttering mechanism[*R*]implemented[*A*]in Spin	context()	negated: False ,passive: True
0.639	[*A*]we[*R*]take[*A*]advantage[*A*]of the stuttering mechanism[*A*]When Java executions are finite	context()	negated: False ,passive: False
0.817	[*A*]Java executions[*R*]are[*A*]finite	context()	negated: False ,passive: True
[LINE#419] So, there are no limitations to using the LTL formulas supported by Spin.
0.944	[*A*]the LTL formulas[*R*]supported[*A*]by Spin	context()	negated: False ,passive: True
[LINE#420] In addition, deadlocks can be detected by the monitoring module by checking the status of each thread before processing each event.
0.877	[*A*]deadlocks[*R*]by checking[*A*]the status of each thread	context()	negated: False ,passive: False
0.894	[*A*]deadlocks[*R*]can be detected[*A*]by the monitoring module	context()	negated: False ,passive: True
[LINE#421] TJT analyzes each program trace independently.
0.852	[*A*]TJT[*R*]analyzes independently[*A*]each program trace	context()	negated: False ,passive: False
[LINE#422] Different traces can be generated by providing information about the input parameters of the program, which will generate different test inputs.
0.887	[*A*]the program[*R*]will generate[*A*]different test inputs	context()	negated: False ,passive: False
0.887	[*A*]Different traces[*R*]by providing[*A*]information about the input parameters of the program	context()	negated: False ,passive: False
0.732	[*A*]Different traces[*R*]can be generated	context()	negated: False ,passive: False
[LINE#423] These test inputs are currently passed on to the main method of the program as command line arguments.
0.950	[*A*]These test inputs[*R*]are passed on[*A*]to the main method of the program as command line arguments[*A*]currently	context()	negated: False ,passive: True
[LINE#424] A main method developed specifically for a test may use these arguments to set different parameters in the program, or to execute slightly different test scenarios.
0.964	[*A*]A main method developed specifically for a test[*R*]may use[*A*]these arguments[*A*]to set different parameters in the program, or to execute slightly different test scenarios	context()	negated: False ,passive: False
0.911	[*A*]A main method[*R*]developed specifically[*A*]for a test	context()	negated: False ,passive: True
[LINE#425] In addition, the program may be run more than once with the same test input, in order to produce different schedulings for threaded programs.
0.903	[*A*]the program[*R*]may be run[*A*]more than once[*A*]in order	context()	negated: False ,passive: True
[LINE#426] In connection with this, we are experimenting with the automatic insertion of calls to methods that alter thread scheduling, e.g. yield and sleep, to cover a greater range of program schedulings.
0.293	[*A*]we[*R*]are experimenting with the automatic insertion of calls to methods to cover[*A*]a greater range of program schedulings	context(we are experimenting)	negated: False ,passive: False
0.877	[*A*]methods[*R*]alter[*A*]thread scheduling sleep	context()	negated: False ,passive: False
0.874	[*A*]methods[*R*]alter e.g.[*A*]thread scheduling	context()	negated: False ,passive: False
0.595	[*A*]we[*R*]are experimenting[*A*]with the automatic insertion of calls to methods[*A*]In connection with this	context()	negated: False ,passive: False
[LINE#427] We have also developed an Eclipse plug-in to make executing tests and reviewing their results more user-friendly.
0.309	[*A*]We[*R*]reviewing[*A*]their results	context()	negated: False ,passive: False
0.393	[*A*]We[*R*]have developed[*A*]an Eclipse plug - in	context()	negated: False ,passive: False
[LINE#428] The plug-in includes a form-based editor for creating test specification files, instead of writing error prone XML code.
0.948	[*A*]The plug-in[*R*]includes[*A*]a form-based editor for creating test specification files	context()	negated: False ,passive: True
[LINE#429] This includes selecting fields to be monitored, setting breakpoints, writing the LTL property to be checked and declaring the test input parameters.
0.381	[*A*]This[*R*]includes[*A*]declaring the test input parameters	context()	negated: False ,passive: True
0.803	[*A*]the LTL property[*R*]to be checked	context()	negated: False ,passive: False
0.425	[*A*]This[*R*]includes[*A*]writing the LTL property	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]includes[*A*]setting breakpoints	context()	negated: False ,passive: True
0.713	[*A*]fields[*R*]to be monitored	context()	negated: False ,passive: False
0.381	[*A*]This[*R*]includes[*A*]selecting fields	context()	negated: False ,passive: True
[LINE#430] Once the specification has been finished, it can be executed within Eclipse and its progress tracked in the TJT console.
0.444	[*A*]it[*R*]can be executed[*A*]within its progress[*A*]Once the specification has been finished	context()	negated: False ,passive: True
0.639	[*A*]it[*R*]can be executed[*A*]within Eclipse[*A*]Once the specification has been finished	context()	negated: False ,passive: True
0.830	[*A*]the specification[*R*]has been finished[*A*]Once	context()	negated: False ,passive: True
[LINE#431] After the test has finished, a dedicated view shows the erroneous traces that were found, i.e. the execution paths that led to a property violation.
0.927	[*A*]i.e. the execution paths[*R*]led[*A*]to a property violation	context()	negated: False ,passive: False
0.718	[*A*]the erroneous traces[*R*]were found	context()	negated: False ,passive: False
0.899	[*A*]a dedicated view[*R*]shows[*A*]the erroneous traces that were found[*A*]After the test has finished	context()	negated: False ,passive: False
0.732	[*A*]the test[*R*]has finished	context()	negated: False ,passive: False
[LINE#432] Clicking on a trace line takes the user to the corresponding Java line of code.
0.937	[*A*]Clicking on a trace line[*R*]takes[*A*]the user[*A*]to the corresponding Java line of code	context()	negated: False ,passive: False
[LINE#433]  A screenshot of the plug-in is shown in Fig..
0.948	[*A*]A screenshot of the plug-in[*R*]is shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#434] The tool TJT and several examples can be downloaded from (Adalid et al., xxxx)..
0.903	[*A*]several examples[*R*]can be downloaded[*A*]from ( Adalid et al	context()	negated: False ,passive: True
0.911	[*A*]The tool TJT[*R*]can be downloaded[*A*]from ( Adalid et al	context()	negated: False ,passive: True
[LINE#435] Implementation with Spin and JDIThis section explains our approach, which uses Spin as the core of the model checking module of our debugging tool for Java.
0.941	[*A*]Implementation with JDIThis section[*R*]explains[*A*]our approach , which uses Spin as the core of the model	context()	negated: False ,passive: False
0.642	[*A*]our approach[*R*]uses[*A*]Spin[*A*]as the core of the model	context()	negated: False ,passive: False
0.941	[*A*]Implementation with Spin section[*R*]explains[*A*]our approach , which uses Spin as the core of the model	context()	negated: False ,passive: False
[LINE#436] In addition to the capability to check properties with Bchi automata, Spin also allows embedding C code in the Promela models, using c_code blocks.
0.822	[*A*]Spin[*R*]allows embedding[*A*]C code	context(Spin allows)	negated: False ,passive: False
0.822	[*A*]Spin[*R*]allows[*A*]embedding C code in the Promela models	context()	negated: False ,passive: False
[LINE#437] These blocks are executed atomically by Spin and may interact with global state variables or call external library functions.
0.887	[*A*]These blocks[*R*]may interact[*A*]with global state variables	context()	negated: False ,passive: False
0.918	[*A*]These blocks[*R*]are executed atomically[*A*]by Spin	context()	negated: False ,passive: True
[LINE#438] The c_expr allows the evaluation of a C expression free from side effects, e.g. to use it as a loop condition.
0.890	[*A*]The c_expr[*R*]allows[*A*]the evaluation of a C expression free from side effects, e.g. to use it as a loop condition	context()	negated: False ,passive: False
[LINE#439] Furthermore, C variables can be treated as if they were part of the global state.
0.616	[*A*]they[*R*]were[*A*]part of the global state	context()	negated: False ,passive: True
0.732	[*A*]C variables[*R*]can be treated	context()	negated: False ,passive: False
[LINE#440] Using c_track, existing C variables can be tracked and included in the global state, even as unmatched variables, i.e. they are stored in the stack but not in the hash.
0.616	[*A*]they[*R*]are not[*A*]in the hash	context()	negated: True ,passive: True
0.751	[*A*]existing C variables[*R*]can be tracked	context()	negated: False ,passive: False
0.882	[*A*]existing C variables[*R*]can be tracked[*A*]even as unmatched variables , i.e. they are stored in the stack	context()	negated: False ,passive: True
[LINE#441] Unmatched variables are restored when backtracking, but they are not taken into account when deciding whether two states are equal (see (Holzmann, 2003) for details).
0.755	[*A*]they[*R*]are not taken[*A*]into account[*A*]when deciding whether two states are equal ( see ( Holzmann , 2003 ) for details	context()	negated: True ,passive: True
0.767	[*A*]Unmatched variables[*R*]are restored[*A*]when backtracking	context()	negated: False ,passive: True
[LINE#442] Note that states in the stack contain all the information whereas the hash table contains only part of the information.
0.911	[*A*]the hash table[*R*]contains[*A*]only part of the information	context()	negated: False ,passive: False
[LINE#443+444+445]  We take advantage of these C oriented features to communicate Spin with the JDI-based monitor, to represent the Java states in Spin, and to implement our abstraction methods for Java states, explained in Section 3.1.3.As explained above, while Spin is generally used to check program specifications written in its own Promela language, TJT uses a special Promela specification, part of which is shown in Fig. 8, to drive all the automatic debugging work.
0.933	[*A*]the Java states[*R*]explained[*A*]in Section 3.1.3.As	context()	negated: False ,passive: True
0.859	[*A*]program specifications[*R*]written[*A*]in its own Promela language	context()	negated: False ,passive: True
0.765	[*A*]Spin[*R*]to check[*A*]program specifications written in its own Promela language	context()	negated: False ,passive: False
0.923	[*A*]a special Promela specification[*R*]is shown[*A*]in Fig	context(TJT uses)	negated: False ,passive: True
0.794	[*A*]Spin[*R*]is used[*A*]to check program specifications	context()	negated: False ,passive: True
0.767	[*A*]Section 3.1.3.As[*R*]explained[*A*]above	context()	negated: False ,passive: True
0.333	[*A*]We[*R*]take advantage to communicate[*A*]Spin[*A*]with the JDI - based monitor[*A*]to represent the Java states	context(We take)	negated: False ,passive: False
0.433	[*A*]We[*R*]take[*A*]advantage[*A*]of these C oriented features[*A*]to communicate Spin with the JDI - based monitor	context()	negated: False ,passive: False
0.923	[*A*]a special Promela specification[*R*]is shown[*A*]in Fig	context(TJT uses)	negated: False ,passive: True
0.213	[*A*]We[*R*]take advantage to implement[*A*]our abstraction methods for Java states	context(We take TJT uses)	negated: False ,passive: False
0.333	[*A*]We[*R*]take advantage to communicate[*A*]Spin[*A*]with the JDI - based monitor[*A*]to represent the Java states	context(We take TJT uses)	negated: False ,passive: False
0.293	[*A*]We[*R*]take[*A*]advantage[*A*]of these C oriented features[*A*]to communicate Spin with the JDI - based monitor[*A*]to implement our abstraction methods for Java states	context(TJT uses)	negated: False ,passive: False
0.923	[*A*]a special Promela specification[*R*]is shown[*A*]in Fig	context(TJT uses)	negated: False ,passive: True
0.333	[*A*]We[*R*]take advantage to communicate[*A*]Spin[*A*]with the JDI - based monitor	context(We take TJT uses)	negated: False ,passive: False
0.433	[*A*]We[*R*]take[*A*]advantage[*A*]of these C oriented features[*A*]to communicate Spin with the JDI - based monitor	context(TJT uses)	negated: False ,passive: False
0.898	[*A*]TJT[*R*]uses[*A*]a special Promela specification , part of which is shown in Fig[*A*]to drive all the automatic debugging work	context()	negated: False ,passive: False
[LINE#446] Such Promela code contains the logic to generate the values for the configuration variables that produce different executions, to communicate with the runtime monitoring module and to check whether a Java execution fails.
0.891	[*A*]Such Promela code[*R*]contains[*A*]the logic[*A*]to generate the values for the configuration variables that produce different executions , to communicate with the runtime monitoring	context()	negated: False ,passive: False
0.897	[*A*]the configuration variables[*R*]produce[*A*]different executions	context()	negated: False ,passive: False
0.891	[*A*]Such Promela code[*R*]contains[*A*]the logic[*A*]to generate the values for the configuration variables that produce different executions , to communicate with the runtime monitoring module	context()	negated: False ,passive: False
[LINE#447] The code is automatically generated using an initial Promela template and the information provided by the user in the correctness specification file (see Fig. 6).
0.958	[*A*]the information provided by the user in the correctness specification file[*R*]see[*A*]Fig	context()	negated: False ,passive: False
0.903	[*A*]the information[*R*]provided[*A*]by the user in the correctness specification file	context()	negated: False ,passive: True
0.732	[*A*]The code[*R*]is automatically generated	context()	negated: False ,passive: False
[LINE#448] When an LTL formula is present in this file, it is translated into a Bchi automaton, and then included in the resulting Promela specification as a never claim definition.
0.969	[*A*]an LTL formula[*R*]is included[*A*]in the resulting Promela specification as a never claim definition[*A*]then	context()	negated: False ,passive: True
0.639	[*A*]it[*R*]is translated[*A*]into a Bchi automaton[*A*]When an LTL formula is present in this file	context()	negated: False ,passive: True
0.949	[*A*]an LTL formula[*R*]is[*A*]present in this file	context()	negated: False ,passive: True
[LINE#449] If the formula represents a behavior that must be satisfied in all traces, it is negated first, in order to find counterexamples.
0.225	[*A*]it[*R*]is negated[*A*]first	context()	negated: False ,passive: True
0.887	[*A*]a behavior[*R*]must be[*A*]satisfied in all traces	context()	negated: False ,passive: True
0.773	[*A*]the formula[*R*]represents[*A*]a behavior that must be satisfied in all traces	context()	negated: False ,passive: False
[LINE#450] The execution of this Promela code by Spin is summarized in Algorithm 1.
0.964	[*A*]The execution of this Promela code by Spin[*R*]is summarized[*A*]in Algorithm 1	context()	negated: False ,passive: True
[LINE#451] This algorithm shows how Spin produces and inspects several Java traces, depending on the potential values for the configuration variables in the correctness specification file.
0.581	[*A*]Spin[*R*]produces	context(This algorithm shows)	negated: False ,passive: False
0.908	[*A*]This algorithm[*R*]shows[*A*]Spin produces	context()	negated: False ,passive: False
0.938	[*A*]This algorithm[*R*]inspects[*A*]several Java traces[*A*]depending on the potential values for the configuration variables in the correctness specification file	context()	negated: False ,passive: False
[LINE#452] For each combination of input values, Spin launches a new execution and then enters a loop to collect the sequence of Java states for that execution, checking the LTL formula and reporting failed executions to the Eclipse plug-in.
0.888	[*A*]each combination of then[*R*]enters[*A*]a loop to collect the sequence of Java states for that execution	context()	negated: False ,passive: False
0.913	[*A*]Spin[*R*]launches[*A*]a new execution[*A*]For each combination of input values	context()	negated: False ,passive: False
[LINE#453] This is described in more detail in the following sections.
0.381	[*A*]This[*R*]is described[*A*]in more detail in the following sections	context()	negated: False ,passive: True
[LINE#454+455+456]  Spin executing the Promela code in Fig.  generateInput()newExecution(input)step step  step + 1end whileif error.
0.840	[*A*]Spin[*R*]executing[*A*]the Promela code[*A*]in Fig	context()	negated: False ,passive: False
[LINE#457]  The main loopThe loop represented in Algorithm 1 actually corresponds to the execution (in Spin) of lines 17 to 22 of the code in Fig..
0.737	[*A*]lines[*R*]have actually of[*A*]1 actually corresponds	context()	negated: False ,passive: False
0.958	[*A*]The main loopThe loop represented in Algorithm 1[*R*]corresponds[*A*]to the execution[*A*]in Spin	context()	negated: False ,passive: True
0.931	[*A*]The main loopThe loop[*R*]represented[*A*]in Algorithm 1	context()	negated: False ,passive: True
[LINE#458] The first two functions, initialization() and createSocket() are executed as if they were a single instruction, using the c_code mechanism.
0.740	[*A*]createSocket[*R*]are executed	context()	negated: False ,passive: False
0.620	[*A*]they[*R*]using[*A*]the c_code mechanism	context()	negated: False ,passive: False
0.658	[*A*]they[*R*]were[*A*]a single instruction[*A*]using the c_code mechanism	context()	negated: False ,passive: True
0.737	[*A*]The first two functions[*R*]are executed	context()	negated: False ,passive: False
[LINE#459] They create all the data and communication structures needed to connect the model checking and the runtime monitoring modules.
0.903	[*A*]communication structures[*R*]needed[*A*]to connect the runtime monitoring modules	context()	negated: False ,passive: True
0.903	[*A*]communication structures[*R*]needed[*A*]to connect the model	context()	negated: False ,passive: True
0.616	[*A*]They[*R*]create[*A*]communication structures needed	context()	negated: False ,passive: False
0.911	[*A*]all the data[*R*]needed[*A*]to connect the runtime monitoring modules	context()	negated: False ,passive: True
0.732	[*A*]the model[*R*]checking	context()	negated: False ,passive: False
0.911	[*A*]all the data[*R*]needed[*A*]to connect the model	context()	negated: False ,passive: True
0.616	[*A*]They[*R*]create[*A*]all the data needed	context()	negated: False ,passive: False
[LINE#460] Note that the communication is done with a socket, so if necessary, e.g. to increase performance, they can run in different computers.
[LINE#461] To ensure interoperability of these two modules in different nodes, we also use standard XDR-based encoding for the data transferred in this socket.
0.392	[*A*]we[*R*]use[*A*]standard XDR-based encoding[*A*]for the data	context()	negated: False ,passive: False
0.903	[*A*]the data[*R*]transferred[*A*]in this socket	context()	negated: False ,passive: True
[LINE#462] Each Java execution corresponds to a possible combination of values for configuration variables defined by the user in the correctness requirement (see Fig. 6).
0.903	[*A*]configuration variables[*R*]defined[*A*]by the user in the correctness requirement	context()	negated: False ,passive: True
0.933	[*A*]Each Java execution[*R*]corresponds[*A*]to a possible combination of values for configuration variables	context()	negated: False ,passive: True
[LINE#463] The generation of one combination of values is done by generateConfig().
0.948	[*A*]The generation of one combination of values[*R*]is done[*A*]by generateConfig	context()	negated: False ,passive: True
[LINE#464] The function execute() launches the Java program being tested with the given configuration values as test input under the supervision of the monitoring module.
0.957	[*A*]the Java program[*R*]being tested[*A*]with the given configuration values as test input under the supervision of the monitoring module	context()	negated: False ,passive: True
0.913	[*A*]The function execute[*R*]launches[*A*]the Java program	context()	negated: False ,passive: False
[LINE#465] When the current Java execution finishes, Spin backtracks to generateConfig() to select another set of values for the configuration variables.
0.833	[*A*]Spin[*R*]to select[*A*]another set of values for the configuration variables	context()	negated: False ,passive: False
0.953	[*A*]Spin[*R*]backtracks[*A*]to generateConfig[*A*]to select another set of values for the configuration variables[*A*]When the current Java execution finishes	context()	negated: False ,passive: True
[LINE#466] Then, execute() is again called to run the program under the new test input.
[LINE#467] This backtracking-based process continues until no more combinations are possible.
0.783	[*A*]no more combinations[*R*]are[*A*]possible	context()	negated: False ,passive: True
0.926	[*A*]This backtracking-based process[*R*]continues[*A*]until no more combinations are possible	context()	negated: False ,passive: True
[LINE#468] The result is the exploration of all the Java executions defined by the programmer in the test specification file.
0.939	[*A*]all the Java executions[*R*]defined[*A*]by the programmer in the test specification file	context()	negated: False ,passive: True
0.937	[*A*]The result[*R*]is[*A*]the exploration of all the Java executions	context()	negated: False ,passive: True
[LINE#469+470]  Getting new Java states and checking failuresThe current Java execution trace is reconstructed in Spin thanks to the getNextState() function partially shown in Fig..
0.911	[*A*]function[*R*]partially shown[*A*]in Fig	context()	negated: False ,passive: True
0.968	[*A*]Getting new Java checking failuresThe current Java execution trace[*R*]is reconstructed[*A*]in Spin[*A*]thanks to the getNextState	context()	negated: False ,passive: True
0.937	[*A*]the getNextState ( ) function[*R*]partially shown[*A*]in Fig	context()	negated: False ,passive: True
0.949	[*A*]Getting new Java states[*R*]is reconstructed[*A*]in Spin[*A*]thanks to the getNextState ( ) function	context()	negated: False ,passive: True
[LINE#471] The next state is either read from the socket with the runtime monitoring module (lines 9 to 16) or retrieved from a list of already visited states in the case of backtracking, as will be explained below.
0.933	[*A*]The next state[*R*]retrieved[*A*]from a list of already visited states in the case of backtracking	context()	negated: False ,passive: True
0.870	[*A*]The next state[*R*]is read[*A*]from the socket with the runtime monitoring module	context()	negated: False ,passive: True
[LINE#472] For each new state, we check events such as program termination (line 17) or assertion violations (line 21), which are also communicated through the socket.
0.910	[*A*]program termination (line 17) or assertion violations[*R*]are communicated[*A*]through the socket	context()	negated: False ,passive: True
0.637	[*A*]we[*R*]check[*A*]events such as program termination (line 17) or assertion violations	context()	negated: False ,passive: False
[LINE#473] The current list of failure-related events include a dozen cases.
0.932	[*A*]The current list of failure-related events[*R*]include[*A*]a dozen cases	context()	negated: False ,passive: True
[LINE#474] The most interesting analysis is checking LTL properties.
0.931	[*A*]The most interesting analysis[*R*]is checking[*A*]LTL properties	context()	negated: False ,passive: False
[LINE#475] Spin checks each execution path using a double depth-first search algorithm that maintains a stack of program states ("Spin States" in Fig. 6).
0.927	[*A*]a double depth-first search algorithm[*R*]maintains[*A*]a stack of program states	context()	negated: False ,passive: False
0.722	[*A*]Spin[*R*]using[*A*]a double depth-first search algorithm that maintains a stack of program states ("Spin States" in Fig	context()	negated: False ,passive: False
[LINE#476] The state of the Bchi automaton, which is used to track the satisfaction of an LTL property, is also stored as part of the global state.
0.911	[*A*]The state of the Bchi automaton[*R*]is stored[*A*]as part of the global state	context()	negated: False ,passive: True
0.934	[*A*]the Bchi automaton[*R*]to track[*A*]the satisfaction of an LTL property	context()	negated: False ,passive: False
0.934	[*A*]the Bchi automaton[*R*]is used[*A*]to track the satisfaction of an LTL property	context()	negated: False ,passive: True
[LINE#477] Each state si handled by Spin is composed of three components j, (j), bi, where bi is the state of the Bchi automata which is executed synchronously with the system, j is the current Java state provided by the runtime monitoring module, and  is a projection function used to simplify the Java states before being analyzed by Spin.
0.913	[*A*]a projection function[*R*]to simplify[*A*]the Java states[*A*]before being analyzed by Spin	context()	negated: False ,passive: False
0.939	[*A*]the current Java state[*R*]provided[*A*]by the runtime monitoring module	context()	negated: False ,passive: True
0.776	[*A*]the Bchi automata[*R*]is executed synchronously	context()	negated: False ,passive: False
0.874	[*A*]bi[*R*]is[*A*]the state of the Bchi automata	context()	negated: False ,passive: True
[LINE#478] The fact that the indexes of si and j are not necessarily equal will be explained below.
0.867	[*A*]The fact that the indexes of j are not necessarily equal[*R*]will be explained below	context()	negated: False ,passive: False
0.799	[*A*]the indexes of j[*R*]are not[*A*]necessarily[*A*]equal	context()	negated: True ,passive: True
0.867	[*A*]The fact that the indexes of si are not necessarily equal[*R*]will be explained below	context()	negated: False ,passive: False
0.799	[*A*]the indexes of si[*R*]are not[*A*]necessarily[*A*]equal	context()	negated: True ,passive: True
[LINE#479] Although the execution of a Java program results in a linear sequence of states, the addition of the Bchi automaton representing the LTL formula may result in several branches that must be explored exhaustively.
0.698	[*A*]several branches[*R*]must be explored exhaustively	context()	negated: False ,passive: False
0.940	[*A*]the addition of the Bchi automaton[*R*]may result[*A*]in several branches	context()	negated: False ,passive: True
0.944	[*A*]the Bchi automaton[*R*]representing[*A*]the LTL formula	context()	negated: False ,passive: False
[LINE#480] To support this, variable values received from the runtime monitoring module are first stored in a Java trace stack ("Java Trace" in Fig. 6), and then retrieved from there, as needed (as explained above).
0.872	[*A*]variable values received from the runtime monitoring module[*R*]are retrieved[*A*]from there[*A*]as needed ( as explained above[*A*]then	context()	negated: False ,passive: True
0.959	[*A*]variable values received from the runtime monitoring module[*R*]are stored[*A*]in a Java trace stack[*A*]first	context()	negated: False ,passive: True
0.903	[*A*]variable values[*R*]received[*A*]from the runtime monitoring module	context()	negated: False ,passive: True
[LINE#481] Therefore, if Spin backtracks during the search, the Bchi automaton will produce new states but the Java states will be a replay of the previously visited states.
0.933	[*A*]the Java states[*R*]will be[*A*]a replay of the previously visited states	context()	negated: False ,passive: True
0.933	[*A*]the Bchi automaton[*R*]will produce[*A*]new states	context()	negated: False ,passive: False
0.855	[*A*]Spin[*R*]backtracks[*A*]during the search	context()	negated: False ,passive: True
[LINE#482+483]  Note that we have acknowledged this in Fig.6 by not necessarily showing the same subindex for the whole state si and the corresponding Java part (j).
[LINE#484] Representing Java states inside SpinThe main drawback that usually has to be taken into consideration when applying model checking to programming languages is state space explosion: states may be too large and too many to be stored in the memory.
0.871	[*A*]states[*R*]may be[*A*]too many to be stored in the memory	context(Representing Java states inside SpinThe main drawback is)	negated: False ,passive: True
0.948	[*A*]Representing Java states inside SpinThe main drawback[*R*]is[*A*]state space explosion	context()	negated: False ,passive: True
0.922	[*A*]SpinThe main drawback[*R*]to be taken[*A*]into consideration[*A*]when applying model	context()	negated: False ,passive: True
0.946	[*A*]Representing Java states inside SpinThe main drawback[*R*]is[*A*]state space explosion	context(states may be)	negated: False ,passive: True
0.696	[*A*]states[*R*]may be[*A*]too large	context()	negated: False ,passive: True
[LINE#485] Apart from taking advantage of some of the Spin optimization methods described in Section 2, our tool TJT deals with these problems with several novel techniques.
0.385	[*A*]TJT[*R*][is] tool [of][*A*]ours	context()	negated: False ,passive: False
0.725	[*A*]our tool TJT[*R*]deals[*A*]with these problems with several novel techniques	context()	negated: False ,passive: False
0.939	[*A*]the Spin optimization methods[*R*]described[*A*]in Section 2	context()	negated: False ,passive: True
[LINE#486] The first one consists of selecting the Java states to be sent to the model checking module: we only send those states produced after relevant events in the Java execution.
0.683	[*A*]The first one[*R*]consists[*A*]of selecting the Java states to be sent to the model checking module	context(we send)	negated: False ,passive: True
0.334	[*A*]we[*R*]send[*A*]those states produced after relevant events in the Java execution	context()	negated: False ,passive: False
0.918	[*A*]those states[*R*]produced[*A*]after relevant events in the Java execution	context()	negated: False ,passive: True
0.933	[*A*]the Java states[*R*]to be sent[*A*]to the model checking module	context()	negated: False ,passive: True
[LINE#487] These events include exceptions, deadlocks, update of designated variables, method entry and exit, interactions with monitors, breakpoints, and program termination.
0.937	[*A*]These events[*R*]include[*A*]exceptions , deadlocks , update of designated variables , exit , interactions with program termination	context()	negated: False ,passive: True
0.937	[*A*]These events[*R*]include[*A*]exceptions , deadlocks , update of designated variables , exit , interactions with breakpoints	context()	negated: False ,passive: True
0.937	[*A*]These events[*R*]include[*A*]exceptions , deadlocks , update of designated variables , exit , interactions with monitors	context()	negated: False ,passive: True
0.937	[*A*]These events[*R*]include[*A*]exceptions , deadlocks , update of designated variables , method entry , interactions with program termination	context()	negated: False ,passive: True
0.903	[*A*]These events[*R*]include[*A*]exceptions , deadlocks , update of designated variables	context()	negated: False ,passive: True
[LINE#488+489]  The second optimization consists of abstracting (projecting)the Java state when it is converted to a Spin state.
0.498	[*A*]it[*R*]is converted[*A*]to a Spin state	context()	negated: False ,passive: True
0.925	[*A*]The second optimization[*R*]consists[*A*]of abstracting (projecting)the Java state	context()	negated: False ,passive: True
[LINE#490] The simplest abstraction method generates a Spin state with only some (a small number) of the variables of the current Java state.
0.931	[*A*]The simplest abstraction method[*R*]generates[*A*]a Spin state	context()	negated: False ,passive: False
[LINE#491] These variables are stored in C variables, which are tracked by Spin and part of the global state.
0.887	[*A*]C variables[*R*]are tracked[*A*]by part of the global state	context()	negated: False ,passive: True
0.905	[*A*]C variables[*R*]are tracked[*A*]by Spin	context()	negated: False ,passive: True
0.903	[*A*]These variables[*R*]are stored[*A*]in C variables	context()	negated: False ,passive: True
[LINE#492+493]  In this case, the runtime monitoring module only sends the (j)part of the original j Java state.
0.978	[*A*]the runtime monitoring module[*R*]sends[*A*]the (j)part of the original j Java state[*A*]In this case	context()	negated: False ,passive: False
[LINE#494] These selected variables are those that are relevant for checking the user requirements, like the LTL formula.
0.333	[*A*]those[*R*]are[*A*]relevant for checking the user requirements, like the LTL formula	context()	negated: False ,passive: True
0.879	[*A*]These selected variables[*R*]are[*A*]those that are relevant for checking the user requirements, like the LTL formula	context()	negated: False ,passive: True
[LINE#495+496+497]  We include one additional variable, the index j, in the Spin state, which is useful to retrieve the appropriate Java state (j) when backtracking, as shown in Fig., abstraction method consists of building an optimized Spin state with all the information in the Java state.
0.846	[*A*]the Spin state[*R*]is[*A*]useful	context()	negated: False ,passive: True
0.381	[*A*]We[*R*]include j[*A*]one additional variable	context(abstraction method consists)	negated: False ,passive: True
0.961	[*A*]abstraction method[*R*]consists[*A*]of building an optimized Spin state with all the information in the Java state[*A*]in the Spin state[*A*]when backtracking, as shown in Fig.	context()	negated: False ,passive: True
[LINE#498] Note that this information may be huge, and includes all the variables in objects, thread state and static variables (states (j) and j Java would be the same).
0.817	[*A*]j Java[*R*]would be[*A*]the same	context()	negated: False ,passive: True
0.898	[*A*]Note that this information includes all the variables in objects , thread static variables[*R*]would be[*A*]the same	context()	negated: False ,passive: True
0.903	[*A*]this information[*R*]includes[*A*]all the variables in objects , thread static variables	context()	negated: False ,passive: True
0.767	[*A*]thread state[*R*]would be[*A*]the same	context()	negated: False ,passive: True
[LINE#499] This state is optimized in two steps.
0.903	[*A*]This state[*R*]is optimized[*A*]in two steps	context()	negated: False ,passive: True
[LINE#500] First, we collect strings representing the Java hash value for all objects, threads and static variables.
0.894	[*A*]strings[*R*]representing[*A*]the Java hash value for all objects, threads and static variables	context()	negated: False ,passive: False
0.614	[*A*]we[*R*]collect[*A*]strings representing the Java hash value for all objects, threads and static variables	context()	negated: False ,passive: False
[LINE#501] Then, we apply the hashing algorithm MD5 to a canonical concatenation of these strings.
0.595	[*A*]we[*R*]apply[*A*]the hashing algorithm[*A*]to a canonical concatenation of these strings[*A*]Then	context()	negated: False ,passive: False
[LINE#502] The result is extremely efficient in both processing time and size of the final state.
0.925	[*A*]The result[*R*]is[*A*]extremely efficient in size of the final state	context()	negated: False ,passive: True
0.925	[*A*]The result[*R*]is[*A*]extremely efficient[*A*]in both processing time of the final state	context()	negated: False ,passive: True
[LINE#503] This abstraction method, called state hashing, is suitable for checking cycles in Spin, and it can be used to detect cycles in the Java program and to check LTL liveness formulas in infinite executions of Java programs.
0.614	[*A*]it[*R*]can be used[*A*]to check LTL liveness formulas in infinite executions of Java programs	context()	negated: False ,passive: True
0.456	[*A*]it[*R*]to detect[*A*]cycles[*A*]in the Java program	context()	negated: False ,passive: False
0.498	[*A*]it[*R*]can be used[*A*]to detect cycles in the Java program	context()	negated: False ,passive: True
0.953	[*A*]This abstraction method , called state hashing[*R*]is[*A*]suitable for checking cycles in Spin	context()	negated: False ,passive: True
0.897	[*A*]This abstraction method[*R*]called[*A*]state hashing	context()	negated: False ,passive: True
[LINE#504] Both abstraction methods are implemented, making use of the Promela features for embedded C code as explained above.
0.943	[*A*]Both abstraction methods[*R*]are implemented[*A*]making use of the Promela features for embedded C code	context()	negated: False ,passive: True
[LINE#505] The next section is dedicated to describing and proving the correctness of these abstraction methods supported by TJT.
0.925	[*A*]these abstraction methods[*R*]supported[*A*]by TJT	context()	negated: False ,passive: True
0.911	[*A*]The next section[*R*]is dedicated[*A*]to proving the correctness of these abstraction methods	context()	negated: False ,passive: True
0.783	[*A*]The next section[*R*]is dedicated[*A*]to describing	context()	negated: False ,passive: True
