[LINE#1]This paper presents the results of a large scale empirical study of coherent dependence clusters.
0.937	[*A*]This paper[*R*]presents[*A*]the results of a large scale empirical study of coherent dependence clusters	context()	negated: False ,passive: False
[LINE#2]All statements in a coherent dependence cluster depend upon the same set of statements and affect the same set of statements; a coherent cluster's statements have 'coherent' shared backward and forward dependence.
0.447	[*A*]coherent[*R*]shared[*A*]backward dependence	context(a coherent cluster 's statements have)	negated: False ,passive: False
0.893	[*A*]a coherent cluster 's statements[*R*]have[*A*]coherent ' shared forward dependence	context()	negated: False ,passive: False
0.447	[*A*]coherent[*R*]shared[*A*]backward dependence	context(a coherent cluster 's statements have)	negated: False ,passive: False
0.924	[*A*]All statements in a coherent dependence cluster[*R*]depend[*A*]upon the same set of statements	context(a coherent cluster 's statements have)	negated: False ,passive: False
0.893	[*A*]a coherent cluster 's statements[*R*]have[*A*]coherent ' shared backward dependence	context()	negated: False ,passive: False
[LINE#3]We introduce an approximation to efficiently locate coherent clusters and show that it has a minimum precision of 97.76%.
0.522	[*A*]it[*R*]has[*A*]a minimum precision of 97.76 %	context()	negated: False ,passive: False
0.208	[*A*]We[*R*]introduce[*A*]an approximation show that it has a minimum precision of 97.76 %	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]introduce[*A*]an approximation to efficiently locate coherent clusters	context()	negated: False ,passive: False
[LINE#4]Our empirical study also finds that, despite their tight coherence constraints, coherent dependence clusters are in abundance: 23 of the 30 programs studied have coherent clusters that contain at least 10% of the whole program.
0.888	[*A*]coherent dependence clusters[*R*]are[*A*]in abundance	context(Our empirical study finds 23 of the 30 programs have)	negated: False ,passive: True
0.348	[*A*]Our empirical study[*R*]finds[*A*]that, despite their tight coherence constraints, coherent dependence clusters are in abundance	context(23 of the 30 programs have)	negated: False ,passive: False
0.826	[*A*]23 of the 30 programs[*R*]have[*A*]coherent clusters that contain at least 10% of the whole program	context()	negated: False ,passive: False
0.887	[*A*]coherent clusters[*R*]contain[*A*]at least 10% of the whole program	context()	negated: False ,passive: False
0.751	[*A*]the 30 programs[*R*]studied	context()	negated: False ,passive: False
[LINE#5]Studying patterns of clustering in these programs reveals that most programs contain multiple substantial coherent clusters.
0.882	[*A*]most programs[*R*]contain[*A*]multiple substantial coherent clusters	context(Studying patterns of clustering in these programs reveals)	negated: False ,passive: False
0.815	[*A*]Studying patterns of clustering in these programs[*R*]reveals[*A*]that most programs contain multiple substantial coherent clusters	context()	negated: False ,passive: False
[LINE#6]A series of subsequent case studies uncover that all clusters of significant size map to a logical functionality and correspond to a program structure.
0.937	[*A*]that all clusters of significant size map to a logical functionality[*R*]correspond[*A*]to a program structure	context(A series of subsequent case studies uncover)	negated: False ,passive: True
0.763	[*A*]A series of subsequent case studies[*R*]uncover	context()	negated: False ,passive: False
[LINE#7]For example, we show that for the program acct, the top five coherent clusters all map to specific, yet otherwise non-obvious, functionality.
0.900	[*A*]the top five coherent clusters[*R*]map[*A*]otherwise non-obvious, functionality	context(we show)	negated: False ,passive: False
0.330	[*A*]we[*R*]show[*A*]that for the program acct, the top five coherent clusters all map to specific, yet otherwise non-obvious, functionality	context()	negated: False ,passive: False
[LINE#8]Cluster visualization also brings out subtle deficiencies in program structure and identifies potential refactoring candidates.
0.920	[*A*]Cluster[*R*]identifies[*A*]potential refactoring candidates	context()	negated: False ,passive: False
0.934	[*A*]Cluster visualization[*R*]brings[*A*]out[*A*]subtle deficiencies in program structure	context()	negated: False ,passive: False
[LINE#9]A study of inter-cluster dependence is used to highlight how coherent clusters are connected to each other, revealing higher-level structures, which can be used in reverse engineering.
0.707	[*A*]how coherent clusters[*R*]are connected	context(A study of inter-cluster dependence to highlight)	negated: False ,passive: False
0.931	[*A*]A study of inter-cluster dependence[*R*]to highlight[*A*]how coherent clusters are connected to each other, revealing higher-level structures,	context()	negated: False ,passive: False
0.905	[*A*]higher-level structures[*R*]can be used[*A*]in reverse engineering	context()	negated: False ,passive: True
0.952	[*A*]A study of inter-cluster dependence[*R*]is used[*A*]to highlight how coherent clusters are connected to each other	context()	negated: False ,passive: True
[LINE#10]Finally, studies are presented to illustrate how clusters are not correlated with program faults as they remain stable during most system evolution.
0.871	[*A*]clusters[*R*]are not correlated[*A*]with program faults	context(studies to illustrate)	negated: True ,passive: True
0.833	[*A*]studies[*R*]to illustrate[*A*]how clusters are not correlated with program faults as they remain stable during most system evolution	context()	negated: False ,passive: False
0.616	[*A*]they[*R*]remain[*A*]stable[*A*]during most system evolution	context()	negated: False ,passive: True
0.931	[*A*]studies[*R*]are presented[*A*]to illustrate how clusters are not correlated with program faults	context()	negated: False ,passive: True
[LINE#11]This section provides background on dependence clusters.
0.903	[*A*]This section[*R*]provides[*A*]background on dependence clusters	context()	negated: False ,passive: False
[LINE#12]It first presents a sequence of definitions that culminate in the definition for a coherent dependence cluster.
0.877	[*A*]definitions[*R*]culminate[*A*]in the definition for a coherent dependence cluster	context()	negated: False ,passive: True
0.554	[*A*]It[*R*]presents[*A*]a sequence of definitions[*A*]first	context()	negated: False ,passive: False
[LINE#13] Previous work (Binkley and Harman, 2005;.
[LINE#14]Harman et al., 2009) has used the term dependence cluster for a particular kind of cluster, termed a mutually-dependent cluster herein to emphasize that such clusters consider only mutual dependence internal to the cluster.
0.882	[*A*]such clusters[*R*]consider[*A*]only mutual dependence internal to the cluster	context(a mutually - dependent cluster herein to emphasize)	negated: False ,passive: False
0.865	[*A*]a mutually-dependent cluster herein[*R*]to emphasize[*A*]that such clusters consider only mutual dependence internal to the cluster	context()	negated: False ,passive: False
0.872	[*A*]Harman et al., 2009[*R*]termed[*A*]a mutually-dependent cluster herein[*A*]to emphasize that such clusters consider only mutual dependence internal to the cluster	context()	negated: False ,passive: False
0.949	[*A*]Harman et al., 2009[*R*]has used[*A*]the term dependence cluster for a particular kind of cluster	context()	negated: False ,passive: False
[LINE#15]This distinction allows the definition to be extended to incorporate external dependence.
0.882	[*A*]the definition[*R*]to be extended[*A*]to incorporate external dependence	context(This distinction allows)	negated: False ,passive: True
0.882	[*A*]This distinction[*R*]allows[*A*]the definition to be extended to incorporate external dependence	context()	negated: False ,passive: False
[LINE#16]The section also reviews the current graph-based visualizations for dependence clusters..
0.887	[*A*]The section[*R*]reviews[*A*]the current graph-based visualizations for dependence clusters	context()	negated: False ,passive: False
[LINE#17] Dependence clustersInformally, mutually-dependent clusters are maximal sets of program statements that mutually depend upon one another.
0.735	[*A*]program statements[*R*]mutually depend[*A*]upon one another	context()	negated: False ,passive: False
0.919	[*A*]mutually-dependent clusters[*R*]are[*A*]maximal sets of program statements	context()	negated: False ,passive: True
[LINE#18]They are formalized in terms of mutually dependent sets in the following definition.
0.320	[*A*]They[*R*]are formalized	context()	negated: False ,passive: False
[LINE#19] Definition 2.1Mutually-dependent set and cluster (Harman et al., 2009)A mutually-dependent set (MDS) is a set of statements, S, such thatx.
[LINE#20]A mutually-dependent cluster is a maximal MDS; thus, it is an MDS not properly contained within another MDS.The definition of an MDS is parameterized by an underlying depends-on relation.
0.809	[*A*]an MDS[*R*]is parameterized[*A*]by an underlying depends-on relation	context(it is)	negated: False ,passive: True
0.939	[*A*]A mutually-dependent cluster[*R*]is[*A*]a maximal MDS	context(it is)	negated: False ,passive: True
0.503	[*A*]it[*R*]is[*A*]an MDS	context()	negated: False ,passive: True
0.887	[*A*]an MDS[*R*]not properly contained[*A*]within another MDS.The definition of an MDS	context()	negated: True ,passive: True
[LINE#21]Ideally, such a relation would precisely capture the impact, influence, and dependence between statements.
[LINE#22]Unfortunately, such a relation is not computable (Weiser, 1984).
0.783	[*A*]such a relation[*R*]is not[*A*]computable	context()	negated: True ,passive: True
[LINE#23]A well known approximation is based on Weiser's program slice (Weiser, 1984): a slice is the set of program statements that affect the values computed at a particular statement of interest (referred to as a slicing criterion).
0.903	[*A*]the values[*R*]computed[*A*]at a particular statement of interest	context()	negated: False ,passive: True
0.927	[*A*]program statements[*R*]affect[*A*]the values computed at a particular statement of interest (	context()	negated: False ,passive: False
0.916	[*A*]A well known approximation[*R*]is based[*A*]on Weiser's program slice	context(a slice is)	negated: False ,passive: True
0.908	[*A*]a slice[*R*]is[*A*]the set of program statements	context()	negated: False ,passive: True
[LINE#24]While its computation is undecidable, a minimal (or precise) slice includes exactly those program elements that affect the criterion and thus can be used to define an MDS in which t depends on s iff s is in the minimal slice taken with respect to slicing criterion t.
0.805	[*A*]a precise ) slice[*R*]includes[*A*]exactly those program elements that affect the criterion	context()	negated: False ,passive: True
0.751	[*A*]the minimal slice[*R*]taken	context()	negated: False ,passive: False
0.905	[*A*]exactly those program elements[*R*]affect[*A*]the criterion	context()	negated: False ,passive: False
0.864	[*A*]iff s[*R*]is[*A*]in the minimal slice	context()	negated: False ,passive: True
0.820	[*A*]a minimal ( ) slice[*R*]includes[*A*]exactly those program elements that affect the criterion	context()	negated: False ,passive: True
0.813	[*A*]t[*R*]depends[*A*]on s iff s is in the minimal slice	context()	negated: False ,passive: False
0.452	[*A*]its computation[*R*]is[*A*]undecidable	context()	negated: False ,passive: True
[LINE#25]The slice-based definition is useful because algorithms to compute approximations to minimal slices can be used to define and compute approximations to mutually-dependent clusters.
0.927	[*A*]algorithms to compute approximations to minimal slices[*R*]to compute[*A*]approximations[*A*]to mutually - dependent clusters	context()	negated: False ,passive: False
0.938	[*A*]algorithms to compute approximations to minimal slices[*R*]can be used[*A*]to compute approximations to mutually - dependent clusters	context()	negated: False ,passive: True
0.964	[*A*]The slice - based definition[*R*]is[*A*]useful[*A*]because algorithms to compute approximations to minimal slices can be used to compute approximations to mutually - dependent clusters	context()	negated: False ,passive: True
0.789	[*A*]algorithms to compute approximations to minimal slices[*R*]to define	context()	negated: False ,passive: False
0.842	[*A*]algorithms to compute approximations to minimal slices[*R*]can be used[*A*]to define	context()	negated: False ,passive: True
0.964	[*A*]The slice - based definition[*R*]is[*A*]useful[*A*]because algorithms to compute approximations to minimal slices can be used to define	context()	negated: False ,passive: True
[LINE#26] One such algorithm computes a slice as the solution to a reachability problem over a program's System Dependence Graph (SDG).
0.943	[*A*]One such algorithm[*R*]computes[*A*]a slice as the solution to a reachability problem over a program's System	context()	negated: False ,passive: False
[LINE#27]An SDG is comprised of vertices, which essentially represent the statements of the program and two kinds of edges: data dependence edges and control dependence edges.
0.877	[*A*]vertices[*R*]represent[*A*]the control dependence edges	context()	negated: False ,passive: False
0.877	[*A*]vertices[*R*]represent[*A*]the data dependence edges	context()	negated: False ,passive: False
0.877	[*A*]vertices[*R*]represent[*A*]the statements of the two kinds of edges	context()	negated: False ,passive: False
0.877	[*A*]vertices[*R*]represent[*A*]the statements of the program	context()	negated: False ,passive: False
0.867	[*A*]An SDG[*R*]is comprised[*A*]of vertices	context()	negated: False ,passive: True
[LINE#28]A data dependence connects a definition of a variable with each use of the variable reached by the definition (Ferrante et al., 1987).
0.903	[*A*]the variable[*R*]reached[*A*]by the definition	context()	negated: False ,passive: True
0.943	[*A*]A data dependence[*R*]connects[*A*]a definition of a variable with each use of the variable	context()	negated: False ,passive: False
[LINE#29]Control dependence connects a predicate p to a vertex v when p has at least two control-flow-graph successors, one of which can lead to the exit vertex without encountering v and the other always leads eventually to v (Ferrante et al., 1987).
0.908	[*A*]a predicate[*R*]p[*A*]to a vertex v	context(Control dependence connects)	negated: False ,passive: False
0.705	[*A*]the other[*R*]leads[*A*]eventually[*A*]to v ( Ferrante et al . , 1987[*A*]always	context()	negated: False ,passive: False
0.744	[*A*]a predicate[*R*]p	context(Control dependence connects)	negated: False ,passive: False
0.882	[*A*]Control dependence[*R*]connects[*A*]a predicate p to a vertex v	context()	negated: False ,passive: False
[LINE#30]Thus p controls the possible future execution of v. For structured code, control dependence reflects the nesting structure of the program.
0.903	[*A*]control dependence[*R*]reflects[*A*]the nesting structure of the program	context()	negated: False ,passive: True
[LINE#31]When slicing an SDG, a slicing criterion is a vertex from the SDG.A nave definition of a dependence cluster would be based on the transitive closure of the dependence relation and thus would define a cluster to be a strongly connected component.
0.957	[*A*]a slicing criterion[*R*]is[*A*]thus[*A*]When slicing an SDG	context()	negated: False ,passive: True
0.903	[*A*]a cluster[*R*]to be[*A*]a strongly connected component	context()	negated: False ,passive: True
0.959	[*A*]a vertex from the SDG.A nave definition of a dependence cluster[*R*]would be based[*A*]on the transitive closure of the dependence relation	context(a slicing criterion is)	negated: False ,passive: True
0.973	[*A*]a slicing criterion[*R*]is[*A*]a vertex from the SDG.A nave definition of a dependence cluster would be based on the transitive closure of the dependence relation[*A*]When slicing an SDG	context()	negated: False ,passive: True
[LINE#32]Unfortunately, for certain language features, dependence is non-transitive.
0.798	[*A*]dependence[*R*]is[*A*]non-transitive	context()	negated: False ,passive: True
[LINE#33]Examples of such features include procedures (Horwitz et al., 1990) and threads (Krinke, 1998).
0.919	[*A*]Examples of such features[*R*]include[*A*]threads	context()	negated: False ,passive: True
0.769	[*A*]Examples of such features[*R*]include	context()	negated: False ,passive: False
0.919	[*A*]Examples of such features[*R*]include[*A*]procedures	context()	negated: False ,passive: True
[LINE#34]Thus, in the presence of these features, strongly connected components overstate the size and number of dependence clusters.
0.948	[*A*]strongly connected components[*R*]overstate[*A*]the number of dependence clusters[*A*]in the presence of these features	context()	negated: False ,passive: False
0.948	[*A*]strongly connected components[*R*]overstate[*A*]the size of dependence clusters[*A*]in the presence of these features	context()	negated: False ,passive: False
[LINE#35] Fortunately, context-sensitive slicing captures the necessary context information (Binkley and Harman, 2005, 2003;.
0.919	[*A*]context - sensitive slicing[*R*]captures[*A*]the necessary context information	context()	negated: False ,passive: False
[LINE#36] Horwitz et al., 1990; Krinke, 2002, 2003).Two kinds of SDG slices are used in this paper: backward slices and forward slices(Horwitz et al., 1990; Ottenstein and Ottenstein, 1984).
0.944	[*A*]Two kinds of SDG slices[*R*]are used[*A*]in this paper	context()	negated: False ,passive: True
[LINE#37]The backward slice taken with respect to vertex v, denoted BSlice(v), is the set of vertices reaching v via a path of control and data dependence edges where this path respects context.
0.903	[*A*]this path[*R*]respects[*A*]context	context()	negated: False ,passive: False
0.749	[*A*]vertices[*R*]reaching[*A*]v	context()	negated: False ,passive: False
0.954	[*A*]The backward slice taken with respect to vertex v[*R*]is[*A*]the set of vertices	context()	negated: False ,passive: True
0.751	[*A*]The backward slice[*R*]taken	context()	negated: False ,passive: False
[LINE#38]The forward slice, taken with respect to vertex v, denoted FSlice(v), is the set of vertices reachable from v via a path of control and data dependence edges where this path respects context.
0.903	[*A*]this path[*R*]respects[*A*]context	context()	negated: False ,passive: False
0.958	[*A*]The forward slice , taken with respect to vertex v[*R*]is[*A*]the set of vertices	context()	negated: False ,passive: True
0.718	[*A*]The forward slice[*R*]taken	context()	negated: False ,passive: False
[LINE#39]1 illustrates the non-transitivity of slice inclusion.
0.381	[*A*]1[*R*]illustrates[*A*]the non-transitivity of slice inclusion	context()	negated: False ,passive: False
[LINE#40]The program has six assignment statements (assigning the variables a, b, c, d, e and f) whose dependencies are shown in columns 1-6 as backward slice inclusion.
0.949	[*A*]six assignment statements ( assigning the variables e and f )[*R*]are shown[*A*]in columns	context()	negated: False ,passive: True
0.784	[*A*]the variables[*R*]e	context()	negated: False ,passive: False
0.952	[*A*]The program[*R*]has[*A*]six assignment statements ( assigning the variables e and f ) whose dependencies are shown in columns 1-6 as backward slice inclusion	context()	negated: False ,passive: False
0.934	[*A*]six assignment statements ( assigning the variables a[*R*]are shown[*A*]in columns[*A*]as backward slice inclusion	context()	negated: False ,passive: True
0.952	[*A*]The program[*R*]has[*A*]six assignment statements ( assigning the variables a and f ) whose dependencies are shown in columns 1-6 as backward slice inclusion	context()	negated: False ,passive: False
[LINE#41]Backward slice inclusion contains statements that affect the slicing criterion through data and control dependence.
0.877	[*A*]statements[*R*]affect[*A*]the slicing criterion	context()	negated: False ,passive: False
0.789	[*A*]Backward slice inclusion[*R*]contains[*A*]statements that affect the slicing criterion through control dependence	context()	negated: False ,passive: False
0.877	[*A*]statements[*R*]affect[*A*]the slicing criterion through data	context()	negated: False ,passive: False
0.789	[*A*]Backward slice inclusion[*R*]contains[*A*]statements that affect the slicing criterion through data	context()	negated: False ,passive: False
[LINE#42] The dependence relationship between these statements is also extracted and shown in Fig. 2using a directed graph where the nodes of the graph represent the assignment statements and the edges represent the backward slice inclusion relationship from Fig. 1.
0.956	[*A*]The dependence relationship between these statements[*R*]is[*A*]represent the backward slice inclusion relationship from Fig	context()	negated: False ,passive: True
0.943	[*A*]The dependence relationship between these statements[*R*]is shown[*A*]in Fig	context()	negated: False ,passive: True
0.724	[*A*]The dependence relationship between these statements[*R*]is extracted	context()	negated: False ,passive: False
[LINE#43]The table on the right in Fig. 2 also gives the forward slice inclusions for the statements.
0.945	[*A*]The table on the right in Fig[*R*]gives[*A*]the forward slice[*A*]inclusions for the statements	context()	negated: False ,passive: False
[LINE#44]All other statements in P, which do not define a variable, are ignored.
0.859	[*A*]All other statements in P, which do not define a variable[*R*]are ignored	context()	negated: False ,passive: False
0.913	[*A*]All other statements in P[*R*]do not define[*A*]a variable	context()	negated: True ,passive: False
[LINE#45] In the diagram, x depends on y (y  BSlice(x)) is represented by y.
0.820	[*A*]y  BSlice(x[*R*]is represented[*A*]by	context()	negated: False ,passive: True
0.639	[*A*]x[*R*]depends[*A*]on y[*A*]In the diagram	context()	negated: False ,passive: False
[LINE#46] The diagram shows two instances of dependence intransitivity in.
0.901	[*A*]The diagram[*R*]shows in[*A*]two instances of dependence intransitivity	context()	negated: False ,passive: False
[LINE#47]P. Although b depends on nodes a, c, and d, node f, which depends on b, does not depend on a, c, or d. Similarly, d depends on e but a, b, and c, which depend on d do not depend on e. .
0.919	[*A*]which depend on d[*R*]do not depend[*A*]on e.	context()	negated: True ,passive: False
0.641	[*A*]node f[*R*]depends[*A*]on b, does not depend on a, c	context()	negated: False ,passive: False
0.569	[*A*]b[*R*]depends[*A*]on nodes a, c, and d, node f	context()	negated: False ,passive: False
[LINE#48]clustersA slice-based cluster is a maximal set of vertices included in each other's slice.
0.894	[*A*]vertices[*R*]included[*A*]in each other's slice	context()	negated: False ,passive: True
0.957	[*A*]clustersA slice-based cluster[*R*]is[*A*]a maximal set of vertices	context()	negated: False ,passive: True
[LINE#49]The following definition essentially instantiates Definition 2.1 using BSlice.
0.889	[*A*]The following definition[*R*]instantiates Definition 2.1 using[*A*]BSlice	context(The following definition instantiates)	negated: False ,passive: False
0.889	[*A*]The following definition[*R*]instantiates[*A*]Definition 2.1	context()	negated: False ,passive: False
[LINE#50] Because xBSlice(y)yFSlice(x)the dual of this definition using FSlice is equivalent.
0.831	[*A*]the dual of this definition[*R*]is[*A*]equivalent	context()	negated: False ,passive: True
0.918	[*A*]this definition[*R*]using[*A*]FSlice	context()	negated: False ,passive: False
[LINE#51]Where such a duality does not hold, both definitions are given.
0.678	[*A*]both definitions[*R*]are given	context(such a duality does not hold)	negated: False ,passive: False
0.868	[*A*]such a duality[*R*]does not hold[*A*]both definitions are given	context()	negated: True ,passive: False
[LINE#52]When it is important to differentiate between the two, the terms backward and forward will be added to the definition's name as is done in this section.
0.894	[*A*]the terms backward[*R*]will be added[*A*]to the definition's name[*A*]as is done in this section[*A*]When it is important to differentiate between the two[*A*]forward	context()	negated: False ,passive: True
[LINE#53] Definition 2.2Backward-slice MDS and cluster (Harman et al., 2009)A backward-slice MDS is a set of SDG vertices, V, such thatx, yV: xBSlice(y).A backward-slice cluster is a backward-slice MDS contained within no other backward-slice MDS.Note, this is equivalent to x, yV:xBSlice(y)yBSlice(x).
0.799	[*A*]a backward - slice MDS[*R*]contained	context(A backward - slice cluster is this is)	negated: False ,passive: False
0.972	[*A*]A backward - slice MDS[*R*]is[*A*]a set of SDG vertices , V , such thatx , yV	context(A backward - slice cluster is this is)	negated: False ,passive: True
0.962	[*A*]A backward - slice cluster[*R*]is[*A*]a backward - slice MDS contained within no other backward - slice MDS.Note	context(this is)	negated: False ,passive: True
0.799	[*A*]a backward - slice MDS[*R*]contained	context(Definition 2.2Backward - slice MDS is this is)	negated: False ,passive: False
0.967	[*A*]Definition 2.2Backward - slice MDS[*R*]is[*A*]a backward - slice MDS contained within no other backward - slice MDS.Note	context(this is)	negated: False ,passive: True
0.395	[*A*]this[*R*]is[*A*]equivalent to x	context()	negated: False ,passive: True
0.964	[*A*]A backward - slice MDS[*R*]is[*A*]a set of SDG vertices	context()	negated: False ,passive: True
[LINE#54]Thus, any unordered pair (x, y) with xBSlice(y)yBSlice(x) creates an edge (x, y) in an undirected graph in which a complete subgraph is equivalent to a backward-slice MDS and a backward-slice cluster is equivalent to a maximal clique.
0.960	[*A*]a complete subgraph[*R*]is[*A*]equivalent to a backward - slice cluster[*A*]an undirected graph	context()	negated: False ,passive: True
0.978	[*A*]any unordered pair ( x , y ) with xBSlice ( y ) yBSlice[*R*]is[*A*]equivalent to a maximal clique	context()	negated: False ,passive: True
0.967	[*A*]a complete subgraph[*R*]is[*A*]equivalent to a backward - slice MDS[*A*]an undirected graph	context()	negated: False ,passive: True
0.971	[*A*]any unordered pair ( x , y ) with xBSlice ( y ) yBSlice[*R*]creates[*A*]an edge[*A*]in an undirected graph	context()	negated: False ,passive: False
[LINE#55]Therefore, the clustering problem is the NP-Hard maximal cliques problem (Bomze et al., 1999) making Definition 2.2 prohibitively expensive to implement.
0.927	[*A*]the clustering problem[*R*]is[*A*]the NP-Hard maximal cliques problem	context()	negated: False ,passive: True
[LINE#56]In the example shown in Fig. 2, the vertices representing the assignments to a, b, c and d are all in each others backward slices and hence satisfy the definition of a backward-slice cluster.
0.339	[*A*]d[*R*]are[*A*]in each others	context()	negated: False ,passive: True
0.339	[*A*]c[*R*]are[*A*]in each others	context()	negated: False ,passive: True
0.950	[*A*]the vertices representing the assignments to a[*R*]are[*A*]in each others[*A*]In the example	context()	negated: False ,passive: True
0.903	[*A*]the vertices[*R*]representing[*A*]the assignments	context()	negated: False ,passive: False
0.937	[*A*]the example[*R*]shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#57]These vertices also satisfy the definition of a forward-slice cluster as they are also in each others forward slices.
0.616	[*A*]they[*R*]are[*A*]also[*A*]in each others[*A*]forward	context()	negated: False ,passive: True
[LINE#58]As dependence is not transitive, a statement can be in multiple slice-based clusters.
0.903	[*A*]a statement[*R*]can be[*A*]in multiple slice-based clusters	context()	negated: False ,passive: True
0.749	[*A*]dependence[*R*]is not[*A*]transitive	context()	negated: True ,passive: True
[LINE#59]the statements d and e are mutually dependent upon each other and thus satisfy the definition of a slice-based cluster.
0.887	[*A*]the statements[*R*]satisfy[*A*]the definition of a slice - based cluster	context()	negated: False ,passive: False
0.178	[*A*]e[*R*]are[*A*]mutually dependent upon each other	context()	negated: False ,passive: True
0.784	[*A*]the statements[*R*]d	context()	negated: False ,passive: False
[LINE#60]Statement d is also mutually dependent on statements a, b, c, thus the set {a, b, c, d} also satisfies the definition of a slice-based cluster. .
0.905	[*A*]Statement d[*R*]is[*A*]also[*A*]mutually dependent on statements	context(a , b , c satisfies)	negated: False ,passive: True
0.807	[*A*]a, b, c[*R*]satisfies[*A*]the definition of a slice-based cluster	context()	negated: False ,passive: False
[LINE#61]alternative definition uses the same-slice relation in place of slice inclusion (Binkley and Harman, 2005).
0.937	[*A*]alternative definition[*R*]uses[*A*]the same - slice relation in place of slice inclusion	context()	negated: False ,passive: False
[LINE#62]This relation replaces the need to check if two vertices are in each others slice with checking if two vertices have the same slice.
0.937	[*A*]This relation[*R*]replaces[*A*]the need to check if two vertices are in each others slice with checking if two vertices have the same slice	context()	negated: False ,passive: True
[LINE#63]The result is captured in the following definitions for same-slice cluster.
0.903	[*A*]The result[*R*]is captured[*A*]in the following definitions for same-slice cluster	context()	negated: False ,passive: True
[LINE#64]The first uses backward slices and the second forward slices.
0.163	[*A*]The first[*R*]uses forward slices	context(The first uses forward)	negated: False ,passive: False
0.258	[*A*]The first[*R*]uses forward[*A*]the second	context()	negated: False ,passive: False
0.568	[*A*]The first[*R*]uses[*A*]backward slices slices	context()	negated: False ,passive: False
[LINE#65] Definition 2.3Same-slice MDS and cluster (Harman et al., 2009)A same-backward-slice MDS is a set of SDG vertices, V, such thatx, yV:BSlice(x)=BSlice(y).A same-backward-slice cluster is a same-backward-slice MDS contained within no other same-backward-slice MDS.A same-forward-slice MDS is a set of SDG vertices, V, such thatx, yV:.
0.970	[*A*]A same - backward - slice MDS[*R*]is[*A*]a set of SDG vertices	context()	negated: False ,passive: True
[LINE#66] FSlice(x)=FSlice(y).A same-forward-slice cluster is a same-forward-slice MDS contained within no other same-forward-slice MDS.Because xBSlice(x) and xFSlice(x),two vertices that have the same slice will always be in each other's slice.
0.919	[*A*]FSlice[*R*]will be[*A*]in each other 's slice[*A*]always	context()	negated: False ,passive: True
0.948	[*A*]a same - forward - slice MDS[*R*]contained[*A*]within xFSlice	context()	negated: False ,passive: True
0.961	[*A*]FSlice[*R*]is[*A*]a same - forward - slice MDS contained within xFSlice ( x ) , two vertices	context()	negated: False ,passive: True
0.946	[*A*]two vertices that have the same slice[*R*]will be[*A*]in each other 's slice[*A*]always	context()	negated: False ,passive: True
0.887	[*A*]two vertices[*R*]have[*A*]the same slice	context()	negated: False ,passive: False
0.975	[*A*]a same - forward - slice MDS[*R*]contained[*A*]within no other same - forward - slice MDS.Because xBSlice	context()	negated: False ,passive: True
0.958	[*A*]FSlice ( x ) =FSlice[*R*]is[*A*]a same - forward - slice MDS	context()	negated: False ,passive: True
[LINE#67]If slice inclusion were transitive, a backward-slice MDS (Definition 2.2) would be identical to a same-backward-slice MDS (Definition 2.3).
0.945	[*A*]a backward-slice MDS[*R*]would be[*A*]identical to a same-backward-slice MDS	context()	negated: False ,passive: True
0.767	[*A*]slice inclusion[*R*]were[*A*]transitive	context()	negated: False ,passive: True
[LINE#68]However, as illustrated by the examples in Fig. 1, slice inclusion is not transitive; thus, the relation is one of containment where every same-backward-slice MDS is also a backward-slice MDS but not necessarily a maximal one.
0.905	[*A*]the relation[*R*]is[*A*]one of containment	context()	negated: False ,passive: True
0.930	[*A*]every same - backward - slice MDS[*R*]is not[*A*]necessarily[*A*]a maximal one	context()	negated: True ,passive: True
0.770	[*A*]slice inclusion[*R*]is[*A*]not transitive	context(the relation is)	negated: False ,passive: True
0.948	[*A*]the relation[*R*]is[*A*]one of containment where every same - backward - slice MDS is also a backward - slice MDS	context()	negated: False ,passive: True
0.970	[*A*]every same - backward - slice MDS[*R*]is[*A*]also[*A*]a backward - slice MDS	context()	negated: False ,passive: True
[LINE#69]For example, in Fig. 2 the set of vertices {a, b, c} form a same-backward-slice cluster because each vertex of the set yields the same backward slice.
0.926	[*A*]each vertex of the set[*R*]yields[*A*]the same backward slice	context()	negated: False ,passive: False
0.927	[*A*]the set of vertices[*R*]form[*A*]a same-backward-slice cluster	context()	negated: False ,passive: False
[LINE#70]Whereas the set of vertices {a, c} form a same-forward-slice cluster as they have the same forward slice.
0.616	[*A*]they[*R*]have[*A*]the same forward slice	context()	negated: False ,passive: False
[LINE#71]Although vertex d is mutually dependent with all vertices of either set, it does not form the same-slice cluster with either set because it has an additional dependence relationship with vertex e.
0.522	[*A*]it[*R*]has[*A*]an additional dependence relationship with vertex	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]does not form[*A*]the same-slice cluster with either set	context()	negated: True ,passive: False
0.944	[*A*]vertex d[*R*]is[*A*]mutually dependent with all vertices of either set	context()	negated: False ,passive: True
[LINE#72]Although the introduction of same-slice clusters was motivated by the need for efficiency, the definition inadvertently introduced an external requirement on the cluster.
0.903	[*A*]the definition[*R*]inadvertently introduced[*A*]an external requirement on the cluster	context()	negated: False ,passive: False
0.938	[*A*]the introduction of same-slice clusters[*R*]was motivated[*A*]by the need for efficiency	context()	negated: False ,passive: True
[LINE#73]Comparing the definitions for slice-based clusters (Definition 2.2) and same-slice clusters (Definition 2.3), a slice-based cluster includes only the internal requirement that the vertices of a cluster depend upon one another.
0.926	[*A*]a slice - based cluster[*R*]includes[*A*]only the internal requirement	context()	negated: False ,passive: True
0.934	[*A*]Comparing the definitions for slice - based clusters[*R*]includes[*A*]only the internal requirement	context()	negated: False ,passive: True
[LINE#74] However, a same-backward-slice cluster (inadvertently)adds to this internal requirement the external requirement that all vertices in the cluster are affected by the same vertices external to the cluster.
0.926	[*A*]all vertices in the cluster[*R*]are affected[*A*]by the same vertices external to the cluster	context()	negated: False ,passive: True
0.954	[*A*]a same-backward-slice cluster (inadvertently[*R*]adds[*A*]to this internal requirement	context()	negated: False ,passive: False
[LINE#75]Symmetrically, a same-forward-slice cluster adds the external requirement that all vertices in the cluster affect the same vertices external to the cluster. .
0.926	[*A*]all vertices in the cluster[*R*]affect[*A*]the same vertices external to the cluster	context()	negated: False ,passive: False
0.921	[*A*]a same-forward-slice cluster[*R*]adds[*A*]the external requirement that all vertices in the cluster affect the same vertices external to the cluster	context()	negated: False ,passive: False
[LINE#76]Coherent dependence clustersThis subsection first formalizes the notion of coherent dependence clusters and then presents a slice-based instantiation of the definition.
0.945	[*A*]Coherent[*R*]presents[*A*]a slice - based instantiation of the definition[*A*]then	context()	negated: False ,passive: False
0.959	[*A*]Coherent dependence clustersThis subsection[*R*]formalizes[*A*]the notion of coherent dependence clusters[*A*]first	context()	negated: False ,passive: False
[LINE#77] Coherent clusters are dependence clusters that include not only an internal dependence requirement(each statement of a cluster depends on all the other statements of the cluster) but also an external dependence requirement.
0.887	[*A*]dependence clusters[*R*]include[*A*]not only an internal dependence requirement	context()	negated: False ,passive: True
[LINE#78]The external dependence requirement includes both that each statement of a cluster depends on the same statements external to the cluster and also that it influences the same set of statements external to the cluster.
0.388	[*A*]it[*R*]influences[*A*]the same set of statements external to the cluster	context(The external dependence requirement includes)	negated: False ,passive: False
0.734	[*A*]The external dependence requirement[*R*]includes[*A*]also[*A*]that it influences the same set of statements external to the cluster	context()	negated: False ,passive: True
0.909	[*A*]each statement of a cluster[*R*]depends[*A*]on the same statements external to the cluster	context(The external dependence requirement includes)	negated: False ,passive: False
0.841	[*A*]The external dependence requirement[*R*]includes[*A*]both that each statement of a cluster depends on the same statements external to the cluster	context()	negated: False ,passive: True
[LINE#79]In other words, a coherent cluster is a set of statements that are mutually dependent and share identical extra-cluster dependence.
0.877	[*A*]statements[*R*]share[*A*]identical extra-cluster dependence	context()	negated: False ,passive: False
0.716	[*A*]statements[*R*]are[*A*]mutually dependent	context()	negated: False ,passive: True
0.932	[*A*]a coherent cluster[*R*]is[*A*]a set of statements	context()	negated: False ,passive: True
[LINE#80] Coherent clusters are defined in terms of the coherent MDS:Definition 2.4Coherent MDS and cluster (Islam et al., 2010b)A coherent MDS is a MDS V, such thatx, yV: x depends on a implies y depends on a anda depends on x implies a depends on y.
0.981	[*A*]Islam et al . , 2010b ) A coherent MDS is a MDS V , such thatx , yV : x depends on a implies y depends on a anda[*R*]depends[*A*]on x implies a depends on	context()	negated: False ,passive: False
0.947	[*A*]A coherent MDS[*R*]is[*A*]a MDS V	context(x depends)	negated: False ,passive: True
0.687	[*A*]Coherent clusters[*R*]are defined	context(x depends)	negated: False ,passive: False
0.860	[*A*]depends on a anda[*R*]depends[*A*]on x implies a depends on	context()	negated: False ,passive: False
0.947	[*A*]A coherent MDS[*R*]is[*A*]a MDS V	context(x depends)	negated: False ,passive: True
0.687	[*A*]Coherent clusters[*R*]are defined	context(x depends)	negated: False ,passive: False
0.330	[*A*]x[*R*]depends[*A*]on a implies y	context()	negated: False ,passive: False
0.189	[*A*]x[*R*]implies[*A*]a depends on	context()	negated: False ,passive: False
[LINE#81]A coherent cluster is a coherent MDS contained within no other coherent MDS.The slice-based instantiation of coherent cluster employs both backward and forward slices.
0.921	[*A*]A coherent cluster is a coherent MDS contained within no other coherent MDS.The slice - based instantiation of coherent cluster employs both forward[*R*]slices	context()	negated: False ,passive: False
0.964	[*A*]a coherent MDS[*R*]contained[*A*]within no other coherent MDS.The slice - based instantiation of coherent cluster	context()	negated: False ,passive: True
0.964	[*A*]a coherent MDS[*R*]contained[*A*]within no other coherent MDS.The slice - based instantiation of coherent cluster employs both backward slices	context()	negated: False ,passive: True
0.942	[*A*]A coherent cluster[*R*]is[*A*]a coherent MDS	context()	negated: False ,passive: True
[LINE#82]The combination has the advantage that the entire cluster is both affected by the same set of vertices (as in the case of same-backward-slice clusters) and also affects the same set of vertices (as in the case of same-forward-slice clusters).
0.897	[*A*]the entire cluster[*R*]affected[*A*]by the same set of vertices	context()	negated: False ,passive: True
0.956	[*A*]the entire cluster[*R*]is[*A*]both affected by the same set of vertices[*A*]as also affects the same set of vertices ( as in the case of same - forward - slice clusters	context()	negated: False ,passive: True
0.879	[*A*]The combination[*R*]has[*A*]the advantage that the entire cluster is both affected by the same set of vertices	context()	negated: False ,passive: False
0.933	[*A*]the entire cluster[*R*]affected[*A*]by the same set of vertices ( as in the case of same - backward - slice clusters	context()	negated: False ,passive: True
0.956	[*A*]the entire cluster[*R*]is[*A*]both affected by the same set of vertices ( as in the case of same - backward - slice clusters	context()	negated: False ,passive: True
0.879	[*A*]The combination[*R*]has[*A*]the advantage that the entire cluster is both affected by the same set of vertices ( as in the case of same - backward - slice clusters	context()	negated: False ,passive: False
[LINE#83] In the slice-based instantiation, a set of vertices V forms a coherent MDS ifx, yV: xBSlice(y)the internal requirement of an MDSaBSlice(x)aBSlice(y)x and y depend on same external aaFSlice(x)aFSlice(y)x and y impact on same external aBecause x and y are interchangeablex,yV:  aFSlice(y) yBSlice(x) aBSlice(y)  aFSlice(x)This is equivalent xBSlice(y)yBSlice(x) (aBSlice(x)aBSlice(y)) (aFSlice(x)aFSlice(y))which simplifies tox,yV:BSlice(x)=BSlice(y)FSlice(x)=FSlice(y)and can be used to define coherent-slice MDS and clusters:.
0.495	[*A*]This[*R*]is[*A*]equivalent xBSlice ( y ) yBSlice	context()	negated: False ,passive: True
0.986	[*A*]a set of vertices y depend on y impact on same external aBecause y[*R*]are[*A*]interchangeablex[*A*]In the slice - based instantiation	context()	negated: False ,passive: True
0.954	[*A*]a set of vertices y depend on y impact on same external[*R*]simplifies[*A*]tox	context()	negated: False ,passive: False
0.593	[*A*]This[*R*]is[*A*]equivalent[*A*]In the slice - based instantiation	context()	negated: False ,passive: True
0.495	[*A*]This[*R*]is[*A*]equivalent xBSlice ( y	context()	negated: False ,passive: True
0.181	[*A*]This[*R*]is[*A*]equivalent	context(a set of vertices y depend)	negated: False ,passive: True
0.940	[*A*]a set of vertices[*R*]y depend[*A*]on same external aaFSlice[*A*]In the slice - based instantiation	context()	negated: False ,passive: False
0.430	[*A*]This[*R*]is[*A*]equivalent xBSlice ( y ) yBSlice	context(a set of vertices V forms a coherent MDS ifx , yV : xBSlice ( y ) the internal requirement of an MDSaBSlice ( x ) aBSlice ( y depend)	negated: False ,passive: True
0.921	[*A*]a set of vertices[*R*]forms[*A*]a coherent MDS ifx	context(a set of vertices V forms a coherent MDS ifx , yV : xBSlice ( y ) the internal requirement of an MDSaBSlice ( x ) aBSlice ( y depend)	negated: False ,passive: False
0.992	[*A*]a set of vertices V forms a coherent MDS ifx , yV : xBSlice ( y ) the internal requirement of an MDSaBSlice ( x ) aBSlice ( y[*R*]depend[*A*]on y impact on same external aBecause y[*A*]In the slice - based instantiation	context()	negated: False ,passive: False
0.792	[*A*]=BSlice ( y ) FSlice ( x ) =FSlice[*R*]can be used[*A*]to define clusters:.	context()	negated: False ,passive: True
0.792	[*A*]=BSlice ( y ) FSlice ( x ) =FSlice[*R*]to define[*A*]clusters:.	context()	negated: False ,passive: False
0.921	[*A*]a set of vertices[*R*]forms[*A*]a coherent MDS ifx	context(a set of vertices V forms a coherent MDS ifx , yV : xBSlice ( y ) the internal requirement of an MDSaBSlice ( x ) aBSlice ( y depend This is)	negated: False ,passive: False
0.990	[*A*]a set of vertices V forms a coherent MDS ifx , yV : xBSlice ( y ) the internal requirement of an MDSaBSlice ( x ) aBSlice ( y[*R*]depend[*A*]on y impact on same external[*A*]In the slice - based instantiation	context(This is)	negated: False ,passive: False
0.906	[*A*]FSlice[*R*]can be used[*A*]to define coherent - slice MDS	context()	negated: False ,passive: True
0.605	[*A*]x[*R*]are[*A*]interchangeablex	context()	negated: False ,passive: True
0.868	[*A*]aFSlice ( y ) x y[*R*]are[*A*]interchangeablex	context()	negated: False ,passive: True
0.951	[*A*]aFSlice ( y ) yBSlice ( x ) aBSlice ( y ) aFSlice ( x[*R*]simplifies[*A*]tox	context()	negated: False ,passive: False
0.912	[*A*]aFSlice ( y ) yBSlice ( x ) aBSlice ( y ) aFSlice ( x ) This[*R*]is[*A*]equivalent	context()	negated: False ,passive: True
0.938	[*A*]a set of vertices[*R*]forms[*A*]a coherent MDS ifx	context()	negated: False ,passive: False
0.774	[*A*]FSlice[*R*]can be used[*A*]to define clusters:.	context()	negated: False ,passive: True
0.774	[*A*]FSlice[*R*]to define[*A*]clusters:.	context()	negated: False ,passive: False
0.921	[*A*]a set of vertices[*R*]forms[*A*]a coherent MDS ifx	context(a set of vertices V forms a coherent MDS ifx , yV : xBSlice ( y ) the internal requirement of an MDSaBSlice ( x ) aBSlice ( y ) depend This is)	negated: False ,passive: False
0.993	[*A*]a set of vertices V forms a coherent MDS ifx , yV : xBSlice ( y ) the internal requirement of an MDSaBSlice ( x ) aBSlice ( y )[*R*]depend[*A*]on same external aaFSlice[*A*]In the slice - based instantiation	context(This is)	negated: False ,passive: False
0.181	[*A*]This[*R*]is[*A*]equivalent	context()	negated: False ,passive: True
0.906	[*A*]FSlice[*R*]to define[*A*]coherent - slice MDS	context()	negated: False ,passive: False
[LINE#84] Definition 2.5Coherent-slice MDS and cluster , 2010b)A coherent-slice MDS is a set of SDG vertices, V, such thatx, yV:.
[LINE#85] BSlice(x)=BSlice(y)FSlice(x)=FSlice(y)A coherent-slice cluster is a coherent-slice MDS contained within no other coherent-slice MDS.At first glancethe use of both backward and forward slices might seem redundant because xBSlice(y)yFSlice(x).
0.799	[*A*]a coherent - slice MDS[*R*]contained	context(BSlice ( x ) =BSlice ( y ) FSlice ( x ) =FSlice is)	negated: False ,passive: False
0.970	[*A*]BSlice ( x ) =BSlice ( y ) FSlice ( x ) =FSlice[*R*]is[*A*]a coherent - slice MDS contained within no other coherent - slice MDS.At	context()	negated: False ,passive: True
0.842	[*A*]first glancethe use of both forward slices[*R*]might seem[*A*]redundant	context()	negated: False ,passive: True
0.799	[*A*]a coherent - slice MDS[*R*]contained	context(BSlice ( x ) =BSlice ( y ) FSlice is)	negated: False ,passive: False
0.957	[*A*]BSlice ( x ) =BSlice ( y ) FSlice[*R*]is[*A*]a coherent - slice MDS contained within no other coherent - slice MDS.At	context()	negated: False ,passive: True
0.842	[*A*]first glancethe use of both backward slices[*R*]might seem[*A*]redundant	context()	negated: False ,passive: True
[LINE#86]This is true up to a point: for the internal requirement of a coherent-slice cluster, the use of either BSlice or FSlice would suffice.
0.181	[*A*]This[*R*]is[*A*]true	context(the use of either BSlice or FSlice would suffice)	negated: False ,passive: True
0.974	[*A*]the use of either BSlice or FSlice[*R*]would suffice[*A*]for the internal requirement of a coherent-slice cluster	context()	negated: False ,passive: False
[LINE#87]However, the two are not redundant when it comes to the external requirements of a coherent-slice cluster.
0.195	[*A*]it[*R*]comes	context()	negated: False ,passive: False
0.534	[*A*]the two[*R*]are not[*A*]redundant[*A*]when it comes to the external requirements of a coherent-slice cluster	context()	negated: True ,passive: True
[LINE#88]With a mutually-dependent cluster (Definition 2.1), it is possible for two vertices within the cluster to influence or be affected by different vertices external to the cluster.
0.522	[*A*]it[*R*]is[*A*]possible[*A*]for two vertices within the cluster	context()	negated: False ,passive: True
[LINE#89]Neither is allowed with a coherent-slice cluster.
0.260	[*A*]Neither[*R*]is allowed	context()	negated: False ,passive: False
[LINE#90]To ensure that both external effects are captured, both backward and forward slices are required for coherent-slice clusters.
0.911	[*A*]both forward slices[*R*]are required[*A*]for coherent - slice clusters	context()	negated: False ,passive: True
0.911	[*A*]both backward slices[*R*]are required[*A*]for coherent - slice clusters	context()	negated: False ,passive: True
[LINE#91]the set of vertices {a, c} form a coherent cluster as both these vertices have exactly the same backward and forward slices.
0.783	[*A*]both these vertices[*R*]have[*A*]exactly the forward slices	context()	negated: False ,passive: False
0.927	[*A*]the set of vertices[*R*]form[*A*]a coherent cluster	context()	negated: False ,passive: False
0.911	[*A*]both these vertices[*R*]have[*A*]exactly the same backward	context()	negated: False ,passive: False
0.953	[*A*]the set of vertices[*R*]form[*A*]a coherent cluster as both these vertices have exactly the same backward	context()	negated: False ,passive: False
[LINE#92]That is, they share identical intra- and extra-cluster dependencies.
0.616	[*A*]they[*R*]share[*A*]extra-cluster dependencies	context()	negated: False ,passive: False
0.616	[*A*]they[*R*]share[*A*]identical intra-	context()	negated: False ,passive: False
[LINE#93]Coherent clusters are therefore a stricter from of same-slice clusters, all coherent clusters are also same-slice MDS but not necessarily maximal.
0.717	[*A*]Coherent clusters[*R*]are[*A*]therefore	context(all coherent clusters are)	negated: False ,passive: True
0.736	[*A*]all coherent clusters[*R*]are[*A*]also[*A*]not necessarily maximal	context()	negated: False ,passive: True
[LINE#94]It is worth noting that same-slice clusters partially share extra-cluster dependency.
0.390	[*A*]It[*R*]is[*A*]worth noting that same-slice clusters partially share extra-cluster dependency	context()	negated: False ,passive: True
[LINE#95]For example, each of the vertices in the same-backward-slice cluster {a, b, c} is dependent on the same set of external statements, but do not influence the same set of external statements.
0.919	[*A*]each of the vertices[*R*]do not influence[*A*]the same set of external statements	context()	negated: True ,passive: False
0.385	[*A*]c }[*R*]is dependent on[*A*]the same set	context()	negated: False ,passive: False
0.965	[*A*]each of the vertices in the same - backward - slice cluster[*R*]is[*A*]dependent on the same set of external statements	context()	negated: False ,passive: True
[LINE#96] Coherent slice-clusters have an important property: If a slice contains a vertex of a coherent slice-cluster V, it will contain all vertices of the cluster:(1)BSlice(x)V  BSlice(x)V= because:y,yV:yBSlice(x)  xFSlice(y)yBSlice(x)The same argument clearly holds for forward slices.
0.397	[*A*]it[*R*]will contain[*A*]all vertices of the cluster	context(Coherent slice - clusters have)	negated: False ,passive: False
0.900	[*A*]Coherent slice-clusters[*R*]have[*A*]an important property	context()	negated: False ,passive: False
0.911	[*A*]The same argument[*R*]clearly holds[*A*]for forward slices	context()	negated: False ,passive: False
0.903	[*A*]a slice[*R*]contains[*A*]a vertex of a coherent slice-cluster V	context()	negated: False ,passive: False
[LINE#97]However, the same is not true for non-coherent clusters.
0.568	[*A*]the same[*R*]is not[*A*]true for non-coherent clusters	context()	negated: True ,passive: True
[LINE#98]For example, in the case of a same-backward-slice cluster, a vertex contained within the forward slice of any vertex of the cluster is not guaranteed to be in the forward slice of other vertices of the same cluster.
0.973	[*A*]a vertex contained within the forward slice of any vertex of the cluster[*R*]to be[*A*]in the forward slice of other vertices of the same cluster	context()	negated: False ,passive: True
0.888	[*A*]a vertex contained within the forward slice of any vertex of the cluster[*R*]is not guaranteed	context()	negated: True ,passive: False
0.937	[*A*]a vertex[*R*]contained[*A*]within the forward slice of any vertex of the cluster	context()	negated: False ,passive: True
[LINE#99]Hash based coherent slice clustersThe computation of coherent-slice clusters (Definition 2.5) grows prohibitively expensive even for mid-sized programs where tens of gigabytes of memory are required to store the set of all possible backward and forward slices.
0.923	[*A*]Hash based coherent slice clustersThe computation of coherent - slice clusters[*R*]grows[*A*]prohibitively expensive	context()	negated: False ,passive: True
0.913	[*A*]tens of gigabytes of memory[*R*]to store[*A*]the set of all possible backward	context()	negated: False ,passive: False
0.957	[*A*]tens of gigabytes of memory[*R*]are required[*A*]to store the set of all possible backward[*A*]mid-sized programs	context()	negated: False ,passive: True
0.971	[*A*]Hash based coherent slice clustersThe computation of coherent - slice clusters[*R*]grows[*A*]prohibitively expensive[*A*]even for mid-sized programs	context()	negated: False ,passive: True
0.877	[*A*]Hash[*R*]based[*A*]coherent slice clustersThe computation of coherent - slice clusters	context()	negated: False ,passive: False
[LINE#100]The computation is cubic in time and quadratic in space.
0.925	[*A*]The computation[*R*]is[*A*]cubic[*A*]in space	context()	negated: False ,passive: True
0.925	[*A*]The computation[*R*]is[*A*]cubic[*A*]in time	context()	negated: False ,passive: True
[LINE#101]An approximation is employed to reduce the computation time and memory requirement.
0.903	[*A*]An approximation[*R*]is employed[*A*]to reduce the memory requirement	context()	negated: False ,passive: True
0.903	[*A*]An approximation[*R*]is employed[*A*]to reduce the computation time	context()	negated: False ,passive: True
[LINE#102]This approximation replaces comparison of slices with comparison of hash values, where hash values are used to summarize slice content.
0.887	[*A*]hash values[*R*]to summarize[*A*]slice content	context()	negated: False ,passive: False
0.903	[*A*]hash values[*R*]are used[*A*]to summarize slice content	context()	negated: False ,passive: True
0.903	[*A*]This approximation[*R*]replaces[*A*]comparison of slices with comparison of hash values	context()	negated: False ,passive: True
[LINE#103]The result is the following approximation to coherent-slice clusters in which H denotes a hash function.
0.886	[*A*]H[*R*]denotes[*A*]a hash function[*A*]coherent-slice clusters	context()	negated: False ,passive: False
0.925	[*A*]The result[*R*]is[*A*]the following approximation to coherent-slice clusters	context()	negated: False ,passive: True
[LINE#104] Definition 2.6Hash-based coherent-slice MDS and cluster (Islam et al., 2010b)A hash-based coherent-slice MDS is a set of SDG vertices, V, such thatx, yV:.
0.983	[*A*]A hash - based coherent - slice MDS[*R*]is[*A*]a set of SDG vertices , V , such thatx , yV	context()	negated: False ,passive: True
[LINE#105]H(BSlice(x))=H(BSlice(y))H(FSlice(x))=H(FSlice(y))A hash-based coherent-slice cluster is a hash-based coherent-slice MDS contained within no other hash-based coherent-slice MDS.A description of the hash function H along with the evaluation of its precision is presented in Section 3.3.
0.940	[*A*]FSlice(x))=H[*R*]is presented[*A*]in Section 3.3	context()	negated: False ,passive: True
0.959	[*A*]a hash-based coherent-slice MDS[*R*]contained[*A*]within no other hash-based coherent-slice MDS.A description of the hash function H along with the evaluation of its precision	context()	negated: False ,passive: True
0.983	[*A*]FSlice(y))A hash-based coherent-slice cluster[*R*]is[*A*]a hash-based coherent-slice MDS	context()	negated: False ,passive: True
[LINE#106]From here on, the paper considers only hash-based coherent-slice clusters unless explicitly stated otherwise.
0.943	[*A*]the paper[*R*]considers[*A*]only hash-based coherent-slice clusters[*A*]From here on	context()	negated: False ,passive: False
[LINE#107]Thus, for ease of reading, a hash-based coherent-slice cluster is referred to simply as a coherent cluster. .
0.933	[*A*]a hash-based coherent-slice cluster[*R*]is referred[*A*]simply as a coherent cluster	context()	negated: False ,passive: True
[LINE#108]Graph based cluster visualizationThis section describes two graph-based visualizations for dependence clusters.
0.944	[*A*]Graph based cluster visualizationThis section[*R*]describes[*A*]two graph-based visualizations for dependence clusters	context()	negated: False ,passive: False
[LINE#109]The first visualization, the Monotone Slice-size Graph (MSG) (Binkley and Harman, 2005), plots a landscape of monotonically increasing slice sizes where the y-axis shows the size of each slice, as a percentage of the entire program, and the x-axis shows each slice, in monotonically increasing order of slice size.
0.937	[*A*]the y - axis[*R*]shows[*A*]the size of each slice	context()	negated: False ,passive: False
0.954	[*A*]the Monotone Slice - size Graph[*R*]plots[*A*]a landscape of monotonically increasing slice sizes	context()	negated: False ,passive: False
0.937	[*A*]the x - axis[*R*]shows[*A*]each slice	context()	negated: False ,passive: False
[LINE#110]In an MSG, a dependence cluster appears as a sheer-drop cliff face followed by a plateau.
0.801	[*A*]a sheer-drop cliff face[*R*]followed	context()	negated: False ,passive: False
0.948	[*A*]a dependence cluster[*R*]appears[*A*]In an MSG	context()	negated: False ,passive: True
[LINE#111] The visualization assists with the inherently subjective task of deciding whether a cluster is large (how long is the plateau at the top of the cliff face relative to the surrounding landscape?)and whether it denotes a discontinuity in the dependence profile (how steep is the cliff face relative to the surrounding landscape?).
0.452	[*A*]it[*R*]denotes[*A*]a discontinuity in the dependence profile	context()	negated: False ,passive: False
0.937	[*A*]The visualization[*R*]assists[*A*]with the inherently subjective task of deciding whether a cluster is large ( how long is the plateau at the top of the cliff face relative to the surrounding landscape	context()	negated: False ,passive: False
[LINE#112]An MSG drawn using backward slice sizes is referred to as a backward-slice MSG (B-MSG), and an MSG drawn using forward slice sizes is referred to as a forward-slice MSG (F-MSG).As an example, the open source calculator bc contains 9438 lines of code represented by 7538 SDG vertices.
[LINE#113] The B-MSG for bc, shown in Fig.3a, contains a large plateau that spans almost 70% of the MSG.
0.933	[*A*]a large plateau[*R*]spans[*A*]almost 70% of the MSG	context()	negated: False ,passive: False
0.917	[*A*]The B-MSG for bc[*R*]contains[*A*]a large plateau that spans almost 70% of the MSG	context()	negated: False ,passive: False
0.962	[*A*]The B-MSG for bc[*R*]shown[*A*]in Fig.3a	context()	negated: False ,passive: True
[LINE#114]Under the assumption that same slice size implies the same slice, this indicates a large same-slice cluster.
0.392	[*A*]this[*R*]indicates[*A*]a large same-slice cluster[*A*]Under the assumption that same slice size implies the same slice	context()	negated: False ,passive: False
0.919	[*A*]that same slice size[*R*]implies[*A*]the same slice	context()	negated: False ,passive: False
[LINE#115]However, "zooming" in reveals that the cluster is actually composed of several smaller clusters made from slices of very similar size.
0.911	[*A*]several smaller clusters[*R*]made[*A*]from slices of very similar size	context()	negated: False ,passive: True
0.859	[*A*]the cluster[*R*]is composed[*A*]of several smaller clusters	context()	negated: False ,passive: True
[LINE#116]The tolerance implicit in the visual resolution used to plot the MSG obscures this detail.
0.927	[*A*]The tolerance implicit in the visual resolution[*R*]obscures[*A*]this detail	context()	negated: False ,passive: False
0.925	[*A*]the visual resolution[*R*]used[*A*]to plot the MSG	context()	negated: False ,passive: True
[LINE#117]The second visualization, the Slice/Cluster Size Graph (SCG) (Islam et al., 2010b), alleviates this issue by combining both slice and cluster sizes.
0.897	[*A*]The second visualization[*R*]alleviates[*A*]this issue	context()	negated: False ,passive: False
[LINE#118]It plots three landscapes, one of increasing slice sizes, one of the corresponding same-slice cluster sizes, and the third of the corresponding coherent cluster sizes.
0.522	[*A*]It[*R*]plots[*A*]three landscapes	context()	negated: False ,passive: False
[LINE#119]In the SCG, vertices are ordered along the x-axis using three values, primarily according to their slice size, secondarily according to their same-slice cluster size, and finally according to the coherent cluster size.
0.894	[*A*]axis[*R*]using[*A*]three values	context()	negated: False ,passive: False
0.948	[*A*]vertices[*R*]are ordered[*A*]along the x[*A*]In the SCG	context()	negated: False ,passive: True
[LINE#120]Three values are plotted on the y-axis: slice sizes form the first landscape, and cluster sizes form the second and third.
0.813	[*A*]cluster sizes[*R*]form[*A*]the third	context()	negated: False ,passive: False
0.813	[*A*]cluster sizes[*R*]form[*A*]the second	context()	negated: False ,passive: False
0.882	[*A*]Three values[*R*]are plotted[*A*]on the y - axis	context(slice sizes form)	negated: False ,passive: True
0.908	[*A*]slice sizes[*R*]form[*A*]the first landscape	context()	negated: False ,passive: False
[LINE#121]Thus, SCGs not only show the sizes of the slices and the clusters, they also show the relation between them and thus bring to light interesting links.
0.836	[*A*]SCGs[*R*]show[*A*]the sizes of the clusters	context(they show)	negated: False ,passive: False
0.836	[*A*]SCGs[*R*]show[*A*]the sizes of the slices	context(they show)	negated: False ,passive: False
0.429	[*A*]they[*R*]show[*A*]the relation between them	context()	negated: False ,passive: False
0.793	[*A*]SCGs[*R*]bring to light[*A*]interesting links	context(SCGs bring)	negated: False ,passive: False
0.836	[*A*]SCGs[*R*]bring[*A*]to light interesting links	context()	negated: False ,passive: False
[LINE#122]Two variants of the SCG are considered: the backward-slice SCG (B-SCG) is built from the sizes of backward slices, same-backward-slice clusters, and coherent clusters, while the forward-slice SCG (F-SCG) is built from the sizes of forward slices, same-forward-slice clusters, and coherent clusters.
0.940	[*A*]the backward - slice SCG[*R*]is built[*A*]from the sizes of coherent clusters[*A*]while the forward - slice SCG ( F - SCG ) is built from the sizes of coherent clusters	context()	negated: False ,passive: True
0.940	[*A*]the backward - slice SCG[*R*]is built[*A*]from the sizes of coherent clusters[*A*]while the forward - slice SCG ( F - SCG ) is built from the sizes of same - forward - slice clusters	context()	negated: False ,passive: True
0.940	[*A*]the backward - slice SCG[*R*]is built[*A*]from the sizes of coherent clusters[*A*]while the forward - slice SCG ( F - SCG ) is built from the sizes of forward slices	context()	negated: False ,passive: True
0.940	[*A*]the backward - slice SCG[*R*]is built[*A*]from the sizes of same - backward - slice clusters[*A*]while the forward - slice SCG ( F - SCG ) is built from the sizes of coherent clusters	context()	negated: False ,passive: True
0.940	[*A*]the backward - slice SCG[*R*]is built[*A*]from the sizes of same - backward - slice clusters[*A*]while the forward - slice SCG ( F - SCG ) is built from the sizes of same - forward - slice clusters	context()	negated: False ,passive: True
0.940	[*A*]the backward - slice SCG[*R*]is built[*A*]from the sizes of same - backward - slice clusters[*A*]while the forward - slice SCG ( F - SCG ) is built from the sizes of forward slices	context()	negated: False ,passive: True
0.940	[*A*]the backward - slice SCG[*R*]is built[*A*]from the sizes of backward slices[*A*]while the forward - slice SCG ( F - SCG ) is built from the sizes of coherent clusters	context()	negated: False ,passive: True
0.934	[*A*]the forward - slice SCG[*R*]is built[*A*]from the sizes of coherent clusters	context()	negated: False ,passive: True
0.940	[*A*]the backward - slice SCG[*R*]is built[*A*]from the sizes of backward slices[*A*]while the forward - slice SCG ( F - SCG ) is built from the sizes of same - forward - slice clusters	context()	negated: False ,passive: True
0.958	[*A*]the forward - slice SCG[*R*]is built[*A*]from the sizes of same - forward - slice clusters	context()	negated: False ,passive: True
0.792	[*A*]Two variants of the SCG[*R*]are considered	context(the backward - slice SCG is built)	negated: False ,passive: False
0.940	[*A*]the backward - slice SCG[*R*]is built[*A*]from the sizes of backward slices[*A*]while the forward - slice SCG ( F - SCG ) is built from the sizes of forward slices	context()	negated: False ,passive: True
0.934	[*A*]the forward - slice SCG[*R*]is built[*A*]from the sizes of forward slices	context()	negated: False ,passive: True
[LINE#123]Note that both backward and forward SCGs use the same coherent cluster sizes.
[LINE#124] The B-SCG and F-SCG for the program bc are shown in Fig..
0.961	[*A*]F - SCG for the program bc[*R*]are shown[*A*]in Fig	context()	negated: False ,passive: True
0.905	[*A*]The B - SCG[*R*]are shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#125] In both graphs the slice size landscape is plotted using a solid blackline, the same-slice cluster size landscape using a gray line, andthe coherent cluster size landscape using a (red) broken line.
0.926	[*A*]andthe coherent cluster size landscape[*R*]using[*A*]a (red) broken line	context()	negated: False ,passive: False
0.938	[*A*]the same-slice cluster size landscape[*R*]using[*A*]a gray line	context()	negated: False ,passive: False
0.944	[*A*]the slice size landscape[*R*]is plotted[*A*]In both graphs	context()	negated: False ,passive: True
[LINE#126]The B-SCG (Fig. 4a) shows that bc contains two large same-backward-slice clusters consisting of around 55% and 15% of the program.
0.883	[*A*]bc[*R*]contains[*A*]two large same - backward - slice clusters consisting of 15 % of the program	context(The B - SCG shows)	negated: False ,passive: False
0.943	[*A*]two large same - backward - slice clusters[*R*]consisting[*A*]of 15 % of the program	context()	negated: False ,passive: True
0.883	[*A*]bc[*R*]contains[*A*]two large same - backward - slice clusters consisting of around 55 %	context(The B - SCG shows)	negated: False ,passive: False
0.833	[*A*]The B - SCG[*R*]shows[*A*]that bc contains two large same - backward - slice clusters	context()	negated: False ,passive: False
0.943	[*A*]two large same - backward - slice clusters[*R*]consisting[*A*]of around 55 %	context()	negated: False ,passive: True
[LINE#127]Surprisingly, the larger same-backward-slice cluster is composed of smaller slices than the smaller same-backward-slice cluster; thus, the smaller cluster has a bigger impact (slice size) than the larger cluster.
0.954	[*A*]the larger same-backward-slice cluster[*R*]is composed[*A*]of smaller slices than the smaller same-backward-slice cluster	context(the smaller cluster has)	negated: False ,passive: True
0.944	[*A*]the smaller cluster[*R*]has[*A*]a bigger impact (slice size) than the larger cluster	context()	negated: False ,passive: False
[LINE#128]In addition, the presence of three coherent clusters spanning approximately 15%, 20% and 30% of the program's statements can also be seen.
0.911	[*A*]three coherent clusters[*R*]spanning[*A*]approximately 30 % of the program 's statements	context()	negated: False ,passive: False
0.911	[*A*]three coherent clusters[*R*]spanning[*A*]approximately 20 %	context()	negated: False ,passive: False
0.690	[*A*]the presence of three coherent clusters[*R*]can be seen	context()	negated: False ,passive: False
0.911	[*A*]three coherent clusters[*R*]spanning[*A*]approximately 15 %	context()	negated: False ,passive: False
[LINE#129]3c shows two box plots depicting the distribution of (backward and forward) slice sizes for bc.
0.943	[*A*]two box plots[*R*]depicting[*A*]the distribution of ( forward ) slice sizes for bc	context()	negated: False ,passive: False
0.567	[*A*]3c[*R*]shows[*A*]two box plots depicting the distribution of ( forward ) slice sizes for bc	context()	negated: False ,passive: False
0.943	[*A*]two box plots[*R*]depicting[*A*]the distribution of ( backward ) slice sizes for bc	context()	negated: False ,passive: False
0.567	[*A*]3c[*R*]shows[*A*]two box plots depicting the distribution of ( backward ) slice sizes for bc	context()	negated: False ,passive: False
[LINE#130]The average size of the slices is also displayed in the box plot using a solid square box.
0.899	[*A*]The average size of the slices[*R*]is displayed[*A*]in the box plot	context()	negated: False ,passive: True
[LINE#131]Comparing the box plot information to the information provided by the MSGs, we can see that all the information available from the box plots can be derived from the MSGs itself (except for the average).
0.939	[*A*]all the information available from the box plots[*R*]can be derived[*A*]from the MSGs	context(we can see)	negated: False ,passive: True
0.195	[*A*]we[*R*]can see[*A*]that all the information available from the box plots can be derived from the MSGs itself (except for the average	context()	negated: False ,passive: False
0.918	[*A*]the information[*R*]provided[*A*]by the MSGs	context()	negated: False ,passive: True
[LINE#132]However, MSGs show a landscape (slice profile) which cannot be obtained from the box plots.
0.887	[*A*]a landscape[*R*]can not be obtained[*A*]from the box plots	context()	negated: True ,passive: True
0.903	[*A*]MSGs[*R*]show[*A*]a landscape (slice profile) which cannot be obtained from the box plots	context()	negated: False ,passive: False
[LINE#133] Similarly, the box plots in Fig.4c show the size distributions of the various clusters (i.e. a vertex is in a cluster of size x) in addition to the slice size distributions.
0.913	[*A*]i.e. a vertex[*R*]is[*A*]in a cluster of size	context(the box plots in Fig.4c show)	negated: False ,passive: True
0.945	[*A*]the box plots in Fig.4c[*R*]show[*A*]the size distributions of the various clusters	context()	negated: False ,passive: False
[LINE#134] Although the information from these box plots can not be derived from the SCGs shown in Fig.directly, the profiles (landscapes) give a better intuition about the clusters, the number of major clusters and their sizes.
0.887	[*A*]the profiles[*R*]give[*A*]a better intuition about the clusters	context()	negated: False ,passive: False
0.884	[*A*]the SCGs[*R*]shown[*A*]in Fig.directly	context()	negated: False ,passive: True
0.932	[*A*]the information from these box plots[*R*]can not be derived[*A*]from the SCGs	context()	negated: True ,passive: True
[LINE#135]For our empirical study we use the size of individual clusters and the cluster profile to find mappings between the clusters and program components.
0.388	[*A*]we[*R*]use the size of the cluster profile to find[*A*]mappings between the clusters and program components	context(we use)	negated: False ,passive: False
0.388	[*A*]we[*R*]use[*A*]the size of the cluster profile[*A*]to find mappings between the clusters and program components	context()	negated: False ,passive: False
0.388	[*A*]we[*R*]use the size of individual clusters to find[*A*]mappings between the clusters and program components	context(we use)	negated: False ,passive: False
0.388	[*A*]we[*R*]use[*A*]the size of individual clusters[*A*]to find mappings between the clusters and program components	context()	negated: False ,passive: False
[LINE#136]Therefore, we drop box plots in favor of SCGs to show the cluster profile and provide additional statistics in tabular format where required.
0.293	[*A*]we[*R*]drop box plots to provide[*A*]additional statistics in tabular format where required	context(we drop)	negated: False ,passive: False
0.457	[*A*]we[*R*]drop[*A*]box plots[*A*]to provide additional statistics in tabular format	context()	negated: False ,passive: False
0.756	[*A*]additional statistics in tabular format[*R*]required	context()	negated: False ,passive: False
0.293	[*A*]we[*R*]drop box plots to show[*A*]the cluster profile	context(we drop)	negated: False ,passive: False
0.457	[*A*]we[*R*]drop[*A*]box plots[*A*]to show the cluster profile	context()	negated: False ,passive: False
[LINE#137]Empirical evaluationThis section presents the empirical evaluation into the existence and impact of coherent dependence clusters.
0.911	[*A*]Empirical evaluationThis section[*R*]presents[*A*]the empirical evaluation[*A*]into the impact of coherent dependence clusters	context()	negated: False ,passive: False
0.911	[*A*]Empirical evaluationThis section[*R*]presents[*A*]the empirical evaluation[*A*]into the existence	context()	negated: False ,passive: False
[LINE#138]The section first discusses the experimental setup and the subject programs included in the study.
0.911	[*A*]the subject programs[*R*]included[*A*]in the study	context()	negated: False ,passive: True
0.934	[*A*]The section[*R*]discusses[*A*]the subject programs included in the study[*A*]first	context()	negated: False ,passive: False
0.934	[*A*]The section[*R*]discusses[*A*]the experimental setup[*A*]first	context()	negated: False ,passive: False
[LINE#139]It then presents two validation studies, the first considers the effect of pointer analysis precision and the second considers the validity of hashing in efficient cluster identification.
0.903	[*A*]the second[*R*]considers[*A*]the validity of hashing in efficient cluster identification	context()	negated: False ,passive: False
0.666	[*A*]It[*R*]presents[*A*]two validation studies the second considers the validity of hashing in efficient cluster identification[*A*]then	context()	negated: False ,passive: False
0.568	[*A*]the first[*R*]considers[*A*]the effect of pointer analysis precision	context()	negated: False ,passive: False
0.666	[*A*]It[*R*]presents[*A*]two validation studies , the first considers the effect of pointer analysis precision[*A*]then	context()	negated: False ,passive: False
[LINE#140]The section then quantitatively considers the existence of coherent dependence clusters and identifies patterns of clustering within the programs.
0.903	[*A*]The section[*R*]identifies[*A*]patterns of clustering	context()	negated: False ,passive: False
0.934	[*A*]The section[*R*]quantitatively considers[*A*]the existence of coherent dependence clusters[*A*]then	context()	negated: False ,passive: False
[LINE#141] This is followed by a series of four case studies, where qualitative analysis, aided by the decluvi cluster visualization tool(Islam et al., 2010a), highlight how knowledge of clusters can aid a software engineer.
0.888	[*A*]knowledge of clusters[*R*]can aid[*A*]a software engineer	context(qualitative analysis , aided by the decluvi cluster visualization tool ( Islam et al highlight)	negated: False ,passive: False
0.963	[*A*]qualitative analysis, aided by the decluvi cluster visualization tool(Islam et al[*R*]highlight[*A*]how knowledge of clusters can aid a software engineer	context()	negated: False ,passive: False
0.887	[*A*]qualitative analysis[*R*]aided[*A*]by the decluvi cluster visualization tool	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]is followed[*A*]by a series of four case studies	context()	negated: False ,passive: True
[LINE#142]The section then presents studies on inter-cluster dependence, and the relationship of program faults and system evolution to coherent clusters.
0.934	[*A*]The section[*R*]presents[*A*]studies on inter-cluster dependence[*A*]then	context()	negated: False ,passive: False
[LINE#143]Finally, threats to validity are considered.
0.843	[*A*]threats to validity[*R*]are considered[*A*]Finally	context()	negated: False ,passive: True
[LINE#144] To formalize the goals of this section, the empirical evaluation addresses the following research questions:RQ1What is the effect of pointer analysis precision on coherent clusters?RQ2How precise is hashing as a proxy for comparing slices?RQ3How large are the coherent clusters that exist in production source code and which patterns of clustering can be identified?RQ4Which structures within a program can coherent cluster analysis reveal?RQ5What are the implications of inter-cluster dependence between coherent clusters?RQ6Howdo program faults relate to coherent clusters?RQ7How stable are coherent clusters during system evolution?The first two research questions provide empirical verification for the results subsequently presented.
0.999	[*A*]coherent cluster analysis[*R*]can reveal[*A*]rq4which structures within a program	context()	negated: False ,passive: False
0.737	[*A*]the empirical evaluation addresses[*R*]can be identified	context()	negated: False ,passive: False
0.927	[*A*]RQ7How stable[*R*]are[*A*]coherent clusters during system evolution	context()	negated: False ,passive: True
0.910	[*A*]RQ7How stable[*R*]are[*A*]coherent clusters during system evolution	context(RQ6Howdo program faults relate)	negated: False ,passive: True
0.951	[*A*]RQ2How precise[*R*]is hashing[*A*]as a proxy for comparing slices ? RQ4Which structures within a program	context(RQ5What are RQ6Howdo program faults relate)	negated: False ,passive: False
0.902	[*A*]RQ5What[*R*]are[*A*]the implications of inter-cluster dependence between coherent clusters	context(RQ6Howdo program faults relate)	negated: False ,passive: True
0.918	[*A*]RQ6Howdo program faults[*R*]relate[*A*]to coherent clusters	context()	negated: False ,passive: True
0.920	[*A*]the following research[*R*]is[*A*]the effect of pointer analysis precision on coherent clusters	context()	negated: False ,passive: True
0.926	[*A*]The first two research questions[*R*]provide[*A*]empirical verification	context()	negated: False ,passive: False
0.832	[*A*]the results[*R*]presented[*A*]subsequently	context()	negated: False ,passive: True
[LINE#145]RQ1 establishes the impact of pointer analysis on the clustering, whereas RQ2 establishes that the hash function used to approximate a slice is sufficiently precise.
0.862	[*A*]the hash function used to approximate a slice[*R*]is[*A*]sufficiently precise	context(RQ2 establishes)	negated: False ,passive: True
0.735	[*A*]RQ2[*R*]establishes[*A*]that the hash function used to approximate a slice is sufficiently precise	context()	negated: False ,passive: False
0.911	[*A*]the hash function[*R*]used[*A*]to approximate a slice	context()	negated: False ,passive: True
0.806	[*A*]RQ1[*R*]establishes[*A*]the impact of pointer analysis on the clustering[*A*]whereas RQ2 establishes that the hash function used to approximate a slice is sufficiently precise	context()	negated: False ,passive: False
[LINE#146]If the static slices produced by the slicer are overly conservative or if the slice approximation is not sufficiently precise, then the results presented will not be reliable.
0.866	[*A*]the results presented[*R*]will not be[*A*]reliable[*A*]then	context()	negated: True ,passive: True
0.732	[*A*]the results[*R*]presented	context()	negated: False ,passive: False
0.783	[*A*]the slice approximation[*R*]is not[*A*]sufficiently precise	context()	negated: True ,passive: True
0.842	[*A*]the static slices produced by the slicer[*R*]are[*A*]overly conservative	context()	negated: False ,passive: True
0.911	[*A*]the static slices[*R*]produced[*A*]by the slicer	context()	negated: False ,passive: True
[LINE#147]Fortunately, the results provide confidence that the slice precision and hashing accuracy are sufficient.
0.783	[*A*]the hashing accuracy[*R*]are[*A*]sufficient	context()	negated: False ,passive: True
0.773	[*A*]the results[*R*]provide[*A*]confidence that the hashing accuracy are sufficient	context()	negated: False ,passive: False
0.799	[*A*]the slice precision accuracy[*R*]are[*A*]sufficient	context()	negated: False ,passive: True
0.773	[*A*]the results[*R*]provide[*A*]confidence that the slice precision accuracy are sufficient	context()	negated: False ,passive: False
[LINE#148]Whereas RQ1 and RQ2 focus on the veracity of our approach, RQ3 investigates the validity of the study; if large coherent clusters are not prevalent, then they would not be worthy of further study.
0.762	[*A*]RQ2[*R*]focus[*A*]on the veracity of our approach	context()	negated: False ,passive: False
0.820	[*A*]RQ3[*R*]investigates[*A*]the validity of the study	context(they would not be)	negated: False ,passive: False
0.552	[*A*]they[*R*]would not be[*A*]worthy of further study	context()	negated: True ,passive: True
0.783	[*A*]large coherent clusters[*R*]are not[*A*]prevalent	context()	negated: True ,passive: True
0.762	[*A*]RQ1[*R*]focus[*A*]on the veracity of our approach	context()	negated: False ,passive: False
[LINE#149]We place very specific and demanding constraints on a set of vertices for it to be deemed a coherent cluster.
0.350	[*A*]We[*R*]place demanding[*A*]constraints[*A*]on a set of vertices	context()	negated: False ,passive: False
0.225	[*A*]We[*R*]place[*A*]very specific	context()	negated: False ,passive: False
[LINE#150]If such clusters are not common then their study would be merely an academic exercise.
0.638	[*A*]their study[*R*]would be[*A*]merely an academic exercise	context()	negated: False ,passive: True
0.767	[*A*]such clusters[*R*]are not[*A*]common	context()	negated: True ,passive: True
[LINE#151]Conversely, if the clustering is similar for every program then it is unlikely that cluster identification will reveal interesting information about programs.
0.925	[*A*]the clustering[*R*]is[*A*]similar for every program	context()	negated: False ,passive: True
[LINE#152]Our findings reveal that, despite the tight constraints inherent in the definition of a coherent dependence cluster, they are, indeed, very common.
0.274	[*A*]they[*R*]are[*A*]indeed[*A*]very common	context(Our findings reveal)	negated: False ,passive: True
0.310	[*A*]Our findings[*R*]reveal[*A*]that, despite the tight constraints inherent in the definition of a coherent dependence cluster, they are, indeed, very common	context()	negated: False ,passive: False
[LINE#153]Also, the cluster profiles for programs are sufficiently different and exhibit interesting patterns.
0.814	[*A*]the cluster profiles for programs[*R*]are[*A*]sufficiently different	context()	negated: False ,passive: True
[LINE#154]These results motivate the remaining research questions.
0.903	[*A*]These results[*R*]motivate[*A*]the remaining research questions	context()	negated: False ,passive: False
[LINE#155]Having demonstrated that our technique is suitable for finding coherent clusters and that such clusters are sufficiently widespread to be worthy of study, we investigate specific coherent clusters in detail.
0.452	[*A*]we[*R*]investigate[*A*]specific coherent clusters in detail	context()	negated: False ,passive: False
0.887	[*A*]such clusters[*R*]to be[*A*]worthy of study	context()	negated: False ,passive: True
0.903	[*A*]such clusters[*R*]are[*A*]sufficiently widespread to be worthy of study	context()	negated: False ,passive: True
[LINE#156]RQ4 studies the underlying logical structure of programs revealed by these clusters.
0.894	[*A*]programs[*R*]revealed[*A*]by these clusters	context()	negated: False ,passive: True
0.813	[*A*]RQ4[*R*]studies[*A*]the underlying logical structure of programs	context()	negated: False ,passive: False
[LINE#157]RQ5 looks explicitly at inter-cluster dependency and considers areas of software engineering where it may be of interest.
0.452	[*A*]it[*R*]may be[*A*]of interest	context()	negated: False ,passive: True
0.837	[*A*]RQ5[*R*]considers[*A*]areas of software engineering where it may be of interest	context()	negated: False ,passive: False
0.855	[*A*]RQ5[*R*]looks[*A*]explicitly at inter-cluster dependency	context()	negated: False ,passive: False
[LINE#158]RQ6 presents a study of how program faults relate to coherent clusters, and, finally, RQ7 studies the effect of system evolution on clustering..
0.913	[*A*]RQ7[*R*]studies[*A*]the effect of system evolution on clustering[*A*]finally	context()	negated: False ,passive: False
0.903	[*A*]program faults[*R*]relate[*A*]to coherent clusters	context()	negated: False ,passive: True
0.904	[*A*]RQ6[*R*]presents[*A*]a study of how program faults relate to coherent clusters	context()	negated: False ,passive: False
[LINE#159] Experimental subjects and setupThe slices along with the mapping between the SDG vertices and the actual source code are extracted from the mature and widely used slicing tool CodeSurfer (Anderson and Teitelbaum, 2001).
0.899	[*A*]setupThe[*R*]slices along[*A*]are extracted from the widely used slicing tool CodeSurfer	context()	negated: False ,passive: False
0.899	[*A*]setupThe[*R*]slices along[*A*]are extracted from the mature slicing tool CodeSurfer	context()	negated: False ,passive: False
0.918	[*A*]Experimental subjects[*R*]are extracted[*A*]from the widely used slicing tool CodeSurfer	context()	negated: False ,passive: True
0.918	[*A*]Experimental subjects[*R*]are extracted[*A*]from the mature slicing tool CodeSurfer	context()	negated: False ,passive: True
0.947	[*A*]Experimental subjects[*R*]are extracted[*A*]from the mature slicing tool CodeSurfer ( Anderson , 2001	context()	negated: False ,passive: True
[LINE#160]The cluster visualizations were generated by decluvi (Islam et al., 2010a) using data extracted from CodeSurfer.
0.911	[*A*]data[*R*]extracted[*A*]from CodeSurfer	context()	negated: False ,passive: True
0.925	[*A*]The cluster visualizations[*R*]were generated[*A*]by decluvi (Islam et al	context()	negated: False ,passive: True
[LINE#161]The data is generated from slices taken with respect to source-code representing SDG vertices.
0.925	[*A*]source-code[*R*]representing[*A*]SDG vertices	context()	negated: False ,passive: False
0.713	[*A*]slices[*R*]taken	context()	negated: False ,passive: False
0.903	[*A*]The data[*R*]is generated[*A*]from slices	context()	negated: False ,passive: True
[LINE#162]This excludes pseudo vertices introduced into the SDG, e.g., to represent global variables which are modeled as additional pseudo parameters by CodeSurfer.
0.905	[*A*]global variables[*R*]are modeled[*A*]as additional pseudo parameters[*A*]by CodeSurfer	context()	negated: False ,passive: True
0.918	[*A*]pseudo vertices[*R*]introduced[*A*]into the SDG, e.g.	context()	negated: False ,passive: True
0.425	[*A*]This[*R*]excludes[*A*]pseudo vertices introduced into the SDG, e.g.,	context()	negated: False ,passive: False
[LINE#163]Cluster sizes are also measured in terms of source-code representing SDG vertices, which is more consistent than using lines of code as it is not influenced by blank lines, comments, statements spanning multiple lines, multiple statements on one line, or compound statements.
0.452	[*A*]it[*R*]is not influenced[*A*]by blank lines, comments, statements	context()	negated: True ,passive: True
0.934	[*A*]SDG vertices[*R*]is[*A*]more consistent than using lines of code	context()	negated: False ,passive: True
0.925	[*A*]source-code[*R*]representing[*A*]SDG vertices	context()	negated: False ,passive: False
0.894	[*A*]statements[*R*]spanning[*A*]multiple lines	context()	negated: False ,passive: False
0.859	[*A*]Cluster sizes[*R*]are measured[*A*]in terms of source-code	context()	negated: False ,passive: True
[LINE#164]The decluvi system along with scheme scripts for data acquisition and pre-compiled datasets for several open-source programs can be downloaded from http://www.cs.ucl.ac.uk/staff/s.islam/decluvi.html.
0.927	[*A*]The decluvi system along with scheme scripts for pre-compiled datasets for several open - source programs[*R*]can be downloaded[*A*]from http://www.cs.ucl.ac.uk/staff/s.islam/decluvi.html.	context()	negated: False ,passive: True
0.877	[*A*]The decluvi system along with scheme scripts for data acquisition[*R*]can be downloaded[*A*]from http://www.cs.ucl.ac.uk/staff/s.islam/decluvi.html.	context()	negated: False ,passive: True
[LINE#165]The study considers the 30 C programs shown in Table 1, which provides a brief description of each program alongside seven measures: number of files containing executable C code, LoC - lines of code (as counted by the Unix utility wc), SLoC - the non-comment non-blank lines of code (as counted by the utility sloccount (Wheeler, 2004)), ELoC - the number of source code lines that CodeSurfer considers to contain executable code, the number of SDG vertices, the number of SDG edges, the number of slices produced, and finally the size (as a percentage of the program's SDG vertex count) of the largest coherent cluster.
0.999	[*A*]The study[*R*]considers[*A*]30 c programs	context()	negated: False ,passive: False
0.914	[*A*]Table 1[*R*]provides[*A*]a brief description of each program alongside seven measures	context()	negated: False ,passive: False
0.999	[*A*]The study alongside seven measures : number of files containing executable C code , LoC - lines of code as a percentage of the program 's SDG vertex count ) of the largest coherent cluster[*R*]considers[*A*]30 c programs	context()	negated: False ,passive: False
0.894	[*A*]files[*R*]containing[*A*]executable C code	context()	negated: False ,passive: False
0.914	[*A*]Table 1[*R*]provides[*A*]a brief description of each program	context()	negated: False ,passive: False
0.947	[*A*]the 30 C programs[*R*]shown[*A*]in Table 1	context()	negated: False ,passive: True
0.918	[*A*]The study[*R*]considers[*A*]the 30 C programs shown in Table 1 ,	context()	negated: False ,passive: False
[LINE#166]All LoC metrics are calculated over source files that CodeSurfer considers to contain executable code and, for example, do not include header files.
0.887	[*A*]source files[*R*]to contain[*A*]executable code	context()	negated: False ,passive: False
0.920	[*A*]CodeSurfer[*R*]considers[*A*]to contain executable code	context()	negated: False ,passive: False
0.933	[*A*]All LoC metrics[*R*]are calculated[*A*]over source files	context()	negated: False ,passive: True
[LINE#167]Columns 10 and 11 provide the runtimes recorded during the empirical study.
0.544	[*A*]11[*R*]provide[*A*]the runtimes recorded during the empirical study	context()	negated: False ,passive: False
0.903	[*A*]the runtimes[*R*]recorded[*A*]during the empirical study	context()	negated: False ,passive: True
0.927	[*A*]Columns 10[*R*]provide[*A*]the runtimes recorded during the empirical study	context()	negated: False ,passive: False
[LINE#168] The runtimes reported are wall clock times captured by the Unix time utility while running the experiments on a 64-bit Linux machine (CentOS 5) with eight Intel(R)3.00GHz processors and 32GB of RAM.
0.935	[*A*]The runtimes[*R*]reported[*A*]are wall clock times captured by the Unix time utility	context()	negated: False ,passive: False
[LINE#169]It should be noted that this machine acts as a group server and is accessed by multiple users.
[LINE#170]There were other CPU intensive processes intermittently running on the machine while these runtimes were collected, and thus the runtimes are only indicative.
0.724	[*A*]the runtimes[*R*]are[*A*]only indicative	context(these runtimes were)	negated: False ,passive: True
0.724	[*A*]these runtimes[*R*]were[*A*]thus	context()	negated: False ,passive: True
0.769	[*A*]other CPU intensive processes[*R*]intermittently running	context()	negated: False ,passive: False
0.732	[*A*]these runtimes[*R*]were collected	context()	negated: False ,passive: False
0.919	[*A*]other CPU intensive processes[*R*]intermittently running[*A*]on the machine[*A*]while these runtimes were collected	context()	negated: False ,passive: False
[LINE#171]Column 10 shows the time needed to build the SDG and CodeSurfer project that is subsequently used for slicing.
0.942	[*A*]Column 10[*R*]shows[*A*]the time needed to build the CodeSurfer project	context()	negated: False ,passive: False
0.829	[*A*]the CodeSurfer project[*R*]is used[*A*]for slicing[*A*]subsequently	context()	negated: False ,passive: True
0.905	[*A*]the time[*R*]to build[*A*]the CodeSurfer project	context()	negated: False ,passive: False
0.687	[*A*]the time[*R*]needed	context(Column 10 shows)	negated: False ,passive: False
0.942	[*A*]Column 10[*R*]shows[*A*]the time needed to build the SDG project	context()	negated: False ,passive: False
0.829	[*A*]the SDG project[*R*]is used[*A*]for slicing[*A*]subsequently	context()	negated: False ,passive: True
0.905	[*A*]the time[*R*]to build[*A*]the SDG project	context()	negated: False ,passive: False
[LINE#172] The build time for the projects were quite small and the longest build time (2m33.456s) was required for gcal with 46,827 SLoC. Column 11shows the time needed for the clustering algorithm to perform the clustering and create all the data dumps for decluvi to create cluster visualizations.
0.894	[*A*]decluvi[*R*]to create[*A*]cluster visualizations	context()	negated: False ,passive: False
0.937	[*A*]the time[*R*]needed create[*A*]all the data dumps for decluvi to create cluster visualizations	context()	negated: False ,passive: False
0.911	[*A*]the clustering algorithm[*R*]to perform[*A*]the clustering	context()	negated: False ,passive: False
0.732	[*A*]the time[*R*]needed	context()	negated: False ,passive: False
0.920	[*A*]Column[*R*]11shows[*A*]the time needed	context()	negated: False ,passive: False
0.905	[*A*]the longest build time[*R*]was required[*A*]for gcal	context()	negated: False ,passive: True
0.829	[*A*]The build time for the projects[*R*]were[*A*]quite small	context()	negated: False ,passive: True
[LINE#173]The process completes in minutes for small programs and can take hours and longer for larger programs.
0.903	[*A*]The process[*R*]completes[*A*]in minutes[*A*]longer for larger programs	context()	negated: False ,passive: True
0.903	[*A*]The process[*R*]can take[*A*]hours[*A*]for larger programs	context()	negated: False ,passive: False
0.903	[*A*]The process[*R*]completes[*A*]in minutes for small programs for larger programs	context()	negated: False ,passive: True
[LINE#174] It should be noted that the runtime includes both the slicing phase which runs in O(ne), where n is the number of SDG vertices and eis the number of edges, and the hashing and clustering algorithm which runs in O(n2).
0.933	[*A*]the clustering algorithm[*R*]runs[*A*]in O	context()	negated: False ,passive: True
0.933	[*A*]the hashing algorithm[*R*]runs[*A*]in O	context()	negated: False ,passive: True
0.938	[*A*]both the slicing phase[*R*]runs[*A*]in O	context()	negated: False ,passive: True
0.938	[*A*]both the slicing phase[*R*]runs[*A*]in O ( ne	context()	negated: False ,passive: True
[LINE#175]Therefore the overall complexity is O(ne).
0.942	[*A*]the overall complexity[*R*]is[*A*]O(ne	context()	negated: False ,passive: True
[LINE#176]The long runtime is mainly due to the current research prototype (which performs slicing, clustering and extraction of the data) using the Scheme interface of CodeSurfer in a pipeline architecture.
0.905	[*A*]the current research prototype[*R*]performs[*A*]extraction of the data	context()	negated: False ,passive: False
0.905	[*A*]the current research prototype[*R*]performs[*A*]clustering of the data	context()	negated: False ,passive: False
0.905	[*A*]the current research prototype[*R*]performs[*A*]slicing of the data	context()	negated: False ,passive: False
0.932	[*A*]The long runtime[*R*]is[*A*]mainly[*A*]due to the current research prototype	context()	negated: False ,passive: True
[LINE#177]In the future we plan to upgrade the tooling with optimizations for fast and massive slicing (Binkley et al., 2007) and to merge the clustering phase into the slicing to reduce the runtime significantly.
0.388	[*A*]we[*R*]plan to upgrade[*A*]the tooling with optimizations for massive slicing	context(we plan)	negated: False ,passive: False
0.744	[*A*]we[*R*]plan[*A*]to upgrade the tooling with optimizations for massive slicing ( Binkley et al , 2007 ) and to merge the clustering phase into the slicing[*A*]In the future	context()	negated: False ,passive: False
0.388	[*A*]we[*R*]plan to upgrade[*A*]the tooling with optimizations for fast slicing	context(we plan)	negated: False ,passive: False
0.744	[*A*]we[*R*]plan[*A*]to upgrade the tooling with optimizations for fast slicing ( Binkley et al , 2007 ) and to merge the clustering phase into the slicing[*A*]In the future	context()	negated: False ,passive: False
0.293	[*A*]we[*R*]plan to merge the clustering phase to reduce[*A*]the runtime[*A*]significantly	context(we plan to merge)	negated: False ,passive: False
0.293	[*A*]we[*R*]plan to merge[*A*]the clustering phase[*A*]into the slicing[*A*]to reduce the runtime significantly	context(we plan)	negated: False ,passive: False
0.388	[*A*]we[*R*]plan to upgrade[*A*]the tooling	context(we plan)	negated: False ,passive: False
0.600	[*A*]we[*R*]plan[*A*]to upgrade the tooling[*A*]In the future	context()	negated: False ,passive: False
[LINE#178]Although the clustering and building the visualization data can take a long time for large projects, it is still useful because the clustering only needs to be done once (for example during a nightly build) and can then be visualised and reused as many times as needed.
0.919	[*A*]building the visualization data[*R*]can take[*A*]a long time for large projects	context()	negated: False ,passive: False
0.887	[*A*]the clustering[*R*]to be reused[*A*]as many times	context()	negated: False ,passive: True
0.887	[*A*]the clustering[*R*]needs[*A*]to be reused as many times	context()	negated: False ,passive: False
0.637	[*A*]it[*R*]is[*A*]still[*A*]useful[*A*]because the clustering only needs to be reused as many times	context()	negated: False ,passive: True
0.522	[*A*]it[*R*]is[*A*]still[*A*]useful[*A*]because the clustering only needs to be done once	context()	negated: False ,passive: True
0.735	[*A*]the clustering[*R*]to be done[*A*]once	context()	negated: False ,passive: True
0.735	[*A*]the clustering[*R*]needs[*A*]to be done once	context()	negated: False ,passive: False
0.637	[*A*]it[*R*]is[*A*]still[*A*]useful[*A*]because the clustering only needs to be done once ( for example during a nightly build	context()	negated: False ,passive: True
0.903	[*A*]the clustering[*R*]can take[*A*]a long time for large projects	context()	negated: False ,passive: False
[LINE#179]During further study of the visualization and the clustering we have also found that small changes to the system does not show a change in the clustering, therefore once the clustering is created it still remains viable through small code changes as the clustering is found to represent the core program architecture (Section 3.9).
0.905	[*A*]small changes to the system[*R*]does not show[*A*]a change in the clustering	context(we have found)	negated: True ,passive: False
0.116	[*A*]we[*R*]have found[*A*]that small changes to the system does not show a change in the clustering , therefore once the clustering is created it	context()	negated: False ,passive: False
0.887	[*A*]the clustering[*R*]to represent[*A*]the core program architecture	context()	negated: False ,passive: False
0.732	[*A*]the clustering[*R*]is found	context()	negated: False ,passive: False
0.666	[*A*]it[*R*]remains[*A*]viable[*A*]as the clustering is found to represent the core program architecture[*A*]During further study of the visualization[*A*]once the clustering is created[*A*]still	context()	negated: False ,passive: True
0.732	[*A*]the clustering[*R*]is created	context()	negated: False ,passive: False
[LINE#180]Furthermore, the number of SDG vertices and edges are quite large, in fact even for very small programs the number of SDG vertices is in the thousands with edge counts in the tens of thousands.
0.761	[*A*]the number of edges[*R*]are[*A*]quite large	context(the number of SDG vertices is)	negated: False ,passive: True
0.826	[*A*]the number of SDG vertices[*R*]are[*A*]quite large	context(the number of SDG vertices is)	negated: False ,passive: True
0.966	[*A*]the number of SDG vertices[*R*]is[*A*]in the thousands with edge counts in the tens of thousands	context()	negated: False ,passive: True
[LINE#181]Moreover, the analysis produces an is-in-the-slice-of relation and graph with even more edges.
0.903	[*A*]the analysis[*R*]produces[*A*]graph[*A*]with even more edges	context()	negated: False ,passive: False
0.903	[*A*]the analysis[*R*]produces[*A*]an is-in-the-slice-of relation with even more edges	context()	negated: False ,passive: False
[LINE#182]We have tried several clustering and visualization tools to cluster the is-in-the-slice-of graph for comparison, but most of the tools (such as Gephi Bastian et al., 2009) failed due to the large dataset.
0.569	[*A*]We[*R*]have tried[*A*]several visualization tools to cluster the is-in-the-slice-of graph for comparison	context()	negated: False ,passive: False
0.569	[*A*]We[*R*]have tried[*A*]several clustering tools to cluster the is-in-the-slice-of graph for comparison	context()	negated: False ,passive: False
0.971	[*A*]most of the tools ( such as Gephi Bastian et al . , 2009[*R*]failed[*A*]due to the large dataset	context()	negated: False ,passive: True
[LINE#183]Other tools such as CCVisu (Beyer, 2008) which were able to handle the large data set simply produced a blob as a visualization which was not at all useful.
0.914	[*A*]Other tools such as CCVisu[*R*]produced a blob to handle[*A*]the large data set	context(Other tools such as CCVisu produced)	negated: False ,passive: False
0.917	[*A*]Other tools such as CCVisu[*R*]produced[*A*]a blob[*A*]as a visualization	context()	negated: False ,passive: False
0.735	[*A*]a visualization[*R*]was not[*A*]at all useful	context()	negated: True ,passive: True
0.800	[*A*]the large data[*R*]set	context()	negated: False ,passive: False
0.934	[*A*]Other tools such as CCVisu[*R*]were[*A*]able to handle the large data	context()	negated: False ,passive: True
[LINE#184]The underlying problem is that the is-in-the-slice-of graph is dense and no traditional clustering can handle such dense graphs. .
0.891	[*A*]no traditional clustering[*R*]can handle[*A*]such dense graphs	context(The underlying problem is)	negated: False ,passive: False
0.916	[*A*]The underlying problem[*R*]is[*A*]no traditional clustering can handle such dense graphs	context()	negated: False ,passive: True
0.793	[*A*]the is-in-the-slice-of graph[*R*]is[*A*]dense	context(The underlying problem is)	negated: False ,passive: True
0.799	[*A*]The underlying problem[*R*]is[*A*]that the is-in-the-slice-of graph is dense	context()	negated: False ,passive: True
[LINE#185]Impact of pointer analysis precisionRecall that the definition of a coherent dependence cluster is based on an underlying depends-on relation, which is approximated using program slicing.
0.677	[*A*]relation[*R*]is approximated	context()	negated: False ,passive: False
0.934	[*A*]Impact of pointer analysis precisionRecall[*R*]depends[*A*]-on relation	context()	negated: False ,passive: False
0.938	[*A*]the definition of a coherent dependence cluster[*R*]is based[*A*]on an underlying	context()	negated: False ,passive: True
[LINE#186] Pointer analysis plays a key role in the precision of slicing andthe interplay between pointer analysis and downstream dependence analysis precision is complex (Shapiro and Horwitz, 1997).
0.904	[*A*]andthe interplay between pointer analysis and downstream dependence analysis precision[*R*]is[*A*]complex	context()	negated: False ,passive: True
0.937	[*A*]Pointer analysis[*R*]plays[*A*]a key role in the precision of slicing andthe interplay between pointer analysis and downstream dependence analysis precision is complex	context()	negated: False ,passive: False
0.841	[*A*]downstream dependence analysis precision[*R*]is[*A*]complex	context()	negated: False ,passive: True
0.947	[*A*]Pointer analysis[*R*]plays[*A*]a key role in the precision of slicing andthe interplay between pointer analysis and downstream dependence analysis precision is complex ( Shapiro	context()	negated: False ,passive: False
[LINE#187]To understand how pointer analysis precision impacts the clustering of the programs we study the effect in this section.
0.452	[*A*]we[*R*]study[*A*]the effect[*A*]in this section	context()	negated: False ,passive: False
[LINE#188]Usually, one would choose the pointer analysis with the highest precision but there may be situations where this is not possible and one has to revert to lower precision analysis.
0.877	[*A*]situations[*R*]to revert[*A*]to lower precision analysis	context()	negated: False ,passive: True
0.523	[*A*]this[*R*]is not[*A*]possible[*A*]situations	context()	negated: True ,passive: True
0.741	[*A*]one[*R*]would choose[*A*]the pointer analysis with the highest precision[*A*]Usually	context()	negated: False ,passive: False
[LINE#189]This section presents a study on the effect of various levels of pointer analysis precision on the size of slices and subsequently on coherent clusters.
0.903	[*A*]This section[*R*]presents[*A*]subsequently[*A*]on coherent clusters	context()	negated: False ,passive: False
0.937	[*A*]This section[*R*]presents[*A*]a study on the effect of various levels of pointer analysis precision on the size of slices	context()	negated: False ,passive: False
[LINE#190] It addresses research question RQ1:.
0.452	[*A*]It[*R*]addresses[*A*]research question RQ1	context()	negated: False ,passive: False
[LINE#191]What is the effect of pointer analysis precision on coherent clusters?CodeSurfer provides three levels of pointer analysis precision (Low, Medium, and High) that provide increasingly precise points-to information at the expense of additional memory and analysis time.
0.890	[*A*]CodeSurfer[*R*]provides[*A*]three levels of pointer analysis precision ( High ) that provide increasingly precise points	context()	negated: False ,passive: False
0.921	[*A*]three levels of pointer analysis precision[*R*]provide[*A*]increasingly precise points	context()	negated: False ,passive: False
0.890	[*A*]CodeSurfer[*R*]provides[*A*]three levels of pointer analysis precision ( Medium that provide increasingly precise points	context()	negated: False ,passive: False
0.342	[*A*]Low[*R*]provide[*A*]increasingly precise points[*A*]to information at the expense of analysis time	context()	negated: False ,passive: False
0.342	[*A*]Low[*R*]provide[*A*]increasingly precise points[*A*]to information at the expense of additional memory time	context()	negated: False ,passive: False
0.920	[*A*]CodeSurfer[*R*]provides[*A*]three levels of pointer analysis precision ( Low	context()	negated: False ,passive: False
[LINE#192]The Low setting uses a minimal pointer analysis that assumes every pointer may point to every object that has its address taken (variable or function).
0.285	[*A*]its address[*R*]taken	context(every object has)	negated: False ,passive: False
0.814	[*A*]every object[*R*]has[*A*]its address taken (variable or function	context()	negated: False ,passive: False
0.878	[*A*]every pointer[*R*]may point[*A*]to every object	context(a minimal pointer analysis assumes)	negated: False ,passive: False
0.880	[*A*]a minimal pointer analysis[*R*]assumes[*A*]every pointer may point to every object	context()	negated: False ,passive: False
0.857	[*A*]The Low setting[*R*]uses[*A*]a minimal pointer analysis that assumes every pointer may point to every object	context()	negated: False ,passive: False
[LINE#193]At the Medium and High settings, CodeSurfer performs extensive pointer analysis using the algorithm proposed by Fahndrich et al.
0.914	[*A*]CodeSurfer[*R*]performs extensive pointer analysis using[*A*]the algorithm proposed by Fahndrich et al	context(CodeSurfer performs)	negated: False ,passive: False
0.940	[*A*]CodeSurfer[*R*]performs[*A*]extensive pointer analysis[*A*]At High settings	context()	negated: False ,passive: False
0.914	[*A*]CodeSurfer[*R*]performs extensive pointer analysis using[*A*]the algorithm proposed by Fahndrich et al	context(CodeSurfer performs)	negated: False ,passive: False
0.950	[*A*]CodeSurfer[*R*]performs[*A*]extensive pointer analysis[*A*]At the Medium	context()	negated: False ,passive: False
0.918	[*A*]the algorithm[*R*]proposed[*A*]by Fahndrich et al	context()	negated: False ,passive: True
[LINE#194] (1998), which implements a variant of Andersen's pointer analysis algorithm (Andersen, 1994)(this includes parameter aliasing).
0.381	[*A*]this[*R*]includes[*A*]parameter aliasing	context()	negated: False ,passive: True
0.661	[*A*]1998[*R*]implements[*A*]a variant of Andersen's pointer analysis algorithm (Andersen, 1994)(this includes parameter aliasing	context()	negated: False ,passive: False
[LINE#195]At the medium setting, fields of a structure are not distinguished while the High level distinguishes structure fields.
0.911	[*A*]the High level[*R*]distinguishes[*A*]structure fields	context()	negated: False ,passive: False
0.953	[*A*]fields of a structure[*R*]are not[*A*]distinguished[*A*]while the High level distinguishes structure fields[*A*]At the medium setting	context()	negated: True ,passive: True
[LINE#196]The High setting should produce the most precise slices but requires more memory and time during SDG construction, which puts a functional limit on the size and complexity of the programs that can be handled by CodeSurfer.
0.925	[*A*]The High setting[*R*]requires[*A*]more time during SDG construction	context()	negated: False ,passive: False
0.934	[*A*]SDG construction[*R*]puts[*A*]a functional limit[*A*]on the complexity of the programs	context()	negated: False ,passive: False
0.905	[*A*]the programs[*R*]can be handled[*A*]by CodeSurfer	context()	negated: False ,passive: True
0.934	[*A*]SDG construction[*R*]puts[*A*]a functional limit[*A*]on the size of the programs	context()	negated: False ,passive: False
0.925	[*A*]The High setting[*R*]requires[*A*]more memory during SDG construction	context()	negated: False ,passive: False
0.911	[*A*]The High setting[*R*]should produce[*A*]the most precise slices	context()	negated: False ,passive: False
[LINE#197]There is no automatic way to determine whether the slices are correct and precise.
[LINE#198]Weiser (1984) considers smaller slices to be better.
0.724	[*A*]smaller slices[*R*]to be[*A*]better	context(Weiser ( 1984 considers)	negated: False ,passive: True
0.904	[*A*]Weiser (1984[*R*]considers[*A*]smaller slices to be better	context()	negated: False ,passive: False
[LINE#199]Slice size is often used to measure the impact of the analysis' precision (Shapiro and Horwitz, 1997), similarly we also use slice size as a measure of precision.
0.893	[*A*]Slice size[*R*]is used[*A*]to measure the impact of the analysis ' precision[*A*]often	context(we use)	negated: False ,passive: True
0.349	[*A*]we[*R*]use[*A*]slice size[*A*]as a measure of precision	context()	negated: False ,passive: False
0.887	[*A*]Slice size[*R*]to measure[*A*]the impact of the analysis ' precision	context()	negated: False ,passive: True
[LINE#200]The study compares slice and cluster size for CodeSurfer's three precision options (Low, Medium, High) to study the impact of pointer analysis precision.
0.918	[*A*]The study[*R*]compares[*A*]cluster size[*A*]for CodeSurfer 's three precision options	context()	negated: False ,passive: False
0.918	[*A*]The study[*R*]compares[*A*]slice size[*A*]for CodeSurfer 's three precision options	context()	negated: False ,passive: False
[LINE#201]The results are shown in Table 2.
0.918	[*A*]The results[*R*]are shown[*A*]in Table 2	context()	negated: False ,passive: True
[LINE#202]Column 1 lists the programs and the other columns present the average slice size, maximum slice size, average cluster size, and maximum cluster size, respectively, for each of the three precision settings.
0.991	[*A*]column 1 lists[*R*]present[*A*]the average slice size maximum slice size average cluster size and maximum cluster size respectively	context()	negated: False ,passive: False
0.976	[*A*]Column 1 lists the programs and the other columns[*R*]present[*A*]the average slice size, maximum slice size, average cluster size, and maximum cluster size, respectively	context()	negated: False ,passive: False
[LINE#203]The results for average slice size deviation and largest cluster size deviation are visualized in Figs.
0.967	[*A*]The results for average slice size deviation and largest cluster size deviation[*R*]are visualized[*A*]in Figs	context()	negated: False ,passive: True
[LINE#204]The graphs use the High setting as the base line and show the percentage deviation when using the Low and Medium settings.
0.937	[*A*]The graphs[*R*]show[*A*]the percentage deviation[*A*]when using the Medium settings	context()	negated: False ,passive: False
0.925	[*A*]The graphs[*R*]show[*A*]the percentage deviation[*A*]when using the Low settings	context()	negated: False ,passive: False
0.918	[*A*]The graphs[*R*]use[*A*]the High setting as the base line	context()	negated: False ,passive: False
[LINE#205]5 shows the average slice size deviation when using the lower two settings compared to the highest.
0.799	[*A*]the lower two settings[*R*]compared[*A*]to the highest	context()	negated: False ,passive: True
0.449	[*A*]5[*R*]shows[*A*]the average slice size deviation[*A*]when using the lower two settings	context()	negated: False ,passive: False
[LINE#206]On average, the Low setting produces slices that are 14% larger than the High setting.
0.877	[*A*]slices[*R*]are[*A*]14% larger than the High setting	context()	negated: False ,passive: True
0.857	[*A*]the Low setting[*R*]produces[*A*]slices that are 14% larger than the High setting	context()	negated: False ,passive: False
[LINE#207]Program userv has the largest deviation of 37% when using the Low setting.
0.997	[*A*]Program userv[*R*]has the largest deviation of[*A*]37 %	context()	negated: False ,passive: False
0.970	[*A*]Program userv[*R*]has[*A*]the largest deviation of 37% when using the Low setting	context()	negated: False ,passive: False
[LINE#208] For example, in userv the minimal pointer analysis fails to recognize that the function pointer oip can never point to functions sighandler_alrm and sighandler_child and includes them as called functions at call sites using *oip, increasing slice size significantly.
0.926	[*A*]called functions at call sites[*R*]using[*A*]*oip	context()	negated: False ,passive: False
[LINE#209]In all 30 programs, the Low setting yields larger slices compared to the High setting.
0.961	[*A*]the Low setting yields larger slices[*R*]compared[*A*]to the High setting[*A*]In all 30 programs	context()	negated: False ,passive: True
[LINE#210]The Medium setting always yields smaller slices when compared to the Low setting.
0.927	[*A*]The Medium[*R*]setting[*A*]always[*A*]yields smaller slices[*A*]when compared to the Low setting	context()	negated: False ,passive: False
[LINE#211]For eight programs, the medium setting produces the same average slice size as the High setting.
0.911	[*A*]the medium setting[*R*]produces[*A*]the same average slice size	context()	negated: False ,passive: False
[LINE#212]For the remaining programs the Medium setting produces slices that are on average 4% larger than when using the High setting.
0.710	[*A*]slices[*R*]are larger[*A*]on average	context()	negated: False ,passive: True
0.777	[*A*]For the remaining programs[*R*]produces[*A*]slices that are on average 4% larger than	context()	negated: False ,passive: True
0.788	[*A*]the Medium[*R*]setting	context()	negated: False ,passive: False
[LINE#213]The difference in slice size occurs because the Medium setting does not differentiate between structure fields, which the High setting does.
0.934	[*A*]structure fields[*R*]does[*A*]the High setting	context()	negated: False ,passive: True
0.933	[*A*]the Medium setting[*R*]does not differentiate[*A*]between structure fields	context()	negated: True ,passive: False
0.960	[*A*]The difference in slice size[*R*]occurs[*A*]because the Medium setting does not differentiate between structure fields	context()	negated: False ,passive: True
[LINE#214]The largest deviation is seen in findutils at 29%.
0.993	[*A*]The largest deviation[*R*]is seen at[*A*]29 %	context()	negated: False ,passive: False
0.911	[*A*]The largest deviation[*R*]is seen[*A*]in findutils	context()	negated: False ,passive: True
[LINE#215]With the medium setting, the structure fields (options, regex_map, stat_buf and state) of findutils are lumped together as if each structure were a scalar variable, resulting in larger, less precise, slices.
0.964	[*A*]the structure fields ( state ) of findutils[*R*]are lumped[*A*]together[*A*]as if each structure were a scalar variable , resulting in larger , less precise , slices	context()	negated: False ,passive: True
0.964	[*A*]the structure fields ( stat_buf ) of findutils[*R*]are lumped[*A*]together[*A*]as if each structure were a scalar variable , resulting in larger , less precise , slices	context()	negated: False ,passive: True
0.903	[*A*]each structure[*R*]were[*A*]a scalar variable[*A*]resulting in larger , less precise , slices	context()	negated: False ,passive: True
0.970	[*A*]the structure fields ( options , regex_map ) of findutils[*R*]are lumped[*A*]together[*A*]as if each structure were a scalar variable , resulting in larger , less precise , slices	context()	negated: False ,passive: True
[LINE#216]6 visualizes the deviation of the largest coherent cluster size when using the lower two settings compared to the highest.
0.799	[*A*]the lower two settings[*R*]compared[*A*]to the highest	context()	negated: False ,passive: True
0.381	[*A*]6[*R*]visualizes[*A*]the deviation of the largest coherent cluster size[*A*]when using the lower two settings	context()	negated: False ,passive: False
[LINE#217]The graph shows that the size of the largest coherent clusters found when using the lower settings is larger in most of the programs.
0.931	[*A*]the size of the largest coherent clusters[*R*]is[*A*]larger in most of the programs	context(The graph shows)	negated: False ,passive: True
0.853	[*A*]The graph[*R*]shows[*A*]that the size of the largest coherent clusters found when using the lower settings is larger in most of the programs	context()	negated: False ,passive: False
0.919	[*A*]the largest coherent clusters[*R*]found[*A*]when using the lower settings	context()	negated: False ,passive: True
[LINE#218]On average there is a 22% increase in the size of the largest coherent cluster when using the Low setting and a 10% increase when using the Medium setting.
[LINE#219]In a2ps and cflow the size of the largest cluster increases over 100% when using the Medium setting and over 150% when using the Low setting.
[LINE#220]The increase in slice size is expected to result in larger clusters due to the loss of precision.
0.913	[*A*]The increase in slice size[*R*]to result[*A*]in larger clusters due to the loss of precision	context()	negated: False ,passive: True
0.785	[*A*]The increase in slice size[*R*]is expected	context()	negated: False ,passive: False
[LINE#221] The B-SCGs for a2ps for the three settings is shown in Fig..
0.971	[*A*]The B-SCGs for a2ps for the three settings[*R*]is shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#222]In the graphs it is seen that the slice sizes get smaller and have increased steps in the (black) landscape indicating that the slices become more precise.
[LINE#223]The red landscape shows that there is a large coherent cluster detected when using the Low setting running from approx.
0.931	[*A*]a large coherent cluster[*R*]detected[*A*]when using the Low setting running from approx	context()	negated: False ,passive: True
0.684	[*A*]The red landscape[*R*]shows[*A*]that there is a large coherent cluster	context()	negated: False ,passive: False
[LINE#224]This cluster drops in size when using the Medium setting.
0.925	[*A*]This cluster[*R*]drops[*A*]when using the Medium setting	context()	negated: False ,passive: True
[LINE#225]At the High setting this coherent cluster breaks up into multiple smaller clusters.
0.957	[*A*]this coherent cluster[*R*]breaks up[*A*]into multiple smaller clusters[*A*]At the High setting	context()	negated: False ,passive: True
[LINE#226]In this case, a drop in the cluster size also leads to breaking of the cluster in to multiple smaller clusters.
0.971	[*A*]a drop in the cluster size[*R*]leads[*A*]to breaking of the cluster in to multiple smaller clusters[*A*]In this case	context()	negated: False ,passive: False
[LINE#227]a similar drop in the slice size and cluster size is observed.
0.816	[*A*]a similar drop in the cluster size[*R*]is observed	context()	negated: False ,passive: False
0.816	[*A*]a similar drop in the slice size[*R*]is observed	context()	negated: False ,passive: False
[LINE#228]However, unlike a2ps the large coherent cluster does not break into smaller clusters but only drops in size.
0.919	[*A*]the large coherent cluster[*R*]does not break[*A*]into only drops in size	context()	negated: True ,passive: True
0.919	[*A*]the large coherent cluster[*R*]does not break[*A*]into smaller clusters	context()	negated: True ,passive: True
[LINE#229]The largest cluster when using the Low setting runs from 60% to 85% on the x-axis.
[LINE#230] This cluster reduces in size and shifts position running 30% to 45%x-axis when using the Medium setting.
0.925	[*A*]This shifts position[*R*]running[*A*]30 % to 45 %[*A*]when using the Medium setting	context()	negated: False ,passive: False
0.732	[*A*]This cluster[*R*]reduces	context()	negated: False ,passive: False
[LINE#231]The cluster further drops in size down to 5% running 25-30% on the x-axis when using the High setting.
0.852	[*A*]5%[*R*]running[*A*]25-30%[*A*]on the x-axis[*A*]when using the High setting	context()	negated: False ,passive: False
[LINE#232]In this case the largest cluster has a significant drop in size but does not break into multiple smaller clusters.
0.960	[*A*]the largest cluster[*R*]has[*A*]a significant drop in size[*A*]In this case	context()	negated: False ,passive: False
[LINE#233]Surprisingly, Fig. 6 also shows seven programs where the largest coherent cluster size actually increases when using the highest pointer analysis setting on CodeSurfer.
0.931	[*A*]the highest pointer analysis[*R*]setting[*A*]on CodeSurfer	context()	negated: False ,passive: True
0.949	[*A*]the largest coherent cluster size[*R*]increases[*A*]when using the highest pointer analysis[*A*]seven programs	context()	negated: False ,passive: True
0.962	[*A*]Fig. 6[*R*]shows[*A*]seven programs where the largest coherent cluster size actually increases	context()	negated: False ,passive: False
[LINE#234]7c shows the B-SCGs for acm which falls in this category.
0.830	[*A*]acm[*R*]falls[*A*]in this category	context()	negated: False ,passive: True
0.495	[*A*]7c[*R*]shows[*A*]the B-SCGs	context()	negated: False ,passive: False
[LINE#235]This counter-intuitive result is seen only when the more precise analysis determines that certain functions cannot be called and thus excludes them from the slice.
0.795	[*A*]certain functions[*R*]can not be[*A*]thus[*A*]excludes them from the slice	context(This counter-intuitive result is seen the more precise analysis determines)	negated: True ,passive: True
0.734	[*A*]the more precise analysis[*R*]determines[*A*]that certain functions can not be thus excludes them from the slice	context(This counter-intuitive result is seen)	negated: False ,passive: False
0.677	[*A*]certain functions[*R*]can not be called	context(This counter-intuitive result is seen the more precise analysis determines)	negated: True ,passive: False
0.760	[*A*]the more precise analysis[*R*]determines[*A*]that certain functions can not be called	context(This counter-intuitive result is seen)	negated: False ,passive: False
0.698	[*A*]This counter-intuitive result[*R*]is seen	context()	negated: False ,passive: False
[LINE#236]Although in all such instances slices get smaller, the clusters may grow if the smaller slices match other slices already forming a cluster.
0.934	[*A*]other slices[*R*]forming[*A*]a cluster[*A*]already	context()	negated: False ,passive: False
0.800	[*A*]the smaller slices[*R*]match	context()	negated: False ,passive: False
0.903	[*A*]the clusters[*R*]may grow[*A*]if the smaller slices match other slices	context()	negated: False ,passive: True
0.952	[*A*]slices[*R*]get[*A*]smaller[*A*]in all such instances	context()	negated: False ,passive: True
[LINE#237]For example, consider replacing function f6 in Fig. 1 with the code shown in Fig. 8, where f depends on a function call to a function referenced through the function pointer p. Assume that the highest precision pointer analysis determines that p does not point to f2 and therefore there is no call to f2 or any other function from f6.
0.732	[*A*]a function[*R*]referenced	context()	negated: False ,passive: False
0.937	[*A*]the code[*R*]shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#238]The higher precision analysis would therefore determine that the forward slices and backward slices of a, b and c are equal, hence grouping these three vertices in a coherent cluster.
0.701	[*A*]The higher precision analysis[*R*]would determine[*A*]that the forward backward slices of a , c are equal[*A*]hence grouping these three vertices in a coherent cluster	context()	negated: False ,passive: False
0.452	[*A*]b[*R*]are[*A*]equal[*A*]hence grouping these three vertices in a coherent cluster	context()	negated: False ,passive: True
0.701	[*A*]The higher precision analysis[*R*]would determine[*A*]that the forward backward slices of a , b are equal	context()	negated: False ,passive: False
0.934	[*A*]that the forward slices , c are equal[*R*]hence grouping[*A*]these three vertices[*A*]in a coherent cluster	context()	negated: False ,passive: False
0.812	[*A*]The higher precision analysis[*R*]would determine[*A*]that the forward slices , c are equal , hence grouping these three vertices in a coherent cluster	context()	negated: False ,passive: False
0.934	[*A*]that the forward slices , b are equal[*R*]hence grouping[*A*]these three vertices[*A*]in a coherent cluster	context()	negated: False ,passive: False
0.812	[*A*]The higher precision analysis[*R*]would determine[*A*]that the forward slices , b are equal , hence grouping these three vertices in a coherent cluster	context()	negated: False ,passive: False
[LINE#239]Whereas the lower precision is unable to determine that p cannot point to f2, the backward slice on f will conservatively include b. This will lead the higher precision analysis to determine that the set of vertices {a, b, c} is one coherent cluster whereas the lower precision analysis include only the set of vertices {a, c} in the same coherent cluster.
0.217	[*A*]This[*R*]will lead[*A*]the higher precision analysis[*A*]to determine that the set of vertices {a, b, c} is one coherent cluster whereas the lower precision analysis include only the set of vertices	context(the backward slice on f will conservatively include)	negated: False ,passive: False
0.920	[*A*]the backward slice on f[*R*]will conservatively include[*A*]b.	context()	negated: False ,passive: True
0.919	[*A*]the lower precision analysis[*R*]include[*A*]only the set of vertices	context()	negated: False ,passive: True
0.397	[*A*]p[*R*]can not point[*A*]to f2	context(the lower precision to determine)	negated: True ,passive: False
0.579	[*A*]the lower precision[*R*]to determine[*A*]that p cannot point to f2	context()	negated: False ,passive: False
0.942	[*A*]the set of vertices[*R*]is[*A*]one coherent cluster whereas the lower precision analysis include only the set of vertices	context(the higher precision analysis to determine)	negated: False ,passive: True
0.841	[*A*]the higher precision analysis[*R*]to determine[*A*]that the set of vertices {a, b, c} is one coherent cluster whereas the lower precision analysis include only the set of vertices	context()	negated: False ,passive: False
0.812	[*A*]the lower precision[*R*]is[*A*]unable to determine that p cannot point to f2	context()	negated: False ,passive: True
[LINE#240]Although we do not explicitly report the project build times on CodeSurfer and the clustering runtimes for the lower settings, it has been our experience that in the majority of the cases the build times for the lower settings were smaller.
0.954	[*A*]the build times for the lower settings[*R*]were[*A*]smaller[*A*]in the majority of the cases	context(it has been)	negated: False ,passive: True
0.878	[*A*]the project[*R*]build[*A*]times[*A*]on the clustering runtimes for the lower settings	context(we do not explicitly report)	negated: False ,passive: False
0.504	[*A*]we[*R*]do not explicitly report[*A*]the project build times on the clustering runtimes for the lower settings	context()	negated: True ,passive: False
0.954	[*A*]the build times for the lower settings[*R*]were[*A*]smaller[*A*]in the majority of the cases	context(it has been)	negated: False ,passive: True
0.256	[*A*]it[*R*]has been[*A*]our experience	context()	negated: False ,passive: True
0.896	[*A*]the project[*R*]build[*A*]times[*A*]on CodeSurfer	context(we do not explicitly report)	negated: False ,passive: False
0.433	[*A*]we[*R*]do not explicitly report[*A*]the project build times on CodeSurfer	context()	negated: True ,passive: False
[LINE#241]However, as lower pointer analysis settings yield large points-to sets and subsequently larger slices, the clustering runtimes were higher than when using the highest setting.
0.783	[*A*]the clustering runtimes[*R*]were[*A*]higher than	context()	negated: False ,passive: True
0.919	[*A*]lower pointer analysis settings[*R*]yield[*A*]large points-to sets and subsequently larger slices	context()	negated: False ,passive: False
[LINE#242]Moreover, in some cases with the lower settings there was an explosive growth in summary edge generation which resulted in exceptionally high project build times and clustering runtimes.
0.897	[*A*]summary edge generation[*R*]resulted[*A*]in clustering runtimes	context()	negated: False ,passive: True
0.897	[*A*]summary edge generation[*R*]resulted[*A*]in exceptionally high project build times	context()	negated: False ,passive: True
[LINE#243]As an answer to RQ1, we find that in the majority of the cases the Medium and Low settings result in larger coherent clusters when compared to the High setting.
0.922	[*A*]the Low settings[*R*]result[*A*]in the majority of the cases	context(we find)	negated: False ,passive: True
0.330	[*A*]we[*R*]find[*A*]that in the majority of the cases the Low settings result in larger coherent clusters	context()	negated: False ,passive: False
0.941	[*A*]the Medium settings[*R*]result[*A*]in the majority of the cases	context(we find)	negated: False ,passive: True
0.372	[*A*]we[*R*]find[*A*]that in the majority of the cases the Medium settings result in larger coherent clusters	context()	negated: False ,passive: False
[LINE#244]For the remaining cases we have identified valid scenarios where more precise pointer analysis can result in larger coherent clusters.
0.919	[*A*]more precise pointer analysis[*R*]can result[*A*]in larger coherent clusters	context()	negated: False ,passive: True
0.569	[*A*]we[*R*]have identified[*A*]valid scenarios where more precise pointer analysis can result in larger coherent clusters	context()	negated: False ,passive: False
[LINE#245]The results also confirm that a more precise pointer analysis leads to more precise (smaller) slices.
0.905	[*A*]a more precise pointer analysis[*R*]leads[*A*]to more precise (smaller) slices	context(The results confirm)	negated: False ,passive: False
0.780	[*A*]The results[*R*]confirm[*A*]that a more precise pointer analysis leads to more precise (smaller) slices	context()	negated: False ,passive: False
[LINE#246]Because it gives the most precise slices and most accurate clusters, the remainder of the paper uses the highest CodeSurfer pointer analysis setting. .
0.452	[*A*]it[*R*]gives[*A*]the most accurate clusters	context()	negated: False ,passive: False
0.926	[*A*]the remainder of the paper[*R*]uses[*A*]the highest CodeSurfer pointer analysis setting	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]gives[*A*]the most precise slices	context()	negated: False ,passive: False
[LINE#247] Validity of the hash functionThis section addresses research question RQ2:.
[LINE#248] How precise is hashing as a proxy for comparing slices?.
[LINE#249]The section first gives a brief description of the hash function and then validates the use of comparing slice hash values in lieu of comparing actual slice content.
0.958	[*A*]The section[*R*]validates[*A*]the use of comparing slice hash values in lieu of comparing actual slice content[*A*]then	context()	negated: False ,passive: False
0.934	[*A*]The section[*R*]gives[*A*]a brief description of the hash function[*A*]first	context()	negated: False ,passive: False
[LINE#250]The use of hash values to represent slices reduces both the memory requirement and runtime, as it is no longer necessary to store or compare entire slices.
0.452	[*A*]it[*R*]is no longer[*A*]necessary to store or compare entire slices	context()	negated: True ,passive: True
0.935	[*A*]The use of hash values to represent slices[*R*]reduces[*A*]both the memory requirement and runtime[*A*]as it is no longer necessary to store or compare entire slices	context()	negated: False ,passive: False
[LINE#251]The hash function, denoted H in Definition 2.6, uses XOR operations iteratively on the unique vertex IDs (of the SDG) which are included in a slice to generate a hash for the entire slice.
0.950	[*A*]the unique vertex IDs (of the SDG[*R*]are included[*A*]in a slice	context()	negated: False ,passive: True
0.976	[*A*]The hash function, denoted H in Definition 2.6[*R*]uses[*A*]XOR operations[*A*]iteratively on the unique vertex IDs (of the SDG	context()	negated: False ,passive: False
[LINE#252]We chose XOR as the hash operator because we do not have duplicate vertices in a slice and the order of the vertices in the slice does not matter.
0.397	[*A*]we[*R*]do not have duplicate[*A*]vertices[*A*]in the order of the vertices in the slice	context(we do not have)	negated: True ,passive: False
0.463	[*A*]We[*R*]chose[*A*]XOR[*A*]as the hash operator[*A*]because we do not have duplicate vertices in the order of the vertices in the slice does not matter	context()	negated: False ,passive: False
0.397	[*A*]we[*R*]do not have duplicate[*A*]vertices	context(we do not have)	negated: True ,passive: False
0.162	[*A*]we[*R*]do not have	context()	negated: True ,passive: False
0.463	[*A*]We[*R*]chose[*A*]XOR[*A*]as the hash operator[*A*]because we do not have duplicate vertices in a slice	context()	negated: False ,passive: False
[LINE#253] A slice S is a set of SDG vertices {v1,,vn} (n1) and id(vi) represents the unique vertex ID assigned by CodeSurfer to vertex vi,where(2)HS=i=1nid(vi)The remainder of this section presents a validation study of the hash function.
0.934	[*A*]2 ) HS=i=1nid ( vi[*R*]presents[*A*]a validation study of the hash function	context()	negated: False ,passive: False
0.942	[*A*]A slice S[*R*]is[*A*]a set of SDG vertices id ( vi	context()	negated: False ,passive: True
0.926	[*A*]The remainder of this section[*R*]presents[*A*]a validation study of the hash function	context()	negated: False ,passive: False
0.877	[*A*]ID[*R*]assigned[*A*]by CodeSurfer[*A*]to vertex vi	context()	negated: False ,passive: True
0.786	[*A*]v1[*R*]represents[*A*]the unique vertex	context()	negated: False ,passive: False
0.942	[*A*]A slice S[*R*]is[*A*]a set of SDG vertices	context()	negated: False ,passive: True
[LINE#254]The validation is needed to confirm that the hash values provide a sufficiently accurate summary of slices to support the correct partitioning of SDG vertices into coherent clusters.
0.943	[*A*]a sufficiently accurate summary of slices[*R*]to support[*A*]the correct partitioning of SDG vertices	context()	negated: False ,passive: False
0.845	[*A*]The validation[*R*]is needed[*A*]to confirm that the hash values provide a sufficiently accurate summary of slices	context()	negated: False ,passive: True
[LINE#255]Ideally, the hash function would produce a unique hash value for each distinct slice.
0.911	[*A*]the hash function[*R*]would produce[*A*]a unique hash value for each distinct slice	context()	negated: False ,passive: False
[LINE#256]The validation study aims to find the number of unique slices for which the hash function successfully produces an unique hash value.
0.891	[*A*]The validation study[*R*]aims to find[*A*]the number of unique slices	context(The validation study aims)	negated: False ,passive: False
0.891	[*A*]The validation study[*R*]aims[*A*]to find the number of unique slices	context()	negated: False ,passive: False
0.911	[*A*]the hash function[*R*]successfully produces[*A*]an unique hash value	context()	negated: False ,passive: False
[LINE#257]For the validation study we chose 16 programs from the set of 30 subject programs.
0.452	[*A*]we[*R*]chose[*A*]16 programs from the set of 30 subject programs	context()	negated: False ,passive: False
[LINE#258]The largest programs were not included in the validation study to make the study time-manageable.
0.911	[*A*]The largest programs[*R*]were not included[*A*]in the validation study	context()	negated: True ,passive: True
[LINE#259]Results are based on both the backward and forward slices for every vertex of these 16 programs.
0.931	[*A*]Results[*R*]are based[*A*]on both the forward slices for every vertex of these 16 programs	context()	negated: False ,passive: True
0.749	[*A*]Results[*R*]are based[*A*]on both the backward	context()	negated: False ,passive: True
[LINE#260]To present the notion of precision we introduce the following formalization.
0.452	[*A*]we[*R*]introduce[*A*]the following formalization	context()	negated: False ,passive: False
[LINE#261]Let V be the set of all source-code representing SDG vertices for a given program P and US denote the number of unique slices: US=|{BSlice(x):xV}|+|{FSlice(x):xV}|.
0.956	[*A*]all source - code[*R*]representing[*A*]SDG vertices for a US denote the number of unique slices	context()	negated: False ,passive: False
0.931	[*A*]all source - code[*R*]representing[*A*]SDG vertices for a given program P	context()	negated: False ,passive: False
[LINE#262]Note that if all vertices have the same backward slice then {BSlice(x):xV} is a singleton set.
0.903	[*A*]all vertices[*R*]have[*A*]the same backward slice	context()	negated: False ,passive: False
[LINE#263]Finally, let UH be the number of unique hash-values, UH=|{H(BSlice(x)):xV}|+|{H(FSlice(x)):xV}|.The accuracy of hash function H is given as Hashed Slice Precision, HSP=UH/US.
0.943	[*A*]The accuracy of hash function H[*R*]is given[*A*]as Hashed Slice Precision	context()	negated: False ,passive: True
0.978	[*A*]UH= | { H ( BSlice ( x ) ) : xV } . The accuracy of hash function H[*R*]is given[*A*]as Hashed Slice Precision	context()	negated: False ,passive: True
[LINE#264] A precision of 1.00 (US=UH) means the hash function is 100% accurate(i.e., it produces a unique hash value for every distinct slice) whereas a precision of 1/US means that the hash function produces the same hash value for every slice leaving UH=1.Table 3 summarizes the results.
0.913	[*A*]the hash function[*R*]is[*A*]100% accurate	context(A precision of 1.00 means it produces)	negated: False ,passive: True
0.880	[*A*]A precision of 1.00[*R*]means[*A*]the hash function is 100% accurate	context(it produces)	negated: False ,passive: False
0.309	[*A*]it[*R*]produces[*A*]a unique hash value for every distinct slice[*A*]whereas a precision of 1/US means that the hash function produces the same hash value for every slice leaving UH=1.Table 3 summarizes the results	context()	negated: False ,passive: False
0.707	[*A*]the hash function[*R*]produces	context(a precision of 1 / US means)	negated: False ,passive: False
0.913	[*A*]a precision of 1/US[*R*]means[*A*]that the hash function produces the same hash value for every slice leaving UH=1.Table 3 summarizes the results	context()	negated: False ,passive: False
0.918	[*A*]every slice[*R*]leaving[*A*]UH=1.Table 3	context()	negated: False ,passive: False
[LINE#265]The first column lists the programs.
0.932	[*A*]The first column[*R*]lists[*A*]the programs	context()	negated: False ,passive: False
[LINE#266]The second and the third columns report the values of US and UH respectively.
0.925	[*A*]the third columns[*R*]report[*A*]the values of UH[*A*]respectively	context()	negated: False ,passive: False
0.925	[*A*]the third columns[*R*]report[*A*]the values of US[*A*]respectively	context()	negated: False ,passive: False
[LINE#267]The fourth column reports HSP, the precision attained using hash values to compare slices.
0.878	[*A*]the precision[*R*]attained using[*A*]hash values[*A*]to compare slices	context(the precision attained)	negated: False ,passive: False
0.939	[*A*]the precision[*R*]attained[*A*]using hash values to compare slices[*A*]The fourth column reports HSP	context()	negated: False ,passive: False
[LINE#268]Considering all 78,587 unique slices the hash function produced unique hash values for 74,575 of them, resulting in an average precision of 94.97%.
0.991	[*A*]78587 unique slices the hash function[*R*]produced[*A*]unique hash values	context()	negated: False ,passive: False
0.848	[*A*]the hash function[*R*]produced[*A*]unique hash values[*A*]for 74,575 of them[*A*]resulting in an average precision of 94.97%	context()	negated: False ,passive: False
[LINE#269]In other words, the hash function fails to produce unique hash values for just over 5% of the slices.
0.897	[*A*]the hash function[*R*]to produce[*A*]unique hash values[*A*]for just over 5% of the slices	context()	negated: False ,passive: False
0.943	[*A*]the hash function[*R*]fails[*A*]to produce unique hash values for just over 5% of the slices	context()	negated: False ,passive: True
[LINE#270]Considering the precision of individual programs, five of the programs have a precision greater than 97%, while the lowest precision, for findutils, is 92.37%.
0.920	[*A*]the lowest precision[*R*]is[*A*]92.37%	context()	negated: False ,passive: True
0.948	[*A*]five of the programs[*R*]have[*A*]a precision greater than 97%[*A*]while the lowest precision, for findutils, is 92.37%	context()	negated: False ,passive: False
[LINE#271]This is, however, a significant improvement over previous use of slice size as the hash value, which is only 78.3% accurate in the strict case of zero tolerance for variation in slice contents (Binkley and Harman, 2005).Coherent cluster identification uses two hash values for each vertex (one for the backward slice and other for the forward slice) and the slice sizes.
0.911	[*A*]Coherent cluster identification[*R*]uses[*A*]two hash values for each vertex	context()	negated: False ,passive: False
0.911	[*A*]Coherent cluster identification[*R*]uses[*A*]the slice sizes	context()	negated: False ,passive: False
0.949	[*A*]the hash value[*R*]is[*A*]only 78.3 % accurate in the strict case of zero tolerance for variation in slice contents	context()	negated: False ,passive: True
0.522	[*A*]This[*R*]is[*A*]however[*A*]a significant improvement over previous use of slice size as the hash value	context()	negated: False ,passive: True
[LINE#272] Slice size matching filters out some instances where the hash values happen to be the same by coincidence.
0.754	[*A*]the hash values[*R*]to be[*A*]the same	context()	negated: False ,passive: True
0.939	[*A*]the hash values[*R*]happen[*A*]some instances	context()	negated: False ,passive: True
[LINE#273]The likelihood of both hash values matching those from another vertex with different slices is less than that of a single hash matching.
0.849	[*A*]The likelihood of both hash values[*R*]is[*A*]less than that of a single hash matching	context()	negated: False ,passive: True
0.789	[*A*]both hash values[*R*]matching[*A*]those from another vertex with different slices	context()	negated: False ,passive: False
[LINE#274]Extending US and UH to clusters, columns 5 and 6 (Table 3) report CC, the number of coherent clusters in a program and HCC, the number of coherent clusters found using hashing.
0.905	[*A*]the number of coherent clusters[*R*]found using[*A*]hashing	context(the number of coherent clusters found)	negated: False ,passive: False
0.905	[*A*]the number of coherent clusters[*R*]found using[*A*]hashing	context(the number of coherent clusters found)	negated: False ,passive: False
0.905	[*A*]the number of coherent clusters[*R*]found[*A*]using hashing	context()	negated: False ,passive: False
[LINE#275]The final column shows the precision attained using hashing to identify clusters, HCP=HCC/CC.
0.882	[*A*]the precision[*R*]attained using[*A*]hashing[*A*]to identify clusters	context(The final column shows the precision attained)	negated: False ,passive: False
0.687	[*A*]the precision[*R*]attained	context(The final column shows)	negated: False ,passive: False
0.955	[*A*]The final column[*R*]shows[*A*]the precision attained using hashing to identify clusters, HCP=HCC/CC	context()	negated: False ,passive: False
[LINE#276]The results show that of the 40,169 coherent clusters, 40,083 are uniquely identified using hashing, which yields a precision of 99.72%.
0.777	[*A*]The results[*R*]show[*A*]that of the 40,169 coherent clusters	context(40,083 are uniquely identified)	negated: False ,passive: False
0.213	[*A*]40,083[*R*]are uniquely identified	context()	negated: False ,passive: False
0.877	[*A*]hashing[*R*]yields[*A*]a precision of 99.72%	context()	negated: False ,passive: False
[LINE#277]Five of the programs show total agreement, furthermore for every program HCP is over 99%, except for userv, which has the lowest precision of 97.76%.
0.862	[*A*]HCP[*R*]is[*A*]over 99%	context(Five of the programs show)	negated: False ,passive: True
0.923	[*A*]Five of the programs[*R*]show[*A*]total agreement, furthermore for every program	context()	negated: False ,passive: False
0.905	[*A*]userv[*R*]has[*A*]the lowest precision of 97.76%	context()	negated: False ,passive: False
[LINE#278]This can be attributed to the large percentage (96%) of single vertex clusters in userv.
0.497	[*A*]This[*R*]can be attributed[*A*]to the large percentage (96%) of single vertex clusters in userv	context()	negated: False ,passive: True
[LINE#279]The hash values for slices taken with respect to these single-vertex clusters have a higher potential for collision leading to a reduction in overall precision.
0.894	[*A*]collision[*R*]leading[*A*]to a reduction in overall precision	context()	negated: False ,passive: False
0.913	[*A*]The hash values for slices[*R*]have[*A*]a higher potential for collision	context()	negated: False ,passive: False
0.713	[*A*]slices[*R*]taken	context()	negated: False ,passive: False
[LINE#280]In summary, as an answer to RQ2, the hash-based approximation is found to be sufficiently accurate at 94.97% for slices and at 99.72% for clusters (for the studied programs).
0.944	[*A*]the hash - based approximation[*R*]to be[*A*]at 99.72 % for clusters ( for the studied programs	context()	negated: False ,passive: True
0.913	[*A*]the hash - based approximation[*R*]to be[*A*]sufficiently accurate at 94.97 % for slices	context()	negated: False ,passive: True
0.949	[*A*]the hash - based approximation[*R*]is found[*A*]In summary	context()	negated: False ,passive: True
[LINE#281]Thus, comparing hash values can replace the need to compare actual slices. .
0.911	[*A*]comparing hash values[*R*]can replace[*A*]the need to compare actual slices	context()	negated: False ,passive: False
[LINE#282] Do large coherent clusters occur in practice?Having demonstrated that hash function H can be used to effectively approximate slice contents, this section and the following section consider the validation research question, RQ3: How large are coherent clusters that exist in production source code and which patterns of clustering can be identified?.
0.751	[*A*]patterns of clustering[*R*]can be identified	context()	negated: False ,passive: False
0.698	[*A*]coherent clusters[*R*]exist	context()	negated: False ,passive: False
0.887	[*A*]coherent clusters[*R*]exist[*A*]in production source code	context()	negated: False ,passive: True
[LINE#283]The question is first answered quantitatively using the size of the largest coherent cluster in each program and then through visual analysis of the SCGs.
0.954	[*A*]The question[*R*]is answered quantitatively[*A*]using the size of the largest coherent cluster in each program and then through visual analysis of the SCGs[*A*]first	context()	negated: False ,passive: True
[LINE#284]To assess if a program includes a large coherent cluster, requires making a judgement concerning what threshold constitutes large.
0.882	[*A*]a judgement[*R*]concerning[*A*]what threshold constitutes large	context()	negated: False ,passive: False
0.903	[*A*]a program[*R*]includes[*A*]a large coherent cluster	context()	negated: False ,passive: True
[LINE#285] (Binkley and Harman, 2005; Harman et al., 2009;.
[LINE#286]Islam et al., 2010a,b), a threshold of 10% is used.
0.785	[*A*]a threshold of 10%[*R*]is used	context()	negated: False ,passive: False
[LINE#287]In other words, a program is said to contain a large coherent cluster if 10% of the program's SDG vertices produce the same backward slice as well as the same forward slice.
0.958	[*A*]10 % of the program 's SDG vertices[*R*]produce[*A*]the same forward slice	context()	negated: False ,passive: False
0.958	[*A*]10 % of the program 's SDG vertices[*R*]produce[*A*]the same backward slice	context()	negated: False ,passive: False
0.887	[*A*]a program[*R*]to contain[*A*]a large coherent cluster	context()	negated: False ,passive: False
0.732	[*A*]a program[*R*]is said	context()	negated: False ,passive: False
[LINE#288]9 shows the size of the largest coherent cluster found in each of the 30 subject programs.
0.919	[*A*]the largest coherent cluster[*R*]found[*A*]in each of the 30 subject programs	context()	negated: False ,passive: True
0.449	[*A*]9[*R*]shows[*A*]the size of the largest coherent cluster	context()	negated: False ,passive: False
[LINE#289]The programs are divided into 3 groups based on the size of the largest cluster present in the program.
0.993	[*A*]The programs[*R*]are divided into[*A*]3 groups	context()	negated: False ,passive: False
0.937	[*A*]3 groups[*R*]based[*A*]on the size of the largest cluster present in the program	context()	negated: False ,passive: True
0.903	[*A*]The programs[*R*]are divided[*A*]into 3 groups	context()	negated: False ,passive: True
[LINE#290]Small:Small consists of seven programs none of which have a coherent cluster constituting over 10% of the program vertices.
0.911	[*A*]a coherent cluster[*R*]constituting[*A*]over 10% of the program vertices	context()	negated: False ,passive: False
0.952	[*A*]seven programs none of which[*R*]have[*A*]a coherent cluster constituting over 10% of the program vertices	context()	negated: False ,passive: False
0.260	[*A*]Small:Small[*R*]consists	context()	negated: False ,passive: False
[LINE#291]These programs are archimedes, time, wdiff, byacc, a2ps, cflow and userv.
0.767	[*A*]These programs[*R*]are[*A*]userv	context()	negated: False ,passive: True
0.767	[*A*]These programs[*R*]are[*A*]cflow	context()	negated: False ,passive: True
0.903	[*A*]These programs[*R*]are[*A*]a2ps	context()	negated: False ,passive: True
0.767	[*A*]These programs[*R*]are[*A*]byacc	context()	negated: False ,passive: True
0.767	[*A*]These programs[*R*]are[*A*]wdiff	context()	negated: False ,passive: True
0.903	[*A*]These programs[*R*]are[*A*]time	context()	negated: False ,passive: True
0.903	[*A*]These programs[*R*]are[*A*]archimedes	context()	negated: False ,passive: True
[LINE#292]Although it may be interesting to study why large clusters are not present in these programs, this paper focuses on studying the existence and implications of large coherent clusters.
0.878	[*A*]this paper[*R*]focuses on studying[*A*]the implications of large coherent clusters	context(this paper focuses)	negated: False ,passive: False
0.878	[*A*]this paper[*R*]focuses[*A*]on studying the implications of large coherent clusters	context()	negated: False ,passive: False
0.903	[*A*]this paper[*R*]focuses[*A*]on studying the existence	context()	negated: False ,passive: False
[LINE#293]This group consists of programs that have at least one cluster with size 10% or larger.
0.920	[*A*]programs[*R*]have[*A*]at least one cluster with size 10% or larger	context()	negated: False ,passive: False
0.903	[*A*]This group[*R*]consists[*A*]of programs	context()	negated: False ,passive: True
[LINE#294]As there are programs containing much larger coherent clusters, a program is placed in this group if it has a large cluster between the size 10% and 50%.
0.522	[*A*]it[*R*]has[*A*]a large cluster between the size	context()	negated: False ,passive: False
0.835	[*A*]a program[*R*]is placed[*A*]in this group[*A*]if it has a large cluster between the size	context()	negated: False ,passive: True
0.894	[*A*]programs[*R*]containing[*A*]much larger coherent clusters	context()	negated: False ,passive: False
[LINE#295]Over two-thirds of the programs studied fall in this category.
0.903	[*A*]the programs[*R*]studied[*A*]fall[*A*]in this category	context()	negated: False ,passive: True
[LINE#296]The program at the bottom of this group (acct) has a coherent cluster of size 11% and the largest program in this group (copia) has a coherent cluster of size 48%.
0.939	[*A*]the largest program in this group[*R*]has[*A*]a coherent cluster of size	context()	negated: False ,passive: False
0.925	[*A*]11 %[*R*]has[*A*]a coherent cluster of size	context()	negated: False ,passive: False
0.949	[*A*]The program at the bottom of this group[*R*]has[*A*]a coherent cluster of size	context()	negated: False ,passive: False
[LINE#297]We present both these programs as case studies and discuss their clustering in detail in Sections 3.6.1 and 3.6.4, respectively.
0.309	[*A*]We[*R*]discuss[*A*]their clustering	context()	negated: False ,passive: False
0.309	[*A*]We[*R*]discuss[*A*]their clustering[*A*]in Sections 3.6.1	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]present[*A*]both these programs as case studies	context()	negated: False ,passive: False
[LINE#298] The program bc which has multiple large clusters with the largest of size 32% falls in the middle of this group and is also presented as a case study in Section 3.6.3.Huge:.
0.837	[*A*]32%[*R*]is presented[*A*]as a case study in Section 3.6.3	context()	negated: False ,passive: True
0.925	[*A*]32%[*R*]falls[*A*]in the middle of this group	context()	negated: False ,passive: True
0.949	[*A*]The program bc[*R*]has[*A*]multiple large clusters with the largest of size 32% falls in the middle of this group and is also presented as a case study in Section 3.6.3	context()	negated: False ,passive: False
[LINE#299]The final group consists of programs that have a large coherent cluster whose size is over 50%.
0.927	[*A*]a large coherent cluster[*R*]is[*A*]over 50%	context()	negated: False ,passive: True
0.920	[*A*]programs[*R*]have[*A*]a large coherent cluster whose size is over 50%	context()	negated: False ,passive: False
0.911	[*A*]The final group[*R*]consists[*A*]of programs	context()	negated: False ,passive: True
[LINE#300]Out of the 30 programs 4 fall in this group.
[LINE#301]These programs are indent, ed, barcode and gcal.
0.767	[*A*]These programs[*R*]are[*A*]indent , gcal	context()	negated: False ,passive: True
0.903	[*A*]These programs[*R*]are[*A*]indent[*A*]barcode	context()	negated: False ,passive: True
0.903	[*A*]These programs[*R*]are[*A*]indent[*A*]ed	context()	negated: False ,passive: True
[LINE#302]From this group, we present indent as a case study in Section 3.6.2.In summary all but 7 of the 30 subject programs contain a large coherent cluster.
0.225	[*A*]we[*R*]present[*A*]indent	context()	negated: False ,passive: False
[LINE#303]Therefore, over 75% of the subject programs contain a coherent cluster of size 10% or more.
0.991	[*A*]over 75 % of the subject programs[*R*]contain[*A*]a coherent cluster of size	context()	negated: False ,passive: False
0.938	[*A*]over 75% of the subject programs[*R*]contain[*A*]a coherent cluster of size[*A*]10% or more	context()	negated: False ,passive: False
[LINE#304]Furthermore, half the programs contain a coherent cluster of at least 20% in size.
0.991	[*A*]half the programs[*R*]contain[*A*]a coherent cluster of at least 20 % in size	context()	negated: False ,passive: False
0.943	[*A*]half the programs[*R*]contain[*A*]a coherent cluster of at least 20% in size	context()	negated: False ,passive: False
[LINE#305]It is interesting to note that although this grouping is based only on the largest cluster, many of the programs contain multiple large coherent clusters.
0.903	[*A*]this grouping[*R*]is based[*A*]only on the largest cluster	context()	negated: False ,passive: True
[LINE#306]For example, ed, ctags, nano, less, bc, findutils, flex and garpd all have multiple large coherent clusters.
0.568	[*A*]flex all[*R*]have[*A*]multiple large coherent clusters	context()	negated: False ,passive: False
0.568	[*A*]less all[*R*]have[*A*]multiple large coherent clusters	context()	negated: False ,passive: False
0.381	[*A*]all[*R*]have[*A*]multiple large coherent clusters	context()	negated: False ,passive: False
[LINE#307]It is also interesting to note that there is no correlation between a program's size (measured in SLoC) and the size of its largest coherent cluster.
0.920	[*A*]a program's size[*R*]measured[*A*]in SLoC	context()	negated: False ,passive: True
[LINE#308]For example, in Table 1 two programs of very different sizes, cflow and userv, have similar largest-cluster sizes of 8% and 9%, respectively.
0.991	[*A*]1 two programs of userv[*R*]have[*A*]similar largest cluster sizes of 9 %	context()	negated: False ,passive: False
0.997	[*A*]in Table two programs of userv[*R*]have similar largest cluster sizes of[*A*]9 %	context()	negated: False ,passive: False
0.945	[*A*]in Table 1 two programs of userv[*R*]have[*A*]similar largest - cluster sizes of 9 %[*A*]respectively	context()	negated: False ,passive: False
0.991	[*A*]1 two programs of userv[*R*]have[*A*]similar largest cluster sizes of 8 %	context()	negated: False ,passive: False
0.997	[*A*]in Table two programs of userv[*R*]have similar largest cluster sizes of[*A*]8 %	context()	negated: False ,passive: False
0.945	[*A*]in Table 1 two programs of userv[*R*]have[*A*]similar largest - cluster sizes of 8 %[*A*]respectively	context()	negated: False ,passive: False
0.991	[*A*]1 two programs of cflow[*R*]have[*A*]similar largest cluster sizes of 9 %	context()	negated: False ,passive: False
0.997	[*A*]in Table two programs of cflow[*R*]have similar largest cluster sizes of[*A*]9 %	context()	negated: False ,passive: False
0.945	[*A*]in Table 1 two programs of cflow[*R*]have[*A*]similar largest - cluster sizes of 9 %[*A*]respectively	context()	negated: False ,passive: False
0.991	[*A*]1 two programs of cflow[*R*]have[*A*]similar largest cluster sizes of 8 %	context()	negated: False ,passive: False
0.997	[*A*]in Table two programs of cflow[*R*]have similar largest cluster sizes of[*A*]8 %	context()	negated: False ,passive: False
0.945	[*A*]in Table 1 two programs of cflow[*R*]have[*A*]similar largest - cluster sizes of 8 %[*A*]respectively	context()	negated: False ,passive: False
0.991	[*A*]1 two programs of very different sizes[*R*]have[*A*]similar largest cluster sizes of 9 %	context()	negated: False ,passive: False
0.997	[*A*]in Table two programs of very different sizes[*R*]have similar largest cluster sizes of[*A*]9 %	context()	negated: False ,passive: False
0.953	[*A*]in Table 1 two programs of very different sizes[*R*]have respectively[*A*]similar largest - cluster sizes of 9 %	context()	negated: False ,passive: False
0.991	[*A*]1 two programs of very different sizes[*R*]have[*A*]similar largest cluster sizes of 8 %	context()	negated: False ,passive: False
0.997	[*A*]in Table two programs of very different sizes[*R*]have similar largest cluster sizes of[*A*]8 %	context()	negated: False ,passive: False
0.953	[*A*]in Table 1 two programs of very different sizes[*R*]have respectively[*A*]similar largest - cluster sizes of 8 %	context()	negated: False ,passive: False
[LINE#309]Whereas programs acct and ed, of similar size, have very different largest coherent clusters of sizes 11% and 55%.Therefore as an answer to first part of RQ3, the study finds that 23 of the 30 programs studied have a large coherent cluster.
0.516	[*A*]ed of similar size[*R*]has % of[*A*]55 %	context()	negated: False ,passive: False
0.995	[*A*]ed of similar size[*R*]has sizes of[*A*]55 %	context()	negated: False ,passive: False
0.999	[*A*]ed of similar size[*R*]have[*A*]55 %	context()	negated: False ,passive: False
0.516	[*A*]ed of similar size[*R*]has % of[*A*]11 %	context()	negated: False ,passive: False
0.995	[*A*]ed of similar size[*R*]has sizes of[*A*]11 %	context()	negated: False ,passive: False
0.999	[*A*]ed of similar size[*R*]have[*A*]11 %	context()	negated: False ,passive: False
0.913	[*A*]ed , of similar size[*R*]have[*A*]very different largest coherent clusters of sizes	context()	negated: False ,passive: False
0.894	[*A*]23 of the 30 programs[*R*]have[*A*]a large coherent cluster	context(the study finds)	negated: False ,passive: False
0.853	[*A*]the study[*R*]finds[*A*]that 23 of the 30 programs studied have a large coherent cluster	context()	negated: False ,passive: False
0.751	[*A*]the 30 programs[*R*]studied	context()	negated: False ,passive: False
0.767	[*A*]programs[*R*]acct	context()	negated: False ,passive: False
[LINE#310]Some programs also have a huge cluster covering over 50% of the program vertices.
0.911	[*A*]a huge cluster[*R*]covering[*A*]over 50% of the program vertices	context()	negated: False ,passive: True
0.927	[*A*]Some programs[*R*]have[*A*]a huge cluster covering over 50% of the program vertices	context()	negated: False ,passive: False
[LINE#311]Furthermore, the choice of 10% as a threshold for classifying a cluster as large is a relatively conservative choice.
0.975	[*A*]the choice of 10% as a threshold for classifying a cluster as large[*R*]is[*A*]a relatively conservative choice	context()	negated: False ,passive: True
[LINE#312]Thus, the results presented in this section can be thought of as a lower bound to the existence question. .
0.801	[*A*]the results presented in this section[*R*]can be thought[*A*]as	context()	negated: False ,passive: True
0.903	[*A*]the results[*R*]presented[*A*]in this section	context()	negated: False ,passive: True
[LINE#313]Patterns of clusteringThis section presents a visual study of SCGs for the three program groups and addresses the second part of RQ3.
0.949	[*A*]Patterns of clusteringThis section[*R*]presents[*A*]a visual study of SCGs	context()	negated: False ,passive: False
[LINE#314]10-12 show graphs for the three categories.
[LINE#315] The graphs in the figures are laid out in ascending order based on the largest coherent cluster present in the program and thus follow the same order as seen in Fig.10 shows SCGs for the seven programs of the small group.
0.938	[*A*]The graphs[*R*]follow[*A*]the same order as seen in Fig.10[*A*]shows SCGs for the seven programs of the small group	context()	negated: False ,passive: False
0.894	[*A*]order[*R*]based[*A*]on the largest coherent cluster present in the program	context()	negated: False ,passive: True
0.944	[*A*]The graphs in the figures[*R*]in ascending[*A*]order based on the largest coherent cluster present in the program	context()	negated: False ,passive: False
[LINE#316] In the SCGs of the first three programs (archimedes, time and wdiff)only a small coherent cluster is visible in the red landscape.
0.967	[*A*]only a small coherent cluster[*R*]is[*A*]visible[*A*]in the red landscape[*A*]In the SCGs of the first three programs	context()	negated: False ,passive: True
[LINE#317]In the remaining four programs, the red landscape shows the presence of multiple small coherent clusters.
0.960	[*A*]the red landscape[*R*]shows[*A*]the presence of multiple small coherent clusters[*A*]In the remaining four programs	context()	negated: False ,passive: False
[LINE#318]It is very likely that, similar to the results of the case studies presented later, these clusters also depict logical constructs within each program.
0.783	[*A*]the case studies[*R*]presented[*A*]later	context()	negated: False ,passive: True
[LINE#319]11 shows SCGs of the 19 programs that have at least one large, but not huge, coherent cluster.
0.897	[*A*]the 19 programs[*R*]have[*A*]at least one not huge , coherent cluster	context()	negated: False ,passive: False
0.897	[*A*]the 19 programs[*R*]have[*A*]at least one large , coherent cluster	context()	negated: False ,passive: False
[LINE#320]That is, each program has at least one coherent cluster covering 10-50% of the program.
0.926	[*A*]at least one coherent cluster[*R*]covering[*A*]10-50% of the program	context()	negated: False ,passive: True
0.952	[*A*]each program[*R*]has[*A*]at least one coherent cluster covering 10-50% of the program	context()	negated: False ,passive: False
[LINE#321]Most of the programs have multiple coherent clusters as is visible on the red landscape.
0.919	[*A*]Most of the programs[*R*]have[*A*]multiple coherent clusters	context()	negated: False ,passive: False
[LINE#322]Some of these have only one large cluster satisfying the definition of large, such as acct.
0.919	[*A*]only one large cluster[*R*]satisfying[*A*]the definition of	context()	negated: False ,passive: False
0.699	[*A*]Some of these[*R*]have[*A*]only one large cluster satisfying the definition of large, such as acct	context()	negated: False ,passive: False
[LINE#323]The clustering of acct is discussed in further detail in Section 3.6.1.
0.919	[*A*]The clustering of acct[*R*]is discussed[*A*]in further detail[*A*]in Section 3.6.1	context()	negated: False ,passive: True
[LINE#324]Most of the remaining programs are seen to have multiple large clusters such as bc, which is also discussed in further detail in Section 3.6.3.
0.706	[*A*]bc[*R*]is discussed[*A*]in further detail[*A*]in Section 3.6.3	context()	negated: False ,passive: True
0.913	[*A*]Most of the remaining programs[*R*]to have[*A*]multiple large clusters such as bc	context()	negated: False ,passive: False
0.785	[*A*]Most of the remaining programs[*R*]are seen	context()	negated: False ,passive: False
[LINE#325]The presence of multiple large coherent cluster hints that the program consists of multiple functional components.
0.903	[*A*]the program[*R*]consists[*A*]of multiple functional components	context()	negated: False ,passive: True
[LINE#326] In three of the programs (which, gnuedma and copia)the landscape is completely dominated by a single large coherent cluster.
0.916	[*A*]the landscape[*R*]is dominated[*A*]by a single large coherent cluster[*A*]In three of the programs	context()	negated: False ,passive: True
0.859	[*A*]the landscape[*R*]is dominated[*A*]by a single large coherent cluster	context()	negated: False ,passive: True
[LINE#327]In which and gnuedma this cluster covers around 40% of the program vertices whereas in copia the cluster covers 50%.
[LINE#328]The presence of a single large dominating cluster points to a centralized functionality or structure being present in the program.
0.970	[*A*]The presence of a single large dominating cluster points to a centralized functionality or structure[*R*]being[*A*]present in the program	context()	negated: False ,passive: True
[LINE#329]Copia is presented as a case study in Section 3.6.4 where its clustering is discussed in further detail.
0.724	[*A*]its clustering[*R*]is discussed[*A*]Section 3.6.4	context()	negated: False ,passive: True
0.920	[*A*]Copia[*R*]is presented[*A*]as a case study in Section 3.6.4	context()	negated: False ,passive: True
[LINE#330] Finally, SCGs for the four programs that contain huge coherent clusters (covering over 50%) are found in Fig..
0.958	[*A*]SCGs for the four programs[*R*]are found[*A*]in Fig[*A*]Finally	context()	negated: False ,passive: True
0.897	[*A*]huge coherent clusters[*R*]covering[*A*]over 50%	context()	negated: False ,passive: True
0.897	[*A*]the four programs[*R*]contain[*A*]huge coherent clusters (covering over 50%	context()	negated: False ,passive: False
[LINE#331]In all four landscapes there is a very large dominating cluster with other smaller clusters also being visible.
0.754	[*A*]other smaller clusters[*R*]being[*A*]visible	context()	negated: False ,passive: True
[LINE#332]This pattern supports the conjecture that the program has one central structure or functionality which consists of most of the program elements, but also has additional logical constructs that work in support of the central idea.
0.920	[*A*]additional logical constructs[*R*]work[*A*]in support of the central idea	context()	negated: False ,passive: False
0.860	[*A*]This pattern[*R*]has[*A*]additional logical constructs that work in support of the central idea	context()	negated: False ,passive: False
0.913	[*A*]one central structure or functionality[*R*]consists[*A*]of most of the program elements	context()	negated: False ,passive: True
0.952	[*A*]the program[*R*]has[*A*]one central structure or functionality which consists of most of the program elements	context()	negated: False ,passive: False
0.845	[*A*]This pattern[*R*]supports[*A*]the conjecture that the program has one central structure or functionality	context()	negated: False ,passive: False
[LINE#333]Indent is one program that falls in this category and is discussed in further detail in Section 3.6.2.As an answer to second part of RQ3, the study finds that most programs contain multiple coherent clusters.
0.882	[*A*]most programs[*R*]contain[*A*]multiple coherent clusters	context(the study finds)	negated: False ,passive: False
0.896	[*A*]Indent[*R*]is[*A*]one program that is discussed in further detail in Section 3.6.2.As an answer to second part of RQ3	context(the study finds)	negated: False ,passive: True
0.868	[*A*]one program[*R*]is discussed[*A*]in Section 3.6.2.As	context()	negated: False ,passive: True
0.882	[*A*]most programs[*R*]contain[*A*]multiple coherent clusters	context(the study finds)	negated: False ,passive: False
0.816	[*A*]Indent[*R*]is[*A*]one program that falls in this category	context(the study finds)	negated: False ,passive: True
0.783	[*A*]the study[*R*]finds[*A*]that most programs contain multiple coherent clusters	context()	negated: False ,passive: False
0.913	[*A*]one program[*R*]falls[*A*]in this category	context()	negated: False ,passive: True
[LINE#334]Furthermore, the visual study reveals that a third of the programs have multiple large coherent clusters.
0.905	[*A*]a third of the programs[*R*]have[*A*]multiple large coherent clusters	context(the visual study reveals)	negated: False ,passive: False
0.822	[*A*]the visual study[*R*]reveals[*A*]that a third of the programs have multiple large coherent clusters	context()	negated: False ,passive: False
[LINE#335]Only three programs copia, gnuedma, and which show the presence of only a single (overwhelming) cluster covering most of the program.
0.938	[*A*]only a single ( overwhelming ) cluster[*R*]covering[*A*]most of the program	context()	negated: False ,passive: True
0.751	[*A*]Only three programs[*R*]copia	context()	negated: False ,passive: False
[LINE#336]Having shown that coherent clusters are prevalent in programs and that most programs have multiple significant clusters, the next section presents a series of four case studies that looks at how program structures are represented by these clusters. .
0.903	[*A*]program structures[*R*]are represented[*A*]by these clusters	context()	negated: False ,passive: True
0.897	[*A*]four case studies[*R*]looks[*A*]at how program structures are represented by these clusters	context()	negated: False ,passive: False
0.911	[*A*]the next section[*R*]presents[*A*]a series of four case studies	context()	negated: False ,passive: False
[LINE#337]Coherent cluster and program decompositionThis section presents four case studies using acct, indent, bc and copia.
0.919	[*A*]Coherent program decompositionThis section[*R*]presents[*A*]four case studies using copia	context()	negated: False ,passive: False
0.919	[*A*]Coherent program decompositionThis section[*R*]presents[*A*]four case studies using bc	context()	negated: False ,passive: False
0.919	[*A*]Coherent program decompositionThis section[*R*]presents[*A*]four case studies using indent	context()	negated: False ,passive: False
0.919	[*A*]Coherent program decompositionThis section[*R*]presents[*A*]four case studies using acct	context()	negated: False ,passive: False
0.911	[*A*]four case studies[*R*]using[*A*]copia	context()	negated: False ,passive: False
0.919	[*A*]Coherent cluster decompositionThis section[*R*]presents[*A*]four case studies using copia	context()	negated: False ,passive: False
0.911	[*A*]four case studies[*R*]using[*A*]bc	context()	negated: False ,passive: False
0.919	[*A*]Coherent cluster decompositionThis section[*R*]presents[*A*]four case studies using bc	context()	negated: False ,passive: False
0.911	[*A*]four case studies[*R*]using[*A*]indent	context()	negated: False ,passive: False
0.919	[*A*]Coherent cluster decompositionThis section[*R*]presents[*A*]four case studies using indent	context()	negated: False ,passive: False
0.911	[*A*]four case studies[*R*]using[*A*]acct	context()	negated: False ,passive: False
0.919	[*A*]Coherent cluster decompositionThis section[*R*]presents[*A*]four case studies using acct	context()	negated: False ,passive: False
[LINE#338] The case studies form a major contribution of the paper and collectively address research question RQ4:.
0.932	[*A*]The case studies[*R*]form[*A*]collectively address research question RQ4	context()	negated: False ,passive: False
0.932	[*A*]The case studies[*R*]form[*A*]a major contribution of the paper	context()	negated: False ,passive: False
[LINE#339] Which structures within a program can coherent cluster analysis reveal?.
[LINE#340]As coherent clusters consist of program vertices that are mutually inter-dependent and share extra-cluster properties we consider such vertices of the cluster to be tightly coupled.
0.529	[*A*]share extra-cluster properties we consider such vertices of the cluster[*R*]to be tightly coupled	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]consider[*A*]such vertices of the cluster	context()	negated: False ,passive: False
0.735	[*A*]program vertices[*R*]are[*A*]mutually inter-dependent	context()	negated: False ,passive: True
0.903	[*A*]coherent clusters[*R*]consist[*A*]of program vertices	context()	negated: False ,passive: True
[LINE#341]It is our conjecture that these clusters likely represent logical structures representing a high-level functional decomposition of systems.
0.903	[*A*]logical structures[*R*]representing[*A*]a high-level functional decomposition of systems	context()	negated: False ,passive: False
0.927	[*A*]these clusters[*R*]represent[*A*]logical structures representing a high-level functional decomposition of systems	context()	negated: False ,passive: False
0.178	[*A*]It[*R*]is[*A*]our conjecture that these clusters likely represent logical structures	context()	negated: False ,passive: True
[LINE#342]This study will therefore look at how coherent clusters map to logical structures of the program.
0.784	[*A*]coherent clusters[*R*]map	context()	negated: False ,passive: False
0.907	[*A*]This study[*R*]will look[*A*]at how coherent clusters map to logical structures of the program	context()	negated: False ,passive: False
[LINE#343]The case studies have been chosen to represent the large and huge groups identified in the previous section.
0.911	[*A*]the huge groups[*R*]identified[*A*]in the previous section	context()	negated: False ,passive: True
0.897	[*A*]The case studies[*R*]to represent[*A*]the huge groups identified in the previous section	context()	negated: False ,passive: False
0.911	[*A*]The case studies[*R*]have been chosen[*A*]to represent the huge groups	context()	negated: False ,passive: True
0.911	[*A*]the large groups[*R*]identified[*A*]in the previous section	context()	negated: False ,passive: True
0.897	[*A*]The case studies[*R*]to represent[*A*]the large groups identified in the previous section	context()	negated: False ,passive: False
0.911	[*A*]The case studies[*R*]have been chosen[*A*]to represent the large groups	context()	negated: False ,passive: True
[LINE#344]Three programs are taken from the large group as it consists of the majority of the programs and one from the huge group.
0.569	[*A*]it[*R*]consists[*A*]of the majority of the one from the huge group	context()	negated: False ,passive: True
0.890	[*A*]Three programs[*R*]are taken[*A*]from the large group[*A*]as it consists of the majority of the one from the huge group	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]consists[*A*]of the majority of the programs	context()	negated: False ,passive: True
0.835	[*A*]Three programs[*R*]are taken[*A*]from the large group[*A*]as it consists of the majority of the programs	context()	negated: False ,passive: True
[LINE#345]Each of the three programs from the large group were chosen because it exhibits specific patterns.
0.452	[*A*]it[*R*]exhibits[*A*]specific patterns	context()	negated: False ,passive: False
0.909	[*A*]Each of the three programs from the large group[*R*]were chosen[*A*]because it exhibits specific patterns	context()	negated: False ,passive: True
[LINE#346]acct has multiple coherent clusters visible in its profile and has the smallest large cluster in the group, bc has multiple large coherent clusters, and copia has only a single large coherent cluster dominating the entire landscape..
0.822	[*A*]acct[*R*]has[*A*]the smallest large cluster in the group	context(bc has)	negated: False ,passive: False
0.715	[*A*]acct[*R*]has[*A*]multiple coherent clusters visible in its profile	context(bc has)	negated: False ,passive: False
0.822	[*A*]bc[*R*]has[*A*]multiple large coherent clusters	context()	negated: False ,passive: False
0.932	[*A*]only a single large coherent cluster[*R*]dominating[*A*]the entire landscape	context()	negated: False ,passive: False
0.947	[*A*]copia[*R*]has[*A*]only a single large coherent cluster dominating the entire landscape	context()	negated: False ,passive: False
[LINE#347]acctThe first of the series of case studies is acct, an open-source program used for monitoring and printing statistics about users and processes.
0.926	[*A*]an open - source program[*R*]used[*A*]for printing statistics about processes	context()	negated: False ,passive: True
0.926	[*A*]an open - source program[*R*]used[*A*]for printing statistics about users	context()	negated: False ,passive: True
0.926	[*A*]an open - source program[*R*]used[*A*]for monitoring about processes	context()	negated: False ,passive: True
0.926	[*A*]an open - source program[*R*]used[*A*]for monitoring about users	context()	negated: False ,passive: True
0.958	[*A*]acctThe[*R*]is[*A*]acct , an open - source program[*A*]first of the series of case studies	context()	negated: False ,passive: True
[LINE#348]The program acct is one of the smaller programs with 2600 LoC and 1558 SLoC from which CodeSurfer produced 2834 slices.
0.961	[*A*]CodeSurfer[*R*]produced[*A*]2834 slices[*A*]2600 1558 SLoC	context()	negated: False ,passive: False
0.942	[*A*]The program acct[*R*]is[*A*]one of the smaller programs with 2600 1558 SLoC	context()	negated: False ,passive: True
0.942	[*A*]The program acct[*R*]is[*A*]one of the smaller programs with 2600 LoC	context()	negated: False ,passive: True
[LINE#349]The program has seven C files, two of which, getopt.c and getopt1.c, contain only conditionally included functions.
0.905	[*A*]The program[*R*]has[*A*]seven C files	context(two of which contain)	negated: False ,passive: False
0.628	[*A*]two of which[*R*]contain[*A*]only conditionally included functions[*A*]getopt1.c	context()	negated: False ,passive: False
0.905	[*A*]The program[*R*]has[*A*]seven C files	context(two of which contain)	negated: False ,passive: False
0.628	[*A*]two of which[*R*]contain[*A*]only conditionally included functions[*A*]getopt.c	context()	negated: False ,passive: False
[LINE#350]These functions provide support for command-line argument processing and are included if needed library code is missing.
0.727	[*A*]if needed library code[*R*]is missing	context(These functions are included)	negated: False ,passive: False
0.882	[*A*]These functions[*R*]are included[*A*]if needed library code is missing	context()	negated: False ,passive: True
0.903	[*A*]These functions[*R*]provide[*A*]support for command - line argument processing	context()	negated: False ,passive: False
[LINE#351]Table 4 shows the statistics for the five largest clusters of acct.
0.636	[*A*]Table 4[*R*]shows[*A*]the statistics for the five largest clusters of acct	context()	negated: False ,passive: False
[LINE#352] Column 1 gives the cluster number, where 1 is the largest and 5is the 5th largest cluster measured using the number of vertices.
0.919	[*A*]the 5th largest cluster[*R*]measured[*A*]using the number of vertices	context()	negated: False ,passive: True
0.495	[*A*]1[*R*]is[*A*]5is	context()	negated: False ,passive: True
0.961	[*A*]Column 1[*R*]gives[*A*]the cluster number , where 1 is 5is the 5th largest cluster	context()	negated: False ,passive: False
0.223	[*A*]1[*R*]is[*A*]the largest	context()	negated: False ,passive: True
0.927	[*A*]Column 1[*R*]gives[*A*]the cluster number , where 1 is the largest	context()	negated: False ,passive: False
[LINE#353]Columns 2 and 3 show the size of the cluster as a percentage of the program's vertices and actual vertex count, as well as the line count.
0.964	[*A*]Columns 3[*R*]show[*A*]the size of the cluster as a percentage of the line count	context()	negated: False ,passive: False
0.964	[*A*]Columns 3[*R*]show[*A*]the size of the cluster as a percentage of actual vertex count	context()	negated: False ,passive: False
0.964	[*A*]Columns 3[*R*]show[*A*]the size of the cluster as a percentage of the program 's vertices	context()	negated: False ,passive: False
0.964	[*A*]Columns 2[*R*]show[*A*]the size of the cluster as a percentage of the line count	context()	negated: False ,passive: False
0.964	[*A*]Columns 2[*R*]show[*A*]the size of the cluster as a percentage of actual vertex count	context()	negated: False ,passive: False
0.964	[*A*]Columns 2[*R*]show[*A*]the size of the cluster as a percentage of the program 's vertices	context()	negated: False ,passive: False
[LINE#354]Columns 4 and 5 show the number of files and functions where the cluster is found.
0.933	[*A*]the cluster[*R*]is found[*A*]functions	context()	negated: False ,passive: True
0.933	[*A*]the cluster[*R*]is found[*A*]files	context()	negated: False ,passive: True
[LINE#355]The cluster sizes range from 11.4% to 2.4%.
0.911	[*A*]The cluster sizes[*R*]range[*A*]from 11.4%[*A*]to 2.4%	context()	negated: False ,passive: True
[LINE#356]These five clusters can be readily identified in the Heat-Map visualization (not shown) of decluvi.
0.807	[*A*]the Heat-Map visualization[*R*]not shown	context()	negated: True ,passive: False
0.952	[*A*]These five clusters[*R*]can be readily identified[*A*]in the Heat-Map visualization (not shown) of decluvi	context()	negated: False ,passive: True
[LINE#357]The rest of the clusters are very small (less than 2% or 30 vertices) in size and are thus of little interest.
0.739	[*A*]size[*R*]has The rest of[*A*]30 vertices	context()	negated: False ,passive: False
0.867	[*A*]The rest of the clusters[*R*]has size of[*A*]30 vertices	context()	negated: False ,passive: False
0.973	[*A*]The rest of the clusters[*R*]are[*A*]30 vertices	context()	negated: False ,passive: False
0.998	[*A*]the clusters[*R*]have The rest of[*A*]30 vertices	context()	negated: False ,passive: False
0.913	[*A*]The rest of the clusters[*R*]are[*A*]thus of little interest	context()	negated: False ,passive: True
0.814	[*A*]The rest of the clusters[*R*]are[*A*]very small	context()	negated: False ,passive: True
[LINE#358]The B-SCG for acct (row one of Fig. 11) shows the existence of these five coherent clusters along with other same-slice clusters.
0.965	[*A*]row one of Fig[*R*]shows[*A*]the existence of these five coherent clusters along with other same-slice clusters	context()	negated: False ,passive: False
[LINE#359]Splitting of the same-slice cluster is evident in the SCG.
0.960	[*A*]Splitting of the same-slice cluster[*R*]is[*A*]evident[*A*]in the SCG	context()	negated: False ,passive: True
[LINE#360]Splitting occurs when the vertices of a same-slice cluster become part of different coherent clusters.
0.943	[*A*]the vertices of a same-slice cluster[*R*]become[*A*]part of different coherent clusters	context()	negated: False ,passive: True
0.657	[*A*]Splitting[*R*]occurs[*A*]when the vertices of a same-slice cluster become part of different coherent clusters	context()	negated: False ,passive: True
[LINE#361]This happens when vertices have either the same backward slice or the same forward slice but not both.
0.931	[*A*]vertices[*R*]have[*A*]either the same backward slice or the same forward slice but not both	context()	negated: False ,passive: False
0.497	[*A*]This[*R*]happens[*A*]when vertices have either the same backward slice or the same forward slice but not both	context()	negated: False ,passive: True
[LINE#362] This is because either same-backward-slice or same-forward-slice clusters only capture one of the two external properties captured by coherent clusters.
0.919	[*A*]the two external properties[*R*]captured[*A*]by coherent clusters	context()	negated: False ,passive: True
0.958	[*A*]either same-backward-slice or same-forward-slice clusters[*R*]capture[*A*]one of the two external properties	context()	negated: False ,passive: False
0.567	[*A*]This[*R*]is[*A*]because either same-backward-slice or same-forward-slice clusters only capture one of the two external properties	context()	negated: False ,passive: True
[LINE#363]In acct's B-SCG the vertices of the largest same-backward-slice cluster spanning the x-axis from 60% to 75% are not part of the same coherent cluster.
0.993	[*A*]the vertices of the largest same-backward-slice cluster spanning the x-axis from 60% to 75%[*R*]are not[*A*]part of the same coherent cluster[*A*]In acct's B-SCG	context()	negated: True ,passive: True
0.943	[*A*]the largest same-backward-slice cluster[*R*]spanning[*A*]the x-axis	context()	negated: False ,passive: False
[LINE#364]This is because the vertices do not share the same forward slice which is also a requirement for coherent clusters.
0.927	[*A*]the same forward slice[*R*]is[*A*]also[*A*]a requirement for coherent clusters	context()	negated: False ,passive: True
0.937	[*A*]the vertices[*R*]do not share[*A*]the same forward slice which is also a requirement for coherent clusters	context()	negated: True ,passive: False
0.567	[*A*]This[*R*]is[*A*]because the vertices do not share the same forward slice	context()	negated: False ,passive: True
[LINE#365]This phenomenon is common in the programs studied and is found in both same-backward-slice and same-forward-slice clusters.
0.813	[*A*]This phenomenon[*R*]is[*A*]common	context()	negated: False ,passive: True
[LINE#366]This is another reason why coherent clusters are often smaller in size then same-slice clusters.
0.903	[*A*]coherent clusters[*R*]are[*A*]often smaller in size	context()	negated: False ,passive: True
0.567	[*A*]This[*R*]is[*A*]another reason why coherent clusters are often smaller in size then same-slice clusters	context()	negated: False ,passive: True
[LINE#367] Decluvi visualization (not shown) of acct reveals that the largest cluster spans four files (file_rd.c, common.c, ac.c, and utmp_rd.c), the 2nd largest cluster spans only a single file(hashtab.c), the 3rd largest cluster spans three files (file_rd.c, ac.c, and hashtab.c), the 4th largest cluster spans two files (ac.c and hashtab.c), while the 5th largest cluster includes parts of ac.c only.
0.927	[*A*]Decluvi visualization ( not shown ) of acct[*R*]reveals[*A*]that the largest cluster spans four files ( utmp_rd.c ) , the 2nd largest cluster spans only a single file	context()	negated: False ,passive: False
0.927	[*A*]Decluvi visualization ( not shown ) of acct[*R*]reveals[*A*]that the largest cluster spans four files ( ac.c ) , the 2nd largest cluster spans only a single file	context()	negated: False ,passive: False
0.927	[*A*]Decluvi visualization ( not shown ) of acct[*R*]reveals[*A*]that the largest cluster spans four files ( common.c ) , the 2nd largest cluster spans only a single file	context()	negated: False ,passive: False
0.923	[*A*]the 2nd largest cluster[*R*]spans[*A*]only a single file	context(Decluvi visualization ( not shown ) of acct reveals)	negated: False ,passive: False
0.927	[*A*]Decluvi visualization ( not shown ) of acct[*R*]reveals[*A*]that the largest cluster spans four files ( file_rd.c ) , the 2nd largest cluster spans only a single file	context()	negated: False ,passive: False
0.919	[*A*]the 5th largest cluster[*R*]includes[*A*]parts of ac.c only	context()	negated: False ,passive: True
0.758	[*A*]Decluvi visualization[*R*]not shown	context()	negated: True ,passive: False
[LINE#368]The largest cluster of acct is spread over six functions, log_in, log_out, file_open, file_reader_get_entry, bad_utmp_record and utmp_get_entry.
0.926	[*A*]The largest cluster of acct[*R*]is spread[*A*]over six functions[*A*]log_out	context()	negated: False ,passive: True
0.926	[*A*]The largest cluster of acct[*R*]is spread[*A*]over six functions	context()	negated: False ,passive: True
[LINE#369]These functions are responsible for putting accounting records into the hash table used by the program, accessing user-defined files, and reading entries from the file.
0.911	[*A*]the hash table[*R*]used[*A*]by the program	context()	negated: False ,passive: True
0.937	[*A*]These functions[*R*]are[*A*]responsible for putting accounting records into the hash table used by the program, accessing user-defined files, and reading entries from the file	context()	negated: False ,passive: True
[LINE#370]Thus, the purpose of the code in this cluster is to track user login and logout events.
0.957	[*A*]the purpose of the code in this cluster[*R*]is[*A*]to track user logout events	context()	negated: False ,passive: True
0.957	[*A*]the purpose of the code in this cluster[*R*]is[*A*]to track user login events	context()	negated: False ,passive: True
[LINE#371]The second largest cluster is spread over two functions hashtab_create and hashtab_resize.
0.919	[*A*]The second largest cluster[*R*]is spread[*A*]over two functions	context()	negated: False ,passive: True
[LINE#372]These functions are responsible for creating fresh hash tables and resizing existing hash tables when the number of entries becomes too large.
0.799	[*A*]the number of entries[*R*]becomes[*A*]too large	context()	negated: False ,passive: True
0.903	[*A*]These functions[*R*]are[*A*]responsible for resizing existing hash tables	context()	negated: False ,passive: True
0.903	[*A*]These functions[*R*]are[*A*]responsible for creating fresh hash tables	context()	negated: False ,passive: True
[LINE#373]The purpose of the code in this cluster is the memory management in support of the program's main data structure.
0.957	[*A*]The purpose of the code in this cluster[*R*]is[*A*]the memory management	context()	negated: False ,passive: True
[LINE#374]The third largest cluster is spread over four functions: hashtab_set_value, log_everyone_out, update_user_time, and hashtab_create.
0.919	[*A*]The third largest cluster[*R*]is spread[*A*]over four functions	context()	negated: False ,passive: True
[LINE#375]These functions are responsible for setting values of an entry, updating all the statistics for users, and resetting the tables.
0.903	[*A*]These functions[*R*]are[*A*]responsible for resetting the tables	context()	negated: False ,passive: True
0.887	[*A*]These functions[*R*]for updating[*A*]all the statistics for users	context()	negated: False ,passive: False
0.903	[*A*]These functions[*R*]are[*A*]responsible for updating all the statistics for users	context()	negated: False ,passive: True
0.903	[*A*]These functions[*R*]are[*A*]responsible for setting values of an entry	context()	negated: False ,passive: True
[LINE#376]The purpose of the code from this cluster is the modification of the user accounting data.
0.957	[*A*]The purpose of the code from this cluster[*R*]is[*A*]the modification of the user accounting data	context()	negated: False ,passive: True
[LINE#377]The fourth cluster is spread over three functions: hashtab_delete, do_statistics, and hashtab_find.
0.911	[*A*]The fourth cluster[*R*]is spread[*A*]over three functions	context()	negated: False ,passive: True
[LINE#378]These functions are responsible for removing entries from the hash table, printing out statistics for users and finding entries in the hash table.
0.903	[*A*]These functions[*R*]are[*A*]responsible for finding entries in the hash table	context()	negated: False ,passive: True
0.887	[*A*]These functions[*R*]for printing out[*A*]statistics for users	context()	negated: False ,passive: False
0.903	[*A*]These functions[*R*]are[*A*]responsible for printing out statistics for users	context()	negated: False ,passive: True
0.903	[*A*]These functions[*R*]are[*A*]responsible for removing entries from the hash table	context()	negated: False ,passive: True
[LINE#379]The purpose of the code from this cluster is maintaining user accounting data and printing results.
0.943	[*A*]The purpose of the code from this cluster[*R*]is maintaining[*A*]user printing results	context()	negated: False ,passive: False
0.943	[*A*]The purpose of the code from this cluster[*R*]is maintaining[*A*]user accounting data	context()	negated: False ,passive: False
[LINE#380]The fifth cluster is contained within the function main.
0.911	[*A*]The fifth cluster[*R*]is contained[*A*]within the function main	context()	negated: False ,passive: True
[LINE#381]This cluster is formed due to the use of a while loop containing various cases based on input to the program.
0.903	[*A*]various cases[*R*]based[*A*]on input to the program	context()	negated: False ,passive: True
0.911	[*A*]a while loop[*R*]containing[*A*]various cases based on input to the program	context()	negated: False ,passive: False
0.903	[*A*]This cluster[*R*]is formed[*A*]due to the use of a while loop	context()	negated: False ,passive: True
[LINE#382]Because of the conservative nature of static analysis, all the code within the loop is part of the same cluster.
0.948	[*A*]all the code within the loop[*R*]is[*A*]part of the same cluster	context()	negated: False ,passive: True
[LINE#383]Finally, it is interesting to note that functions from the same file or with similar names do not necessarily belong to the same cluster.
[LINE#384]Intuitively, it can be presumed that functions that have similar names or prefixes work together to provide some common functionality.
[LINE#385]In this case, six functions that have the same common prefix "hashtab" all perform operations on the hash table.
0.321	[*A*]all[*R*]perform[*A*]operations[*A*]on the hash table	context(six functions that have the same common prefix hashtab)	negated: False ,passive: False
0.858	[*A*]six functions[*R*]have[*A*]the same common prefix	context(six functions that have the same common prefix hashtab)	negated: False ,passive: False
0.942	[*A*]six functions that have the same common prefix[*R*]hashtab[*A*]all perform operations on the hash table[*A*]In this case	context()	negated: False ,passive: False
[LINE#386]However, these six functions are not part of the same cluster.
0.911	[*A*]these six functions[*R*]are not[*A*]part of the same cluster	context()	negated: True ,passive: True
[LINE#387]Instead the functions that work together to provide a particular functionality are found in the same cluster.
0.858	[*A*]the functions[*R*]work together to provide[*A*]a particular functionality	context(the functions work together)	negated: False ,passive: False
0.858	[*A*]the functions[*R*]work together[*A*]to provide a particular functionality	context()	negated: False ,passive: False
0.913	[*A*]the functions that work together[*R*]are found[*A*]in the same cluster	context()	negated: False ,passive: True
[LINE#388]The clusters help identify functionality which is not obvious from the name of program artefacts such as functions and files.
0.923	[*A*]The clusters[*R*]help identify[*A*]functionality which is not obvious from the name of program artefacts such as files	context(The clusters help)	negated: False ,passive: False
0.920	[*A*]functionality[*R*]is not[*A*]obvious from the name of program artefacts such as files	context()	negated: True ,passive: True
0.923	[*A*]The clusters[*R*]help identify[*A*]functionality which is not obvious from the name of program artefacts such as functions	context(The clusters help)	negated: False ,passive: False
0.908	[*A*]The clusters[*R*]help[*A*]identify functionality	context()	negated: False ,passive: False
0.920	[*A*]functionality[*R*]is not[*A*]obvious from the name of program artefacts such as functions	context()	negated: True ,passive: True
[LINE#389]As an answer to RQ4, we find that in this case study each of the top five clusters maps to specific logical functionality. .
0.330	[*A*]we[*R*]find[*A*]that in this case study each of the top five clusters maps to specific logical functionality	context()	negated: False ,passive: False
[LINE#390]indentThe next case study uses indent to further support the answer found for RQ4 in the acct case study.
0.886	[*A*]the answer[*R*]found[*A*]in the acct case study	context()	negated: False ,passive: True
0.894	[*A*]study[*R*]uses[*A*]indent[*A*]to further support the answer	context()	negated: False ,passive: False
[LINE#391]The characteristics of indent are very different from those of acct as indent has a very large dominant coherent cluster (52%) whereas acct has multiple smaller clusters with the largest being 11%.
0.852	[*A*]acct[*R*]has[*A*]multiple smaller clusters with the largest being 11%	context()	negated: False ,passive: False
0.918	[*A*]indent[*R*]has[*A*]a very large dominant coherent cluster	context()	negated: False ,passive: False
0.869	[*A*]The characteristics of indent[*R*]are[*A*]very different from those of acct[*A*]as indent has a very large dominant coherent cluster (52%) whereas acct has multiple smaller clusters with the largest being 11%	context()	negated: False ,passive: True
[LINE#392]We include indent as a case study to ensure that the answer for RQ4 is derived from programs with different cluster profiles and sizes giving confidence as to the generality of the answer.
0.911	[*A*]different cluster sizes[*R*]giving[*A*]confidence[*A*]as to the generality of the answer	context()	negated: False ,passive: False
0.911	[*A*]different cluster profiles[*R*]giving[*A*]confidence[*A*]as to the generality of the answer	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]include[*A*]indent as a case study	context()	negated: False ,passive: True
[LINE#393]Indent is a Unix utility used to format C source code.
0.933	[*A*]a Unix utility[*R*]used[*A*]to format C source code	context()	negated: False ,passive: True
0.948	[*A*]Indent[*R*]is[*A*]a Unix utility	context()	negated: False ,passive: True
[LINE#394]It consists of 6978 LoC with 7543 vertices in the SDG produced by CodeSurfer.
0.887	[*A*]the SDG[*R*]produced[*A*]by CodeSurfer	context()	negated: False ,passive: True
0.498	[*A*]It[*R*]consists[*A*]of 6978 LoC with 7543 vertices in the SDG	context()	negated: False ,passive: True
[LINE#395]Table 5 shows statistics of the five largest clusters found in the program.
0.919	[*A*]the five largest clusters[*R*]found[*A*]in the program	context()	negated: False ,passive: True
0.636	[*A*]Table 5[*R*]shows[*A*]statistics of the five largest clusters	context()	negated: False ,passive: False
[LINE#396]Indent has one extremely large coherent cluster that spans 52.1% of the program's vertices.
0.933	[*A*]one extremely large coherent cluster[*R*]spans[*A*]52.1% of the program's vertices	context()	negated: False ,passive: False
0.899	[*A*]Indent[*R*]has[*A*]one extremely large coherent cluster that spans 52.1% of the program's vertices	context()	negated: False ,passive: False
[LINE#397]The cluster is formed of vertices from 54 functions spread over 7 source files.
0.903	[*A*]54 functions[*R*]spread[*A*]over 7 source files	context()	negated: False ,passive: True
0.732	[*A*]The cluster[*R*]is formed	context()	negated: False ,passive: False
[LINE#398]This cluster captures most of the logical functionalities of the program.
0.903	[*A*]This cluster[*R*]captures[*A*]most of the logical functionalities of the program	context()	negated: False ,passive: False
[LINE#399]Out of the 54 functions, 26 begin with the common prefix of "handle_token".
0.720	[*A*]26[*R*]begin[*A*]with the common prefix of "handle_token[*A*]Out of the 54 functions	context()	negated: False ,passive: True
[LINE#400]These 26 functions are individually responsible for handling a specific token during the formatting process.
0.943	[*A*]These 26 functions[*R*]are[*A*]individually responsible for handling a specific token during the formatting process	context()	negated: False ,passive: True
[LINE#401]For example, handle_token_colon, handle_token_comma, handle_token_comment, and handle_token_lbrace are responsible for handling the colon, comma, comment, and left brace tokens, respectively.
0.927	[*A*]handle_token_colon handle_token_lbrace[*R*]are[*A*]responsible for handling the colon , comma , comment	context()	negated: False ,passive: True
0.927	[*A*]handle_token_colon handle_token_comment[*R*]are[*A*]responsible for handling the colon , comma , comment	context()	negated: False ,passive: True
0.920	[*A*]handle_token_comma[*R*]are[*A*]responsible for handling the colon , comma , comment	context()	negated: False ,passive: True
[LINE#402]This cluster also includes multiple handler functions that check the size of the code and labels being handled, such as check_code_size and check_lab_size.
0.933	[*A*]multiple handler functions[*R*]check[*A*]the labels being handled , such as check_lab_size	context()	negated: False ,passive: False
0.847	[*A*]This cluster[*R*]includes[*A*]multiple handler functions that check the labels being handled , such as check_lab_size	context()	negated: False ,passive: True
0.732	[*A*]the labels[*R*]being handled	context()	negated: False ,passive: False
0.933	[*A*]multiple handler functions[*R*]check[*A*]the labels being handled , such as check_code_size	context()	negated: False ,passive: False
0.847	[*A*]This cluster[*R*]includes[*A*]multiple handler functions that check the labels being handled , such as check_code_size	context()	negated: False ,passive: True
0.920	[*A*]multiple handler functions[*R*]check[*A*]the size of the code	context()	negated: False ,passive: False
0.822	[*A*]This cluster[*R*]includes[*A*]multiple handler functions that check the size of the code	context()	negated: False ,passive: True
[LINE#403]Others, such as search_brace, sw_buffer, print_comment, and reduce, help with tracking braces and comments in code.
[LINE#404]The cluster also spans the main loop of indent (indent_main_loop) that repeatedly calls the parser function parse.
0.961	[*A*]the main loop of indent[*R*]calls[*A*]the parser function parse[*A*]repeatedly	context()	negated: False ,passive: False
0.860	[*A*]The cluster[*R*]spans[*A*]the main loop of indent (indent_main_loop) that repeatedly calls the parser function parse	context()	negated: False ,passive: False
[LINE#405]Finally, the cluster consists of code for outputting formatted lines such as the functions better_break, computer_code_target, dump_line, dump_line_code, dump_line_label, inhibit_indenting, is_comment_start, output_line_length and slip_horiz_space, and ones that perform flag and memory management (clear_buf_break_list, fill_buffer and set_priority).Cluster 1 therefore consists of the main functionality of this program and provides support for parsing, handling tokens, associated memory management, and output.
0.877	[*A*]ones[*R*]perform[*A*]memory management	context()	negated: False ,passive: False
0.877	[*A*]ones[*R*]perform[*A*]flag management	context()	negated: False ,passive: False
0.897	[*A*]support for parsing[*R*]handling[*A*]output	context()	negated: False ,passive: False
0.955	[*A*]better_break , computer_code_target , dump_line , dump_line_code , dump_line_label[*R*]provides[*A*]support for parsing , handling output	context()	negated: False ,passive: False
0.913	[*A*]better_break , computer_code_target , dump_line , dump_line_code , dump_line_label[*R*]provides support for parsing handling[*A*]associated memory management	context(better_break , computer_code_target , dump_line , dump_line_code , dump_line_label provides)	negated: False ,passive: False
0.942	[*A*]better_break , computer_code_target , dump_line , dump_line_code , dump_line_label[*R*]provides[*A*]support for parsing[*A*]handling associated memory management	context()	negated: False ,passive: False
0.913	[*A*]better_break , computer_code_target , dump_line , dump_line_code , dump_line_label[*R*]provides support for parsing handling[*A*]tokens	context(better_break , computer_code_target , dump_line , dump_line_code , dump_line_label provides)	negated: False ,passive: False
0.942	[*A*]better_break , computer_code_target , dump_line , dump_line_code , dump_line_label[*R*]provides[*A*]support for parsing[*A*]handling tokens	context()	negated: False ,passive: False
0.740	[*A*]dump_line_label[*R*]inhibit_indenting	context()	negated: False ,passive: False
0.964	[*A*]the cluster[*R*]consists[*A*]of code for outputting formatted lines such as the functions[*A*]Finally	context()	negated: False ,passive: True
[LINE#406]The parsing, handling of individual tokens and associated memory management are highly inter-twined.
0.854	[*A*]The parsing , handling of associated memory management[*R*]are[*A*]highly inter-twined	context()	negated: False ,passive: True
0.842	[*A*]The parsing , handling of individual tokens[*R*]are[*A*]highly inter-twined	context()	negated: False ,passive: True
[LINE#407]For example, the handling of each individual token is dictated by operations of indent and closely depends on the parsing.
0.933	[*A*]the handling of each individual token[*R*]is[*A*]closely[*A*]depends on the parsing	context()	negated: False ,passive: True
0.932	[*A*]the handling of each individual token[*R*]is dictated[*A*]by operations of indent	context()	negated: False ,passive: True
[LINE#408]This code cannot easily be decoupled and, for example, reused.
0.698	[*A*]This code[*R*]reused	context()	negated: False ,passive: False
0.732	[*A*]This code[*R*]can not easily be decoupled	context()	negated: True ,passive: False
[LINE#409]Similarly the memory management code is specific to the data structures used by indent resulting in these many logical constructs to become part of the same cluster.
0.911	[*A*]the data structures[*R*]used[*A*]by indent[*A*]to become part of the same cluster	context()	negated: False ,passive: True
0.937	[*A*]the memory management code[*R*]is[*A*]specific to the data structures	context()	negated: False ,passive: True
[LINE#410]The second largest coherent cluster consists of 7 functions from 3 source files.
0.926	[*A*]The second largest coherent cluster[*R*]consists[*A*]of 7 functions from 3 source files	context()	negated: False ,passive: True
[LINE#411]These functions handle the arguments and parameters passed to indent.
0.903	[*A*]the parameters[*R*]passed[*A*]to indent	context()	negated: False ,passive: True
0.903	[*A*]These functions[*R*]handle[*A*]the parameters passed to indent	context()	negated: False ,passive: False
0.903	[*A*]the arguments[*R*]passed[*A*]to indent	context()	negated: False ,passive: True
0.903	[*A*]These functions[*R*]handle[*A*]the arguments passed to indent	context()	negated: False ,passive: False
[LINE#412]For example, set_option and option_prefix along with the helper function eqin to check and verify that the options or parameters passed to indent are valid.
0.915	[*A*]For example, set_option and option_prefix along with the helper function eqin to check and verify[*R*]are[*A*]valid	context()	negated: False ,passive: True
0.919	[*A*]the options or parameters[*R*]passed[*A*]to indent	context()	negated: False ,passive: True
[LINE#413]When options are specified without the required arguments, the function arg_missing produces an error message by invoking usage followed by a call to DieError to terminate the program.
0.713	[*A*]usage[*R*]followed	context()	negated: False ,passive: False
0.948	[*A*]the function arg_missing[*R*]produces[*A*]an error message[*A*]When options are specified without the required arguments	context()	negated: False ,passive: False
0.713	[*A*]options[*R*]are specified	context()	negated: False ,passive: False
[LINE#414]Clusters 3-5 are less than 3% of the program and are too small to warrant a detailed discussion.
0.877	[*A*]Clusters[*R*]to warrant[*A*]a detailed discussion	context()	negated: False ,passive: False
0.894	[*A*]Clusters[*R*]are[*A*]too small to warrant a detailed discussion	context()	negated: False ,passive: True
0.586	[*A*]Clusters 3-5[*R*]have the program of[*A*]less than 3 %	context()	negated: False ,passive: False
0.973	[*A*]Clusters 3-5[*R*]are[*A*]less than 3 %	context()	negated: False ,passive: False
0.903	[*A*]Clusters 3-5[*R*]are[*A*]less than 3 % of the program	context()	negated: False ,passive: True
[LINE#415]Cluster 3 includes 6 functions that generate numbered/un-numbered backup for subject files.
0.887	[*A*]6 functions[*R*]generate[*A*]numbered/un-numbered backup for subject files	context()	negated: False ,passive: False
0.881	[*A*]Cluster 3[*R*]includes[*A*]6 functions that generate numbered/un-numbered backup for subject files	context()	negated: False ,passive: True
[LINE#416]Cluster 4 has functions for reading and ignoring comments.
0.944	[*A*]Cluster 4[*R*]has[*A*]functions	context()	negated: False ,passive: False
[LINE#417]Cluster 5 consists of a single function that reinitializes the parser and associated data structures.
0.897	[*A*]a single function[*R*]reinitializes[*A*]the associated data structures	context()	negated: False ,passive: False
0.897	[*A*]a single function[*R*]reinitializes[*A*]the parser	context()	negated: False ,passive: False
0.927	[*A*]Cluster 5[*R*]consists[*A*]of a single function	context()	negated: False ,passive: True
[LINE#418]The case study of indent further illustrates that coherent clusters can capture the program's logical structure as an answer to research question RQ4.
0.903	[*A*]coherent clusters[*R*]can capture[*A*]the program's logical structure as an answer	context()	negated: False ,passive: False
[LINE#419]However, in cases such as this where the internal functionality is tightly knit, a single large coherent cluster maps to the program's core functionality. .
0.939	[*A*]the internal functionality[*R*]is tightly knit[*A*]cases such as this	context()	negated: False ,passive: True
[LINE#420]bcThe third case study in this series is bc, an open-source calculator, which consists of 9438 LoC and 5450 SLoC.
0.927	[*A*]an open - source calculator[*R*]consists[*A*]of 5450 SLoC	context()	negated: False ,passive: True
0.927	[*A*]an open - source calculator[*R*]consists[*A*]of 9438 LoC	context()	negated: False ,passive: True
0.952	[*A*]bcThe third case study in this series[*R*]is[*A*]bc , an open - source calculator	context()	negated: False ,passive: True
[LINE#421]The program has nine C files from which CodeSurfer produced 15,076 slices (backward and forward).Analyzing bc's SCG (row 3, Fig. 11), two interesting observations can be made.
0.950	[*A*]The program[*R*]has[*A*]nine C files from which CodeSurfer produced 15,076 slices ( forward	context(Analyzing bc 's SCG ( row 3 , Fig . 11 ) , two interesting observations can be made)	negated: False ,passive: False
0.920	[*A*]Analyzing bc 's SCG ( row 3 , Fig . 11 ) , two interesting observations[*R*]can be made	context()	negated: False ,passive: False
0.924	[*A*]nine C files[*R*]produced forward[*A*]CodeSurfer[*A*]15,076 slices	context()	negated: False ,passive: True
0.950	[*A*]The program[*R*]has[*A*]nine C files from which CodeSurfer produced 15,076 slices ( backward ) . Analyzing	context(two interesting observations can be made)	negated: False ,passive: False
0.707	[*A*]two interesting observations[*R*]can be made	context()	negated: False ,passive: False
0.882	[*A*]nine C files from which CodeSurfer produced 15,076 slices ( backward[*R*]Analyzing	context()	negated: False ,passive: False
0.956	[*A*]CodeSurfer[*R*]produced backward[*A*]nine C files from which CodeSurfer produced 15,076 slices ( backward ) . Analyzing[*A*]15,076 slices	context()	negated: False ,passive: False
[LINE#422]First, bc contains two large same-backward-slice clusters visible in the light gray landscapes as opposed to the three large coherent clusters.
0.944	[*A*]bc[*R*]contains[*A*]two large same-backward-slice clusters visible in the light gray landscapes[*A*]First	context()	negated: False ,passive: False
[LINE#423]Second, looking at the B-SCG, it can be seen that the x-axis range spanned by the largest same-backward-slice cluster is occupied by the top two coherent clusters shown in the dashed red (dark gray) landscape.
0.962	[*A*]the x-axis range spanned by the largest same-backward-slice cluster[*R*]is occupied[*A*]by the top two coherent clusters	context(it can be seen)	negated: False ,passive: True
0.157	[*A*]it[*R*]can be seen	context()	negated: False ,passive: False
0.853	[*A*]the top two coherent clusters[*R*]shown[*A*]in the dashed red	context()	negated: False ,passive: True
0.926	[*A*]the x-axis range[*R*]spanned[*A*]by the largest same-backward-slice cluster	context()	negated: False ,passive: True
[LINE#424]This indicates that the same-backward-slice cluster splits into the two coherent clusters.
0.941	[*A*]the same-backward-slice cluster[*R*]splits[*A*]into the two coherent clusters	context(This indicates)	negated: False ,passive: True
0.224	[*A*]This[*R*]indicates[*A*]that the same-backward-slice cluster splits into the two coherent clusters	context()	negated: False ,passive: False
[LINE#425]The statistics for bc's top five clusters are given in Table 6.
0.964	[*A*]The statistics for bc's top five clusters[*R*]are given[*A*]in Table 6	context()	negated: False ,passive: True
[LINE#426]Sizes of these five clusters range from 32.3% through to 1.4% of the program.
0.926	[*A*]Sizes of these five clusters[*R*]range[*A*]from 32.3%[*A*]to 1.4% of the program	context()	negated: False ,passive: True
[LINE#427]Clusters six onwards are less than 1% of the program.
0.887	[*A*]Clusters six[*R*]are[*A*]less than 1% of the program	context()	negated: False ,passive: True
[LINE#428]The Project View (Fig. 13) shows their distribution over the source files.
0.894	[*A*]The Project View[*R*]shows[*A*]their distribution over the source files	context()	negated: False ,passive: False
[LINE#429]In more detail, Cluster 1 spans all of bc's files except for scan.c and bc.c.
[LINE#430]This cluster encompasses the core functionality of the program - loading and handling of equations, converting to bc's own number format, performing calculations, and accumulating results.
0.824	[*A*]This cluster[*R*]encompasses the core functionality of the handling of equations converting[*A*]to accumulating results	context(This cluster encompasses)	negated: False ,passive: False
0.878	[*A*]This cluster[*R*]encompasses[*A*]the core functionality of the handling of equations[*A*]converting to accumulating results	context()	negated: False ,passive: False
0.824	[*A*]This cluster[*R*]encompasses the core functionality of the handling of equations converting[*A*]to performing calculations	context(This cluster encompasses)	negated: False ,passive: False
0.878	[*A*]This cluster[*R*]encompasses[*A*]the core functionality of the handling of equations[*A*]converting to performing calculations	context()	negated: False ,passive: False
0.849	[*A*]This cluster[*R*]encompasses the core functionality of the handling of equations converting[*A*]to bc 's own number format	context(This cluster encompasses)	negated: False ,passive: False
0.896	[*A*]This cluster[*R*]encompasses[*A*]the core functionality of the handling of equations[*A*]converting to bc 's own number format	context()	negated: False ,passive: False
0.824	[*A*]This cluster[*R*]encompasses the core functionality of the program - loading of equations converting[*A*]to accumulating results	context(This cluster encompasses)	negated: False ,passive: False
0.920	[*A*]This cluster[*R*]encompasses[*A*]the core functionality of the program - loading of equations[*A*]converting to accumulating results	context()	negated: False ,passive: False
0.824	[*A*]This cluster[*R*]encompasses the core functionality of the program - loading of equations converting[*A*]to performing calculations	context(This cluster encompasses)	negated: False ,passive: False
0.920	[*A*]This cluster[*R*]encompasses[*A*]the core functionality of the program - loading of equations[*A*]converting to performing calculations	context()	negated: False ,passive: False
0.849	[*A*]This cluster[*R*]encompasses the core functionality of the program - loading of equations converting[*A*]to bc 's own number format	context(This cluster encompasses)	negated: False ,passive: False
0.933	[*A*]This cluster[*R*]encompasses[*A*]the core functionality of the program - loading of equations[*A*]converting to bc 's own number format	context()	negated: False ,passive: False
[LINE#431]Cluster 2 spans five files, util.c, execute.c, main.c, scan.c, and bc.c.
0.944	[*A*]Cluster 2[*R*]spans[*A*]five files	context()	negated: False ,passive: False
[LINE#432]The majority of the cluster is distributed over the latter two files.
0.926	[*A*]The majority of the cluster[*R*]is distributed[*A*]over the latter two files	context()	negated: False ,passive: True
[LINE#433]Even more interestingly, the source code of these two files (scan.c and bc.c) map only to Cluster 2 and none of the other top five clusters.
[LINE#434]This indicates a clear purpose to the code in these files.
0.381	[*A*]This[*R*]indicates[*A*]a clear purpose to the code in these files	context()	negated: False ,passive: False
[LINE#435]These two files are solely used for lexical analysis and parsing of equations.
0.911	[*A*]These two files[*R*]are solely used[*A*]for lexical parsing of equations	context()	negated: False ,passive: True
0.911	[*A*]These two files[*R*]are solely used[*A*]for lexical analysis of equations	context()	negated: False ,passive: True
[LINE#436]To aid in this task, some utility functions from util.c are employed.
0.832	[*A*]some utility functions from util.c[*R*]are employed	context()	negated: False ,passive: False
[LINE#437]Only five lines of code in execute.c are also part of Cluster 2 and are used for flushing output and clearing interrupt signals.
0.911	[*A*]Only five lines[*R*]are used[*A*]for flushing clearing	context()	negated: False ,passive: True
0.911	[*A*]Only five lines[*R*]are used[*A*]for flushing output	context()	negated: False ,passive: True
0.911	[*A*]Only five lines[*R*]interrupt[*A*]signals	context()	negated: False ,passive: False
0.961	[*A*]Only five lines of code in execute.c[*R*]are[*A*]also[*A*]part of Cluster 2	context()	negated: False ,passive: True
[LINE#438]The third cluster is completely contained within the file number.c.
0.870	[*A*]The third cluster[*R*]is contained[*A*]within the file number.c	context()	negated: False ,passive: True
[LINE#439]It encompasses functions such as _bc_do_sub, _bc_init_num, _bc_do_compare, _bc_do_add, _bc_simp_mul, _bc_shift_addsub, and _bc_rm_leading_zeros, which are responsible for initializing bc's number formatter, performing comparisons, modulo and other arithmetic operations.
0.920	[*A*]_bc_rm_leading_zeros[*R*]are[*A*]responsible for initializing bc 's number formatter , performing other arithmetic operations	context()	negated: False ,passive: True
0.920	[*A*]_bc_rm_leading_zeros[*R*]are[*A*]responsible for initializing bc 's number formatter , performing modulo	context()	negated: False ,passive: True
0.920	[*A*]_bc_rm_leading_zeros[*R*]are[*A*]responsible for initializing bc 's number formatter , performing comparisons	context()	negated: False ,passive: True
0.452	[*A*]It[*R*]encompasses[*A*]functions such as _bc_rm_leading_zeros	context()	negated: False ,passive: False
0.498	[*A*]It[*R*]encompasses[*A*]functions such as _bc_shift_addsub	context()	negated: False ,passive: False
0.498	[*A*]It[*R*]encompasses[*A*]functions such as _bc_simp_mul	context()	negated: False ,passive: False
0.498	[*A*]It[*R*]encompasses[*A*]functions such as _bc_do_add	context()	negated: False ,passive: False
0.498	[*A*]It[*R*]encompasses[*A*]functions such as _bc_do_compare	context()	negated: False ,passive: False
0.452	[*A*]It[*R*]encompasses[*A*]functions such as _bc_init_num	context()	negated: False ,passive: False
0.498	[*A*]It[*R*]encompasses[*A*]functions such as _bc_do_sub	context()	negated: False ,passive: False
[LINE#440]Clusters 4 and 5 are also completely contained within number.c.
0.887	[*A*]Clusters 5[*R*]contained[*A*]within number.c	context()	negated: False ,passive: True
0.903	[*A*]Clusters 5[*R*]are[*A*]also[*A*]completely contained within number.c	context()	negated: False ,passive: True
0.887	[*A*]Clusters 4[*R*]contained[*A*]within number.c	context()	negated: False ,passive: True
0.903	[*A*]Clusters 4[*R*]are[*A*]also[*A*]completely contained within number.c	context()	negated: False ,passive: True
[LINE#441]These clusters encompass functions to perform bcd operations for base ten numbers and arithmetic division, respectively.
0.878	[*A*]These clusters[*R*]encompass functions to perform[*A*]bcd operations[*A*]for base ten arithmetic division[*A*]respectively	context(These clusters encompass)	negated: False ,passive: False
0.920	[*A*]These clusters[*R*]encompass[*A*]functions[*A*]to perform bcd operations for base ten arithmetic division , respectively	context()	negated: False ,passive: False
0.878	[*A*]These clusters[*R*]encompass functions to perform[*A*]bcd operations[*A*]respectively	context(These clusters encompass)	negated: False ,passive: False
0.920	[*A*]These clusters[*R*]encompass[*A*]functions[*A*]to perform bcd operations for base ten numbers , respectively	context()	negated: False ,passive: False
[LINE#442]As an answer to RQ4, the results of the cluster visualizations for bc reveal its high-level structure.
0.863	[*A*]the results of the cluster visualizations[*R*]bc reveal[*A*]its high-level structure	context()	negated: False ,passive: False
[LINE#443]This aids an engineer in understanding how the artifacts (e.g., functions and files) of the program interact, thus aiding in program comprehension.
0.381	[*A*]This[*R*]aids[*A*]an engineer in understanding e.g. , functions and files	context()	negated: False ,passive: False
0.934	[*A*]functions and files ) of the program interact[*R*]aiding[*A*]in program comprehension	context()	negated: False ,passive: False
0.381	[*A*]This[*R*]aids[*A*]an engineer in understanding	context()	negated: False ,passive: False
[LINE#444]The remainder of this subsection illustrates a side-effect of decluvi's multi-level visualization, how it can help find potential problems with the structure of a program.
0.388	[*A*]it[*R*]can help find[*A*]potential problems with the structure of a program	context(it can help)	negated: False ,passive: False
0.388	[*A*]it[*R*]can help[*A*]find potential problems with the structure of a program	context()	negated: False ,passive: False
0.926	[*A*]The remainder of this subsection[*R*]illustrates[*A*]a side-effect of decluvi's multi-level visualization	context()	negated: False ,passive: False
[LINE#445]Util.c consists of small utility functions called from various parts of the program.
0.911	[*A*]small utility functions[*R*]called[*A*]from various parts of the program	context()	negated: False ,passive: True
0.920	[*A*]Util.c[*R*]consists[*A*]of small utility functions	context()	negated: False ,passive: True
[LINE#446] This file contains code from Clusters 1 and 2.
0.903	[*A*]This file[*R*]contains[*A*]code	context()	negated: False ,passive: False
[LINE#447]Five of the utility functions belong with Cluster 1, while six belong with Cluster 2.
0.425	[*A*]six[*R*]belong[*A*]with Cluster 2	context()	negated: False ,passive: False
0.937	[*A*]Five of the utility functions[*R*]belong[*A*]with Cluster 1[*A*]while six belong with Cluster 2	context()	negated: False ,passive: False
[LINE#448]14 shows that the distribution of the two clusters in red (dark gray) and blue (medium gray) within the file are well separated.
0.812	[*A*]the blue ( medium gray ) within the file[*R*]are well separated	context(14 shows)	negated: False ,passive: False
0.426	[*A*]14[*R*]shows[*A*]that the blue ( medium gray ) within the file are well separated	context()	negated: False ,passive: False
0.934	[*A*]the distribution of the two clusters in red ( dark gray ) ( medium gray ) within the file[*R*]are well separated	context()	negated: False ,passive: False
[LINE#449] Both clusters do not occur together inside any function with the exception of init_gen (highlighted by the rectangle in first column of Fig..
0.940	[*A*]the exception of init_gen[*R*]highlighted[*A*]by the rectangle[*A*]in first column of Fig	context()	negated: False ,passive: True
0.918	[*A*]Both clusters[*R*]do not occur together[*A*]inside any function with the exception of init_gen	context()	negated: True ,passive: True
[LINE#450]The other functions of util.c thus belong to either Cluster 1 or Cluster 2.
0.927	[*A*]The other functions of util.c[*R*]belong[*A*]to either Cluster 1 or Cluster 2	context()	negated: False ,passive: False
[LINE#451]Separating these utility functions into two separate source files where each file is dedicated to functions belonging to a single cluster would improve the code's logical separation and file-level cohesion.
0.939	[*A*]Separating these utility functions into two separate source files[*R*]would improve[*A*]the code file - level cohesion	context()	negated: False ,passive: False
0.939	[*A*]Separating these utility functions into two separate source files[*R*]would improve[*A*]the code 's logical separation	context()	negated: False ,passive: False
0.894	[*A*]functions[*R*]belonging[*A*]to a single cluster	context()	negated: False ,passive: False
0.943	[*A*]each file[*R*]is dedicated[*A*]to functions[*A*]two separate source files	context()	negated: False ,passive: True
[LINE#452]This would make the code easier to understand and maintain at the expense of a very simple refactoring.
0.497	[*A*]This[*R*]would make[*A*]the code easier to maintain at the expense of a very simple refactoring	context()	negated: False ,passive: False
0.381	[*A*]This[*R*]would make[*A*]the code easier to understand	context()	negated: False ,passive: False
[LINE#453]In general, this example illustrates how decluvi visualization can provide an indicator of potential points of code degradation during evolution.
0.878	[*A*]decluvi visualization[*R*]can provide[*A*]an indicator of potential points of code degradation[*A*]during evolution	context(this example illustrates)	negated: False ,passive: False
0.920	[*A*]this example[*R*]illustrates[*A*]how decluvi visualization can provide an indicator of potential points of code degradation during evolution	context()	negated: False ,passive: False
[LINE#454]Finally, the Code View for function init_gen shown in Fig. 15 includes Lines 244, 251, 254, and 255 in red (dark gray) from Cluster 1 and Lines 247, 248, 249, and 256 in blue (medium gray) from Cluster 2.
0.908	[*A*]the Code View for function init_gen[*R*]includes[*A*]255 in red ( dark gray[*A*]Finally	context()	negated: False ,passive: True
0.937	[*A*]function init_gen[*R*]shown[*A*]in Fig	context()	negated: False ,passive: True
0.999	[*A*]the Code View for function init_gen shown in Fig[*R*]includes[*A*]254 from lines 247	context()	negated: False ,passive: False
0.971	[*A*]the Code View for function init_gen[*R*]includes[*A*]Lines 244[*A*]Finally	context()	negated: False ,passive: True
0.967	[*A*]the Code View for function init_gen[*R*]shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#455]Other lines, shown in light gray, belong to smaller clusters and lines containing no executable code.
0.894	[*A*]lines[*R*]containing[*A*]no executable code	context()	negated: False ,passive: False
0.927	[*A*]Other lines , shown in light gray[*R*]belong[*A*]to lines	context()	negated: False ,passive: False
0.927	[*A*]Other lines , shown in light gray[*R*]belong[*A*]to smaller clusters	context()	negated: False ,passive: False
0.913	[*A*]Other lines[*R*]shown[*A*]in light gray	context()	negated: False ,passive: True
[LINE#456]Ideally, clusters should capture a particular functionality; thus, functions should generally not contain code from multiple clusters (unless perhaps the clusters are completely contained within the function).
0.867	[*A*]clusters[*R*]should capture[*A*]a particular functionality	context(functions should not contain)	negated: False ,passive: False
0.810	[*A*]functions[*R*]should not contain[*A*]code	context()	negated: True ,passive: False
0.859	[*A*]the clusters[*R*]are contained[*A*]within the function	context()	negated: False ,passive: True
[LINE#457]Functions with code from multiple clusters reduce code separation (hindering comprehension) and increase the likelihood of ripple-effects (Black, 2001).
0.932	[*A*]Functions with code from multiple clusters[*R*]reduce[*A*]code separation ( hindering comprehension	context()	negated: False ,passive: False
[LINE#458]Like other initialization functions, bc'sinit_gen is an exception to this guideline.
0.938	[*A*]bc'sinit_gen[*R*]is[*A*]an exception to this guideline	context()	negated: False ,passive: True
[LINE#459]This case study not only provides support for the answer to research question RQ4 found in previous case studies, but also illustrates that the visualization is able to reveal structural defects in programs. .
0.905	[*A*]the visualization[*R*]is[*A*]able to reveal structural defects in programs	context(This case illustrates)	negated: False ,passive: True
0.780	[*A*]This case[*R*]illustrates[*A*]that the visualization is able to reveal structural defects in programs	context()	negated: False ,passive: False
0.887	[*A*]the visualization[*R*]to reveal[*A*]structural defects in programs	context()	negated: False ,passive: False
0.927	[*A*]support for the answer to research question[*R*]found[*A*]in previous case studies	context()	negated: False ,passive: True
0.944	[*A*]This case study[*R*]provides[*A*]support for the answer to research question RQ4 found in previous case studies	context()	negated: False ,passive: False
[LINE#460]copiaThe final case study in this series is copia, an industrial program used by the ESA to perform signal processing.
[LINE#461]Copiais the smallest program considered in this series of case studies with 1168 LoC and 1111 SLoC all in a single C file.
0.952	[*A*]the smallest program[*R*]considered[*A*]in this series of case studies with 1111 SLoC all in a single C file	context()	negated: False ,passive: True
0.952	[*A*]the smallest program[*R*]considered[*A*]in this series of case studies with 1168 LoC SLoC all in a single C file	context()	negated: False ,passive: True
[LINE#462]Its largest coherent cluster covers 48% of the program.
0.999	[*A*]Its largest coherent cluster[*R*]covers[*A*]48 %	context()	negated: False ,passive: False
0.681	[*A*]Its largest coherent cluster[*R*]covers[*A*]48% of the program	context()	negated: False ,passive: True
[LINE#463]The program is at the top of the group with large coherent clusters.
0.952	[*A*]The program[*R*]is[*A*]at the top of the group with large coherent clusters	context()	negated: False ,passive: True
[LINE#464]CodeSurfer extracts 6654 slices (backward and forward).The B-SCG for copia is shown in Fig. 16a.
0.920	[*A*]CodeSurfer[*R*]extracts[*A*]6654 slices ( forward	context()	negated: False ,passive: False
0.999	[*A*]CodeSurfer[*R*]extracts[*A*]6654 slices	context()	negated: False ,passive: False
0.957	[*A*]The B - SCG for copia[*R*]is shown[*A*]in Fig	context()	negated: False ,passive: True
0.920	[*A*]CodeSurfer[*R*]extracts[*A*]6654 slices ( backward	context()	negated: False ,passive: False
[LINE#465]The single large coherent cluster spanning 48% of the program is shown by the dashed red (dark gray) line (running approx.
0.887	[*A*]The single large coherent cluster spanning 48% of the program[*R*]is shown[*A*]by the dashed red	context()	negated: False ,passive: True
0.926	[*A*]The single large coherent cluster[*R*]spanning[*A*]48% of the program	context()	negated: False ,passive: False
[LINE#466]The plots for same-backward-slice cluster sizes (light gray line) and the coherent cluster sizes (dashed line) are identical.
0.771	[*A*]the coherent cluster sizes[*R*]are[*A*]identical	context()	negated: False ,passive: True
0.857	[*A*]The plots for same - backward - slice cluster sizes[*R*]are[*A*]identical	context()	negated: False ,passive: True
[LINE#467]This is because the size of the coherent clusters are restricted by the size of the same-backward-slice clusters.
0.956	[*A*]the size of the coherent clusters[*R*]are restricted[*A*]by the size of the same-backward-slice clusters	context()	negated: False ,passive: True
0.567	[*A*]This[*R*]is[*A*]because the size of the coherent clusters are restricted by the size of the same-backward-slice clusters	context()	negated: False ,passive: True
[LINE#468]Although the plot for the size of the backward slices (black line) seems to be the same from the 10% mark to 95% mark on the x-axis, the slices are not exactly the same.
0.767	[*A*]the slices[*R*]are not[*A*]exactly the same	context()	negated: True ,passive: True
0.845	[*A*]the plot for the size of the backward slices[*R*]to be[*A*]the same	context()	negated: False ,passive: True
0.820	[*A*]the plot for the size of the backward slices[*R*]seems	context()	negated: False ,passive: False
[LINE#469]Only vertices plotted from 2% through to 50% have exactly same backward and forward slice resulting in the large coherent cluster.
0.903	[*A*]forward slice[*R*]resulting[*A*]in the large coherent cluster	context()	negated: False ,passive: True
0.903	[*A*]Only vertices[*R*]plotted[*A*]from 2 % through[*A*]have exactly same forward slice	context()	negated: False ,passive: False
0.991	[*A*]50 %[*R*]have[*A*]exactly same backward slice resulting in the large coherent cluster	context()	negated: False ,passive: False
0.943	[*A*]to 50 %[*R*]have[*A*]exactly same backward slice resulting in the large coherent cluster	context()	negated: False ,passive: False
0.903	[*A*]Only vertices[*R*]plotted[*A*]from 2 %[*A*]through	context()	negated: False ,passive: False
[LINE#470]Table 7 shows statistics for the top five coherent clusters found in copia.
0.926	[*A*]the top five coherent clusters[*R*]found[*A*]in copia	context()	negated: False ,passive: True
0.636	[*A*]Table 7[*R*]shows[*A*]statistics for the top five coherent clusters	context()	negated: False ,passive: False
[LINE#471]Other than the largest cluster which covers 48% of the program, the rest of the clusters are extremely small.
0.814	[*A*]the rest of the clusters[*R*]are[*A*]extremely small	context()	negated: False ,passive: True
0.897	[*A*]the largest cluster[*R*]covers[*A*]48% of the program	context()	negated: False ,passive: True
[LINE#472]Clusters 2-5 include no more than 0.1% of the program (four vertices) rendering them too small to be of interest.
0.999	[*A*]Clusters 2-5[*R*]include[*A*]more than 0.1 %	context()	negated: False ,passive: False
0.411	[*A*]them[*R*]to be[*A*]of interest	context()	negated: False ,passive: True
0.903	[*A*]Clusters 2-5[*R*]include[*A*]no more than 0.1% of the program	context()	negated: False ,passive: True
[LINE#473]This suggests a program with a single functionality or structure.
0.381	[*A*]This[*R*]suggests[*A*]a program with a single functionality or structure	context()	negated: False ,passive: False
[LINE#474]During analysis of copiausing decluvi, the File View (Fig. 17) reveals an intriguing structure.
0.955	[*A*]the File View[*R*]reveals[*A*]an intriguing structure[*A*]During analysis of copiausing decluvi	context()	negated: False ,passive: False
[LINE#475] There is a large block of code with the same spatial arrangement (bounded by the dotted black rectangle in Fig. 17)that belongs to the largest cluster of the program.
[LINE#476]It is unusual for so many consecutive source code lines to have nearly identical length and indentation.
0.932	[*A*]so many consecutive source code lines[*R*]to have[*A*]indentation	context()	negated: False ,passive: False
0.932	[*A*]so many consecutive source code lines[*R*]to have[*A*]nearly identical length	context()	negated: False ,passive: False
[LINE#477]Inspection of the source code reveals that this block of code is a switch statement handling 234 cases.
0.923	[*A*]this block of code[*R*]is[*A*]a switch statement handling 234 cases	context(Inspection of the source code reveals)	negated: False ,passive: True
0.784	[*A*]Inspection of the source code[*R*]reveals[*A*]that this block of code is a switch statement	context()	negated: False ,passive: False
0.911	[*A*]a switch statement[*R*]handling[*A*]234 cases	context()	negated: False ,passive: False
[LINE#478]Further investigation shows that copiahas 234 small functions that eventually call one large function, seleziona, which in turn calls the smaller functions effectively implementing a finite state machine.
0.911	[*A*]the smaller functions[*R*]effectively implementing[*A*]a finite state machine	context()	negated: False ,passive: False
0.892	[*A*]seleziona[*R*]calls[*A*]that copiahas 234 small functions that eventually call one large function, seleziona, which in turn calls the smaller functions effectively implementing a finite state machine	context()	negated: False ,passive: False
0.954	[*A*]234 small functions[*R*]call[*A*]one large function, seleziona[*A*]eventually	context()	negated: False ,passive: False
0.911	[*A*]Further investigation[*R*]shows[*A*]copiahas	context()	negated: False ,passive: False
[LINE#479]Each of the smaller functions returns a value that is the next state for the machine and is used by the switch statement to call the appropriate next function.
0.887	[*A*]a value[*R*]is used[*A*]by the switch statement[*A*]to call the appropriate next function	context()	negated: False ,passive: True
0.913	[*A*]a value[*R*]is[*A*]the next state for the machine	context()	negated: False ,passive: True
0.879	[*A*]Each of the smaller functions[*R*]returns[*A*]a value that is the next state for the machine and is used by the switch statement to call the appropriate next function	context()	negated: False ,passive: False
[LINE#480]The primary reason for the high level of dependence in the program lies with the statement switch(next_state), which controls the calls to the smaller functions.
0.897	[*A*]the statement switch[*R*]controls[*A*]the calls to the smaller functions	context()	negated: False ,passive: False
0.961	[*A*]The primary reason for the high level of dependence in the program[*R*]lies[*A*]with the statement switch	context()	negated: False ,passive: True
[LINE#481] This causes what might be termed 'conservative dependence analysis collateral damage' because the static analysis cannot determine that when function f() returns the constant value 5this leads the switch statement to eventually invoke function g().
0.940	[*A*]5this[*R*]leads[*A*]the switch statement[*A*]when function f() returns the constant value	context(the static analysis can not determine)	negated: False ,passive: False
0.848	[*A*]the static analysis[*R*]can not determine[*A*]that when function f() returns the constant value 5this leads the switch statement to eventually invoke function g	context()	negated: True ,passive: False
0.250	[*A*]This[*R*]causes[*A*]what might be termed 'conservative dependence analysis collateral damage[*A*]because the static analysis cannot determine that when function f() returns the constant value 5this leads the switch statement to eventually invoke function g	context()	negated: False ,passive: False
0.923	[*A*]the switch statement[*R*]to invoke[*A*]function g[*A*]eventually	context()	negated: False ,passive: False
[LINE#482]Instead, the analysis makes the conservative assumption that a call to f() might be followed by a call to any of the functions called in the switch statement, resulting in a mutual recursion involving most of the program.
0.911	[*A*]a mutual recursion[*R*]involving[*A*]most of the program	context()	negated: False ,passive: True
0.903	[*A*]the functions[*R*]called[*A*]in the switch statement	context()	negated: False ,passive: True
0.888	[*A*]a call to f[*R*]might be followed[*A*]resulting in a mutual recursion	context()	negated: False ,passive: True
0.845	[*A*]the analysis[*R*]makes[*A*]the conservative assumption that a call to f() might be followed by a call to any of the functions	context()	negated: False ,passive: False
[LINE#483]Although the coherent cluster still shows the structure of the program and includes all these stub functions that work together, this is a clear case of dependence pollution (Binkley and Harman, 2005), which is avoidable.
0.737	[*A*]all these stub functions[*R*]work together	context()	negated: False ,passive: False
0.880	[*A*]dependence pollution ( Harman , 2005[*R*]is[*A*]avoidable	context()	negated: False ,passive: True
0.612	[*A*]this[*R*]is[*A*]a clear case of dependence pollution ( Harman , 2005	context()	negated: False ,passive: True
0.858	[*A*]dependence pollution ( Binkley[*R*]is[*A*]avoidable	context()	negated: False ,passive: True
0.495	[*A*]this[*R*]is[*A*]a clear case of dependence pollution ( Binkley	context()	negated: False ,passive: True
0.954	[*A*]the coherent cluster[*R*]shows[*A*]the structure of the program[*A*]still	context()	negated: False ,passive: False
[LINE#484]To illustrate this, the code was re-factored to simulate the replacement of the integer next_state with direct recursive function calls.
0.937	[*A*]the code[*R*]was re-factored[*A*]to simulate the replacement of the integer next_state with direct recursive function calls	context()	negated: False ,passive: True
[LINE#485]The SCG for the modified version of copiais shown in Fig. 16b where the large cluster has clearly disappeared.
0.751	[*A*]the large cluster[*R*]has clearly disappeared	context()	negated: False ,passive: False
0.931	[*A*]copiais[*R*]shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#486]As a result of this reduction, the potential impact of changes to the program will be greatly reduced, making it easier to understand and maintain.
0.831	[*A*]the potential impact of changes to the program[*R*]will be reduced[*A*]making it easier to maintain	context()	negated: False ,passive: True
0.831	[*A*]the potential impact of changes to the program[*R*]will be reduced[*A*]making it easier to understand	context()	negated: False ,passive: True
[LINE#487]This is even further amplified for automatic static analysis tools such as CodeSurfer.
0.385	[*A*]This[*R*]amplified[*A*]for automatic static analysis tools such as CodeSurfer	context()	negated: False ,passive: True
0.612	[*A*]This[*R*]is[*A*]even further amplified for automatic static analysis tools such as CodeSurfer	context()	negated: False ,passive: True
[LINE#488]Of course, in order to do a proper re-factoring, the programmer will have to consider ways in which the program can be re-written to change the flow of control.
0.732	[*A*]the program[*R*]can be re-written	context()	negated: False ,passive: False
0.927	[*A*]the programmer[*R*]to consider[*A*]ways in which the program can be re-written to change the flow of control	context()	negated: False ,passive: False
[LINE#489]Whether such a re-factoring is deemed cost-effective is a decision that can only be taken by the engineers and managers responsible for maintaining the program in question.
0.837	[*A*]a decision[*R*]can be taken[*A*]by managers responsible for maintaining the program in question	context()	negated: False ,passive: True
0.892	[*A*]a decision[*R*]can be taken[*A*]by the engineers responsible for maintaining the program in question	context()	negated: False ,passive: True
[LINE#490]This case study reiterates the answer for RQ4 by showing the structure and dependency within the program.
0.925	[*A*]This case study[*R*]reiterates[*A*]the answer for RQ4	context()	negated: False ,passive: False
[LINE#491]It also identifies potential refactoring points which can improve the performance of static analysis tools and make the program easier to understand. .
0.897	[*A*]potential refactoring points[*R*]can make[*A*]the program easier to understand	context()	negated: False ,passive: False
0.528	[*A*]It[*R*]identifies[*A*]potential refactoring points which can make the program easier to understand	context()	negated: False ,passive: False
0.897	[*A*]potential refactoring points[*R*]can improve[*A*]the performance of static analysis tools	context()	negated: False ,passive: False
0.528	[*A*]It[*R*]identifies[*A*]potential refactoring points which can improve the performance of static analysis tools	context()	negated: False ,passive: False
[LINE#492] dependenceThis section addresses research question RQ5:.
[LINE#493] What are the implications of inter-cluster dependence between coherent clusters?.
[LINE#494]The question attempts to reveal whether there is dependence (slice inclusion) relationship between the vertices of different coherent clusters.
0.867	[*A*]The question[*R*]attempts to reveal[*A*]whether there is dependence (slice inclusion) relationship between the vertices of different coherent clusters	context(The question attempts)	negated: False ,passive: False
0.867	[*A*]The question[*R*]attempts[*A*]to reveal whether there is dependence (slice inclusion) relationship between the vertices of different coherent clusters	context()	negated: False ,passive: False
[LINE#495] A slice inclusion relationship between two clusters X and Y exist, if xX:BSlice(x)Y. If such containment occurs, it must be a strict containment relationship (BSlice(x)Y.
0.452	[*A*]it[*R*]must be[*A*]a strict containment relationship	context()	negated: False ,passive: True
0.732	[*A*]such containment[*R*]occurs	context()	negated: False ,passive: False
0.960	[*A*]A slice inclusion relationship between two clusters X and Y[*R*]exist[*A*]if xX:BSlice(x)Y. If such containment occurs, it must be a strict containment relationship	context()	negated: False ,passive: True
[LINE#496]Defining this relation using forward slices produces the inverse relation.
0.932	[*A*]Defining this relation using forward slices[*R*]produces[*A*]the inverse relation	context()	negated: False ,passive: False
[LINE#497]In the series of case studies presented earlier we have seen that coherent clusters map to logical components of a system and can be used to gain an understanding of the architecture of the program.
0.163	[*A*]that[*R*]can be used[*A*]to gain an understanding of the architecture of the program	context(we have seen)	negated: False ,passive: True
0.399	[*A*]we[*R*]have seen[*A*]that can be used to gain an understanding of the architecture of the program[*A*]In the series of case studies[*A*]earlier	context()	negated: False ,passive: False
0.905	[*A*]coherent clusters[*R*]map[*A*]to logical components of a system	context(we have seen)	negated: False ,passive: False
0.399	[*A*]we[*R*]have seen[*A*]that coherent clusters map to logical components of a system[*A*]In the series of case studies[*A*]earlier	context()	negated: False ,passive: False
0.732	[*A*]case studies[*R*]presented	context()	negated: False ,passive: False
[LINE#498]If such dependencies exist that allows entire clusters to depend on other clusters, then this dependence relationship can be used to group clusters to form a hierarchical decomposition of the system where coherent clusters are regarded as sub-systems, opening up the potential use of coherent clusters in reverse engineering.
0.897	[*A*]this dependence relationship[*R*]to group[*A*]clusters[*A*]to form a hierarchical decomposition of the system	context()	negated: False ,passive: False
0.967	[*A*]this dependence relationship[*R*]can be used[*A*]to group clusters to form a hierarchical decomposition of the system[*A*]then	context()	negated: False ,passive: True
0.943	[*A*]coherent clusters[*R*]are regarded[*A*]as sub-systems[*A*]the system	context()	negated: False ,passive: True
0.878	[*A*]entire clusters[*R*]to depend[*A*]on other clusters	context(that allows)	negated: False ,passive: False
0.108	[*A*]that[*R*]allows[*A*]entire clusters to depend on other clusters	context()	negated: False ,passive: False
0.894	[*A*]clusters[*R*]to form[*A*]a hierarchical decomposition of the system	context()	negated: False ,passive: False
0.732	[*A*]such dependencies[*R*]exist	context()	negated: False ,passive: False
[LINE#499]Secondly, if there are mutual dependency relations between clusters then such mutual dependency relationships can be used to provide a better estimate of slice-based clusters.
0.905	[*A*]such mutual dependency relationships[*R*]to provide[*A*]a better estimate of slice-based clusters	context()	negated: False ,passive: False
[LINE#500]All vertices of a coherent cluster share the same external and internal dependence, that is, all vertices have the same backward slice and also the same forward slice.
0.903	[*A*]all vertices[*R*]have[*A*]also[*A*]the same forward slice	context()	negated: False ,passive: False
0.903	[*A*]all vertices[*R*]have[*A*]the same backward slice	context()	negated: False ,passive: False
[LINE#501]Because of this, any backward/forward slice that includes a vertex from a cluster will also include all other vertices of the same cluster (Eq. 1).
0.941	[*A*]any backward/forward slice that includes a vertex from a cluster[*R*]will include[*A*]all other vertices of the same cluster	context()	negated: False ,passive: True
0.913	[*A*]any backward/forward slice[*R*]includes[*A*]a vertex from a cluster	context()	negated: False ,passive: True
[LINE#502]The study exploits this unique property of coherent clusters to investigate whether or not a backward slice taken with respect to a vertex of a coherent cluster includes vertices of another cluster.
0.769	[*A*]not a backward slice[*R*]taken	context()	negated: False ,passive: False
0.903	[*A*]The study[*R*]exploits[*A*]this unique property of coherent clusters	context()	negated: False ,passive: False
[LINE#503] Note that if vertices of coherent cluster X are contained in the slice taken with respect to a vertex of coherent cluster Y, then all vertices of X are contained in the slice taken with respect to each vertex of Y18 shows Cluster Dependence Graphs (CDG) for each of the four case study subjects.
0.997	[*A*]Note that if vertices of coherent cluster X are contained in the slice taken with respect to a vertex of coherent cluster Y, then all vertices of X are contained in the slice[*R*]shows[*A*]Cluster Dependence Graphs	context()	negated: False ,passive: False
0.953	[*A*]all vertices of X[*R*]are contained[*A*]in the slice[*A*]then	context()	negated: False ,passive: True
0.732	[*A*]the slice[*R*]taken	context()	negated: False ,passive: False
0.926	[*A*]vertices of coherent cluster X[*R*]are contained[*A*]in the slice	context()	negated: False ,passive: True
[LINE#504]Only the five largest clusters of the case study subjects are considered during this study.
0.953	[*A*]Only the five largest clusters of the case study subjects[*R*]are considered[*A*]during this study	context()	negated: False ,passive: True
[LINE#505]The graphs depict slice containment relationships between the top five clusters of each program.
0.937	[*A*]The graphs[*R*]depict[*A*]slice containment relationships between the top five clusters of each program	context()	negated: False ,passive: False
[LINE#506]In these graphs, the top five clusters are represented by nodes (1 depicts the largest coherent cluster, while 5 is the 5th largest cluster) and the directional edges denote backward slice22A definition based on forward slices will have the same results with reversed edges.
0.925	[*A*]the directional edges[*R*]denote[*A*]backward slice22A definition	context()	negated: False ,passive: False
0.449	[*A*]5[*R*]is[*A*]the 5th largest cluster	context()	negated: False ,passive: True
0.381	[*A*]1[*R*]depicts[*A*]the largest coherent cluster	context()	negated: False ,passive: False
0.953	[*A*]the top five clusters[*R*]are represented[*A*]by nodes ( 1 depicts the largest coherent cluster[*A*]while 5 is the 5th largest cluster[*A*]In these graphs	context()	negated: False ,passive: True
[LINE#507] AB depicts that vertices of cluster B depend on vertices of cluster A, that is, a backward slice of any vertex of cluster B will include all vertices of cluster A (xB:.
0.897	[*A*]vertices of cluster B[*R*]depend[*A*]on vertices of cluster A	context(AB depicts a backward slice of any vertex of cluster B will include)	negated: False ,passive: False
0.727	[*A*]AB[*R*]depicts[*A*]that vertices of cluster B depend on vertices of cluster A	context(a backward slice of any vertex of cluster B will include)	negated: False ,passive: False
0.934	[*A*]a backward slice of any vertex of cluster B[*R*]will include[*A*]all vertices of cluster A (xB	context()	negated: False ,passive: True
[LINE#508]Bi-directional edges show mutual dependencies, whereas uni-directional edges show dependency in one direction only.
0.925	[*A*]uni-directional edges[*R*]show[*A*]dependency	context()	negated: False ,passive: False
0.925	[*A*]Bi-directional edges[*R*]show[*A*]mutual dependencies[*A*]whereas uni-directional edges show dependency in one direction only	context()	negated: False ,passive: False
[LINE#509], the top five clusters have no slice inclusion relationships between them (absence of edges between the nodes of the CDG).
0.860	[*A*]the top five clusters[*R*]have[*A*]no slice inclusion relationships between them	context()	negated: False ,passive: False
[LINE#510]Looking at Table 7, only the largest cluster of copiais truly large at 48%, while the other four clusters are extremely small making them unlikely candidates for inter-cluster dependence.
0.838	[*A*]the other four clusters[*R*]making[*A*]them unlikely candidates for inter-cluster dependence	context()	negated: False ,passive: False
0.799	[*A*]the other four clusters[*R*]are[*A*]extremely small	context()	negated: False ,passive: True
[LINE#511]there is a dependence between all of the top five clusters.
[LINE#512]In fact, there is mutual dependence between clusters 1, 2, 3 and 4, while cluster 5 depends on all the other four clusters but not mutually.
0.767	[*A*]cluster 5[*R*]depends[*A*]on all the other four not mutually	context()	negated: False ,passive: False
0.903	[*A*]cluster 5[*R*]depends[*A*]on all the other four clusters	context()	negated: False ,passive: False
[LINE#513]Clusters 1 through 4 contain logic for manipulating, accessing, and maintaining the hash tables, making them interdependent.
0.908	[*A*]Clusters 1 through 4[*R*]contain[*A*]logic for maintaining the hash tables , making them interdependent	context()	negated: False ,passive: False
0.919	[*A*]Clusters 1 through 4[*R*]contain[*A*]logic for accessing	context()	negated: False ,passive: False
0.919	[*A*]Clusters 1 through 4[*R*]contain[*A*]logic for manipulating	context()	negated: False ,passive: False
[LINE#514]Cluster 5 on the other hand is a loop structure within the main function for executing different cases based on command line inputs.
[LINE#515]Similarly for indent (Fig. 18c), clusters 1, 2, 4, and 5 are mutually dependent and 3 depends on all the other top five clusters but not mutually.
0.878	[*A*]Fig . 18c ) , clusters 5[*R*]are[*A*]mutually dependent	context()	negated: False ,passive: True
0.878	[*A*]Fig . 18c ) , clusters 4[*R*]are[*A*]mutually dependent	context()	negated: False ,passive: True
0.878	[*A*]Fig . 18c ) , clusters 2[*R*]are[*A*]mutually dependent	context()	negated: False ,passive: True
0.878	[*A*]Fig . 18c ) , clusters 1[*R*]are[*A*]mutually dependent	context()	negated: False ,passive: True
0.497	[*A*]3[*R*]depends[*A*]on all the other top five clusters but not mutually	context()	negated: False ,passive: False
[LINE#516]Finally, in the case of bc (Fig. 18d), all the vertices from the top five clusters are mutually inter-dependent.
0.983	[*A*]all the vertices from the top five clusters[*R*]are[*A*]mutually inter-dependent[*A*]Finally[*A*]in the case of bc (Fig. 18d	context()	negated: False ,passive: True
[LINE#517]The rest of this section uses bcas an example where this mutual dependence is used to identify larger dependence structures by grouping of the inter-dependent coherent clusters.
0.897	[*A*]this mutual dependence[*R*]to identify[*A*]larger dependence structures	context()	negated: False ,passive: False
0.943	[*A*]this mutual dependence[*R*]is used[*A*]to identify larger dependence structures by grouping of the inter-dependent coherent clusters	context()	negated: False ,passive: True
0.943	[*A*]The rest of this section[*R*]uses[*A*]an example where this mutual dependence is used to identify larger dependence structures by grouping of the inter-dependent coherent clusters	context()	negated: False ,passive: False
[LINE#518]At first glance it may seem that the grouping of the coherent clusters is simply reversing the splitting of same-backward-slice or same-forward-slice clusters observed earlier in Section 3.6.3.
0.961	[*A*]same-backward-slice or same-forward-slice clusters[*R*]observed[*A*]earlier in Section 3.6.3	context()	negated: False ,passive: True
[LINE#519]However, examining the sizes of the top five same-backward-slice clusters, same-forward-slice clusters and coherent clusters for bcillustrates that it is not the case.
0.452	[*A*]it[*R*]is not[*A*]the case	context()	negated: True ,passive: True
[LINE#520]Table 8 shows the size of these clusters both in terms of number of vertices and as a percentage of the program.
0.636	[*A*]Table 8[*R*]shows[*A*]the size of these clusters	context()	negated: False ,passive: False
[LINE#521]The combined size of the group of top five inter-dependent coherent clusters is 70.43%, which is 15.67% larger than the largest same-backward-slice cluster (54.86%) and 37.91% larger than the same-forward-slice cluster (32.35%).
0.981	[*A*]The combined size of the group of top five inter-dependent coherent clusters[*R*]is[*A*]70.43 % , which is 15.67 % larger than the largest same - backward - slice cluster ( 37.91 % larger than the same - forward - slice cluster ( 32.35 % )	context()	negated: False ,passive: True
0.973	[*A*]The combined size of the group of top five inter-dependent coherent clusters[*R*]is[*A*]70.43 %	context()	negated: False ,passive: False
0.998	[*A*]the group of top five inter-dependent coherent clusters[*R*]has The combined size of[*A*]70.43 %	context()	negated: False ,passive: False
0.944	[*A*]70.43 %[*R*]is[*A*]15.67 % larger than the largest same - backward - slice cluster	context()	negated: False ,passive: True
0.981	[*A*]The combined size of the group of top five inter-dependent coherent clusters[*R*]is[*A*]70.43 % , which is 15.67 % larger than the largest same - backward - slice cluster ( 54.86 % )	context()	negated: False ,passive: True
[LINE#522]Therefore, the set of all (mutually dependent) vertices from the top five coherent clusters when taken together form a larger dependence structure, an estimate of a slice-based cluster.
0.991	[*A*]the set of all (mutually dependent) vertices from the top five coherent clusters[*R*]form[*A*]a larger dependence structure, an estimate of a slice-based cluster[*A*]when taken together	context()	negated: False ,passive: False
[LINE#523]As an answer to RQ5, this section shows that there are dependence relationships between coherent clusters and in some cases there are mutual dependences between large coherent clusters.
0.848	[*A*]this section[*R*]shows[*A*]that in some cases there are mutual dependences between large coherent clusters	context()	negated: False ,passive: False
0.654	[*A*]this section[*R*]shows[*A*]that there are dependence relationships between coherent clusters	context()	negated: False ,passive: False
[LINE#524]It also shows that it may be possible to leverage this inter-cluster relationship to build a hierarchical system decomposition.
0.184	[*A*]It[*R*]shows[*A*]that it may be possible to leverage this inter-cluster relationship	context()	negated: False ,passive: False
[LINE#525]Furthermore, groups of inter-dependent coherent clusters form larger dependence structures than same-slice clusters and provides a better approximation for slice-based clusters.
0.894	[*A*]groups[*R*]provides[*A*]a better approximation for slice - based clusters	context()	negated: False ,passive: False
0.943	[*A*]groups of inter-dependent coherent clusters[*R*]form[*A*]larger dependence structures than same - slice clusters	context()	negated: False ,passive: False
[LINE#526] This indicates that the sizes of dependence clusters reported by previous studies (Binkley et al., 2008; Binkley and Harman, 2005, 2009; Harman et al., 2009;maybe conservative and mutual dependence clusters are larger and more prevalent than previously reported. .
0.998	[*A*]by previous studies ( Binkley et al . , 2008 ; Harman , 2005 , 2009 ; Harman et al . , 2009 ; mutual dependence clusters are more prevalent[*R*]reported[*A*]dependence clusters	context()	negated: False ,passive: False
0.998	[*A*]by previous studies ( Binkley et al . , 2008 ; Harman , 2005 , 2009 ; Harman et al . , 2009 ; maybe conservative clusters are more prevalent[*R*]reported[*A*]dependence clusters	context()	negated: False ,passive: False
0.998	[*A*]by previous studies ( Binkley et al . , 2008 ; Harman , 2005 , 2009 ; Harman et al . , 2009 ; maybe conservative clusters are larger[*R*]reported[*A*]dependence clusters	context()	negated: False ,passive: False
0.783	[*A*]mutual dependence clusters[*R*]are[*A*]more prevalent than previously reported	context()	negated: False ,passive: True
0.998	[*A*]by previous studies ( Binkley et al . , 2008 ; Binkley , 2005 , 2009 ; Harman et al . , 2009 ; mutual dependence clusters are more prevalent[*R*]reported[*A*]dependence clusters	context()	negated: False ,passive: False
0.153	[*A*]This[*R*]indicates	context()	negated: False ,passive: False
0.783	[*A*]mutual dependence clusters[*R*]are[*A*]larger than previously reported	context()	negated: False ,passive: True
0.970	[*A*]by previous studies[*R*]reported[*A*]dependence clusters	context()	negated: False ,passive: False
0.767	[*A*]conservative clusters[*R*]are[*A*]more prevalent than previously reported	context()	negated: False ,passive: True
0.998	[*A*]by previous studies ( Binkley et al . , 2008 ; Binkley , 2005 , 2009 ; Harman et al . , 2009 ; maybe conservative clusters are more prevalent[*R*]reported[*A*]dependence clusters	context()	negated: False ,passive: False
0.767	[*A*]conservative clusters[*R*]are[*A*]larger than previously reported	context()	negated: False ,passive: True
0.998	[*A*]by previous studies ( Binkley et al . , 2008 ; Binkley , 2005 , 2009 ; Harman et al . , 2009 ; maybe conservative clusters are larger[*R*]reported[*A*]dependence clusters	context()	negated: False ,passive: False
0.339	[*A*]This[*R*]indicates[*A*]the sizes of dependence clusters	context()	negated: False ,passive: False
[LINE#527]Dependence clusters and bug fixesInitial work on dependence clusters advised that they might cause problems in software maintenance, and thus even be considered harmful, because they represent an intricate interweaving of mutual dependencies between program elements.
0.770	[*A*]bug fixesInitial work on dependence clusters[*R*]advised[*A*]that they might thus even be considered harmful[*A*]because they represent an intricate interweaving of mutual dependencies between program elements	context()	negated: False ,passive: False
0.562	[*A*]they[*R*]might cause[*A*]problems in software maintenance	context(bug fixesInitial work on dependence clusters advised)	negated: False ,passive: False
0.685	[*A*]bug fixesInitial work on dependence clusters[*R*]advised[*A*]that they might cause problems in software maintenance	context()	negated: False ,passive: False
0.695	[*A*]Dependence clusters[*R*]advised[*A*]that they might thus even be considered harmful[*A*]because they represent an intricate interweaving of mutual dependencies between program elements	context()	negated: False ,passive: False
0.616	[*A*]they[*R*]represent[*A*]an intricate interweaving of mutual dependencies between program elements	context()	negated: False ,passive: False
0.562	[*A*]they[*R*]might cause[*A*]problems in software maintenance	context(Dependence clusters advised)	negated: False ,passive: False
0.597	[*A*]Dependence clusters[*R*]advised[*A*]that they might cause problems in software maintenance	context()	negated: False ,passive: False
[LINE#528]Thus a large dependence cluster might be thought of as a bad code smell (Elssamadisy and Schalliol, 2002) or a anti-pattern (Binkley et al., 2008).
0.948	[*A*]a large dependence cluster[*R*]might be thought[*A*]as a bad code smell (Elssamadisy and Schalliol, 2002) or a anti-pattern (Binkley et al., 2008	context()	negated: False ,passive: True
[LINE#529](2006) suggested that dependence clusters are potentially where bugs may be located and suggested the possibility of a link between clusters and program faults.
0.506	[*A*]bugs[*R*]may be located	context(2006 suggested dependence clusters are)	negated: False ,passive: False
0.724	[*A*]dependence clusters[*R*]are[*A*]potentially	context(2006 suggested)	negated: False ,passive: True
0.321	[*A*]2006[*R*]suggested[*A*]that dependence clusters are potentially bugs may be located and suggested the possibility of a link between clusters and program faults	context()	negated: False ,passive: False
0.855	[*A*]bugs[*R*]suggested[*A*]the possibility of a link between clusters and program faults	context()	negated: False ,passive: False
0.923	[*A*]dependence clusters[*R*]are[*A*]potentially where and suggested the possibility of a link between clusters and program faults	context(2006 suggested)	negated: False ,passive: True
0.321	[*A*]2006[*R*]suggested[*A*]that dependence clusters are potentially where and suggested the possibility of a link between clusters and program faults	context()	negated: False ,passive: False
[LINE#530]This section further investigates this issue using a study that explores the relationship between program faults and dependence clusters.
0.780	[*A*]This section[*R*]investigates this issue using[*A*]a study that explores the relationship between program faults and dependence clusters	context(This section investigates)	negated: False ,passive: False
0.858	[*A*]This section[*R*]investigates[*A*]this issue[*A*]using a study	context()	negated: False ,passive: False
0.887	[*A*]a study[*R*]explores[*A*]the relationship between program faults and dependence clusters	context()	negated: False ,passive: False
[LINE#531] In doing so, it addresses research question RQ6:.
0.452	[*A*]it[*R*]addresses[*A*]research question RQ6	context()	negated: False ,passive: False
[LINE#532]How do program faults relate to coherent clusters?Barcode, an open source utility tool for converting text strings to printed bars (barcodes) is used in this study.
0.385	[*A*]Barcode[*R*][is] an open tool [of][*A*]source utility	context()	negated: False ,passive: False
0.886	[*A*]Barcode[*R*]is used[*A*]in this study	context()	negated: False ,passive: True
[LINE#533] A series of versions of the system are available for download from GNU repository.33http://gnu.mirror.iweb.com/gnubarcode/. There are nine public releases for barcode, details of which are shown in Table 9.
0.943	[*A*]the system[*R*]has versions of[*A*]9	context()	negated: False ,passive: False
0.925	[*A*]details of which[*R*]are shown[*A*]in Table 9	context()	negated: False ,passive: True
0.948	[*A*]A series of versions of the system[*R*]are[*A*]available for download from GNU repository.33	context()	negated: False ,passive: True
[LINE#534]Column 1 shows the release version, columns 3-6 show various metrics about the size of the system in terms of number of source files and various source code size measures.
0.944	[*A*]Column 1[*R*]shows[*A*]the release version	context()	negated: False ,passive: False
0.964	[*A*]Column 1[*R*]shows[*A*]the release version , columns 3-6 show various metrics about the size of the system in terms of number of source files	context()	negated: False ,passive: False
[LINE#535]Columns 7-9 report the number of SDG vertices, SDG edges and the number of slices produced for each release.
0.894	[*A*]slices[*R*]produced[*A*]for each release	context()	negated: False ,passive: True
[LINE#536]Finally, Column 10 reports the number of faults that were fixed since the previous release of the system.
0.877	[*A*]faults[*R*]were fixed[*A*]since the previous release of the system	context()	negated: False ,passive: True
0.958	[*A*]Column 10[*R*]reports[*A*]the number of faults[*A*]Finally	context()	negated: False ,passive: False
[LINE#537]In Table 9 the size of barcode increases from 1352 lines of code in version 0.90 to 3968 lines of code in version 0.98.
[LINE#538]The total number of faults that were fixed during this time was 39.Fault data, gathered by manually analyzing the publicly available version control repository44cvs.savannah.gnu.org:/sources/barcode.
0.887	[*A*]39.Fault data[*R*]by manually analyzing[*A*]the publicly available version control	context()	negated: False ,passive: False
0.913	[*A*]The total number of faults[*R*]were fixed[*A*]during this time	context()	negated: False ,passive: True
[LINE#539]for the system, showed that total number of commits for barcode during these releases were 137.
[LINE#540]Each update was manually checked using CVSAnaly (Robles et al., 2004) to determine whether the update was a bug fix or simply an enhancement or upgrade to the system.
0.926	[*A*]Each update[*R*]was manually checked[*A*]to determine whether the update was a bug fix or simply an enhancement or upgrade to the system	context()	negated: False ,passive: True
[LINE#541]Those commits that were identified as bug fixes were isolated and mapped to the release that contained the update.
0.334	[*A*]Those[*R*]commits that were identified mapped to the release mapped[*A*]commits	context(Those commits)	negated: False ,passive: False
0.259	[*A*]Those[*R*]commits[*A*]that were identified mapped to the release	context()	negated: False ,passive: False
0.887	[*A*]the release[*R*]contained[*A*]the update	context()	negated: False ,passive: False
0.527	[*A*]Those commits[*R*]were identified[*A*]mapped to the release	context()	negated: False ,passive: True
0.259	[*A*]Those[*R*]commits[*A*]that were identified as bug fixes were isolated	context()	negated: False ,passive: False
0.732	[*A*]bug fixes[*R*]were isolated	context()	negated: False ,passive: False
[LINE#542]All the bug fixes made during a certain release cycle were then accumulated to give the total number of bugs fixed during a particular release cycle (Column 10 of Table 9).
0.813	[*A*]bugs[*R*]fixed[*A*]during a particular release cycle	context()	negated: False ,passive: True
0.874	[*A*]All the bug fixes made during a certain release cycle[*R*]were accumulated[*A*]then	context()	negated: False ,passive: True
0.919	[*A*]All the bug fixes[*R*]made[*A*]during a certain release cycle	context()	negated: False ,passive: True
[LINE#543]The reported number only includes bug fixes and does not include enhancement or addition of new functionality.
0.897	[*A*]The reported number[*R*]does not include[*A*]enhancement or addition of new functionality	context()	negated: True ,passive: True
0.897	[*A*]The reported number[*R*]includes[*A*]bug fixes	context()	negated: False ,passive: True
[LINE#544]19 shows the backward slice size plots for all versions of barcode in a single graph.
0.718	[*A*]19[*R*]shows[*A*]the backward slice size plots for all versions of barcode in a single graph	context()	negated: False ,passive: False
[LINE#545] The values of the axises in Fig.19 are shown as vertex counts rather than relative values (percentages).
0.953	[*A*]The values of the axises in Fig.19[*R*]are shown[*A*]as vertex counts rather than relative values	context()	negated: False ,passive: True
[LINE#546]This allows the growth of barcode to be easily visualized.
0.727	[*A*]the growth of barcode[*R*]to be easily visualized	context(This allows)	negated: False ,passive: False
0.330	[*A*]This[*R*]allows[*A*]the growth of barcode to be easily visualized	context()	negated: False ,passive: False
[LINE#547]From the plots it is seen that the size of the program increases progressively with each new release.
[LINE#548]The graphs also show that a significant number of vertices in each revision of the program yields identical backward slices and the proportion of vertices in the program that have identical backward slices stays roughly the same.
0.776	[*A*]the proportion of vertices in the program[*R*]stays[*A*]roughly the same	context(The graphs show)	negated: False ,passive: True
0.825	[*A*]The graphs[*R*]show[*A*]the proportion of vertices in the program that have identical backward slices stays roughly the same	context()	negated: False ,passive: False
0.905	[*A*]vertices in the program[*R*]have[*A*]identical backward slices	context()	negated: False ,passive: False
0.945	[*A*]a significant number of vertices in each revision of the program[*R*]yields[*A*]identical backward slices	context(The graphs show)	negated: False ,passive: False
0.825	[*A*]The graphs[*R*]show[*A*]that a significant number of vertices in each revision of the program yields identical backward slices	context()	negated: False ,passive: False
[LINE#549]Overall, the profile of the clusters and slices remains consistent.
0.814	[*A*]the profile of the slices[*R*]remains[*A*]consistent	context()	negated: False ,passive: True
0.814	[*A*]the profile of the clusters[*R*]remains[*A*]consistent	context()	negated: False ,passive: True
[LINE#550]The graph also shows that the plots do not show any significant change in their overall shape or structure.
0.796	[*A*]the plots[*R*]do not show[*A*]any significant change in their overall shape or structure	context(The graph shows)	negated: True ,passive: False
0.719	[*A*]The graph[*R*]shows[*A*]that the plots do not show any significant change in their overall shape or structure	context()	negated: False ,passive: False
[LINE#551]Interestingly, the plot for version 0.92 with 9 fault fixes is not different in shape from revision 0.94 where only a single fault was fixed.
0.769	[*A*]only a single fault[*R*]was fixed	context()	negated: False ,passive: False
0.948	[*A*]the plot for version 0.92 with 9 fault fixes[*R*]is not[*A*]different in shape from revision 0.94	context()	negated: True ,passive: True
[LINE#552]As coherent clusters are composed of both backward and forward slices, the stability of the backward slice profile itself does not guarantee the stability of coherent cluster profile.
0.903	[*A*]coherent clusters[*R*]are composed[*A*]of both forward slices	context()	negated: False ,passive: True
0.927	[*A*]the stability of the backward slice profile[*R*]does not guarantee[*A*]the stability of coherent cluster profile	context()	negated: True ,passive: False
0.903	[*A*]coherent clusters[*R*]are composed[*A*]of both backward slices	context()	negated: False ,passive: True
[LINE#553]The remainder of this section looks at how the clustering profile is affected by bug fixes.
0.911	[*A*]the clustering profile[*R*]is affected[*A*]by bug fixes	context()	negated: False ,passive: True
0.952	[*A*]The remainder of this section[*R*]looks[*A*]at how the clustering profile is affected by bug fixes	context()	negated: False ,passive: False
[LINE#554]20 shows individual SCGs for each version of barcode.
0.613	[*A*]20[*R*]shows[*A*]individual SCGs for each version of barcode	context()	negated: False ,passive: False
[LINE#555]As coherent clusters are dependent on both backward and forward slices, such clusters will be more sensitive to changes in dependences within the program.
0.500	[*A*]coherent clusters[*R*]are dependent on[*A*]both forward slices	context()	negated: False ,passive: False
0.903	[*A*]coherent clusters[*R*]are[*A*]dependent on both forward slices	context()	negated: False ,passive: True
0.903	[*A*]such clusters[*R*]will be[*A*]more sensitive to changes in dependences within the program	context()	negated: False ,passive: True
0.903	[*A*]coherent clusters[*R*]are[*A*]dependent on both backward slices	context()	negated: False ,passive: True
[LINE#556]The SCGs show that from the initial version barcode-0.90 there were two coherent clusters in the system.
0.618	[*A*]The SCGs[*R*]show[*A*]that from the initial version barcode-0.90 there were two coherent clusters in the system	context()	negated: False ,passive: False
[LINE#557]The smaller one is around 10% of the code while the larger is around 40% of the code.
0.636	[*A*]the larger[*R*]is[*A*]around 40% of the code	context()	negated: False ,passive: True
0.755	[*A*]The smaller one[*R*]is[*A*]around 10% of the code[*A*]while the larger is around 40% of the code	context()	negated: False ,passive: True
[LINE#558]As the system evolved and went through various modifications and enhancements, the number of clusters and the profile of the clusters remained consistent other than its scaled growth with the increase in program size.
0.963	[*A*]the number of the profile of the clusters[*R*]remained[*A*]consistent other than its scaled growth with the increase in program size[*A*]As the system went through various enhancements	context()	negated: False ,passive: True
0.963	[*A*]the number of the profile of the clusters[*R*]remained[*A*]consistent other than its scaled growth with the increase in program size[*A*]As the system went through various modifications	context()	negated: False ,passive: True
0.946	[*A*]the number of clusters[*R*]remained[*A*]consistent other than its scaled growth with the increase in program size[*A*]As the system went through various enhancements	context()	negated: False ,passive: True
0.925	[*A*]the system[*R*]went[*A*]through various enhancements	context()	negated: False ,passive: True
0.946	[*A*]the number of clusters[*R*]remained[*A*]consistent other than its scaled growth with the increase in program size[*A*]As the system went through various modifications	context()	negated: False ,passive: True
0.925	[*A*]the system[*R*]went[*A*]through various modifications	context()	negated: False ,passive: True
0.963	[*A*]the number of the profile of the clusters[*R*]remained[*A*]consistent other than its scaled growth with the increase in program size[*A*]As the system evolved	context()	negated: False ,passive: True
0.946	[*A*]the number of clusters[*R*]remained[*A*]consistent other than its scaled growth with the increase in program size[*A*]As the system evolved	context()	negated: False ,passive: True
0.732	[*A*]the system[*R*]evolved	context()	negated: False ,passive: False
[LINE#559]It is also evident that during evolution of the system, the enhancement code or newly added code formed part of the larger cluster.
0.954	[*A*]the enhancement code or newly added code[*R*]formed[*A*]part of the larger cluster[*A*]during evolution of the system	context(It is)	negated: False ,passive: False
0.229	[*A*]It[*R*]is[*A*]also[*A*]evident	context()	negated: False ,passive: True
[LINE#560]This is why in the later stages of the evolution we see an increase in the size of the largest cluster, but not the smaller one.
0.541	[*A*]we[*R*]see[*A*]an increase in the size of the largest cluster[*A*]in the later stages of the evolution	context(This is)	negated: False ,passive: False
0.187	[*A*]This[*R*]is[*A*]why	context()	negated: False ,passive: True
[LINE#561]However, we do not see any significant changes in the slice and cluster profile of the program that can be attributed to bug fixes.
0.569	[*A*]we[*R*]do not see[*A*]any significant changes in the cluster profile of the program	context()	negated: True ,passive: False
0.887	[*A*]the program[*R*]can be attributed[*A*]to bug fixes	context()	negated: False ,passive: True
0.569	[*A*]we[*R*]do not see[*A*]any significant changes in the slice profile of the program	context()	negated: True ,passive: False
[LINE#562]For example, the single bug fixed between revisions 0.93 and 0.94 was on a single line of code from the file code128.c.
0.975	[*A*]the single bug fixed between revisions 0.93 and 0.94[*R*]was[*A*]on a single line of code from the file code128.c	context()	negated: False ,passive: True
0.911	[*A*]the single bug[*R*]fixed[*A*]between revisions 0.93 and 0.94	context()	negated: False ,passive: True
[LINE#563] The changes to the line is shown in Fig.(in version 0.93 there is an error in calculating the checksum value, which was corrected in version 0.94).
0.920	[*A*]The changes to the line[*R*]is shown[*A*]in Fig[*A*]in version 0.93	context()	negated: False ,passive: True
0.897	[*A*]the checksum value[*R*]was corrected[*A*]in version 0.94	context()	negated: False ,passive: True
[LINE#564] As illustrated by this example, the data and control flow of the program and thus the dependencies between program points are not affected by the bug fix and hence no change is observed between the SCGs of the two releases (Fig.20).If dependence clusters correlated to faults, or, if dependence clusters were directly related to the number of faults in a program, then a significant difference would be expected in the shape of the SCG when faults were rectified.
0.989	[*A*]the control flow of the program and thus the dependencies between program points are not affected by the bug fix and hence no change[*R*]is observed[*A*]between the SCGs of the two releases	context()	negated: False ,passive: True
0.937	[*A*]dependence clusters[*R*]were[*A*]directly related to the number of faults in a program	context()	negated: False ,passive: True
0.903	[*A*]dependence clusters[*R*]correlated[*A*]to faults	context()	negated: False ,passive: True
0.713	[*A*]faults[*R*]were rectified	context()	negated: False ,passive: False
0.989	[*A*]the data flow of the program and thus the dependencies between program points are not affected by the bug fix and hence no change[*R*]is observed[*A*]between the SCGs of the two releases	context()	negated: False ,passive: True
0.957	[*A*]a significant difference[*R*]would be expected[*A*]in the shape of the SCG[*A*]then	context()	negated: False ,passive: True
0.960	[*A*]the dependencies between program points[*R*]are not affected[*A*]by the bug fix and hence no change[*A*]if dependence clusters were directly related to the number of faults in a program , then a significant difference would be expected in the shape of the SCG	context()	negated: True ,passive: True
0.887	[*A*]dependence clusters[*R*]directly related[*A*]to the number of faults in a program	context()	negated: False ,passive: True
[LINE#565](Fig. 20) show no change in their profile when faults within the program are fixed.
0.769	[*A*]faults within the program[*R*]are fixed	context()	negated: False ,passive: False
[LINE#566]This provides evidence that faults may not be dictated by the presence or absence of dependence clusters.
0.894	[*A*]faults[*R*]may not be dictated[*A*]by the presence or absence of dependence clusters	context()	negated: True ,passive: True
0.265	[*A*]This[*R*]provides[*A*]evidence that faults may not be dictated by the presence or absence of dependence clusters	context()	negated: False ,passive: False
[LINE#567]As an answer to RQ6, the study of barcode finds no correlation between the existence of dependence clusters and program faults and their fix.
0.385	[*A*]RQ6[*R*][is] the study of[*A*]barcode	context()	negated: False ,passive: False
0.929	[*A*]the study of barcode[*R*]finds[*A*]no correlation between the existence of dependence clusters and program faults and their fix	context()	negated: False ,passive: False
[LINE#568]We have to be careful in generalising the answer to this question because of the small dataset considered in this study, further extended research is needed to derive a more generalised answer.
0.891	[*A*]further extended research[*R*]is needed[*A*]to derive a more generalised answer	context()	negated: False ,passive: True
0.911	[*A*]the small dataset[*R*]considered[*A*]in this study	context()	negated: False ,passive: True
0.528	[*A*]We[*R*]to be[*A*]careful in generalising the answer to this question because of the small dataset	context()	negated: False ,passive: True
[LINE#569]Moreover, this does not exclude the possibility that most program faults occur in code that are part of large clusters.
0.877	[*A*]code[*R*]are[*A*]part of large clusters	context()	negated: False ,passive: True
0.911	[*A*]most program faults[*R*]occur[*A*]in code	context()	negated: False ,passive: True
0.183	[*A*]this[*R*]does not exclude[*A*]the possibility that most program faults occur in code	context()	negated: True ,passive: False
[LINE#570]In future we plan to extend this experiment in a qualitative form to study whether program faults lie within large or small clusters, or outside them altogether. .
0.875	[*A*]program faults[*R*]lie altogether[*A*]within large or small clusters	context(we plan to extend to study)	negated: False ,passive: True
0.265	[*A*]we[*R*]plan to extend this experiment to study[*A*]whether program faults lie within large or small clusters, or outside them altogether	context(we plan to extend)	negated: False ,passive: False
0.356	[*A*]we[*R*]plan to extend[*A*]this experiment[*A*]in a qualitative form[*A*]to study whether program faults lie within large or small clusters, or outside them altogether	context(we plan)	negated: False ,passive: False
0.567	[*A*]we[*R*]plan[*A*]to extend this experiment in a qualitative form to study whether program faults lie within large or small clusters, or outside them altogether[*A*]In future	context()	negated: False ,passive: False
[LINE#571]evolutionThe previous section showed that for barcode the slice and cluster profiles remain quite stable through bug fixes during system evolution and its growth of almost 2.5 times over a period of 3 years.
0.817	[*A*]the cluster profiles[*R*]remain[*A*]quite stable[*A*]during its growth of	context(evolutionThe previous section showed)	negated: False ,passive: True
0.723	[*A*]evolutionThe previous section[*R*]showed[*A*]that for barcode the cluster profiles remain quite stable through bug fixes during its growth of	context()	negated: False ,passive: False
0.891	[*A*]the cluster profiles[*R*]remain[*A*]quite stable[*A*]during system evolution	context(evolutionThe previous section showed)	negated: False ,passive: True
0.828	[*A*]evolutionThe previous section[*R*]showed[*A*]that for barcode the cluster profiles remain quite stable through bug fixes during system evolution	context()	negated: False ,passive: False
0.817	[*A*]the slice profiles[*R*]remain[*A*]quite stable[*A*]during its growth of	context(evolutionThe previous section showed)	negated: False ,passive: True
0.723	[*A*]evolutionThe previous section[*R*]showed[*A*]that for barcode the slice profiles remain quite stable through bug fixes during its growth of	context()	negated: False ,passive: False
0.891	[*A*]the slice profiles[*R*]remain[*A*]quite stable[*A*]during system evolution	context(evolutionThe previous section showed)	negated: False ,passive: True
0.828	[*A*]evolutionThe previous section[*R*]showed[*A*]that for barcode the slice profiles remain quite stable through bug fixes during system evolution	context()	negated: False ,passive: False
[LINE#572]This section extends that study by looking for cluster changes during system evolution.
0.878	[*A*]This section[*R*]extends that study by looking[*A*]for cluster changes during system evolution	context(This section extends)	negated: False ,passive: False
0.724	[*A*]This section[*R*]extends[*A*]that study[*A*]by looking for cluster changes during system evolution	context()	negated: False ,passive: False
[LINE#573] It addresses RQ7: How stable are coherent clusters during system evolution?using longitudinal analysis of the case studies presented earlier.
0.443	[*A*]It[*R*]addresses[*A*]RQ7	context()	negated: False ,passive: False
0.783	[*A*]the case studies[*R*]presented[*A*]earlier	context()	negated: False ,passive: True
[LINE#574]From the GNU repository we were able to retrieve four releases for bc, four releases for acct and 14 releases for indent.
0.411	[*A*]we[*R*]to retrieve[*A*]four releases for 14 releases for indent	context()	negated: False ,passive: False
0.740	[*A*]we[*R*]were[*A*]able to retrieve four releases for 14 releases for indent[*A*]From the GNU repository	context()	negated: False ,passive: True
0.411	[*A*]we[*R*]to retrieve[*A*]four releases for four releases for acct	context()	negated: False ,passive: False
0.740	[*A*]we[*R*]were[*A*]able to retrieve four releases for four releases for acct[*A*]From the GNU repository	context()	negated: False ,passive: True
0.411	[*A*]we[*R*]to retrieve[*A*]four releases for bc	context()	negated: False ,passive: False
0.639	[*A*]we[*R*]were[*A*]able to retrieve four releases for bc[*A*]From the GNU repository	context()	negated: False ,passive: True
[LINE#575]As copia is an industrial closed-source program, we were unable to obtain any previous versions of the program and thus the program is excluded from this study.
0.903	[*A*]the program[*R*]is excluded[*A*]from this study	context()	negated: False ,passive: True
0.411	[*A*]we[*R*]to obtain[*A*]any previous versions of the program	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]were[*A*]unable to obtain any previous versions of the program[*A*]thus the program is excluded from this study	context()	negated: False ,passive: True
0.918	[*A*]copia[*R*]is[*A*]an industrial closed-source program	context()	negated: False ,passive: True
[LINE#576]22 show backward slice size overlays for every version of each program.
[LINE#577]Fig. 22a and c for bc and indent show that these systems grow in size during its evolution.
0.848	[*A*]these systems[*R*]grow[*A*]during its evolution	context()	negated: False ,passive: True
[LINE#578]The growth is more prominent in indent (Fig. 22c) where the program grows from around 4800 vertices in its initial version to around 7000 vertices in the final version.
0.915	[*A*]the program[*R*]grows[*A*]from around 4800 vertices in its initial version to around 7000 vertices in the final version	context()	negated: False ,passive: True
0.925	[*A*]The growth[*R*]is[*A*]more prominent[*A*]in indent	context()	negated: False ,passive: True
[LINE#579]The growth for bc is smaller, it grows from around 6000 vertices to 7000 vertices.
0.803	[*A*]The growth for bc[*R*]is[*A*]smaller	context(The growth for bc is smaller grows)	negated: False ,passive: True
0.922	[*A*]The growth for bc is smaller[*R*]grows[*A*]from around 6000 vertices[*A*]to 7000 vertices	context()	negated: False ,passive: True
[LINE#580]This is partly because the versions considered for bc are all minor revisions.
0.912	[*A*]the versions considered for bc[*R*]are[*A*]minor revisions	context()	negated: False ,passive: True
0.903	[*A*]the versions[*R*]considered[*A*]for bc	context()	negated: False ,passive: True
0.567	[*A*]This[*R*]is[*A*]partly[*A*]because the versions considered for bc are all minor revisions	context()	negated: False ,passive: True
[LINE#581]For both bc and indent the slice-size graphs show very little change in their profile.
0.900	[*A*]the slice-size graphs[*R*]show[*A*]very little change in their profile	context()	negated: False ,passive: False
[LINE#582]The graphs mainly show a scale up that parallels the growth of the system.
0.897	[*A*]a scale up[*R*]parallels[*A*]the growth of the system	context()	negated: False ,passive: False
0.860	[*A*]The graphs[*R*]show[*A*]a scale up that parallels the growth of the system	context()	negated: False ,passive: False
[LINE#583]the plots do not simply show a scale up but show a significant difference.
0.903	[*A*]the plots[*R*]do not show[*A*]a significant difference	context()	negated: True ,passive: False
0.859	[*A*]the plots[*R*]do not show[*A*]a scale up	context()	negated: True ,passive: False
[LINE#584]In the 4 plots, the revisions that belong to the same major release are seen to be similar and show a scaling, whereas those from different major releases show very different landscapes.
0.939	[*A*]the revisions that belong to the same major release[*R*]to show[*A*]a scaling	context()	negated: False ,passive: False
0.993	[*A*]the revisions that belong to the same major release[*R*]are seen In[*A*]4 plots	context()	negated: False ,passive: False
0.943	[*A*]those from different major releases[*R*]show[*A*]very different landscapes	context()	negated: False ,passive: False
0.845	[*A*]the revisions that belong to the same major release[*R*]to be[*A*]similar	context()	negated: False ,passive: True
0.965	[*A*]the revisions that belong to the same major release[*R*]are seen[*A*]In the 4 plots	context()	negated: False ,passive: True
0.887	[*A*]the revisions[*R*]belong[*A*]to the same major release	context()	negated: False ,passive: False
[LINE#585]The remainder of this section gives detail of these clustering profile changes.
0.926	[*A*]The remainder of this section[*R*]gives[*A*]detail of these clustering profile changes	context()	negated: False ,passive: False
[LINE#586]23 shows the BSCGs for the four versions of bc.
0.656	[*A*]23[*R*]shows[*A*]the BSCGs[*A*]for the four versions of bc	context()	negated: False ,passive: False
[LINE#587]Initially, the backward slice size plots (solid black lines) show very little difference.
0.961	[*A*]the backward slice size plots[*R*]show[*A*]very little difference[*A*]Initially	context()	negated: False ,passive: False
[LINE#588]However, upon closer inspection of the last three versions we see that the backward slice size plot changes slightly at around the 80% mark on the x-axis.
0.903	[*A*]the last three versions[*R*]see[*A*]we	context()	negated: False ,passive: True
[LINE#589]This is highlighted by the fact that the later three versions show an additional coherent cluster spanning from 85% to 100% on the x-axis which is absent from the initial release.
0.927	[*A*]the x-axis[*R*]is[*A*]absent from the initial release	context()	negated: False ,passive: True
0.769	[*A*]an additional coherent cluster[*R*]spanning	context()	negated: False ,passive: False
0.937	[*A*]the later three versions[*R*]show[*A*]an additional coherent cluster spanning	context()	negated: False ,passive: False
0.265	[*A*]This[*R*]is highlighted[*A*]by the fact that the later three versions show an additional coherent cluster spanning from 85% to 100% on the x-axis	context()	negated: False ,passive: True
[LINE#590]Upon inspection of the source code changes between versions bc-1.03 and bc-1.04 the following types of updates were found:1bug fixes,2addition of command line options,3reorganization of the source tree, and4addition of new commands for dc.
[LINE#591]The reorganization of the program involved significant architectural changes that separated out the code supporting bc's related dc functionality into a separate hierarchy and moved files common to both bc and dc to a library.
0.897	[*A*]significant architectural changes[*R*]moved[*A*]files common to both dc[*A*]to a library	context()	negated: False ,passive: False
0.879	[*A*]The reorganization of the program[*R*]involved[*A*]significant architectural changes that moved files common to both dc to a library	context()	negated: False ,passive: True
0.897	[*A*]significant architectural changes[*R*]moved[*A*]files common to both bc[*A*]to a library	context()	negated: False ,passive: False
0.879	[*A*]The reorganization of the program[*R*]involved[*A*]significant architectural changes that moved files common to both bc to a library	context()	negated: False ,passive: True
0.897	[*A*]significant architectural changes[*R*]separated out[*A*]the code supporting bc 's related dc functionality[*A*]into a separate hierarchy	context()	negated: False ,passive: False
0.879	[*A*]The reorganization of the program[*R*]involved[*A*]significant architectural changes that separated out the code supporting bc 's related dc functionality into a separate hierarchy	context()	negated: False ,passive: True
[LINE#592]This refactoring of the code broke up the largest cluster into two clusters, where a new third cluster is formed as seen in the SCG.
0.960	[*A*]a new third cluster[*R*]is formed[*A*]as seen in the SCG[*A*]two clusters	context()	negated: False ,passive: True
0.926	[*A*]This refactoring of the code[*R*]broke up[*A*]the largest cluster into two clusters	context()	negated: False ,passive: False
[LINE#593]Thus, the major restructuring of the code between revisions 1.03 and 1.04 causes a significant change in the cluster profile.
[LINE#594]Almost no other change is seen in the cluster profile between the remaining three bc revisions 1.04, 1.05, and 1.06, where no significant restructuring took place.
0.911	[*A*]no significant restructuring[*R*]took[*A*]place	context()	negated: False ,passive: True
0.948	[*A*]Almost no other change[*R*]is seen[*A*]in the cluster profile between the remaining three bc revisions 1.04, 1.05, and 1.06	context()	negated: False ,passive: True
[LINE#595]24 shows the SCGs for the four versions of acct considered in this study.
0.926	[*A*]the four versions of acct[*R*]considered[*A*]in this study	context()	negated: False ,passive: True
0.656	[*A*]24[*R*]shows[*A*]the SCGs[*A*]for the four versions of acct	context()	negated: False ,passive: False
[LINE#596]The slice profile and the cluster profile show very little change between acct-6.3 and acct-6.3.2.
0.956	[*A*]the cluster profile[*R*]show[*A*]very little change between acct - 6.3 and acct - 6.3.2	context()	negated: False ,passive: False
0.956	[*A*]The slice profile[*R*]show[*A*]very little change between acct - 6.3 and acct - 6.3.2	context()	negated: False ,passive: False
[LINE#597]Similarly, not much change is seen between acct-6.5 and acct-6.5.5.
0.911	[*A*]not much change[*R*]is seen[*A*]between acct-6.5 and acct-6.5.5	context()	negated: False ,passive: True
[LINE#598]However, the slice and the cluster profiles change significantly between major revisions, 6.3.X and 6.5.X.
0.911	[*A*]the cluster profiles[*R*]change significantly[*A*]between major revisions	context()	negated: False ,passive: True
[LINE#599] The change log of release 6.5 notes "" The refactoring of the code is primarily in the way system log files are handled using utmp_rd.c, file_rd.c, dump-utmp.c and stored using hash tables whose operations are defined in hashtab.c and uid_hash.c.
0.905	[*A*]hash tables[*R*]are defined[*A*]in uid_hash.c	context()	negated: False ,passive: True
0.905	[*A*]hash tables[*R*]are defined[*A*]in hashtab.c	context()	negated: False ,passive: True
0.756	[*A*]The refactoring of the code[*R*]are handled	context()	negated: False ,passive: False
0.950	[*A*]The change log of release 6.5 notes " " The refactoring of the code is primarily in the way system log files[*R*]are handled	context()	negated: False ,passive: False
0.943	[*A*]The refactoring of the code[*R*]is[*A*]primarily[*A*]in the way system log files	context()	negated: False ,passive: True
[LINE#600]Finally, Fig. 25 shows the SCGs for the 14 versions of indent.
0.975	[*A*]Fig. 25[*R*]shows[*A*]the SCGs[*A*]for the 14 versions of indent[*A*]Finally	context()	negated: False ,passive: False
[LINE#601]These revisions include two major releases.
0.903	[*A*]These revisions[*R*]include[*A*]two major releases	context()	negated: False ,passive: True
[LINE#602]It is evident from the SCGs that the slice profile during the evolution hardly changes.
[LINE#603]The cluster profile also remains similar through the evolution.
0.897	[*A*]The cluster profile[*R*]remains[*A*]similar through the evolution	context()	negated: False ,passive: True
[LINE#604]The system grows from 4466 to 6521 SLoC during its evolution which is supported by Fig. 22c showing the growth of the system SDG size.
0.642	[*A*]its evolution[*R*]is supported[*A*]by Fig	context()	negated: False ,passive: True
0.890	[*A*]The system[*R*]grows[*A*]from 4466 to 6521 SLoC[*A*]during its evolution[*A*]showing the growth of the system	context()	negated: False ,passive: True
[LINE#605]Indent is a program for formatting C programs.
0.938	[*A*]Indent[*R*]is[*A*]a program for formatting C programs	context()	negated: False ,passive: True
[LINE#606]A study of the change logs for indent did not reveal any major refactoring or restructuring.
0.943	[*A*]A study of the change logs for indent[*R*]did not reveal[*A*]any major refactoring or restructuring	context()	negated: True ,passive: False
[LINE#607]The changes to the system were mostly bug fixes and upgrades to support new command line options.
0.903	[*A*]mostly upgrades[*R*]to support[*A*]new command line options	context()	negated: False ,passive: False
0.926	[*A*]The changes to the system[*R*]were[*A*]mostly upgrades to support new command line options	context()	negated: False ,passive: True
0.903	[*A*]bug fixes[*R*]to support[*A*]new command line options	context()	negated: False ,passive: False
0.926	[*A*]The changes to the system[*R*]were[*A*]mostly[*A*]bug fixes to support new command line options	context()	negated: False ,passive: True
[LINE#608]This results in almost negligible changes in the slice and cluster profiles despite the system evolution and growth.
0.497	[*A*]This[*R*]results[*A*]in almost negligible changes in the cluster profiles despite growth	context()	negated: False ,passive: True
0.497	[*A*]This[*R*]results[*A*]in almost negligible changes in the cluster profiles despite the system evolution	context()	negated: False ,passive: True
0.497	[*A*]This[*R*]results[*A*]in almost negligible changes in the slice profiles despite growth	context()	negated: False ,passive: True
0.497	[*A*]This[*R*]results[*A*]in almost negligible changes in the slice profiles despite the system evolution	context()	negated: False ,passive: True
[LINE#609]As an answer to RQ7, this study finds that unless there is significant refactoring of the system, coherent cluster profiles remain stable during system evolution and thus captures the core architecture of the program in all three case studies.
0.752	[*A*]this study[*R*]finds[*A*]that unless there is significant refactoring of the system thus captures the core architecture of the program in all three case studies	context()	negated: False ,passive: False
0.888	[*A*]coherent cluster profiles[*R*]remain[*A*]stable[*A*]during system evolution	context(this study finds)	negated: False ,passive: True
0.752	[*A*]this study[*R*]finds[*A*]that unless there is significant refactoring of the system , coherent cluster profiles remain stable during system evolution	context()	negated: False ,passive: False
[LINE#610]Future work will replicate this longitudinal study on a large code corpus to ascertain whether this stability holds for other programs.
0.937	[*A*]Future work[*R*]will replicate[*A*]this longitudinal study on a large code corpus to ascertain whether this stability holds for other programs	context()	negated: False ,passive: False
[LINE#611]Threats to validityThis section presents threats to the validity of the results presented.
0.878	[*A*]Threats to validityThis section presents threats to the validity of the results[*R*]presented	context()	negated: False ,passive: False
[LINE#612]Threats to three types of validity (external, internal and construct) are considered.
0.773	[*A*]Threats to three types of validity[*R*]are considered	context()	negated: False ,passive: False
[LINE#613]The primary external threat arises from the possibility that the programs selected are not representative of programs in general (i.e., the findings of the experiments do not apply to 'typical' programs).
0.836	[*A*]The primary external threat[*R*]arises[*A*]from the possibility that the programs selected are not representative of programs in general	context(the findings of the experiments do not apply)	negated: False ,passive: True
0.905	[*A*]the findings of the experiments[*R*]do not apply[*A*]to 'typical' programs	context()	negated: True ,passive: True
0.911	[*A*]the programs selected[*R*]are not[*A*]representative of programs in general	context()	negated: True ,passive: True
0.732	[*A*]the programs[*R*]selected	context()	negated: False ,passive: False
[LINE#614]This is a reasonable concern that applies to any study of program properties.
0.897	[*A*]a reasonable concern[*R*]applies[*A*]to any study of program properties	context()	negated: False ,passive: True
0.323	[*A*]This[*R*]is[*A*]a reasonable concern that applies to any study of program properties	context()	negated: False ,passive: True
[LINE#615]To address this issue, a set of thirty open-source and industrial programs were analyzed in the quantitative study.
0.943	[*A*]a set of thirty open - industrial programs[*R*]were analyzed[*A*]in the quantitative study	context()	negated: False ,passive: True
0.943	[*A*]a set of thirty open - source programs[*R*]were analyzed[*A*]in the quantitative study	context()	negated: False ,passive: True
[LINE#616]The programs were not selected based on any criteria or property and thus represent a random selection from various domains.
0.732	[*A*]The programs[*R*]were not selected	context()	negated: True ,passive: False
[LINE#617]However, these were from the set of programs that were studied in previous work on dependence clusters to facilitate comparison with previous results.
0.877	[*A*]programs[*R*]were studied[*A*]in previous work[*A*]on dependence clusters[*A*]to facilitate comparison with previous results	context()	negated: False ,passive: True
0.544	[*A*]these[*R*]were[*A*]from the set of programs	context()	negated: False ,passive: True
[LINE#618]In addition, all of the programs studied were C programs, so there is greater uncertainty that the results will hold for other programming paradigms such as object-oriented or aspect-oriented programming.
0.937	[*A*]the results[*R*]will hold[*A*]for other programming paradigms such as object-oriented or aspect-oriented programming	context()	negated: False ,passive: False
0.905	[*A*]all of the programs[*R*]were[*A*]C programs	context()	negated: False ,passive: True
0.732	[*A*]the programs[*R*]studied	context()	negated: False ,passive: False
[LINE#619]Internal validity is the degree to which conclusions can be drawn about the causal effect of the independent variables on the dependent variable.
0.934	[*A*]the degree[*R*]can be drawn[*A*]conclusions	context()	negated: False ,passive: True
0.952	[*A*]Internal validity[*R*]is[*A*]the degree to which conclusions can be drawn about the causal effect of the independent variables on the dependent variable	context()	negated: False ,passive: True
[LINE#620]The use of hash values to approximate slice content during clustering is a source of potential internal threat.
0.385	[*A*]clustering[*R*]is a source of[*A*]potential internal threat	context()	negated: False ,passive: False
0.967	[*A*]The use of hash values to approximate slice content during clustering[*R*]is[*A*]a source of potential internal threat	context()	negated: False ,passive: True
[LINE#621]The approach assumes that hash values uniquely identify slice contents.
0.882	[*A*]hash values[*R*]uniquely identify[*A*]slice contents	context(The approach assumes)	negated: False ,passive: False
0.731	[*A*]The approach[*R*]assumes[*A*]that hash values uniquely identify slice contents	context()	negated: False ,passive: False
[LINE#622]Hash functions are prone to hash collision which in our approach can cause clustering errors.
0.884	[*A*]hash collision[*R*]can cause[*A*]clustering errors[*A*]in our approach	context()	negated: False ,passive: False
0.903	[*A*]Hash functions[*R*]are[*A*]prone to hash collision	context()	negated: False ,passive: True
[LINE#623]The hash function used is carefully crafted to minimize collision and its use is validated in Section 3.3.
0.585	[*A*]its use[*R*]is validated[*A*]in Section 3.3	context(The hash function used to minimize)	negated: False ,passive: True
0.806	[*A*]The hash function used[*R*]to minimize[*A*]its use is validated in Section 3.3	context()	negated: False ,passive: False
0.860	[*A*]The hash function used[*R*]is carefully crafted[*A*]to minimize its use is validated in Section 3.3	context()	negated: False ,passive: True
0.905	[*A*]The hash function used[*R*]to minimize[*A*]collision	context()	negated: False ,passive: False
0.919	[*A*]The hash function used[*R*]is carefully crafted[*A*]to minimize collision	context()	negated: False ,passive: True
0.751	[*A*]The hash function[*R*]used	context()	negated: False ,passive: False
[LINE#624]Furthermore, the identification of logical structure in programs were done by the authors of the paper who are not involved in the development of any of the case study subjects.
0.927	[*A*]the paper[*R*]are not involved[*A*]in the development of any of the case study subjects	context()	negated: True ,passive: True
0.938	[*A*]the identification of logical structure in programs[*R*]were done[*A*]by the authors of the paper	context()	negated: False ,passive: True
[LINE#625]This brings about the possibility that the identified structures do not represent actual logical constructs of the programs.
0.911	[*A*]the identified structures[*R*]do not represent[*A*]actual logical constructs of the programs	context()	negated: True ,passive: False
0.193	[*A*]This[*R*]brings	context()	negated: False ,passive: False
[LINE#626]As the case studies are Unix utilities, their design specification are not available for evaluation.
0.660	[*A*]their design specification[*R*]are not[*A*]available for evaluation	context()	negated: True ,passive: True
0.925	[*A*]the case studies[*R*]are[*A*]Unix utilities	context()	negated: False ,passive: True
[LINE#627]Future work will entail consultation with the development team of the systems to further validate the results.
0.903	[*A*]Future work[*R*]will entail[*A*]consultation with the development team of the systems[*A*]to further validate the results	context()	negated: False ,passive: False
[LINE#628]Construct validity refers to the validity that observations or measurement tools actually represent or measure the construct being investigated.
0.811	[*A*]the validity[*R*]represent[*A*]that observations or measurement tools	context()	negated: False ,passive: True
0.903	[*A*]Construct validity[*R*]refers[*A*]to the validity	context()	negated: False ,passive: False
[LINE#629]In this paper, one possible threat to construct arises from the potential for faults in the slicer.
[LINE#630]A mature and widely used slicing tool (CodeSurfer) is used to mitigate this concern.
0.913	[*A*]A widely used slicing tool[*R*]to mitigate[*A*]this concern	context()	negated: False ,passive: False
0.913	[*A*]A widely used slicing tool[*R*]is used[*A*]to mitigate this concern	context()	negated: False ,passive: True
0.905	[*A*]A mature slicing tool[*R*]to mitigate[*A*]this concern	context()	negated: False ,passive: False
0.905	[*A*]A mature slicing tool[*R*]is used[*A*]to mitigate this concern	context()	negated: False ,passive: True
[LINE#631]Another possible concern surrounds the precision of the pointer analysis used.
0.751	[*A*]the pointer analysis[*R*]used	context()	negated: False ,passive: False
0.911	[*A*]Another possible concern[*R*]surrounds[*A*]the precision of the pointer analysis	context()	negated: False ,passive: False
[LINE#632]An overly conservative, and therefore imprecise, analysis would tend to increase the levels of dependence and potentially also increase the size of clusters.
0.913	[*A*]An therefore imprecise , analysis[*R*]increase[*A*]the size of clusters	context()	negated: False ,passive: False
0.913	[*A*]An therefore imprecise , analysis[*R*]to increase[*A*]the levels of	context()	negated: False ,passive: False
0.926	[*A*]An therefore imprecise , analysis[*R*]would tend[*A*]to increase the levels of	context()	negated: False ,passive: True
0.913	[*A*]An overly conservative , analysis[*R*]increase[*A*]the size of clusters	context()	negated: False ,passive: False
0.913	[*A*]An overly conservative , analysis[*R*]to increase[*A*]the levels of	context()	negated: False ,passive: False
0.926	[*A*]An overly conservative , analysis[*R*]would tend[*A*]to increase the levels of	context()	negated: False ,passive: True
0.913	[*A*]An therefore imprecise , analysis[*R*]to increase[*A*]the levels of dependence	context()	negated: False ,passive: False
0.926	[*A*]An therefore imprecise , analysis[*R*]would tend[*A*]to increase the levels of dependence	context()	negated: False ,passive: True
0.913	[*A*]An overly conservative , analysis[*R*]to increase[*A*]the levels of dependence	context()	negated: False ,passive: False
0.926	[*A*]An overly conservative , analysis[*R*]would tend[*A*]to increase the levels of dependence	context()	negated: False ,passive: True
[LINE#633]There is no automatic way to tell whether a cluster arises because of imprecision in the computation of dependence or whether it is 'real'.
0.243	[*A*]it[*R*]is[*A*]real	context()	negated: False ,passive: True
[LINE#634]Section 3.2 discusses the various pointer analysis settings and validates its precision.
0.821	[*A*]Section[*R*]validates[*A*]its precision	context()	negated: False ,passive: False
0.903	[*A*]Section 3.2[*R*]discusses[*A*]the various pointer analysis settings	context()	negated: False ,passive: False
[LINE#635]CodeSurfer's most precise pointer analysis option was used for the study.
0.953	[*A*]CodeSurfer's most precise pointer analysis option[*R*]was used[*A*]for the study	context()	negated: False ,passive: True
[LINE#636]Program dependence analysis is a foundation for many activities in software engineering such as testing, comprehension, and impact analysis (Binkley, 2007).
0.956	[*A*]Program dependence analysis[*R*]is[*A*]a foundation for many activities in software engineering such as impact analysis	context()	negated: False ,passive: True
0.956	[*A*]Program dependence analysis[*R*]is[*A*]a foundation for many activities in software engineering such as comprehension	context()	negated: False ,passive: True
0.956	[*A*]Program dependence analysis[*R*]is[*A*]a foundation for many activities in software engineering such as testing	context()	negated: False ,passive: True
[LINE#637]For example, it is essential to understand the relationships between different parts of a system when making changes and the impacts of these changes (Gallagher and Lyle, 1991).
[LINE#638] This has led to both static (Yau and Collofello, 1985; Black, 2001) and blended (static and dynamic) (dependence analyses of the relationships between dependence and impact.
0.425	[*A*]This[*R*]has led[*A*]to both static Collofello	context()	negated: False ,passive: False
0.425	[*A*]This[*R*]has led[*A*]to both static ( Yau	context()	negated: False ,passive: False
[LINE#639]One important property of dependence is the way in which it may cluster.
0.195	[*A*]it[*R*]may cluster	context()	negated: False ,passive: False
0.900	[*A*]One important property of dependence[*R*]is[*A*]the way in which it may cluster	context()	negated: False ,passive: True
[LINE#640]This occurs when a set of statements all depend upon one another, forming a dependence cluster.
0.771	[*A*]a set of statements[*R*]depend[*A*]upon one another	context()	negated: False ,passive: False
0.497	[*A*]This[*R*]occurs[*A*]when a set of statements all depend upon one another, forming a dependence cluster	context()	negated: False ,passive: True
[LINE#641]Within such a cluster, any change to an element potentially affects every other element of the cluster.
0.949	[*A*]any change to an element[*R*]affects[*A*]every other element of the cluster[*A*]Within such a cluster	context()	negated: False ,passive: False
[LINE#642]If such a dependence cluster is very large, then this mutual dependence clearly has implications related to the cost of maintaining the code.
0.894	[*A*]implications[*R*]related[*A*]to the cost of maintaining the code	context()	negated: False ,passive: True
0.954	[*A*]this mutual dependence[*R*]has[*A*]implications related to the cost of maintaining the code[*A*]then	context()	negated: False ,passive: False
0.841	[*A*]such a dependence cluster[*R*]is[*A*]very large	context()	negated: False ,passive: True
[LINE#643]In previous work (Binkley and Harman, 2005), we introduced the study of dependence clusters in terms of program slicing and demonstrated that large dependence clusters were (perhaps surprisingly) common, both in production (closed source) code and in open source code (Harman et al., 2009).
0.595	[*A*]we[*R*]introduced[*A*]the study of dependence clusters[*A*]in terms of program slicing[*A*]In previous work	context()	negated: False ,passive: False
[LINE#644]Our findings over a large corpus of C code was that 89% of the programs studied contained at least one dependence cluster composed of 10% or more of the program's statements.
0.745	[*A*]Our findings over a large corpus of C code[*R*]was[*A*]that 89% of the programs studied contained at least one dependence cluster	context()	negated: False ,passive: True
0.952	[*A*]at least one dependence cluster[*R*]composed[*A*]of 10% or more of the program's statements	context()	negated: False ,passive: True
[LINE#645]The average size of the programs studied was 20KLoC, so these clusters of more than 10% denoted significant portions of code.
0.732	[*A*]the programs[*R*]studied	context()	negated: False ,passive: False
[LINE#646]We also found evidence of super-large clusters: 40% of the programs had a dependence cluster that consumed over half of the program.
0.882	[*A*]40% of the programs[*R*]had[*A*]a dependence cluster that consumed over half of the program	context(We found)	negated: False ,passive: False
0.349	[*A*]We[*R*]found[*A*]evidence of super-large clusters	context()	negated: False ,passive: False
0.897	[*A*]a dependence cluster[*R*]consumed[*A*]over half of the program	context()	negated: False ,passive: False
[LINE#647]More recently, our finding that large clusters are widespread in C systems has been replicated for other languages and systems by other authors, both in open source and in proprietary code (Acharya and Robinson, 2011; Beszdes et al., 2007; Szegedi et al., 2007).
0.861	[*A*]our finding that large clusters are widespread in C systems[*R*]has been replicated[*A*]by other authors[*A*]More recently	context(Beszdes et)	negated: False ,passive: True
0.885	[*A*]our finding that large clusters are widespread in C systems[*R*]has been replicated[*A*]by other authors[*A*]More recently	context()	negated: False ,passive: True
0.861	[*A*]our finding that large clusters are widespread in C systems[*R*]has been replicated[*A*]by other authors[*A*]More recently	context(Beszdes et)	negated: False ,passive: True
0.936	[*A*]Beszdes[*R*]et[*A*]al	context()	negated: False ,passive: False
0.902	[*A*]our finding that large clusters are widespread in C systems[*R*]has been replicated[*A*]for other languages[*A*]by other authors[*A*]More recently	context()	negated: False ,passive: True
0.918	[*A*]large clusters[*R*]are[*A*]widespread[*A*]in C systems	context()	negated: False ,passive: True
[LINE#648] Large dependence clusters were also found in Java systems (Beszdes et al., 2007; Savernik, 2007; Szegedi et al., 2007)and in legacy Cobol systems (Hajnal and Forgcs, 2011).There has been interesting work on the relationship between faults, program size, and dependence clusters (Black et al., 2006), and between impact analysis and dependence clusters (Acharya and Robinson, 2011; Harman et al., 2009).
0.890	[*A*]Large dependence clusters[*R*]were found[*A*]in Java systems	context()	negated: False ,passive: True
[LINE#649]Large dependence clusters can be thought of as dependence 'anti-patterns' because of the high impact that a change anywhere in the cluster has.
0.954	[*A*]the high impact[*R*]has[*A*]a change anywhere in the cluster	context()	negated: False ,passive: True
0.943	[*A*]Large dependence clusters[*R*]can be thought[*A*]of as dependence 'anti-patterns' because of the high impact	context()	negated: False ,passive: True
[LINE#650]For example, it may lead to problems for on-going software maintenance and evolution (Acharya and Robinson, 2011; Binkley et al., 2008; Savernik, 2007).
0.452	[*A*]it[*R*]may lead[*A*]to problems for on - going evolution	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]may lead[*A*]to problems for on - going software maintenance	context()	negated: False ,passive: False
[LINE#651]As a result, refactoring has been proposed as a technique for breaking larger clusters of dependence into smaller clusters (Binkley and Harman, 2005; Black et al., 2009).Dependence cluster analysis is complicated by the fact that inter-procedural program dependence is non-transitive, which means that the statements in a traditional dependence cluster, though they all depend on each other, may not each depend on the same set of statements, nor need they necessarily affect the same set of statements external to the cluster.
0.828	[*A*]inter-procedural program dependence[*R*]is[*A*]non-transitive	context()	negated: False ,passive: True
0.765	[*A*]Dependence cluster analysis[*R*]is complicated[*A*]by the fact that inter-procedural program dependence is non-transitive, which means that the statements in a traditional dependence cluster, though they all depend on each other, may not each depend on the same set of statements, nor need they necessarily affect the same set of statements external to the cluster	context()	negated: False ,passive: True
0.323	[*A*]they[*R*]depend[*A*]on each other	context()	negated: False ,passive: False
0.931	[*A*]refactoring[*R*]has been proposed[*A*]as a technique for breaking larger clusters of dependence into smaller clusters	context()	negated: False ,passive: True
[LINE#652]This paper introduces and empirically studies11Preliminary results were presented at PASTE (Islam et al., 2010b).
0.918	[*A*]studies11Preliminary results[*R*]were presented[*A*]at PASTE ( Islam et al	context()	negated: False ,passive: True
0.732	[*A*]This paper[*R*]introduces	context()	negated: False ,passive: False
[LINE#653]In a coherent dependence cluster all statements share identical intra-cluster and extra-cluster dependence.
0.943	[*A*]all statements[*R*]share[*A*]extra-cluster dependence[*A*]In a coherent dependence cluster	context()	negated: False ,passive: False
0.943	[*A*]all statements[*R*]share[*A*]identical intra-cluster[*A*]In a coherent dependence cluster	context()	negated: False ,passive: False
[LINE#654]A coherent dependence cluster is thus more constrained than a general dependence cluster.
0.737	[*A*]A coherent dependence cluster[*R*]more constrained	context()	negated: False ,passive: False
0.937	[*A*]A coherent dependence cluster[*R*]is[*A*]thus more constrained than a general dependence cluster	context()	negated: False ,passive: True
[LINE#655]A coherent dependence cluster retains the essential property that all statements within the cluster are mutually dependent, but adds the constraint that all incoming dependence must be identical and all outgoing dependence must also be identical.
0.702	[*A*]all outgoing dependence[*R*]must be[*A*]identical	context()	negated: False ,passive: True
0.889	[*A*]A coherent dependence[*R*]adds[*A*]the constraint that all outgoing dependence must also be identical	context()	negated: False ,passive: False
0.783	[*A*]all incoming dependence[*R*]must be[*A*]identical	context()	negated: False ,passive: True
0.833	[*A*]A coherent dependence[*R*]adds[*A*]the constraint that all incoming dependence must be identical	context()	negated: False ,passive: False
0.814	[*A*]all statements within the cluster[*R*]are[*A*]mutually dependent	context()	negated: False ,passive: True
0.869	[*A*]A coherent dependence cluster[*R*]retains[*A*]the essential property that all statements within the cluster are mutually dependent	context()	negated: False ,passive: False
[LINE#656] That is, all statements within a coherent cluster depend upon the same set of statements outside the cluster andall statements within a coherent cluster affect the same set of statements outside the cluster.
0.956	[*A*]all statements within a coherent cluster[*R*]depend[*A*]upon the same set of statements outside the cluster andall statements within a coherent cluster	context()	negated: False ,passive: False
[LINE#657]This means that, when studying a coherent cluster, we need to understand only a single external dependence context in order to understand the behavior of the entire cluster.
0.388	[*A*]we[*R*]need to understand[*A*]only a single external dependence context[*A*]in order	context(This means we need)	negated: False ,passive: False
0.645	[*A*]we[*R*]need[*A*]to understand only a single external dependence context in order[*A*]when studying a coherent cluster	context(This means)	negated: False ,passive: False
0.131	[*A*]This[*R*]means[*A*]that, when studying a coherent cluster, we need to understand only a single external dependence context in order	context()	negated: False ,passive: False
[LINE#658]For a dependence cluster that fails to meet the external constraint, statements of the cluster may have a different external dependence context.
0.919	[*A*]statements of the cluster[*R*]may have[*A*]a different external dependence context	context()	negated: False ,passive: False
0.897	[*A*]a dependence cluster[*R*]to meet[*A*]the external constraint	context()	negated: False ,passive: False
0.897	[*A*]a dependence cluster[*R*]fails[*A*]to meet the external constraint	context()	negated: False ,passive: True
[LINE#659]This is possible because inter-procedural dependence is non-transitive.
0.813	[*A*]inter-procedural dependence[*R*]is[*A*]non-transitive	context()	negated: False ,passive: True
0.449	[*A*]This[*R*]is[*A*]possible[*A*]because inter-procedural dependence is non-transitive	context()	negated: False ,passive: True
[LINE#660]It might be thought that very few sets of statements would meet these additional coherence constraints, or that, where such sets of statements do meet the constraints, there would be relatively few statements in the coherent cluster so-formed.
0.919	[*A*]such sets of statements[*R*]do meet[*A*]the constraints	context()	negated: False ,passive: False
[LINE#661]Our empirical findings provide evidence that this is not the case: coherent dependence clusters are common and they can be very large.
0.361	[*A*]they[*R*]can be[*A*]very large	context()	negated: False ,passive: True
0.250	[*A*]this[*R*]is not[*A*]the case : they can be very large	context()	negated: True ,passive: True
0.382	[*A*]Our empirical findings[*R*]provide[*A*]evidence that this is not the case : they can be very large	context()	negated: False ,passive: False
0.783	[*A*]coherent dependence clusters[*R*]are[*A*]common	context()	negated: False ,passive: True
0.381	[*A*]this[*R*]is not[*A*]the case : coherent dependence clusters are common	context()	negated: True ,passive: True
0.532	[*A*]Our empirical findings[*R*]provide[*A*]evidence that this is not the case : coherent dependence clusters are common	context()	negated: False ,passive: False
[LINE#662]This paper is part of a series of work that we have conducted in the area of dependence clusters.
0.786	[*A*]work[*R*]have conducted[*A*]in the area of dependence clusters	context()	negated: False ,passive: True
0.925	[*A*]This paper[*R*]is[*A*]part of a series of work	context()	negated: False ,passive: True
[LINE#663]The overarching motivation for this work is to gain a better understanding of the dependence clusters found in programs.
0.911	[*A*]the dependence clusters[*R*]found[*A*]in programs	context()	negated: False ,passive: True
0.948	[*A*]The overarching motivation for this work[*R*]is[*A*]to gain a better understanding of the dependence clusters	context()	negated: False ,passive: True
[LINE#664]Although this paper is a continuation of our previous work on dependence clusters, we present the work in a completely new light.
0.452	[*A*]we[*R*]present[*A*]the work in a completely new light	context()	negated: False ,passive: False
0.870	[*A*]this paper[*R*]is[*A*]a continuation of our previous work on dependence clusters	context()	negated: False ,passive: True
[LINE#665]In this paper we show that the specialized version of dependence clusters, coherent clusters are found in abundance in programs and need not be regarded as problems.
0.610	[*A*]we[*R*]show[*A*]the specialized version of dependence clusters[*A*]In this paper	context(coherent clusters are found)	negated: False ,passive: False
0.882	[*A*]coherent clusters[*R*]are found[*A*]in abundance in programs	context()	negated: False ,passive: True
0.878	[*A*]coherent clusters[*R*]are found[*A*]in abundance in programs	context(we show)	negated: False ,passive: True
0.468	[*A*]we[*R*]show[*A*]that , coherent clusters are found in abundance in programs and need not be regarded as problems[*A*]In this paper	context()	negated: False ,passive: False
0.887	[*A*]coherent clusters[*R*]need not be regarded[*A*]as problems	context()	negated: True ,passive: True
[LINE#666]We rather show that these clusters map to logical program structures which will aid developers in program comprehension and understanding.
0.905	[*A*]these clusters[*R*]map[*A*]to logical program structures	context(We show)	negated: False ,passive: False
0.206	[*A*]We[*R*]show[*A*]that these clusters map to logical program structures	context()	negated: False ,passive: False
0.897	[*A*]logical program structures[*R*]will aid[*A*]developers	context()	negated: False ,passive: False
[LINE#667]Furthermore, this paper extends the current knowledge in the area and motivates future work by presenting initial results of inter-cluster dependence which can be used as a foundation for reverse engineering.
0.887	[*A*]inter-cluster dependence[*R*]can be used[*A*]as a foundation for reverse engineering	context()	negated: False ,passive: True
0.903	[*A*]this paper[*R*]extends[*A*]the current knowledge in the area	context()	negated: False ,passive: False
[LINE#668]We answer several representative open questions such as whether clusters are related to program faults and how clusters change over time during system evolution.
0.894	[*A*]clusters[*R*]change[*A*]over time[*A*]during system evolution	context()	negated: False ,passive: True
0.894	[*A*]clusters[*R*]are related[*A*]to how clusters change over time during system evolution	context()	negated: False ,passive: True
0.569	[*A*]We[*R*]answer[*A*]several representative open questions such as whether clusters are related to how clusters change over time during system evolution	context()	negated: False ,passive: False
0.894	[*A*]clusters[*R*]are related[*A*]to program faults	context()	negated: False ,passive: True
0.569	[*A*]We[*R*]answer[*A*]several representative open questions such as whether clusters are related to program faults	context()	negated: False ,passive: False
[LINE#669]The primary contributions of the paper are as follows:1An Empirical analysis of thirty programs assesses the frequency and size of coherent dependence clusters.
0.447	[*A*]follows:1An[*R*]assesses[*A*]the size of coherent dependence clusters	context()	negated: False ,passive: False
0.917	[*A*]The primary contributions of the paper[*R*]are[*A*]as follows:1An Empirical analysis of thirty programs	context(follows:1An assesses)	negated: False ,passive: True
0.447	[*A*]follows:1An[*R*]assesses[*A*]the frequency of coherent dependence clusters	context()	negated: False ,passive: False
[LINE#670]The results demonstrate that large coherent clusters are common, validating their further study.2Two further empirical validation studies consider the impact of data-flow analysis precision and the precision of the approximation used to efficiently identify coherent clusters.3A series of four case studies shows how coherent clusters map to logical program structures.4A study of inter-cluster dependence highlights how coherent clusters form the building blocks of larger dependence structures where identification can support, as an example, reverse engineering.5A study of bug fixes finds no relationship between program faults and coherent clusters implying that dependence clusters are not responsible for program faults.6A longitudinal study of system evolution shows that coherent clusters remain stable during evolution thus depicting the core architecture of systems.
0.877	[*A*]evolution[*R*]depicting[*A*]the core architecture of systems	context()	negated: False ,passive: False
0.900	[*A*]dependence clusters[*R*]are not[*A*]responsible for program faults.6A longitudinal study of system evolution	context(coherent clusters implying)	negated: True ,passive: True
0.840	[*A*]coherent clusters[*R*]implying[*A*]that dependence clusters are not responsible for program faults.6A longitudinal study of system evolution	context()	negated: False ,passive: False
0.825	[*A*]large coherent clusters[*R*]validating[*A*]their further study.2Two further empirical validation studies	context()	negated: False ,passive: False
0.926	[*A*]identification[*R*]can support[*A*]larger dependence structures	context()	negated: False ,passive: False
[LINE#671]The remainder of this paper is organized as follows: Section 2 provides background on coherent clusters and their visualization.
0.915	[*A*]The remainder of this paper[*R*]is organized[*A*]as follows : Section 2 provides background on their visualization	context()	negated: False ,passive: True
0.778	[*A*]The remainder of this paper[*R*]is organized[*A*]as follows	context(Section 2 provides)	negated: False ,passive: True
0.882	[*A*]Section 2[*R*]provides[*A*]background on coherent clusters	context()	negated: False ,passive: False
[LINE#672]Section 3 provides details on the subject programs, the validation of the slice approximation used, and the experimental setup.
0.751	[*A*]the slice approximation[*R*]used	context()	negated: False ,passive: False
0.903	[*A*]Section 3[*R*]provides[*A*]details[*A*]on the subject programs	context()	negated: False ,passive: False
[LINE#673]This is followed by quantitative and qualitative studies into the existence and impact of coherent dependence clusters and the inter-cluster dependence study.
0.381	[*A*]This[*R*]is followed[*A*]by qualitative studies	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]is followed[*A*]by quantitative studies	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]is followed[*A*]by qualitative studies into the existence	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]is followed[*A*]by quantitative studies into the existence	context()	negated: False ,passive: True
[LINE#674]It also includes studies on program faults and system evolution and their relationship to coherent clusters.
0.274	[*A*]It[*R*]includes[*A*]studies on their relationship to coherent clusters	context()	negated: False ,passive: True
0.411	[*A*]It[*R*]includes[*A*]studies on system evolution	context()	negated: False ,passive: True
0.411	[*A*]It[*R*]includes[*A*]studies on program faults	context()	negated: False ,passive: True
[LINE#675]Section 4 considers related work and finally, Section 5 summarizes the work presented.
0.732	[*A*]the work[*R*]presented	context()	negated: False ,passive: False
0.943	[*A*]Section 5[*R*]summarizes[*A*]the work presented[*A*]finally	context()	negated: False ,passive: False
0.903	[*A*]Section 4[*R*]considers[*A*]related work	context()	negated: False ,passive: False
[LINE#676]Related workIn testing, dependence analysis has been shown to be effective at reducing the computational effort required to automate the test-data generation process (Ali et al., 2010).
0.911	[*A*]the computational effort[*R*]required[*A*]to automate the test-data generation process	context()	negated: False ,passive: True
0.887	[*A*]dependence analysis[*R*]to be[*A*]effective at reducing the computational effort	context()	negated: False ,passive: True
0.732	[*A*]dependence analysis[*R*]has been shown	context()	negated: False ,passive: False
[LINE#677]In software maintenance, dependence analysis is used to protect a software maintainer against the potentially unforeseen side effects of a maintenance change.
0.927	[*A*]dependence analysis[*R*]to protect[*A*]a software maintainer against the potentially unforeseen side effects of a maintenance change	context()	negated: False ,passive: False
0.964	[*A*]dependence analysis[*R*]is used[*A*]to protect a software maintainer against the potentially unforeseen side effects of a maintenance change[*A*]In software maintenance	context()	negated: False ,passive: True
[LINE#678]This can be achieved by measuring the impact of the proposed change (Black, 2001) or by attempting to identify portions of code for which a change can be safely performed free from side effects (Gallagher and Lyle, 1991; Tonella, 2003).
0.342	[*A*]This[*R*]by measuring[*A*]the impact of the proposed change	context()	negated: False ,passive: False
0.732	[*A*]a change[*R*]can be safely performed	context()	negated: False ,passive: False
0.153	[*A*]This[*R*]can be achieved	context()	negated: False ,passive: False
[LINE#679]A recently proposed impact analysis framework (Acharya and Robinson, 2011) reports that impact sets are often part of large dependence clusters when using time consuming but high precision slicing.
0.882	[*A*]impact sets[*R*]are[*A*]often[*A*]part of large dependence clusters	context(A recently proposed impact analysis framework reports)	negated: False ,passive: True
0.882	[*A*]impact sets[*R*]are[*A*]often[*A*]part of large dependence clusters[*A*]when using time	context(A recently proposed impact analysis framework reports)	negated: False ,passive: True
0.882	[*A*]impact sets[*R*]are[*A*]often[*A*]part of large dependence clusters	context(A recently proposed impact analysis framework reports)	negated: False ,passive: True
0.845	[*A*]A recently proposed impact analysis framework[*R*]reports[*A*]that impact sets are often part of large dependence clusters	context()	negated: False ,passive: False
0.882	[*A*]impact sets[*R*]are[*A*]often[*A*]part of large dependence clusters[*A*]when using time	context(A recently proposed impact analysis framework reports)	negated: False ,passive: True
0.845	[*A*]A recently proposed impact analysis framework[*R*]reports[*A*]that impact sets are often part of large dependence clusters when using time	context()	negated: False ,passive: False
0.713	[*A*]time[*R*]consuming	context()	negated: False ,passive: False
[LINE#680]When low precision slicing is used, the study reports smaller dependence clusters.
0.943	[*A*]the study[*R*]reports[*A*]smaller dependence clusters[*A*]When low precision slicing is used	context()	negated: False ,passive: False
0.751	[*A*]low precision slicing[*R*]is used	context()	negated: False ,passive: False
[LINE#681]This paper uses the most precise static slicing available.
0.903	[*A*]This paper[*R*]uses[*A*]the most precise static slicing available	context()	negated: False ,passive: False
[LINE#682]There has also been recent work on finding dependence communities in software (Hamilton and Danicic, 2012) where social network community structure detection algorithms are applied to slice-inclusion graphs to identify communities.
0.932	[*A*]social network community structure detection algorithms[*R*]are applied[*A*]to slice - inclusion graphs	context()	negated: False ,passive: True
[LINE#683]Dependence clusters have previously been linked to software faults (Black et al., 2006) and have been identified as a potentially harmful 'dependence anti-pattern' (Binkley et al., 2008).
0.903	[*A*]Dependence clusters[*R*]have been identified[*A*]as a potentially harmful ' dependence anti-pattern	context()	negated: False ,passive: True
0.761	[*A*]Dependence clusters[*R*]have been linked[*A*]previously	context()	negated: False ,passive: True
[LINE#684]The presence of large dependence cluster was thought to reduce the effectiveness of testing and maintenance support techniques.
0.921	[*A*]The presence of large dependence cluster[*R*]to reduce[*A*]the effectiveness of maintenance support techniques	context()	negated: False ,passive: False
0.921	[*A*]The presence of large dependence cluster[*R*]to reduce[*A*]the effectiveness of testing support techniques	context()	negated: False ,passive: False
0.801	[*A*]The presence of large dependence cluster[*R*]was thought	context()	negated: False ,passive: False
[LINE#685]Having considered dependence clusters harmful, previous work on dependence clusters focuses on locating dependence clusters, understanding their cause, and removing them.
0.871	[*A*]previous work on dependence clusters[*R*]focuses[*A*]on removing them	context()	negated: False ,passive: False
0.871	[*A*]previous work on dependence clusters[*R*]focuses[*A*]on understanding their cause	context()	negated: False ,passive: False
0.926	[*A*]previous work on dependence clusters[*R*]focuses[*A*]on locating dependence clusters	context()	negated: False ,passive: False
[LINE#686]The first of these studies (Binkley and Harman, 2005; Harman et al., 2009) were based on efficient technique for locating dependence clusters and identifying dependence pollution (avoidable dependence clusters).
0.913	[*A*]The first of these studies[*R*]were based[*A*]on efficient technique for identifying dependence pollution	context()	negated: False ,passive: True
0.913	[*A*]The first of these studies[*R*]were based[*A*]on efficient technique for locating dependence clusters	context()	negated: False ,passive: True
[LINE#687]One common cause of large dependence clusters is the use of global variables.
0.952	[*A*]One common cause of large dependence clusters[*R*]is[*A*]the use of global variables	context()	negated: False ,passive: True
[LINE#688]A study of 21 programs found that 50% of the programs had a global variable that was responsible for holding together large dependence clusters (Binkley et al., 2009).
0.903	[*A*]50% of the programs[*R*]had[*A*]a global variable that was responsible for holding together large dependence clusters (Binkley et al., 2009)	context(A study of 21 programs found)	negated: False ,passive: False
0.854	[*A*]A study of 21 programs[*R*]found[*A*]that 50% of the programs had a global variable	context()	negated: False ,passive: False
0.920	[*A*]a global variable[*R*]was[*A*]responsible for holding together large dependence clusters	context()	negated: False ,passive: True
[LINE#689]Other work on dependence clusters in software engineering has considered clusters at both low-level (Binkley and Harman, 2005; Harman et al., 2009) (SDG based) and high-level (Eisenbarth et al., 2003; Mitchell and Mancoridis, 2006) (models and functions) abstractions.
0.952	[*A*]Other work on dependence clusters in software engineering[*R*]has considered[*A*]clusters at both low - level ( Harman	context()	negated: False ,passive: False
0.952	[*A*]Other work on dependence clusters in software engineering[*R*]has considered[*A*]clusters at both low - level ( Binkley	context()	negated: False ,passive: False
0.918	[*A*]software engineering[*R*]has considered[*A*]clusters at both low - level ( Harman	context()	negated: False ,passive: False
0.918	[*A*]software engineering[*R*]has considered[*A*]clusters at both low - level ( Binkley	context()	negated: False ,passive: False
[LINE#690]This paper extends our previous work which introduced coherent dependence clusters (Islam et al., 2010b) and decluvi (Islam et al., 2010a).
0.621	[*A*]our previous work[*R*]introduced[*A*]coherent dependence clusters	context()	negated: False ,passive: False
0.907	[*A*]This paper[*R*]extends[*A*]our previous work which introduced coherent dependence clusters (Islam et al., 2010b) and decluvi (Islam et al., 2010a)	context()	negated: False ,passive: False
[LINE#691]Previous work established the existence of coherent dependence clusters and detailed the functionalities of the visualization tool.
0.903	[*A*]Previous work[*R*]detailed[*A*]the functionalities of the visualization tool	context()	negated: False ,passive: False
0.903	[*A*]Previous work[*R*]established[*A*]the existence of coherent dependence clusters	context()	negated: False ,passive: False
[LINE#692]This paper extends previous work in many ways, firstly by introducing an efficient hashing algorithm for slice approximation.
0.903	[*A*]This paper[*R*]extends[*A*]previous work	context()	negated: False ,passive: False
[LINE#693]This improves on the precision of previous slice approximation from 78% to 95%, resulting in precise and accurate clustering.
0.339	[*A*]This[*R*]improves[*A*]resulting in accurate clustering	context()	negated: False ,passive: True
0.339	[*A*]This[*R*]improves[*A*]resulting in precise clustering	context()	negated: False ,passive: True
[LINE#694]The coherent cluster existence study is extended to empirically validate the results by considering 30 production programs.
0.952	[*A*]The coherent cluster existence study[*R*]is extended[*A*]to empirically validate the results by considering 30 production programs	context()	negated: False ,passive: True
[LINE#695]Additional case studies show that coherent clusters can help reveal the structure of a program and identify structural defects.
0.878	[*A*]coherent clusters[*R*]can help identify[*A*]structural defects	context(Additional case studies show coherent clusters can help)	negated: False ,passive: False
0.878	[*A*]coherent clusters[*R*]can help[*A*]identify structural defects	context(Additional case studies show)	negated: False ,passive: False
0.793	[*A*]Additional case studies[*R*]show[*A*]that coherent clusters can help identify structural defects	context()	negated: False ,passive: False
0.878	[*A*]coherent clusters[*R*]can help reveal[*A*]the structure of a program	context(Additional case studies show coherent clusters can help)	negated: False ,passive: False
0.878	[*A*]coherent clusters[*R*]can help[*A*]reveal the structure of a program	context(Additional case studies show)	negated: False ,passive: False
0.860	[*A*]Additional case studies[*R*]show[*A*]that coherent clusters can help reveal the structure of a program	context()	negated: False ,passive: False
[LINE#696]We also introduce the notion of inter-cluster dependence which will form the base of reverse engineering efforts in future.
0.887	[*A*]inter-cluster dependence[*R*]will form[*A*]the base of reverse engineering efforts in future	context()	negated: False ,passive: False
0.411	[*A*]We[*R*]introduce[*A*]the notion of inter-cluster dependence	context()	negated: False ,passive: False
[LINE#697]Finally, we also present studies which show the lack of correlation between coherent clusters and bug fixes and show that coherent clusters remain surprisingly stable during system evolution.
[LINE#698]In some ways our work follows the evolutionary development of the study of software clones (Bellon et al., 2007), which were thought to be harmful and problematic when first observed.
0.788	[*A*]the study of software clones[*R*]to be[*A*]problematic[*A*]first	context()	negated: False ,passive: True
0.788	[*A*]the study of software clones[*R*]to be[*A*]harmful[*A*]when first observed	context()	negated: False ,passive: True
0.638	[*A*]our work[*R*]follows[*A*]the evolutionary development of the study of software clones	context()	negated: False ,passive: False
[LINE#699]Further reflection and analysis revealed that these code clone structures were a widespread phenomena that deserved study and consideration.
0.768	[*A*]these code clone structures[*R*]were[*A*]a widespread phenomena that deserved consideration	context(Further analysis revealed)	negated: False ,passive: True
0.768	[*A*]these code clone structures[*R*]were[*A*]a widespread phenomena that deserved study	context(Further analysis revealed)	negated: False ,passive: True
0.731	[*A*]Further analysis[*R*]revealed[*A*]that these code clone structures were a widespread phenomena	context()	negated: False ,passive: False
0.768	[*A*]these code clone structures[*R*]were[*A*]a widespread phenomena that deserved consideration	context(Further reflection revealed)	negated: False ,passive: True
0.897	[*A*]a widespread phenomena[*R*]deserved[*A*]consideration	context()	negated: False ,passive: False
0.768	[*A*]these code clone structures[*R*]were[*A*]a widespread phenomena that deserved study	context(Further reflection revealed)	negated: False ,passive: True
0.731	[*A*]Further reflection[*R*]revealed[*A*]that these code clone structures were a widespread phenomena	context()	negated: False ,passive: False
0.897	[*A*]a widespread phenomena[*R*]deserved[*A*]study	context()	negated: False ,passive: False
[LINE#700]While engineers needed to be aware of them, it remains a subject of much debate as to whether or not they should be refactored, tolerated or even nurtured (Bouktif et al., 2006; Kapser and Godfrey, 2008).We believe the same kind of discussion may apply to dependence clusters.
0.284	[*A*]they[*R*]tolerated	context()	negated: False ,passive: False
0.909	[*A*]the same kind of discussion[*R*]may apply[*A*]to dependence clusters	context(We believe)	negated: False ,passive: True
0.409	[*A*]it[*R*]remains[*A*]a subject of much debate as to whether or not they should be refactored, tolerated or even nurtured (Bouktif et al	context(We believe)	negated: False ,passive: True
0.514	[*A*]We[*R*]believe[*A*]the same kind of discussion may apply to dependence clusters	context()	negated: False ,passive: False
0.795	[*A*]engineers[*R*]to be[*A*]aware of them	context()	negated: False ,passive: True
0.576	[*A*]they[*R*]nurtured[*A*]Bouktif et al	context()	negated: False ,passive: False
0.821	[*A*]engineers[*R*]needed[*A*]to be aware of them	context()	negated: False ,passive: False
[LINE#701]While dependence clusters may have significant impact on comprehension and maintenance and though there is evidence that these clusters are a widespread phenomena, it is not always obvious whether they can be or should be removed or refactored.
0.903	[*A*]these clusters[*R*]are[*A*]a widespread phenomena	context()	negated: False ,passive: True
0.903	[*A*]dependence clusters[*R*]may have[*A*]significant impact on comprehension and maintenance	context()	negated: False ,passive: False
[LINE#702] There may be a (good) reason for the presence of a clusterand/or it may not be obvious how it can be removed (though its presence should surely be brought to the attention of the software maintainer).
0.535	[*A*]its presence[*R*]should be brought[*A*]to the attention of the software maintainer	context()	negated: False ,passive: True
0.374	[*A*]it[*R*]can be removed[*A*]though its presence should surely be brought to the attention of the software maintainer	context()	negated: False ,passive: True
0.225	[*A*]it[*R*]may not be[*A*]obvious	context()	negated: True ,passive: True
[LINE#703]These observations motivate further study to investigate and understand dependence clusters, and to provide tools to support software engineers in their analysis.
0.903	[*A*]These observations[*R*]motivate[*A*]further study to provide tools	context()	negated: False ,passive: False
0.903	[*A*]These observations[*R*]motivate[*A*]further study to understand dependence clusters	context()	negated: False ,passive: False
0.903	[*A*]These observations[*R*]motivate[*A*]further study to investigate	context()	negated: False ,passive: False
[LINE#704] In support of future research, we make available all data from our study at the website http://www.cs.ucl.ac.uk/staff/.
0.444	[*A*]we[*R*]make[*A*]available all data from our study at the website[*A*]In support of future research	context()	negated: False ,passive: False
[LINE#705]The reader can obtain the slices for each program studied and the clusters they form, facilitating replication of our results and other studies of dependence and dependence clusters.
0.312	[*A*]they[*R*]form facilitating[*A*]replication of our other studies of dependence clusters	context(they form)	negated: False ,passive: False
0.312	[*A*]they[*R*]form facilitating[*A*]replication of our results	context(they form)	negated: False ,passive: False
0.332	[*A*]they[*R*]form	context()	negated: False ,passive: False
0.903	[*A*]The reader[*R*]can obtain[*A*]the slices for each program studied and the clusters	context()	negated: False ,passive: False
[LINE#706]The visualizations used in this paper are similar to those used for program comprehension.
0.234	[*A*]those[*R*]used[*A*]for program comprehension	context()	negated: False ,passive: True
0.638	[*A*]The visualizations used in this paper[*R*]are[*A*]similar to those	context()	negated: False ,passive: True
0.903	[*A*]The visualizations[*R*]used[*A*]in this paper	context()	negated: False ,passive: True
[LINE#707]Seesoft (Eick et al., 1992) is a seminal tool for line oriented visualization of software statistics.
[LINE#708]The system pioneered four key ideas: reduced representation, coloring by statistic, direct manipulation, and capability to read actual code.
0.903	[*A*]The system[*R*]pioneered[*A*]four key ideas : reduced representation ,	context()	negated: False ,passive: False
[LINE#709]The reduced representation was achieved by displaying files in columns with lines of code as lines of pixels.
0.933	[*A*]The reduced representation[*R*]by displaying[*A*]files in columns with lines of code as lines of pixels	context()	negated: False ,passive: False
0.751	[*A*]The reduced representation[*R*]was achieved	context()	negated: False ,passive: False
[LINE#710]This approach allows 50,000 lines of code to be shown on a single screen.
0.900	[*A*]50,000 lines of code[*R*]to be shown[*A*]on a single screen	context(This approach allows)	negated: False ,passive: True
0.923	[*A*]This approach[*R*]allows[*A*]50,000 lines of code to be shown on a single screen	context()	negated: False ,passive: False
[LINE#711]The SeeSys System (Baker and Eick, 1995) introduced tree maps to show hierarchical data.
0.901	[*A*]The SeeSys System[*R*]introduced tree maps to show[*A*]hierarchical data	context(The SeeSys System introduced)	negated: False ,passive: False
0.901	[*A*]The SeeSys System[*R*]introduced tree maps to show[*A*]hierarchical data	context(The SeeSys System introduced)	negated: False ,passive: False
0.901	[*A*]The SeeSys System[*R*]introduced[*A*]tree maps[*A*]to show hierarchical data	context()	negated: False ,passive: False
[LINE#712]It displays code organized hierarchically into subsystems, directories, and files by representing the whole system as a rectangle and recursively representing the various sub-units with interior rectangles.
0.569	[*A*]It[*R*]displays[*A*]code organized hierarchically into files by recursively representing the various sub-units with interior rectangles	context()	negated: False ,passive: False
0.569	[*A*]It[*R*]displays[*A*]code organized hierarchically into files by representing the whole system as a rectangle	context()	negated: False ,passive: False
0.876	[*A*]code[*R*]organized hierarchically[*A*]by recursively representing the various sub-units with interior rectangles	context()	negated: False ,passive: True
0.569	[*A*]It[*R*]displays[*A*]code organized hierarchically into directories by recursively representing the various sub-units with interior rectangles	context()	negated: False ,passive: False
0.876	[*A*]code[*R*]organized hierarchically[*A*]by representing the whole system as a rectangle	context()	negated: False ,passive: True
0.569	[*A*]It[*R*]displays[*A*]code organized hierarchically into directories by representing the whole system as a rectangle	context()	negated: False ,passive: False
0.894	[*A*]code[*R*]organized hierarchically[*A*]into subsystems[*A*]by recursively representing the various sub-units with interior rectangles	context()	negated: False ,passive: True
0.569	[*A*]It[*R*]displays[*A*]code organized hierarchically into subsystems by recursively representing the various sub-units with interior rectangles	context()	negated: False ,passive: False
0.894	[*A*]code[*R*]organized hierarchically[*A*]into subsystems[*A*]by representing the whole system as a rectangle	context()	negated: False ,passive: True
0.569	[*A*]It[*R*]displays[*A*]code organized hierarchically into subsystems by representing the whole system as a rectangle	context()	negated: False ,passive: False
[LINE#713]The area of each rectangle is used to reflect statistic associated with the sub-unit.
0.894	[*A*]statistic[*R*]associated[*A*]with the sub-unit	context()	negated: False ,passive: True
0.913	[*A*]The area of each rectangle[*R*]to reflect[*A*]statistic associated with the sub-unit	context()	negated: False ,passive: True
0.926	[*A*]The area of each rectangle[*R*]is used[*A*]to reflect statistic	context()	negated: False ,passive: True
[LINE#714]Decluvi builds on the SeeSoft concepts through different abstractions and dynamic mapping of line statistics removing the 50,000 line limitation.
0.903	[*A*]line statistics[*R*]removing[*A*]the 50,000 line limitation	context()	negated: False ,passive: False
0.932	[*A*]Decluvi[*R*]builds[*A*]on the SeeSoft concepts	context()	negated: False ,passive: False
[LINE#715]An alternative software visualization approach often used in program comprehension does not use the "line of pixels" approach, but instead uses nested graphs for hierarchical fish-eye views.
0.887	[*A*]An alternative[*R*]uses[*A*]nested graphs for hierarchical fish - eye views	context()	negated: False ,passive: False
0.953	[*A*]An alternative software visualization approach often used in program comprehension[*R*]does not use[*A*]the " line of pixels " approach	context()	negated: True ,passive: False
0.949	[*A*]An alternative software visualization approach[*R*]used[*A*]in program comprehension[*A*]often	context()	negated: False ,passive: True
[LINE#716] Most of these tools focus on visualizing high-level system abstractions (often referred to as 'clustering' or 'aggregation')such as classes, modules, and packages.
0.968	[*A*]high-level system abstractions[*R*]referred[*A*]to[*A*]as 'clustering' or 'aggregation')such as classes, modules, and packages[*A*]often	context()	negated: False ,passive: False
0.919	[*A*]Most of these tools[*R*]focus[*A*]on visualizing high-level system abstractions	context()	negated: False ,passive: False
[LINE#717]A popular example is the reverse engineering tool Rigi (Storey et al., 1997).
0.942	[*A*]A popular example[*R*]is[*A*]the reverse engineering tool Rigi (Storey et al	context()	negated: False ,passive: True
[LINE#718]Summary and future workPrevious work has deemed dependence clusters to be problematic as they inhibit program understanding and maintenance.
0.616	[*A*]they[*R*]inhibit[*A*]program maintenance	context()	negated: False ,passive: False
0.835	[*A*]dependence clusters[*R*]to be[*A*]problematic[*A*]as they inhibit program maintenance	context()	negated: False ,passive: True
0.616	[*A*]they[*R*]inhibit[*A*]program understanding	context()	negated: False ,passive: False
0.835	[*A*]dependence clusters[*R*]to be[*A*]problematic[*A*]as they inhibit program understanding	context()	negated: False ,passive: True
0.911	[*A*]future workPrevious work[*R*]has deemed[*A*]dependence clusters	context()	negated: False ,passive: False
[LINE#719]This paper views them in a new light, it introduces and evaluates a specialized form of dependence cluster: the coherent cluster.
0.903	[*A*]This paper[*R*]evaluates[*A*]a specialized form of dependence cluster	context()	negated: False ,passive: False
0.802	[*A*]This paper[*R*]views[*A*]them[*A*]in a new light	context(This paper views them in a new light introduces)	negated: False ,passive: False
0.674	[*A*]This paper views them in a new light[*R*]introduces[*A*]it	context()	negated: False ,passive: True
[LINE#720]Such clusters have vertices that share the same internal and external dependencies.
0.877	[*A*]vertices[*R*]share[*A*]the same external dependencies	context()	negated: False ,passive: False
0.773	[*A*]Such clusters[*R*]have[*A*]vertices that share the same external dependencies	context()	negated: False ,passive: False
0.877	[*A*]vertices[*R*]share[*A*]the same internal dependencies	context()	negated: False ,passive: False
0.773	[*A*]Such clusters[*R*]have[*A*]vertices that share the same internal dependencies	context()	negated: False ,passive: False
[LINE#721]The paper shows that such clusters are not necessarily problems but rather can aid an engineer understand program components and their interactions.
0.654	[*A*]The paper[*R*]shows[*A*]that can aid an engineer understand their interactions	context()	negated: False ,passive: False
0.777	[*A*]The paper[*R*]shows[*A*]that can aid an engineer understand program components	context()	negated: False ,passive: False
0.882	[*A*]such clusters[*R*]are not[*A*]necessarily[*A*]problems	context(The paper shows)	negated: True ,passive: True
0.783	[*A*]The paper[*R*]shows[*A*]that such clusters are not necessarily problems	context()	negated: False ,passive: False
[LINE#722]Developers can exploit knowledge of coherent clusters as they aid in program comprehension as the clusters bring out interactions between logical constructs of the system.
0.903	[*A*]the clusters[*R*]bring out[*A*]interactions between logical constructs of the system	context()	negated: False ,passive: False
0.616	[*A*]they[*R*]aid[*A*]in program comprehension	context()	negated: False ,passive: False
0.880	[*A*]Developers[*R*]can exploit[*A*]knowledge of coherent clusters[*A*]as they aid in program comprehension as the clusters bring out interactions between logical constructs of the system	context()	negated: False ,passive: False
[LINE#723]We also lay a foundation for research into this new application area and encourage further research.
0.411	[*A*]We[*R*]lay[*A*]a foundation for research into this new application area	context()	negated: False ,passive: True
[LINE#724]Moreover, future research could compare the aspects of various definitions of dependence clusters and the properties they capture.
0.884	[*A*]the properties[*R*]capture[*A*]they	context()	negated: False ,passive: True
0.903	[*A*]future research[*R*]could compare[*A*]the aspects of various definitions of the properties	context()	negated: False ,passive: False
0.903	[*A*]future research[*R*]could compare[*A*]the aspects of various definitions of dependence clusters	context()	negated: False ,passive: False
[LINE#725]This paper presents new approximations that support the efficient and accurate identification of coherent clusters.
0.887	[*A*]new approximations[*R*]support[*A*]the accurate identification of coherent clusters	context()	negated: False ,passive: False
0.845	[*A*]This paper[*R*]presents[*A*]new approximations that support the accurate identification of coherent clusters	context()	negated: False ,passive: False
0.887	[*A*]new approximations[*R*]support[*A*]the efficient identification of coherent clusters	context()	negated: False ,passive: False
0.845	[*A*]This paper[*R*]presents[*A*]new approximations that support the efficient identification of coherent clusters	context()	negated: False ,passive: False
[LINE#726]Empirical evaluation finds that 23 of the 30 subject programs have at least one large coherent cluster.
0.853	[*A*]Empirical evaluation[*R*]finds[*A*]that 23 of the 30 subject programs have at least one large coherent cluster	context()	negated: False ,passive: False
[LINE#727]A series of four case studies illustrate that coherent clusters map to a logical functional decomposition and can be used to depict the structure of a program.
0.112	[*A*]that[*R*]can be used[*A*]to depict the structure of a program	context(A series of four case studies illustrate)	negated: False ,passive: True
0.865	[*A*]A series of four case studies[*R*]illustrate[*A*]that can be used to depict the structure of a program	context()	negated: False ,passive: False
0.908	[*A*]coherent clusters[*R*]map[*A*]to a logical functional decomposition	context(A series of four case studies illustrate)	negated: False ,passive: False
0.800	[*A*]A series of four case studies[*R*]illustrate[*A*]that coherent clusters map to a logical functional decomposition	context()	negated: False ,passive: False
[LINE#728]In all four case studies, coherent clusters map to subsystems, each of which is responsible for implementing concise functionality.
0.905	[*A*]subsystems[*R*]is[*A*]responsible for implementing concise functionality	context()	negated: False ,passive: True
0.957	[*A*]coherent clusters[*R*]map[*A*]to subsystems[*A*]In all four case studies	context()	negated: False ,passive: False
[LINE#729]As side-effects of the study, we find that the visualization of coherent clusters can identify potential structural problems as well as refactoring opportunities.
0.905	[*A*]the visualization of coherent clusters[*R*]can identify[*A*]potential structural problems	context(we find)	negated: False ,passive: False
0.330	[*A*]we[*R*]find[*A*]that the visualization of coherent clusters can identify potential structural problems as well as refactoring opportunities	context()	negated: False ,passive: False
[LINE#730]The paper also discusses inter-cluster dependence and how mutual dependencies between clusters may be exploited to reveal large dependence structure that form the basis of reverse engineering efforts.
0.897	[*A*]mutual dependencies between clusters[*R*]may be exploited[*A*]to reveal large dependence structure	context(The paper discusses)	negated: False ,passive: True
0.907	[*A*]The paper[*R*]discusses[*A*]how mutual dependencies between clusters may be exploited to reveal large dependence structure	context()	negated: False ,passive: False
0.920	[*A*]large dependence structure[*R*]form[*A*]the basis of reverse engineering efforts	context()	negated: False ,passive: False
0.887	[*A*]The paper[*R*]discusses[*A*]inter-cluster dependence	context()	negated: False ,passive: False
[LINE#731]Furthermore, the paper presents a study on how bug fixes relate to the presence of coherent clusters, and finds no relationship between program faults and coherent clusters in barcode.
0.925	[*A*]the paper[*R*]finds[*A*]no relationship between coherent clusters in barcode	context()	negated: False ,passive: False
0.925	[*A*]the paper[*R*]finds[*A*]no relationship between program faults	context()	negated: False ,passive: False
0.903	[*A*]bug fixes[*R*]relate[*A*]to the presence of coherent clusters	context()	negated: False ,passive: True
0.937	[*A*]the paper[*R*]presents[*A*]a study on how bug fixes relate to the presence of coherent clusters	context()	negated: False ,passive: False
[LINE#732]Finally, a longitudinal study of three subjects shows that coherent clusters remain surprisingly stable through system evolution.
0.717	[*A*]coherent clusters[*R*]remain[*A*]surprisingly stable	context(a longitudinal study of three subjects shows)	negated: False ,passive: True
0.901	[*A*]a longitudinal study of three subjects[*R*]shows[*A*]that coherent clusters remain surprisingly stable through system evolution[*A*]Finally	context()	negated: False ,passive: False
[LINE#733]The paper is one of the first in the area of dependence clusters to suggest that dependence clusters (coherent clusters) are not problematic but represent program structure and give evidence to that cause.
0.952	[*A*]The paper[*R*]is[*A*]one of the first in the area of dependence clusters	context()	negated: False ,passive: True
[LINE#734]Future work in this area is rife with opportunities beginning with enabling the use of coherent clusters in a program comprehension and reverse engineering tools.
0.931	[*A*]opportunities[*R*]beginning[*A*]with enabling the use of coherent clusters in a program comprehension	context()	negated: False ,passive: True
0.943	[*A*]Future work in this area[*R*]is[*A*]rife with opportunities	context()	negated: False ,passive: True
[LINE#735]The inter-cluster dependence study lays out the ground work in this context.
0.919	[*A*]The inter-cluster dependence study[*R*]lays out[*A*]the ground work	context()	negated: False ,passive: False
[LINE#736]There is also room for further research aimed at understanding the formation and impact of coherent clusters on software quality.
0.903	[*A*]further research[*R*]aimed[*A*]at understanding impact of coherent clusters on software quality	context()	negated: False ,passive: True
0.937	[*A*]further research[*R*]aimed[*A*]at understanding the formation of coherent clusters on software quality	context()	negated: False ,passive: True
[LINE#737]For example, by studying how well dependence clusters can capture functionality.
[LINE#738]Furthermore, application of dynamic slicing in formation of dependence clusters might by considered as static analysis can suffer from over approximation caused by its conservative nature.
0.821	[*A*]approximation[*R*]caused[*A*]by its conservative nature	context()	negated: False ,passive: True
