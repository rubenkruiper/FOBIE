[LINE#0+1]  A formal modeling framework for self-stabilizing fault-tolerant circuitsInthis section, we introduce a novel formal framework for specifying self-stabilizing fault-tolerant modules.
0.569	[*A*]we[*R*]introduce[*A*]a novel formal framework for specifying self-stabilizing fault-tolerant modules	context()	negated: False ,passive: False
[LINE#2] It is a non-trivial extension of [32,42] that allows us to rigorously express the properties related to self-stabilization as used in [13].
0.388	[*A*]us[*R*]to rigorously express[*A*]the properties related to self-stabilization	context(32,42 allows)	negated: False ,passive: False
0.297	[*A*]32,42[*R*]allows[*A*]us to rigorously express the properties	context()	negated: False ,passive: False
0.903	[*A*]the properties[*R*]related[*A*]to self-stabilization	context()	negated: False ,passive: True
0.522	[*A*]It[*R*]is[*A*]a non-trivial extension of [32,42	context()	negated: False ,passive: True
[LINE#3] Using this framework, we then give a precise formal specification of our basic modules' behavior..
0.455	[*A*]we[*R*]give[*A*]a precise formal specification of our basic modules' behavior[*A*]then	context()	negated: False ,passive: False
[LINE#4]  We define (the trace of) a signal to be a timed event trace over a finite alphabet S of possible signal states:.
0.937	[*A*]a signal[*R*]to be[*A*]a timed event trace over a finite alphabet S of possible signal	context()	negated: False ,passive: True
0.407	[*A*]We[*R*]define[*A*]the trace of	context()	negated: False ,passive: False
[LINE#5+6]  The elements of  are called events, and for each event (s,t)we call s the state of event (s,t) and t the time of event (s,t).
0.925	[*A*]The elements[*R*]t[*A*]the time of event	context()	negated: False ,passive: False
0.910	[*A*]The elements[*R*]call[*A*]we	context()	negated: False ,passive: True
0.911	[*A*]The elements of[*R*]are called[*A*]events	context()	negated: False ,passive: True
[LINE#7] Note that we allow for events (s,t) and (s,t), where t<t, without having an event (s,t) with ss and t<t<t.
[LINE#8] In this case, we call event (s,t) idempotent.
0.661	[*A*]we[*R*]call[*A*]event[*A*]s,t[*A*]In this case	context()	negated: False ,passive: False
[LINE#9+10+11+12]  In general, a signal  is required to fulfill the following conditions:(i)From (s,t) and =s.(ii)For each time interval [t-,t+]R of finite length , the number of non-idempotent events in  with times within [t-,t+] is finite.(iii)For any time t, there exists an event (s,t) with tt.
0.887	[*A*]a signal[*R*]to fulfill[*A*]the following conditions	context()	negated: False ,passive: False
0.937	[*A*]a signal[*R*]is required[*A*]to fulfill the following conditions : ( i ) From =s	context()	negated: False ,passive: True
0.697	[*A*]t - , t+[*R*]is[*A*]finite	context()	negated: False ,passive: True
0.927	[*A*]a signal[*R*]to fulfill[*A*]the following conditions : ( i ) From ( s , t	context()	negated: False ,passive: False
0.937	[*A*]a signal[*R*]is required[*A*]to fulfill the following conditions : ( i ) From ( s , t	context()	negated: False ,passive: True
[LINE#13] We say that signal  switches to s at time t iff event (s,t) is not idempotent.
0.509	[*A*]t[*R*]is not[*A*]idempotent	context(We say)	negated: True ,passive: True
0.279	[*A*]We[*R*]say[*A*]that signal  switches to s at time t iff event (s,t) is not idempotent	context()	negated: False ,passive: False
[LINE#14] Due to property (ii), there is always a non-zero amount of time between two such events.
[LINE#15] These events describe when the corresponding physical signal undergoes an actual transition.
0.919	[*A*]the corresponding physical signal[*R*]undergoes[*A*]an actual transition	context()	negated: False ,passive: True
0.903	[*A*]These events[*R*]describe[*A*]when the corresponding physical signal undergoes an actual transition	context()	negated: False ,passive: False
[LINE#16] Therefore, we define that signals  and  are equivalent, iff they differ in idempotent events only, and identify all signals of an equivalence class.
0.616	[*A*]they[*R*]differ[*A*]in idempotent events	context()	negated: False ,passive: True
0.411	[*A*]we[*R*]identify[*A*]all signals of an equivalence class	context()	negated: False ,passive: False
0.231	[*A*]we[*R*]define[*A*]that signals	context()	negated: False ,passive: False
[LINE#17+18]  Each equivalence class [] contains a unique signal max that contains an event for each timetR. We identify this signal (and thus the entire class) with the function that maps each time t to the state (t):=s satisfying that (s,t)max.
0.803	[*A*]Each equivalence class[*R*]contains[*A*]a unique signal max that contains an event for each timetR	context(We identify thus)	negated: False ,passive: False
0.397	[*A*]We[*R*]identify thus[*A*]the entire class	context()	negated: False ,passive: False
0.614	[*A*]=s[*R*]satisfying[*A*]that ( s , t[*A*]max	context()	negated: False ,passive: False
0.784	[*A*]=s[*R*]satisfying[*A*]s , t ) max	context()	negated: False ,passive: False
0.913	[*A*]the function[*R*]maps[*A*]each time t	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]identify[*A*]this signal ( with the function	context()	negated: False ,passive: False
0.905	[*A*]a unique signal max[*R*]contains[*A*]an event for each timetR	context()	negated: False ,passive: False
0.734	[*A*]Each equivalence class[*R*]contains[*A*]a unique signal max that contains an event for each timetR . We identify this signal ( with the function	context()	negated: False ,passive: False
[LINE#19+20]  the state function of signal , and (t)the state of signal  at time t. Note that since the state function of a signal  depends on [] only, we may add or remove idempotent events at will without changing the state function. .
0.777	[*A*]the state of signal  at time[*R*]t. Note[*A*]that since the state function of a signal  depends on [] only, we may add or remove idempotent events at will without changing the state function	context()	negated: False ,passive: False
0.411	[*A*]we[*R*]remove[*A*]idempotent events	context()	negated: False ,passive: False
0.195	[*A*]we[*R*]may add	context()	negated: False ,passive: False
[LINE#21] Modules and executionsEach module comprises a (possibly empty) set of input ports and a (possibly empty) set of output ports.
0.937	[*A*]executionsEach module[*R*]comprises[*A*]a ( a ( possibly empty ) set of output ports	context()	negated: False ,passive: True
0.903	[*A*]executionsEach module[*R*]comprises[*A*]a ( possibly empty ) set of input ports	context()	negated: False ,passive: True
[LINE#22] These sets must be disjoint, i.e., we do not allow a module's output to be identical to one of its inputs; it may be identical to the input port of another module, however.
0.717	[*A*]These sets[*R*]must be[*A*]disjoint	context(it may be)	negated: False ,passive: True
0.388	[*A*]it[*R*]may be[*A*]identical to the input port of another module[*A*]however	context()	negated: False ,passive: True
[LINE#23] An execution of ports P on interval IR assigns a state to each port in P at any time in I. For convenience of notation, for any port p, we identify p and its state function whenever the respective execution is clear from the context.
0.309	[*A*]we[*R*]identify[*A*]its state function	context()	negated: False ,passive: False
0.927	[*A*]IR[*R*]assigns[*A*]a state[*A*]to each port[*A*]at any time in I.[*A*]An execution of ports P on interval	context()	negated: False ,passive: False
0.850	[*A*]IR[*R*]assigns[*A*]a state[*A*]to each port[*A*]at any time in I.	context(we identify)	negated: False ,passive: False
0.397	[*A*]we[*R*]identify[*A*]p	context()	negated: False ,passive: False
0.932	[*A*]the respective execution[*R*]is[*A*]clear from the context	context()	negated: False ,passive: True
[LINE#24] Moreover, we may omit the "on R" for all executions for which I=R when clear from the context.
0.407	[*A*]we[*R*]may omit[*A*]when clear from the context	context()	negated: False ,passive: False
[LINE#25]  An execution of module M on I is an execution of M's input and output ports on.
0.820	[*A*]An execution of module M on I[*R*]is[*A*]an execution of M 's output ports on	context()	negated: False ,passive: True
0.820	[*A*]An execution of module M on I[*R*]is[*A*]an execution of M 's input ports on	context()	negated: False ,passive: True
[LINE#26]  I. The restriction of execution E on I to II is the restriction of all of E's state functions to the interval.
0.914	[*A*]I.[*R*]is[*A*]the restriction of all of E's state functions to the interval	context()	negated: False ,passive: True
[LINE#27] Let E be an execution of ports P on I.
[LINE#28] Then the restriction of execution E on I to ports PP is the execution of ports P on I with state functions equal to E's state functions on P.Besides input and output ports, a module M further has a module specification.
0.872	[*A*]PP[*R*]is[*A*]the execution of ports P on I with state functions equal to E 's state functions on output ports	context()	negated: False ,passive: True
0.869	[*A*]M[*R*]has[*A*]a module specification	context()	negated: False ,passive: False
0.891	[*A*]PP[*R*]is[*A*]the execution of ports P on I with state functions equal to E 's state functions on P.Besides input	context()	negated: False ,passive: True
[LINE#29] We allow two kinds of module specifications for a module M, distinguishing between basic and compound modules.
0.452	[*A*]We[*R*]allow[*A*]two kinds of module specifications[*A*]distinguishing between basic and compound modules	context()	negated: False ,passive: False
[LINE#30] In this case, the module specification is a function M that, for all I, maps every execution of the module's input ports on I to a set of executions of the module's output ports on I.
0.446	[*A*]I[*R*]maps[*A*]every execution of the module's input ports on I	context()	negated: False ,passive: False
0.960	[*A*]the module specification[*R*]is[*A*]a function[*A*]In this case	context()	negated: False ,passive: True
[LINE#31] The intended meaning of M is to map each and every conceivable execution of M's input ports on I to the resulting possible reactions of M during the same time, which may be many different ones.
0.958	[*A*]the resulting possible reactions of M during[*R*]may be[*A*]many different ones[*A*]the same time	context()	negated: False ,passive: True
0.959	[*A*]The intended meaning of M[*R*]is[*A*]to map every conceivable execution of M 's input ports on I to the resulting possible reactions of M during the same time	context()	negated: False ,passive: True
0.888	[*A*]The intended meaning of M[*R*]is[*A*]to map each	context()	negated: False ,passive: True
[LINE#32] For example, a module that may behave arbitrarily for some input execution Ein is specified by setting M(Ein) to be the set of all conceivable output executions.
0.833	[*A*]M[*R*]to be[*A*]the set of all conceivable output executions	context()	negated: False ,passive: True
0.899	[*A*]a module that may behave arbitrarily for some input execution Ein[*R*]is specified	context()	negated: False ,passive: False
0.887	[*A*]a module[*R*]may behave[*A*]arbitrarily[*A*]for some input execution	context()	negated: False ,passive: False
[LINE#33]  M we say that execution E of M on some.
0.551	[*A*]we[*R*]say[*A*]M	context()	negated: False ,passive: False
[LINE#34] I is feasible iff EoutM(Ein), where Ein and Eout are the restrictions of execution E to M's input and output ports, respectively.
0.975	[*A*]Eout[*R*]are[*A*]the restrictions of execution E to M 's output ports[*A*]EoutM	context()	negated: False ,passive: True
0.678	[*A*]I[*R*]is[*A*]feasible[*A*]iff EoutM ( Ein ) , where Eout are the restrictions of execution E to M 's output ports , respectively	context()	negated: False ,passive: True
0.975	[*A*]Eout[*R*]are[*A*]the restrictions of execution E to M 's input ports[*A*]EoutM	context()	negated: False ,passive: True
0.678	[*A*]I[*R*]is[*A*]feasible[*A*]iff EoutM ( Ein ) , where Eout are the restrictions of execution E to M 's input ports , respectively	context()	negated: False ,passive: True
0.975	[*A*]Ein[*R*]are[*A*]the restrictions of execution E to M 's output ports[*A*]EoutM	context()	negated: False ,passive: True
0.678	[*A*]I[*R*]is[*A*]feasible[*A*]iff EoutM ( Ein ) , where Ein are the restrictions of execution E to M 's output ports , respectively	context()	negated: False ,passive: True
0.975	[*A*]Ein[*R*]are[*A*]the restrictions of execution E to M 's input ports[*A*]EoutM	context()	negated: False ,passive: True
0.678	[*A*]I[*R*]is[*A*]feasible[*A*]iff EoutM ( Ein ) , where Ein are the restrictions of execution E to M 's input ports , respectively	context()	negated: False ,passive: True
[LINE#35+36]  We require two properties for M to hold:(i)Non-emptiness : (Ein) for all executions Ein of M's input ports.(ii)Properness:.
0.944	[*A*]two properties[*R*]to hold[*A*]M	context()	negated: False ,passive: True
0.498	[*A*]We[*R*]require[*A*]two properties for M to hold	context()	negated: False ,passive: False
[LINE#37] Any restriction (in time) of a feasible execution of M is feasible.
0.939	[*A*]Any restriction (in time) of a feasible execution of M[*R*]is[*A*]feasible	context()	negated: False ,passive: True
[LINE#38] These properties are motivated by the facts that (i) any given input of a correctly operating module will produce some output and (ii) correct operation on a given time interval implies correct operation on any subinterval of this interval.
0.868	[*A*]These properties[*R*]will produce[*A*]correct operation[*A*]on a given time interval	context()	negated: False ,passive: False
0.887	[*A*]These properties[*R*]will produce[*A*]some output	context()	negated: False ,passive: False
0.913	[*A*]the facts[*R*](i)[*A*]any given input of a correctly operating module	context()	negated: False ,passive: False
[LINE#39+40+41]  Example 3.1A simple basic module is a (zero-time) inverter with (binary) i, (binary) output port o, and module specification Inv defined by: For each interval IR and each execution Ein of input port i, an execution Eout of output port o on I is in Inv(Ein) iff for all tI.
0.955	[*A*]3.1A simple basic module[*R*]is[*A*]a ( zero - time ) inverter with ( binary ) i , ( binary ) output module specification Inv defined by : IR and each execution Ein of input port i , an execution Eout of output port o on I is in Inv ( Ein ) iff	context()	negated: False ,passive: True
0.868	[*A*]binary ) output module specification Inv[*R*]defined[*A*]by	context()	negated: False ,passive: True
0.947	[*A*]3.1A simple basic module[*R*]is[*A*]a ( zero - time ) inverter with ( binary ) i	context()	negated: False ,passive: True
0.955	[*A*]3.1A simple basic module[*R*]is[*A*]a ( zero - time ) inverter with ( binary ) i , ( binary ) output port o IR and each execution Ein of input port i , an execution Eout of output port o on I is in Inv ( Ein ) iff for all tI	context()	negated: False ,passive: True
0.568	[*A*]I[*R*]is[*A*]in Inv	context()	negated: False ,passive: True
0.955	[*A*]3.1A simple basic module[*R*]is[*A*]a ( zero - time ) inverter with ( binary ) i , ( binary ) output port o For each interval and each execution Ein of input port i , an execution Eout of output port o on I is in Inv ( Ein ) iff for all tI	context()	negated: False ,passive: True
[LINE#42] Example 3.2As an example of a timed basic module, consider a fixed-delay channel with input port i, output port o, and delay d>0.
0.802	[*A*]Example[*R*]3.2As[*A*]an > 0	context()	negated: False ,passive: False
0.934	[*A*]Example[*R*]3.2As[*A*]an example of a timed basic module , consider a fixed - delay channel with	context(input port i o)	negated: False ,passive: False
0.757	[*A*]input port i[*R*]o[*A*]0	context()	negated: False ,passive: False
[LINE#43+44+45]  Its module specification C is defined by: For each interval [t-,t+)R and each execution Ein of input port i on [t-,t+), an execution Eout of output port o on I is in C(Ein)we have that o(t)=i(t-d).Clearly, a basic module needs to adhere to M only on intervals I during which it is correct, and may behave arbitrarily when it is faulty.
0.905	[*A*]a basic module[*R*]needs to adhere[*A*]to M[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.868	[*A*]a basic module[*R*]needs to adhere[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.162	[*A*]we[*R*]have	context(an execution Eout of output port is)	negated: False ,passive: False
0.631	[*A*]Its module specification C[*R*]is defined[*A*]by : For each interval [ t	context(an execution Eout of output port is)	negated: False ,passive: True
0.937	[*A*]an execution Eout of output port[*R*]is[*A*]in C	context()	negated: False ,passive: True
0.905	[*A*]a basic module[*R*]needs to adhere[*A*]to M[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.691	[*A*]Its module specification C[*R*]is defined[*A*]by : For each interval [ t - each execution [ t - , t+ ) , an execution Eout of output port o on I is in C	context()	negated: False ,passive: True
0.868	[*A*]a basic module[*R*]needs to adhere[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.838	[*A*]a basic module[*R*]needs[*A*]to adhere to M only on intervals I	context()	negated: False ,passive: False
0.825	[*A*]a basic module[*R*]may behave[*A*]arbitrarily[*A*]when it is faulty	context()	negated: False ,passive: False
0.681	[*A*]Its module specification C[*R*]is defined[*A*]by : For each interval [ t	context()	negated: False ,passive: True
0.278	[*A*]it[*R*]is[*A*]correct	context()	negated: False ,passive: True
0.905	[*A*]a basic module[*R*]needs to adhere[*A*]to M[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.905	[*A*]a basic module[*R*]needs[*A*]to adhere to M only on intervals	context()	negated: False ,passive: False
0.278	[*A*]it[*R*]is[*A*]faulty	context()	negated: False ,passive: True
0.568	[*A*]I[*R*]is[*A*]in C	context()	negated: False ,passive: True
0.274	[*A*]I[*R*]may behave[*A*]arbitrarily[*A*]when it is faulty	context()	negated: False ,passive: False
0.691	[*A*]Its module specification C[*R*]is defined[*A*]by : For each interval [ t - , t+ ) R [ t - , t+ ) , an execution Eout of output port o on I is in C	context()	negated: False ,passive: True
[LINE#46] Subtle issues originate in the fact that a module may become correct after an earlier (transient) fault, in the sense that its internal components work as intended afterwards.
0.903	[*A*]a module[*R*]may become[*A*]correct[*A*]after an earlier (transient) fault	context()	negated: False ,passive: True
0.845	[*A*]Subtle issues[*R*]originate[*A*]in the fact that a module may become correct after an earlier (transient) fault, in the sense	context()	negated: False ,passive: True
[LINE#47] At this point in time, it may or may not be the case that all traces of the transient fault have been vanished from the internal state of the module.
0.932	[*A*]all traces of the transient fault[*R*]have been vanished[*A*]from the internal state of the module	context()	negated: False ,passive: True
0.422	[*A*]it[*R*]may not be[*A*]the case that all traces of the transient fault have been vanished from the internal state of the module[*A*]At this point in time	context()	negated: True ,passive: True
[LINE#48] The typical use of basic modules is the description of a (sub)problem.
0.948	[*A*]The typical use of basic modules[*R*]is[*A*]the description of a (sub)problem	context()	negated: False ,passive: True
[LINE#49] For instance, the module specification of a threshold module will be such that the output is required to indicate whether a certain number of binary input ports is in state 1.
0.941	[*A*]a certain number of binary input ports[*R*]is[*A*]in state 1	context(the output to indicate)	negated: False ,passive: True
0.910	[*A*]the output[*R*]to indicate[*A*]whether a certain number of binary input ports is in state 1	context()	negated: False ,passive: False
0.937	[*A*]the output[*R*]is required[*A*]to indicate whether a certain number of binary input ports is in state 1	context()	negated: False ,passive: True
0.898	[*A*]the module specification of a threshold module[*R*]will be[*A*]such that the output is required to indicate whether a certain number of binary input ports is in state 1	context()	negated: False ,passive: True
[LINE#50] Basic modules are then employed with the understanding that they require an implementation matching their specification.
0.835	[*A*]an implementation[*R*]matching[*A*]their specification	context()	negated: False ,passive: False
0.465	[*A*]they[*R*]require[*A*]an implementation matching their specification	context()	negated: False ,passive: False
0.683	[*A*]Basic modules[*R*]are employed[*A*]with the understanding that they require an implementation[*A*]then	context()	negated: False ,passive: True
[LINE#51] This use of basic modules in our algorithms entails that correct modules have correct internal states.
0.882	[*A*]correct modules[*R*]have[*A*]correct internal states	context(This use of basic modules in our algorithms entails)	negated: False ,passive: False
0.479	[*A*]This use of basic modules in our algorithms[*R*]entails[*A*]that correct modules have correct internal states	context()	negated: False ,passive: False
[LINE#52+53]  Although a basic module description abstracts away its internal state, this property can be characterized in a natural way by another constraint on the module specification : We say that the specification of some module.
0.686	[*A*]this property[*R*]can be characterized	context(We say)	negated: False ,passive: False
0.162	[*A*]We[*R*]say	context()	negated: False ,passive: False
0.860	[*A*]a basic module description[*R*]abstracts[*A*]away[*A*]its internal state	context()	negated: False ,passive: False
[LINE#54+55]  M is extendable iff each feasible execution of M on some interval[t-,t+)R is the restriction of a feasible execution of M on R.
0.986	[*A*]M is extendable iff each feasible execution of M on some interval[*R*]is[*A*]the restriction of a feasible execution of M on R.	context()	negated: False ,passive: True
0.918	[*A*]M[*R*]is[*A*]extendable iff each feasible execution of M on some interval	context()	negated: False ,passive: True
[LINE#56+57+58+59]  In other words, for each execution on some interval [t-,t+), (i) a fault-free history exists that leads to the internal state of the module at time t- (and therefore, for the given input signals, to the same execution on [t-,t+)), and (ii) the module is capable of continuing to operate correctly in the future(i.e., there is no fault-free execution that eventually cannot be continued in a way that adheres to M).
0.869	[*A*]no fault-free execution[*R*]can not be continued[*A*]eventually	context()	negated: True ,passive: True
0.905	[*A*]a way[*R*]adheres[*A*]to M	context()	negated: False ,passive: False
[LINE#60] While (ii) should always be true for essentially the same reason that we demand non-emptiness for, (i) can be seen as the requirement of a correct internal state: For a correct module with an extensible specification, it is required that both all internal components of a physical implementation of the module operate according to their specification and all traces of an earlier transient fault (if any) from the internal state must have worn off, in the sense that it could have been reached by a non-faulty history.
0.834	[*A*]both all internal components of a physical implementation of the module[*R*]operate	context(it is required)	negated: False ,passive: False
0.399	[*A*]it[*R*]is required[*A*]that both all internal components of a physical implementation of the module operate according to all traces of an earlier transient fault[*A*]For a correct module with an extensible specification	context()	negated: False ,passive: True
0.958	[*A*]both all internal components of a physical implementation of the module[*R*]operate[*A*]if any ) from the internal state must have worn off , in the sense	context(it is required)	negated: False ,passive: True
0.265	[*A*]it[*R*]is required[*A*]that both all internal components of a physical implementation of the module operate according to their specification if any ) from the internal state must have worn off , in the sense[*A*]For a correct module with an extensible specification	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]could have been reached[*A*]by a non-faulty history	context()	negated: False ,passive: True
0.225	[*A*]we[*R*]demand[*A*]non-emptiness	context()	negated: False ,passive: False
0.920	[*A*]any ) from the internal state[*R*]must have worn off[*A*]in the sense	context()	negated: False ,passive: True
[LINE#61] Most of the basic module specifications we are going to introduce will be extendable.
0.803	[*A*]Most of the basic module specifications[*R*]will be[*A*]extendable	context()	negated: False ,passive: True
0.885	[*A*]the basic module specifications[*R*]to introduce[*A*]we	context()	negated: False ,passive: True
[LINE#62] However, there are also basic modules with non-extendable specifications; we will provide an example later on.
0.388	[*A*]we[*R*]will provide[*A*]an example[*A*]later on	context()	negated: False ,passive: False
[LINE#63+64]  The next lemma shows that any extendable module specification is uniquely characterized by its values on input executions of the respective module on R.Lemma 3.3Any function  that maps each execution Ein of a set of input ports Pin on R to a non-empty set of executions Eout of a set of output ports.
0.905	[*A*]any extendable module specification[*R*]is uniquely characterized[*A*]by its values on input executions of the respective module on R.Lemma 3.3Any function	context(The next lemma shows)	negated: False ,passive: True
0.807	[*A*]The next lemma[*R*]shows[*A*]that any extendable module specification is uniquely characterized by its values on input executions of the respective module on R.Lemma 3.3Any function	context()	negated: False ,passive: False
0.940	[*A*]R.Lemma 3.3Any function[*R*]maps[*A*]each execution	context()	negated: False ,passive: False
[LINE#65+66]  Pout on R specifies a unique module such that (i) M is extendable and (ii) M(Ein)=(Ein) for each execution of M's input ports Pin on R. Conversely, for each module.
0.879	[*A*]Pout on R[*R*]specifies[*A*]a unique module such that ( ii ) M ( Ein ) = ( Ein ) for each execution of M 's input ports Pin on R. Conversely , for each module	context()	negated: False ,passive: False
0.734	[*A*]M[*R*]is[*A*]extendable[*A*]Conversely	context()	negated: False ,passive: True
0.911	[*A*]Pout on R[*R*]specifies[*A*]a unique module such	context()	negated: False ,passive: False
[LINE#67+68]  M whose specification is extendable, M is uniquely characterized by its values on executions of ports Pin on R.ProofWe show first that for a function  as assumed by the lemma there exists a module.
0.647	[*A*]Pin on R.ProofWe[*R*]show[*A*]first[*A*]that	context(M is uniquely characterized)	negated: False ,passive: False
0.711	[*A*]M[*R*]is uniquely characterized[*A*]by its values on executions of ports	context()	negated: False ,passive: True
0.632	[*A*]M[*R*]is[*A*]extendable	context()	negated: False ,passive: True
[LINE#69] M such that M(Ein)=(Ein) for executions Ein of ports Pin on R and M is extendable.
0.915	[*A*]M ( Ein ) = ( Ein ) for executions[*R*]is[*A*]extendable	context()	negated: False ,passive: True
[LINE#70+71]  To this end, we simply define that M is a module with input ports Pin and output ports Pout whose specification M is given by EoutM(Ein) iff Ein and Eout are restrictions of executions Ein and Eout on R, respectively,.
0.879	[*A*]M[*R*]is[*A*]a module with input ports output ports Pout	context(we define)	negated: False ,passive: True
0.403	[*A*]we[*R*]define[*A*]that M is a module with input ports output ports Pout[*A*]To this end	context()	negated: False ,passive: False
0.877	[*A*]M[*R*]is given[*A*]by EoutM	context()	negated: False ,passive: True
0.921	[*A*]M[*R*]is[*A*]a module with input ports Pin ports Pout whose specification M is given by EoutM ( Ein ) iff Eout	context(we define)	negated: False ,passive: True
0.934	[*A*]Pin ports Pout[*R*]are[*A*]restrictions of Eout on R[*A*]respectively	context()	negated: False ,passive: True
0.921	[*A*]M[*R*]is[*A*]a module with input ports Pin ports Pout whose specification M is given by EoutM ( Ein ) iff Ein	context(we define)	negated: False ,passive: True
0.296	[*A*]we[*R*]define[*A*]that M is a module with input ports[*A*]To this end	context()	negated: False ,passive: False
0.934	[*A*]Pin ports Pout[*R*]are[*A*]restrictions of executions Ein on R[*A*]respectively	context()	negated: False ,passive: True
0.944	[*A*]whose specification M[*R*]is given[*A*]by EoutM	context()	negated: False ,passive: True
[LINE#72] Clearly, M satisfies properness and extendability by construction.
0.855	[*A*]M[*R*]satisfies[*A*]extendability	context()	negated: False ,passive: False
0.855	[*A*]M[*R*]satisfies[*A*]properness	context()	negated: False ,passive: False
[LINE#73]  Regarding non-emptiness, we can extend any input execution Ein on some interval.
0.452	[*A*]we[*R*]can extend[*A*]any input execution[*A*]on some interval	context()	negated: False ,passive: False
[LINE#74] I arbitrarily to an execution Ein on R. By assumption, (Ein), so there must be some execution Eout(Ein).
[LINE#75] By definition, its restriction Eout to I is in M(Ein), proving non-emptiness.
0.704	[*A*]its restriction[*R*]is[*A*]in M(Ein[*A*]proving non-emptiness	context()	negated: False ,passive: True
[LINE#76]  Hence M is a valid specification of a module M with input ports.
0.926	[*A*]M[*R*]is[*A*]a valid specification of a module M with input ports	context()	negated: False ,passive: True
[LINE#77] We now establish the second claim of the lemma, which will also show that the module M we constructed from  is unique and thus complete the proof.
0.837	[*A*]the lemma[*R*]will complete[*A*]the proof	context()	negated: False ,passive: False
0.483	[*A*]the module M we constructed from[*R*]is[*A*]unique	context(the lemma will show)	negated: False ,passive: True
0.440	[*A*]the lemma[*R*]will show[*A*]that the module M we constructed from is unique	context()	negated: False ,passive: False
0.754	[*A*]the module M[*R*]constructed[*A*]from	context()	negated: False ,passive: True
0.554	[*A*]We[*R*]establish[*A*]the second claim of the lemma[*A*]now	context()	negated: False ,passive: False
[LINE#78] To this end, let Ein and Eout be any executions of the input and output ports of M, respectively.
[LINE#79+80]  If EoutM(Ein), by extendability Ein and Eout are restrictions ofexecutions Ein and Eout on R, respectively, such that EoutM(Ein).
0.878	[*A*]EoutM ( Ein ) , by Eout[*R*]are[*A*]such	context()	negated: False ,passive: True
0.774	[*A*]EoutM[*R*]are[*A*]such	context()	negated: False ,passive: True
0.961	[*A*]EoutM ( Ein ) , by Eout[*R*]are[*A*]Eout	context()	negated: False ,passive: True
0.921	[*A*]EoutM[*R*]are[*A*]Eout	context()	negated: False ,passive: True
0.921	[*A*]EoutM[*R*]are[*A*]restrictions ofexecutions Ein	context()	negated: False ,passive: True
[LINE#81]  On the other hand, if EoutM(Ein), properness necessitates that there are no such executions.
[LINE#82] This shows the second statement and the lemma follows.
0.732	[*A*]the lemma[*R*]follows	context()	negated: False ,passive: False
0.449	[*A*]This[*R*]shows[*A*]the second statement	context()	negated: False ,passive: False
[LINE#83] Enabled by this lemma, we will specify most of our basic modules by defining M(Ein) for input executions Ein on R only.
0.309	[*A*]we[*R*]will specify[*A*]most of our basic modules	context()	negated: False ,passive: False
[LINE#84] For instance, the fixed delay channel from Example 3.2 can now be specified equivalently as follows.
0.894	[*A*]the fixed delay channel from Example 3.2[*R*]can be specified[*A*]equivalently[*A*]as follows[*A*]now	context()	negated: False ,passive: True
[LINE#85+86+87+88]  Example 3.4A fixed-delay channel with input port i, output port o, and delay d>0 is a basic module with extendable module specification C defined by: For each execution Ein of input port i on R, an execution Eout of output port o on R is in C(Ein) we have that o(t)=i(t-d).Because we do not need to describe partial feasible executions on a finite interval I=[t-,t+) here, the fact that the condition o(t)=i(t-d) applies only to a subinterval of I in Example 3.2 becomes superfluous:(-+d;)=R, so no additional specification is required to describe the module's behavior near the lower bound of intervals [t-,t+) with t-.
0.388	[*A*]we[*R*]do not need to describe[*A*]partial feasible executions[*A*]on a finite interval I=	context(we do not need)	negated: True ,passive: False
0.504	[*A*]we[*R*]do not need[*A*]to describe partial feasible executions on a finite interval I=	context()	negated: True ,passive: False
0.637	[*A*]i on R[*R*]is[*A*]in C[*A*]Because we do not need to describe partial feasible executions on a finite interval I= : ( - +d ; ) =R , so no additional specification is required to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: False ,passive: True
0.388	[*A*]we[*R*]do not need to describe[*A*]partial feasible executions[*A*]on a finite interval	context(we do not need)	negated: True ,passive: False
0.388	[*A*]we[*R*]do not need[*A*]to describe partial feasible executions on a finite interval	context()	negated: True ,passive: False
0.188	[*A*]we[*R*]have[*A*]that o ( t	context(i on R is)	negated: False ,passive: False
0.637	[*A*]i on R[*R*]is[*A*]in C[*A*]t - d ) . Because we do not need to describe partial feasible executions on a finite interval I= [ t ; ) =R , so no additional specification is required to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: False ,passive: True
0.943	[*A*]no additional specification[*R*]is required[*A*]to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: False ,passive: True
0.388	[*A*]we[*R*]do not need to describe[*A*]partial feasible executions	context(we do not need)	negated: True ,passive: False
0.504	[*A*]we[*R*]do not need[*A*]to describe partial feasible executions on a finite interval I= : ( - +d ; ) =R , so no additional specification is required to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: True ,passive: False
0.925	[*A*]an execution Eout of output port[*R*]is[*A*]in C[*A*]Because we do not need to describe partial feasible executions on a finite interval I= : ( - +d ; ) =R , so no additional specification is required to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: False ,passive: True
0.388	[*A*]we[*R*]do not need to describe[*A*]partial feasible executions on a finite interval	context(we do not need)	negated: True ,passive: False
0.550	[*A*]we[*R*]do not need[*A*]to describe partial feasible executions on a finite interval I= [ t	context()	negated: True ,passive: False
0.188	[*A*]we[*R*]have[*A*]that o ( t	context(an execution Eout of output port is)	negated: False ,passive: False
0.925	[*A*]an execution Eout of output port[*R*]is[*A*]in C[*A*]Because we do not need to describe partial feasible executions on a finite interval I= [ t	context()	negated: False ,passive: True
0.943	[*A*]no additional specification[*R*]is required[*A*]to describe the module 's behavior near the lower bound of intervals	context()	negated: False ,passive: True
0.933	[*A*]no additional specification[*R*]to describe[*A*]the module 's behavior near the lower bound of intervals	context()	negated: False ,passive: False
[LINE#89] By contrast, in Example 3.2, we had to specify this explicitly, by stating that any behavior of the output in [t-,t-+d) is feasible (by leaving the behavior unspecified in this interval).Whereas the specification in Example 3.4 simplifies the one of Example 3.2 only marginally, this is very different for the modules exhibiting more complex relations between input and output introduced later on: Accurately describing all suffixes of a non-trivial partial execution can be error-prone and may result in unnecessarily involved module specifications.
0.381	[*A*]By[*R*]may result[*A*]in unnecessarily involved module specifications	context()	negated: False ,passive: True
0.783	[*A*]input and output[*R*]introduced[*A*]later on	context()	negated: False ,passive: True
0.903	[*A*]the modules[*R*]exhibiting[*A*]more complex relations between input and output	context()	negated: False ,passive: False
0.891	[*A*]any behavior of the output in [ t - , t - +d[*R*]is[*A*]feasible	context(we to specify explicitly by stating)	negated: False ,passive: True
0.170	[*A*]we[*R*]to specify explicitly by stating[*A*]that any behavior of the output in [ t - , t - +d ) is feasible ( by leaving the behavior unspecified in this interval	context(we to specify explicitly)	negated: False ,passive: False
0.155	[*A*]we[*R*]to specify explicitly[*A*]this	context()	negated: False ,passive: False
0.386	[*A*]this[*R*]is[*A*]very different for the modules	context(Accurately describing all suffixes of a non-trivial partial execution can be)	negated: False ,passive: True
0.934	[*A*]Accurately describing all suffixes of a non-trivial partial execution[*R*]can be[*A*]error - prone	context()	negated: False ,passive: True
0.952	[*A*]the specification in Example 3.4[*R*]simplifies only marginally[*A*]the one of Example 3.2	context()	negated: False ,passive: False
[LINE#90] In this case, the module M is given by a finite set SM of submodules of M.
0.937	[*A*]a finite[*R*]set[*A*]SM[*A*]of submodules of M.	context()	negated: False ,passive: False
0.961	[*A*]the module M[*R*]is given[*A*]by a finite[*A*]In this case	context()	negated: False ,passive: True
[LINE#91] These submodules are interconnected, i.e., an output port of one submodule can be the input port of another, and the ports of M may also be ports of submodules.
0.909	[*A*]the ports of M[*R*]may be[*A*]ports of submodules	context()	negated: False ,passive: True
0.767	[*A*]These submodules[*R*]are[*A*]interconnected	context()	negated: False ,passive: True
[LINE#92+93+94+95]  We require that SM is well-formed, i.e., the following conditions are satisfied:1.For each output port p of M, there is exactly one submodule SSM such that S has output port p.2.For each input port p of a submodule of M, either p is an input port of M, or there is exactly one submodule SSM.
0.874	[*A*]p[*R*]is[*A*]an input port of M	context()	negated: False ,passive: True
0.887	[*A*]S[*R*]has[*A*]output port	context()	negated: False ,passive: False
0.688	[*A*]SM[*R*]is[*A*]well-formed	context(We require)	negated: False ,passive: True
0.202	[*A*]We[*R*]require[*A*]that SM is well-formed, i.e., the following conditions are satisfied:1.For each output port p of M, there is exactly one submodule SSM such that S has output port p.2.For each input port p of a submodule of M, either p is an input port of M, or there is exactly one submodule SSM	context()	negated: False ,passive: False
[LINE#96] The idea behind this definition is to "plug together" ports in a way such that no port is "driven" by more than one port or be left "floating".
0.868	[*A*]no port[*R*]driven[*A*]by more than one port	context()	negated: False ,passive: True
0.943	[*A*]no port[*R*]is[*A*]driven" by more than one port or be left "floating	context()	negated: False ,passive: True
0.924	[*A*]The idea behind this definition[*R*]is such[*A*]to "plug together" ports in a way	context()	negated: False ,passive: True
[LINE#97] For a compound module M, we now define the corresponding basic module (M).
0.554	[*A*]we[*R*]define[*A*]the corresponding basic module[*A*]For a compound module M[*A*]now	context()	negated: False ,passive: False
[LINE#98] input and output ports are the input and output ports of M, whereas its module specification (M) is defined as follows: Let E be an execution of M on IR and denote by Ein and Eout its restrictions to M's input and output ports, respectively.
0.907	[*A*]output ports[*R*]are[*A*]the output ports of M[*A*]whereas its module specification ( M ) is defined as follows : Let E be denote by Eout	context()	negated: False ,passive: True
0.907	[*A*]output ports[*R*]are[*A*]the output ports of M[*A*]whereas its module specification ( M ) is defined as follows : Let E be denote by Ein	context()	negated: False ,passive: True
0.907	[*A*]output ports[*R*]are[*A*]the input ports of M[*A*]whereas its module specification ( M ) is defined as follows : Let E be denote by Eout	context()	negated: False ,passive: True
0.907	[*A*]output ports[*R*]are[*A*]the input ports of M[*A*]whereas its module specification ( M ) is defined as follows : Let E be denote by Ein	context()	negated: False ,passive: True
0.907	[*A*]input ports[*R*]are[*A*]the output ports of M[*A*]whereas its module specification ( M ) is defined as follows : Let E be denote by Eout	context()	negated: False ,passive: True
0.907	[*A*]input ports[*R*]are[*A*]the output ports of M[*A*]whereas its module specification ( M ) is defined as follows : Let E be denote by Ein	context()	negated: False ,passive: True
0.907	[*A*]input ports[*R*]are[*A*]the input ports of M[*A*]whereas its module specification ( M ) is defined as follows : Let E be denote by Eout	context()	negated: False ,passive: True
0.907	[*A*]input ports[*R*]are[*A*]the input ports of M[*A*]whereas its module specification ( M ) is defined as follows : Let E be denote by Ein	context()	negated: False ,passive: True
0.325	[*A*]its module specification[*R*]is defined	context()	negated: False ,passive: False
[LINE#99+100]  Then Eout(M)(Ein), iff there exists an execution EM,SM on I of all ports of modules in {M}SM,such that, for each module SSM, the restriction of execution EM,SM to the ports of S is feasible for S, and EM,SM restricted to M's ports is equal to E. Note that (M) satisfies properness: This follows directly from the definition and properness of all submodules if all submodules are basic, and for more complex modules by structural induction.
0.833	[*A*]M[*R*]satisfies[*A*]properness	context()	negated: False ,passive: False
0.722	[*A*]E.[*R*]Note[*A*]that ( M ) satisfies properness	context()	negated: False ,passive: False
0.845	[*A*]SM[*R*]restricted[*A*]to M 's ports	context(This follows directly)	negated: False ,passive: False
0.321	[*A*]This[*R*]follows directly[*A*]from properness of all submodules	context()	negated: False ,passive: True
0.321	[*A*]This[*R*]follows directly[*A*]from properness of all submodules[*A*]if all submodules are basic	context()	negated: False ,passive: True
0.321	[*A*]This[*R*]follows directly[*A*]from the definition of all submodules	context()	negated: False ,passive: True
0.321	[*A*]This[*R*]follows directly[*A*]from the definition of all submodules[*A*]if all submodules are basic	context()	negated: False ,passive: True
0.767	[*A*]all submodules[*R*]are[*A*]basic	context()	negated: False ,passive: True
0.700	[*A*]SSM[*R*]is[*A*]feasible	context()	negated: False ,passive: True
[LINE#101] We further require that the choice of SM is such that (M) fulfills non-emptiness.
0.873	[*A*]the choice of SM[*R*]is[*A*]such that (M) fulfills non-emptiness	context(We require)	negated: False ,passive: True
0.274	[*A*]We[*R*]require[*A*]that the choice of SM is such that (M) fulfills non-emptiness	context()	negated: False ,passive: False
0.833	[*A*]M[*R*]fulfills[*A*]non-emptiness	context()	negated: False ,passive: False
[LINE#102] Hence, (M) is indeed a basic module with specification (M).
0.869	[*A*]M[*R*]is[*A*]indeed[*A*]a basic module with specification	context()	negated: False ,passive: True
[LINE#103+104]  We say that execution E of M is feasible for M iff it is feasible for the corresponding basic module.
0.945	[*A*]execution E of M[*R*]is[*A*]feasible[*A*]for M iff it is feasible for the corresponding basic module	context(We say)	negated: False ,passive: True
0.225	[*A*]We[*R*]say[*A*]that execution E of M is feasible	context()	negated: False ,passive: False
0.522	[*A*]it[*R*]is[*A*]feasible[*A*]for the corresponding basic module	context()	negated: False ,passive: True
[LINE#105] Intuitively, this means that we consider a compound module correct whenever all its submodules are correct.
0.356	[*A*]we[*R*]consider[*A*]a compound module correct whenever all its submodules are correct	context(this means)	negated: False ,passive: False
0.086	[*A*]this[*R*]means[*A*]that we consider a compound module correct	context()	negated: False ,passive: False
0.406	[*A*]all its submodules[*R*]are[*A*]correct	context()	negated: False ,passive: True
[LINE#106+107+108]  Example 3.5Consider a compound module output port o. InvChain is specified by the set of modules SInvChain={Inv1,Inv2,Chan1,Chan2}, where Inv1 and Inv2 are (zero-time) inverters, and Chan1 and Chan2fixed-delay channels with delay d>0.
0.932	[*A*]Inv2[*R*]are[*A*]Chan1	context()	negated: False ,passive: True
0.932	[*A*]Inv1[*R*]are[*A*]Chan1	context()	negated: False ,passive: True
0.802	[*A*]Inv2[*R*]are[*A*]0	context()	negated: False ,passive: True
0.905	[*A*]Inv2[*R*]are[*A*]zero - time ) inverters	context()	negated: False ,passive: True
0.802	[*A*]Inv1[*R*]are[*A*]0	context()	negated: False ,passive: True
0.961	[*A*]InvChain[*R*]is specified[*A*]by the set of modules SInvChain=[*A*]a compound module output port	context()	negated: False ,passive: True
0.905	[*A*]Inv1[*R*]are[*A*]zero - time ) inverters	context()	negated: False ,passive: True
0.953	[*A*]InvChain[*R*]is specified[*A*]by the set of modules[*A*]a compound module output port	context()	negated: False ,passive: True
[LINE#109+110+111+112]  We connect the modules' ports sequentially, as depicted in Fig. 3: i of InvChain is also the input port of Inv1, whose output port a is the input port of Chan1; the output b of Chan1 is fed into Inv2, whose output c in turn is input to Chan2; finally, the output port o of Chan2 is also the output port of M.Let Ein be the execution of porti whose state function is i(t)=0 for t(-,0) and i(t)=1 for t[0,).
0.764	[*A*]i of InvChain[*R*]is[*A*]also[*A*]the input port of Inv1	context(We connect sequentially the output port is)	negated: False ,passive: True
0.381	[*A*]We[*R*]connect sequentially[*A*]the modules ' ports	context(the output port is)	negated: False ,passive: False
0.837	[*A*]porti[*R*]is[*A*]i	context()	negated: False ,passive: True
0.480	[*A*]We[*R*]be[*A*]the execution of porti	context()	negated: False ,passive: True
0.381	[*A*]We[*R*]connect sequentially[*A*]the modules ' ports	context(i of InvChain is the output b of Chan1 is fed the output port is)	negated: False ,passive: False
0.764	[*A*]i of InvChain[*R*]is[*A*]also[*A*]the input port of Inv1	context(the output b of Chan1 is fed the output port is)	negated: False ,passive: True
0.940	[*A*]the output b of Chan1[*R*]is fed[*A*]into Inv2	context(the output port is)	negated: False ,passive: True
0.950	[*A*]the output port[*R*]is[*A*]also[*A*]the output port of M.Let Ein[*A*]finally	context()	negated: False ,passive: True
0.939	[*A*]Inv2[*R*]is[*A*]input to Chan2	context()	negated: False ,passive: True
[LINE#113+114]  For the module specification of InvChain's corresponding basic module (InvChain) it then holds that (InvChain)(Ein)={Eout}, where Eout is the execution of port o with o(t)=0 for t(-,2d) and o(t)=1 for t[2d,).Notethat (InvChain) is extendable: Any feasible execution E on some interval [t-,t+) satisfies o(t)=c(t-d)=b(t-d)=a(t-2d)=i(t-2d) for all times t[t-+2d,t+).
0.784	[*A*]Notethat[*R*]is[*A*]extendable	context(Any feasible execution E on some interval satisfies)	negated: False ,passive: True
0.818	[*A*]Any feasible execution E on some interval[*R*]satisfies[*A*]o	context()	negated: False ,passive: False
0.819	[*A*]Notethat[*R*]is[*A*]extendable	context()	negated: False ,passive: True
0.938	[*A*]Eout[*R*]is[*A*]the execution of port	context()	negated: False ,passive: True
0.761	[*A*]it[*R*]holds[*A*]For the module specification of InvChain 's corresponding basic module[*A*]then	context()	negated: False ,passive: False
[LINE#115+116]  An infinite feasible execution of InvChain on R whose restriction to [t-,t+)matches E is easily found by (i) extending the input ports execution to [t--2d,t-) by using i(t-2d)=o(t) on [t-,t-+2d), (ii) extending the output ports execution to [t+,t++2d) by using o(t+2d)=i(t) on [t+-2d,t+), and finally defining o(t)=i(t-2d) arbitrarily for t(-,t-) and t[t++2d,).From this observation, we can infer by Lemma 3.3 that the module specification of InvChain matches that of a fixed-delay channel with delay 2d, as in feasible executions of InvChain on R we clearly have o(t)=i(t-2d) at all times tR.
0.884	[*A*]the module specification of InvChain[*R*]matches[*A*]that of a fixed - delay channel with delay 2 d	context(An infinite feasible execution of InvChain on R whose restriction to [ t - , t+ ) matches E is easily found we can infer)	negated: False ,passive: False
0.309	[*A*]we[*R*]can infer[*A*]by Lemma 3.3[*A*]that the module specification of InvChain matches that of a fixed - delay channel with delay 2 d	context(An infinite feasible execution of InvChain on R whose restriction to [ t - , t+ ) matches E is easily found)	negated: False ,passive: False
0.884	[*A*]the module specification of InvChain[*R*]matches[*A*]that of a fixed - delay channel with delay 2 d	context(we can infer)	negated: False ,passive: False
0.309	[*A*]we[*R*]can infer[*A*]by Lemma 3.3[*A*]that the module specification of InvChain matches that of a fixed - delay channel with delay 2 d	context()	negated: False ,passive: False
0.985	[*A*]An infinite feasible execution of InvChain on R whose restriction to [ t - , t+ ) matches E[*R*]is easily found[*A*]by (i)	context()	negated: False ,passive: True
0.197	[*A*]we[*R*]have[*A*]o	context()	negated: False ,passive: False
0.980	[*A*]An infinite feasible execution of InvChain on R whose restriction to [ t - , t+ ) matches E[*R*]is easily found[*A*]by (i)	context(we can infer)	negated: False ,passive: True
0.444	[*A*]we[*R*]can infer[*A*]by Lemma 3.3[*A*]that the module specification of InvChain matches that of a fixed - delay channel with delay 2 d[*A*]From this observation	context()	negated: False ,passive: False
0.813	[*A*](i)[*R*]extending[*A*]the input ports execution[*A*]to [ t	context()	negated: False ,passive: False
0.758	[*A*]=i[*R*]defining[*A*]o[*A*]finally	context()	negated: False ,passive: False
[LINE#117] This demonstrates that compound modules permit to reason about the behavior of complex systems in a hierarchical fashion, based on basic modules that can be understood much easier.
0.923	[*A*]compound modules[*R*]permit to reason[*A*]about the behavior of complex systems in a hierarchical fashion	context(This demonstrates compound modules permit)	negated: False ,passive: False
0.923	[*A*]compound modules[*R*]permit[*A*]to reason about the behavior of complex systems in a hierarchical fashion	context(This demonstrates)	negated: False ,passive: False
0.224	[*A*]This[*R*]demonstrates[*A*]that compound modules permit to reason about the behavior of complex systems in a hierarchical fashion	context()	negated: False ,passive: False
0.698	[*A*]basic modules[*R*]can be understood much easier	context()	negated: False ,passive: False
0.897	[*A*]a hierarchical fashion[*R*]based[*A*]on basic modules	context()	negated: False ,passive: True
[LINE#118] The level of detail can be adjusted by the granularity at which one relies on basic modules; in particular, it is feasible to refine the analysis later on by further breaking down basic modules into compound modules.
0.741	[*A*]one[*R*]relies[*A*]on basic modules[*A*]the granularity	context()	negated: False ,passive: False
[LINE#119] Example 3.6As an example of a non-extendable specification, consider the compound module Osc, a simple oscillator that is started at, say, time 0.
0.897	[*A*]a simple oscillator[*R*]is started[*A*]at, say, time 0	context()	negated: False ,passive: True
0.957	[*A*]Example[*R*]3.6As[*A*]an example of a non-extendable specification, consider the compound module Osc, a simple oscillator	context()	negated: False ,passive: False
[LINE#120+121]  The module has no input port and one (binary)output port c, the clock signal.1414In practice, one would of course need an input conveying the control signal starting the oscillator; we conveniently hide this detail within the module specification.
0.446	[*A*]one[*R*]would need[*A*]an input conveying the control signal starting the oscillator	context(we hide)	negated: False ,passive: False
0.770	[*A*]The module[*R*]has[*A*]one	context(we hide)	negated: False ,passive: False
0.349	[*A*]we[*R*]hide[*A*]this detail	context()	negated: False ,passive: False
0.905	[*A*]The module[*R*]has[*A*]no input port	context(one would need we conveniently hide)	negated: False ,passive: False
0.446	[*A*]one[*R*]would need[*A*]an input conveying the control signal	context(we conveniently hide)	negated: False ,passive: False
0.388	[*A*]we[*R*]conveniently hide[*A*]this detail	context()	negated: False ,passive: False
0.903	[*A*]an input[*R*]conveying[*A*]the control signal starting the oscillator	context()	negated: False ,passive: False
[LINE#122] It comprises a binary resettable fixed-delay channel (RChan) of delay d>0, with input port c and output port o, whose extendable specification demands that its output fulfills o(t)=0 for all times t(-,0) and o(t)=c(t-d) for all times t[0,).
0.240	[*A*]It[*R*]comprises[*A*]a binary resettable fixed - delay channel ( RChan ) of delay d > 0 , with input output port o , whose extendable specification demands that its output fulfills o ( t ) =0 for all times t ( o ( t ) =c ( t - d ) for all times t	context()	negated: False ,passive: True
0.614	[*A*]It[*R*]comprises[*A*]a binary resettable fixed - delay channel ( RChan ) of delay d > 0 , with input output port o , whose extendable specification demands	context()	negated: False ,passive: True
0.240	[*A*]It[*R*]comprises[*A*]a binary resettable fixed - delay channel ( RChan ) of delay d > 0 , with input port c port o , whose extendable specification demands that its output fulfills o ( t ) =0 for all times t ( o ( t ) =c ( t - d ) for all times t	context()	negated: False ,passive: True
0.240	[*A*]It[*R*]comprises[*A*]a binary resettable fixed - delay channel ( RChan ) of delay d > 0 , with input port c port o , whose extendable specification demands that its output fulfills o ( t ) =0 for all times t ( - , 0 ) ( t ) =c ( t - d ) for all times t	context()	negated: False ,passive: True
[LINE#123] Port o further is the input port of a (zero-time) inverter (Inv), whose output port is c, the clock signal.
0.914	[*A*]Port[*R*]is[*A*]the input port of a (zero-time) inverter	context()	negated: False ,passive: True
[LINE#124] It is not hard to see that the only feasible execution of Osc on R maintains signal 0 on port o and signal 1 on port c until time 0.
[LINE#125] Then the feedback loop starts to oscillate with frequency 1/(2d), since the channel reproduces its input with fixed delay d and the inverter inverts the signal.
0.882	[*A*]the inverter[*R*]inverts[*A*]the signal	context(the channel reproduces)	negated: False ,passive: False
0.802	[*A*]the channel[*R*]reproduces[*A*]its input with fixed delay d	context()	negated: False ,passive: False
0.877	[*A*]the feedback loop[*R*]starts[*A*]Then	context()	negated: False ,passive: True
[LINE#126] The specification of Osc is not extendable.
0.844	[*A*]The specification of Osc[*R*]is not[*A*]extendable	context()	negated: True ,passive: True
[LINE#127] This can be seen from the execution on [0,) where o(t)=kmod2 for all t[kd/3,(k+1)d/3) and kN0, and c(t)=o(t) for all t[0,).
0.381	[*A*]This[*R*]can be seen[*A*]from the execution on [ 0	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]can be seen[*A*]from the execution on	context()	negated: False ,passive: True
[LINE#128] This execution is feasible when restricted to each submodule since c(t)=o(t)=o(t-d) for all t[d,), but the output signal c(t) oscillates at frequency 3/(2d).
0.905	[*A*]the output signal c[*R*]oscillates[*A*]at frequency 3	context()	negated: False ,passive: True
0.952	[*A*]This execution[*R*]is[*A*]feasible[*A*]when restricted to each submodule[*A*]since c(t)=o(t)=o(t-d) for all t[d,), but the output signal c(t) oscillates at frequency 3	context()	negated: False ,passive: True
[LINE#129] Hence this execution is feasible, but not a restriction of the unique feasible execution of Osc on R.Note carefully that an oscillator according to Fig. 4 involving a channel with delay d=0 would be an example of a well-formed set of modules M that is not a compound module, since it violates non-emptyness of (M). .
0.498	[*A*]it[*R*]violates[*A*]non-emptyness of ( M	context()	negated: False ,passive: False
0.926	[*A*]a well - formed set of modules M[*R*]is not[*A*]a compound module[*A*]since it violates non-emptyness of ( M	context()	negated: True ,passive: True
0.986	[*A*]an oscillator according to Fig . 4 involving a channel with delay d=0[*R*]would be[*A*]an example of a well - formed set of modules M	context()	negated: False ,passive: True
0.934	[*A*]an oscillator according to Fig[*R*]involving[*A*]a channel with delay d=0	context()	negated: False ,passive: True
0.813	[*A*]this execution[*R*]is[*A*]feasible	context()	negated: False ,passive: True
[LINE#130] Examples 3.5 and 3.6 of InvChain and Osc reveal a crucial insight about the behavior of compound modules.
0.961	[*A*]3.6 of Osc[*R*]reveal[*A*]a crucial insight about the behavior of compound modules[*A*]Examples	context()	negated: False ,passive: False
0.961	[*A*]3.6 of InvChain[*R*]reveal[*A*]a crucial insight about the behavior of compound modules[*A*]Examples	context()	negated: False ,passive: False
0.961	[*A*]3.5 of Osc[*R*]reveal[*A*]a crucial insight about the behavior of compound modules[*A*]Examples	context()	negated: False ,passive: False
0.961	[*A*]3.5 of InvChain[*R*]reveal[*A*]a crucial insight about the behavior of compound modules[*A*]Examples	context()	negated: False ,passive: False
[LINE#131] While InvChain behaves like a fixed-delay channel in all feasible executions, it cannot be said for Osc that it always behaves like an oscillator of frequency 1/(2d).
0.606	[*A*]it[*R*]behaves[*A*]like an oscillator of frequency 1/(2d[*A*]always	context(it can not be said)	negated: False ,passive: False
0.433	[*A*]it[*R*]can not be said[*A*]for Osc	context()	negated: True ,passive: True
0.948	[*A*]InvChain[*R*]behaves[*A*]like a fixed-delay channel in all feasible executions	context()	negated: False ,passive: False
[LINE#132+133]  Even though Osc will run at the fixed frequency of 1/(2d)if it is feasible at all times, an inconsistent initialization or a transient fault can cause it to run forever at an arbitrarily high frequency.
0.388	[*A*]it[*R*]to run[*A*]forever[*A*]at an arbitrarily high frequency	context(an inconsistent initialization or a transient fault can cause)	negated: False ,passive: False
0.863	[*A*]an inconsistent initialization or a transient fault[*R*]can cause[*A*]it to run forever at an arbitrarily high frequency	context()	negated: False ,passive: False
0.522	[*A*]it[*R*]is[*A*]feasible[*A*]at all times	context()	negated: False ,passive: True
[LINE#134] In general, when devising compound modules, typically our design goal will be to implement a certain basic module, that is, essentially ensure that the feasible executions of the compound module are also feasible according to the (usually more idealized) specification of the respective basic module.
0.670	[*A*]our design goal[*R*]will be[*A*]to implement a certain basic module, that is, essentially ensure that the feasible executions of the compound module are also feasible according to the (usually more idealized) specification of the respective basic module[*A*]when devising compound modules	context()	negated: False ,passive: True
[LINE#135] For InvChain, the intended basic module is a fixed-delay channel, where for Osc we had an (externally started) oscillator of frequency 1/(2d) in mind.
0.790	[*A*]we[*R*]had[*A*]an (externally started) oscillator of frequency 1/(2d[*A*]a fixed-delay channel[*A*]for Osc	context()	negated: False ,passive: False
0.940	[*A*]the intended basic module[*R*]is[*A*]a fixed-delay channel, where for Osc we had an (externally started) oscillator of frequency 1/(2d) in mind	context()	negated: False ,passive: True
[LINE#136] Since we strive for self-stabilization properties, intuitively InvChain would be a "good" implementation of a fixed-delay channel, whereas Osc is not satisfactory because it does not recover from transient faults.
0.452	[*A*]it[*R*]does not recover[*A*]from transient faults	context()	negated: True ,passive: True
0.762	[*A*]Osc[*R*]is not[*A*]satisfactory[*A*]because it does not recover from transient faults	context()	negated: True ,passive: True
0.957	[*A*]InvChain[*R*]would be[*A*]a "good" implementation of a fixed-delay channel[*A*]whereas Osc is not satisfactory	context()	negated: False ,passive: True
0.452	[*A*]we[*R*]strive[*A*]for self-stabilization properties	context()	negated: False ,passive: False
[LINE#137] Before we formalize the concepts of implementation and self-stabilization, let us get a better understanding of the critical difference between InvChain and Osc.
0.452	[*A*]we[*R*]formalize[*A*]the concepts of self - stabilization	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]formalize[*A*]the concepts of implementation	context()	negated: False ,passive: False
[LINE#138] In both cases, the output depends on past inputs, so both compound modules have a sort of memory.
0.911	[*A*]both compound modules[*R*]have[*A*]a sort of memory	context()	negated: False ,passive: False
0.943	[*A*]the output[*R*]depends[*A*]on past inputs[*A*]so both compound modules have a sort of memory[*A*]In both cases	context()	negated: False ,passive: False
[LINE#139] In any real-world system, this cannot be avoided since physics entails positive delays for any building block we might use.
0.894	[*A*]any building block[*R*]might use[*A*]we	context()	negated: False ,passive: True
0.894	[*A*]physics[*R*]entails[*A*]positive delays for any building block	context()	negated: False ,passive: False
0.523	[*A*]this[*R*]can not be avoided[*A*]since physics entails positive delays for any building block[*A*]In any real-world system	context()	negated: True ,passive: True
[LINE#140] However, InvChain eventually "forgets" about previous inputs, while Osc contains a feedback-loop that, in a feasible execution, determines the future output as a periodic function of the first d time units of the execution.
0.825	[*A*]Osc[*R*]contains[*A*]a feedback-loop	context()	negated: False ,passive: False
0.935	[*A*]InvChain[*R*]forgets[*A*]about previous inputs[*A*]eventually	context()	negated: False ,passive: False
[LINE#141] This motivates the following definitions.
0.381	[*A*]This[*R*]motivates[*A*]the following definitions	context()	negated: False ,passive: False
[LINE#142+143]  +, we say that a module is F-forgetful, iff its specification permits the following construction:1.Take an arbitrary feasible execution E of M on some interval [t-,t+]R. Denote by Ein and Eout its restrictions to the input and output ports of M, respectively.2.Restrict Eout to.
0.920	[*A*]a module[*R*]is[*A*]F - forgetful	context(we say)	negated: False ,passive: True
0.218	[*A*]we[*R*]say[*A*]that a module is F - forgetful	context()	negated: False ,passive: False
0.638	[*A*]its specification[*R*]permits[*A*]the following con	context()	negated: False ,passive: False
[LINE#144]  Then for each execution Ein on R whose restriction to [t-,t+] equals Ein, there is a feasible execution of M on R whose respective restrictions to the input and output ports (and in time) are.
0.963	[*A*]a feasible execution of M on R[*R*]are[*A*]in time	context()	negated: False ,passive: True
[LINE#145+146]  We say a module is forgetful iff it is F-forgetful for some FR0.
0.866	[*A*]a module[*R*]is[*A*]forgetful[*A*]iff it is F-forgetful for some FR0	context(We say)	negated: False ,passive: True
0.409	[*A*]We[*R*]say[*A*]a module is forgetful iff it is F-forgetful for some FR0	context()	negated: False ,passive: False
0.568	[*A*]it[*R*]is[*A*]F-forgetful for some FR0	context()	negated: False ,passive: True
[LINE#147] Essentially, F-forgetfulness requires that feasibility of the output at time t merely depends on the inputs during [t-F,t].
0.940	[*A*]feasibility of the output at time t[*R*]depends[*A*]on the inputs during [t-F,t	context(F - forgetfulness requires)	negated: False ,passive: False
0.863	[*A*]F-forgetfulness[*R*]requires[*A*]that feasibility of the output at time t merely depends on the inputs during [t-F,t	context()	negated: False ,passive: False
[LINE#148] That is, the effects of earlier inputs, as well as all traces of a possible transient fault, wear out from the internal state within time F. Note that 0-forgetful modules are exactly those with extendable specifications, i.e., forgetfulness is a generalization of extendability.
0.918	[*A*]forgetfulness[*R*]is[*A*]a generalization of extendability	context()	negated: False ,passive: True
[LINE#149] Let the circuit graph of a compound module M be the directed graph whose nodes are the submodules SM, and for each port p that is an output port of SSM and an input port of SSM it contains a (directed) edge from S to S.
0.933	[*A*]each port p[*R*]is[*A*]an output port of an input port of SSM	context()	negated: False ,passive: True
0.498	[*A*]it[*R*]contains[*A*]a ( directed ) edge from S to S.	context()	negated: False ,passive: False
0.933	[*A*]each port p[*R*]is[*A*]an output port of SSM	context()	negated: False ,passive: True
0.913	[*A*]the directed graph[*R*]are[*A*]the submodules SM	context()	negated: False ,passive: True
[LINE#150+151]  We recursively define that M is feedback-free iff (i)all its basic submodules are forgetful, (ii) all its compound submodules are feedback-free, and (iii) its circuit graph is acyclic.
0.376	[*A*]all its basic submodules[*R*]are[*A*]forgetful	context(M is its circuit graph is)	negated: False ,passive: True
0.421	[*A*]its circuit graph[*R*]is[*A*]acyclic	context(M is)	negated: False ,passive: True
0.862	[*A*]M[*R*]is[*A*]feedback - free iff	context()	negated: False ,passive: True
0.240	[*A*]We[*R*]recursively define[*A*]that M is feedback - free iff ( i ) all its basic submodules are forgetful , ( ii ) ( iii ) its circuit graph is acyclic	context()	negated: False ,passive: False
0.681	[*A*]all its compound submodules[*R*]are[*A*]feedback - free	context()	negated: False ,passive: True
0.430	[*A*]all its basic submodules[*R*]are[*A*]forgetful	context()	negated: False ,passive: True
0.872	[*A*]M[*R*]is[*A*]feedback - free iff ( i ) all its basic submodules are forgetful	context()	negated: False ,passive: True
0.195	[*A*]We[*R*]recursively define	context()	negated: False ,passive: False
[LINE#152+153+154]  Finally, we define the idealized basic module (M) corresponding to compound module M (with the same ports as M) by execution E of (M)it is the restriction of a feasible execution of M on R.According to these definitions, InvChain is clearly 2d-forgetful and feedback-free.
0.921	[*A*]InvChain[*R*]is[*A*]clearly[*A*]2d - feedback - free	context()	negated: False ,passive: True
0.619	[*A*]it[*R*]is[*A*]the restriction of a feasible execution of M on R.According to these definitions	context(we define InvChain is)	negated: False ,passive: True
0.686	[*A*]we[*R*]define[*A*]the idealized basic module ( M ) corresponding to compound module M ( with the same ports as M ) by execution E of ( M )[*A*]Finally	context(InvChain is)	negated: False ,passive: False
0.805	[*A*]InvChain[*R*]is[*A*]clearly[*A*]2d - forgetful	context()	negated: False ,passive: True
0.939	[*A*]the idealized basic module[*R*]corresponding[*A*]to compound module M ( with the same ports as M	context()	negated: False ,passive: True
[LINE#155] Since we observed that (InvChain) is extendable, it is in fact 0-forgetful and its corresponding basic and idealized basic modules are identical.
0.430	[*A*]its idealized basic modules[*R*]are[*A*]identical	context()	negated: False ,passive: True
0.454	[*A*]its corresponding basic basic modules[*R*]are[*A*]identical	context()	negated: False ,passive: True
0.784	[*A*]InvChain[*R*]is[*A*]extendable	context(we observed)	negated: False ,passive: True
0.225	[*A*]we[*R*]observed[*A*]that ( InvChain ) is extendable	context()	negated: False ,passive: False
0.522	[*A*]it[*R*]is[*A*]in fact[*A*]0 - forgetful	context()	negated: False ,passive: True
[LINE#156] In contrast, Osc satisfies neither of these properties.
0.855	[*A*]Osc[*R*]satisfies[*A*]neither of these properties	context()	negated: False ,passive: False
[LINE#157] Note, however, that replacing a basic module in InvChain by a compound module might result in a module that does not have these properties either.
0.887	[*A*]a module[*R*]does not have[*A*]these properties[*A*]either	context()	negated: True ,passive: False
[LINE#158] We are now in the position to formulate a theorem that states that any feedback-free module will eventually behave like its idealized basic module in a feasible execution.
0.887	[*A*]any feedback-free module[*R*]will behave[*A*]like its idealized basic module in a feasible execution[*A*]eventually	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]are[*A*]now[*A*]in the position	context()	negated: False ,passive: True
[LINE#159] Theorem 3.7Suppose M is a feedback-free compound module.
0.949	[*A*]Theorem 3.7Suppose M[*R*]is[*A*]a feedback-free compound module	context()	negated: False ,passive: True
[LINE#160] Let P be the set of paths in its circuit graph and submodule SSM be FS-forgetful.
[LINE#161]  Then M is F-forgetful withF:=max(S1,,Sk)P{i=1kFSi}.ProofConsider an arbitrary execution E on [t-,t+) on the ports of M and its submodules whose restriction to the ports of M (and thus also its restrictions to each submodule of M) is feasible, its restrictions Ein and Eout to the input and output ports of M, the restriction.
0.949	[*A*]i=1kFSi[*R*]ProofConsider[*A*]an arbitrary execution E on [ the input and output ports of M	context()	negated: False ,passive: False
0.669	[*A*]M[*R*]is withF[*A*]Then	context()	negated: False ,passive: True
[LINE#162]  Eout of Eout to [t-+F,t+), and an arbitrary execution.
[LINE#163] Ein on R satisfying that its restriction to [t-,t+) equals EI.
0.797	[*A*]Ein on R[*R*]satisfying[*A*]that its restriction to [t-,t+) equals EI	context()	negated: False ,passive: True
[LINE#164] Denote for each SSMFS,M:=max(S1,S2,,Sk=S)P{i=1kFSi}.
[LINE#165] Note that maxSSM{FS,M}=F.By induction on the submodules of M, we will construct a feasible execution Eimax on the ports of M and its submodules on R that is feasible for M when restricted to the ports of M and whose respective restrictions equal Ein and Eout.
0.861	[*A*]the ports of its submodules on R[*R*]is[*A*]feasible[*A*]when restricted to the ports of whose respective restrictions equal Eout	context()	negated: False ,passive: True
0.861	[*A*]the ports of its submodules on R[*R*]is[*A*]feasible[*A*]when restricted to the ports of whose respective restrictions equal Ein	context()	negated: False ,passive: True
0.614	[*A*]we[*R*]will construct[*A*]a feasible execution[*A*]on the ports of M[*A*]when restricted to the ports of whose respective restrictions equal Eout	context()	negated: False ,passive: False
0.614	[*A*]we[*R*]will construct[*A*]a feasible execution[*A*]on the ports of M[*A*]when restricted to the ports of whose respective restrictions equal Ein	context()	negated: False ,passive: False
0.794	[*A*]the ports of its submodules on R[*R*]is[*A*]feasible[*A*]when restricted to the ports of M	context()	negated: False ,passive: True
0.309	[*A*]we[*R*]will construct[*A*]a feasible execution[*A*]on the ports of its submodules on R	context()	negated: False ,passive: False
0.498	[*A*]we[*R*]will construct[*A*]a feasible execution[*A*]on the ports of M[*A*]when restricted to the ports of M	context()	negated: False ,passive: False
[LINE#166] In each step of the induction, we will add the output ports of some submodule of M to the execution.
0.639	[*A*]we[*R*]will add[*A*]the output ports of some submodule of M[*A*]to the execution[*A*]In each step of the induction	context()	negated: False ,passive: False
[LINE#167] The induction halts once we run out of submodules of M after imax|SM| steps.
0.523	[*A*]we[*R*]run[*A*]after imax|SM| steps	context()	negated: False ,passive: False
0.928	[*A*]The induction[*R*]halts[*A*]once we run out of submodules of M after imax|SM| steps	context()	negated: False ,passive: False
[LINE#168]  The induction hypothesis states for the execution.
[LINE#169+170+171+172+173+174]  Ei on the union of the input ports of M and the ports of a subset of its submodules thatits respective restrictions to submodules are feasible,its restriction to the input ports of M equals Ein,its restriction to output ports of M on [t-+F,t+) matches the restriction of Eout to such ports, andfor each submodule SSM whose execution ES is already fully specified by Ei , we have that ES restricted to [t-+FS,M,t+)[t-+F,t+)equals the corresponding restriction of E. Note that these properties together prove the theorem, since they show the claims we made on the properties of Eimax, and E and Ein are chosen arbitrarily (respecting the constraints imposed by the definition of forgetfulness).
0.910	[*A*]that ES[*R*]restricted[*A*]to [ t - +FS	context(we have)	negated: False ,passive: False
0.823	[*A*]Ei on the union of the input ports of the ports of a subset of its submodules thatits respective restrictions to submodules[*R*]are[*A*]feasible	context(we have)	negated: False ,passive: True
0.885	[*A*]Ei on the union of the input ports of M[*R*]are[*A*]feasible	context(its restriction to the input ports of M equals)	negated: False ,passive: True
0.804	[*A*]its restriction to the input ports of M[*R*]equals[*A*]Ein	context()	negated: False ,passive: True
0.910	[*A*]that ES[*R*]restricted[*A*]to [ t - +FS	context(we have)	negated: False ,passive: False
0.225	[*A*]we[*R*]have[*A*]that ES restricted to [ t - +FS	context()	negated: False ,passive: False
0.305	[*A*]its restriction[*R*]matches	context()	negated: False ,passive: False
[LINE#175+176+177]  We set E0:=Ein and anchor the induction at E0, trivially satisfying the induction hypothesis for i=0 and guaranteeing that all Ei restricted to the input ports of M that if any submodule is already covered by E0, it must not have any output port and due to non-emptiness the only possible (trivial)execution on the output ports is always feasible.
0.845	[*A*]anchor the induction at E0[*R*]trivially satisfying[*A*]the induction hypothesis[*A*]for guaranteeing that all Ei restricted to the input ports of M that if any submodule is already covered by E0 , it must not have any output due to non-emptiness	context()	negated: False ,passive: False
0.929	[*A*]any submodule[*R*]is covered[*A*]by E0[*A*]already	context()	negated: False ,passive: True
0.934	[*A*]anchor the induction at E0[*R*]trivially satisfying[*A*]the induction hypothesis for i=0	context()	negated: False ,passive: False
0.912	[*A*]the only possible ( trivial ) execution on the output ports[*R*]is[*A*]always[*A*]feasible	context()	negated: False ,passive: True
0.522	[*A*]We[*R*]set[*A*]E0	context()	negated: False ,passive: False
[LINE#178] Recall that the input ports of M cannot be output ports of its submodules.
[LINE#179] Any other ports of M and its submodules are output ports of a submodule, hence the final execution will indeed contain all ports and thus cover all submodules.
0.806	[*A*]Any other ports of its submodules[*R*]are[*A*]output ports of a submodule , hence the final execution will thus cover all submodules	context()	negated: False ,passive: True
0.806	[*A*]Any other ports of its submodules[*R*]are[*A*]output ports of a submodule , hence the final execution will indeed contain all ports	context()	negated: False ,passive: True
0.870	[*A*]the final execution[*R*]will cover[*A*]all submodules	context()	negated: False ,passive: True
0.964	[*A*]Any other ports of M[*R*]are[*A*]output ports of a submodule , hence the final execution will thus cover all submodules	context()	negated: False ,passive: True
0.870	[*A*]the final execution[*R*]will contain[*A*]all ports	context()	negated: False ,passive: False
0.964	[*A*]Any other ports of M[*R*]are[*A*]output ports of a submodule , hence the final execution will indeed contain all ports	context()	negated: False ,passive: True
[LINE#180] To perform the induction step, suppose we have already constructed Ei-1 for some i[1..imax].
0.386	[*A*]we[*R*]have constructed[*A*]Ei-1[*A*]for some i[1..imax[*A*]already	context()	negated: False ,passive: False
[LINE#181] By definition of imax, there is an uncovered submodule left, i.e., Ei-1 does not specify the execution on all ports of all submodules.
0.933	[*A*]Ei-1[*R*]does not specify[*A*]the execution on all ports of all submodules	context()	negated: True ,passive: False
[LINE#182] Because M is feedback-free, its circuit graph is acyclic.
0.476	[*A*]its circuit graph[*R*]is[*A*]acyclic	context()	negated: False ,passive: True
0.887	[*A*]M[*R*]is[*A*]feedback-free	context()	negated: False ,passive: True
[LINE#183] Consider the subgraph of the circuit graph induced by the remaining uncovered submodules.
0.911	[*A*]the circuit graph[*R*]induced[*A*]by the remaining uncovered submodules	context()	negated: False ,passive: True
[LINE#184] As it is acyclic as well, there must be a module S without an incoming edge, implying that Ei-1 specifies executions of all its input ports.
0.278	[*A*]it[*R*]is[*A*]acyclic[*A*]as well	context()	negated: False ,passive: True
[LINE#185]  By the induction hypothesis, we have that these executions restricted to [t-+FS,M-FS,t+) equal the respective restrictions of E:.
0.903	[*A*]these executions[*R*]restricted[*A*]to [t-+FS	context()	negated: False ,passive: True
0.367	[*A*]we[*R*]have[*A*]that these executions restricted to [t-+FS,M-FS,t+) equal the respective restrictions of E	context()	negated: False ,passive: False
[LINE#186+187]  Any such port is either an input port of M and therefore its executions in Ei-1 and E are identical on [t-,t+), or it is an output port of some module.
0.522	[*A*]it[*R*]is[*A*]an output port of some module	context()	negated: False ,passive: True
0.942	[*A*]Any such port[*R*]is[*A*]either an input port of M	context()	negated: False ,passive: True
[LINE#188+189]  S satisfying that there is some path (S1,,Sk-1and therefore the executions of the port in Ei-1 and E are identical on [t-+FS,M,t+)[t-+FS,M-FS,t+).
0.409	[*A*]S[*R*]satisfying[*A*]that there is some path	context()	negated: False ,passive: False
0.961	[*A*]the executions of the port in Ei - E[*R*]are[*A*]identical on [ t - +FS	context()	negated: False ,passive: True
0.571	[*A*]S[*R*]satisfying[*A*]that there is some path ( S1 ,, Sk - 1and therefore the executions of the port in Ei - 1 are identical on [ t - +FS , M , t+ ) [ t - +FS , M - FS , t+ )	context()	negated: False ,passive: False
[LINE#190] Since the output ports of S cannot be output ports of other modules and the input ports of M cannot be output ports of submodules, Ei-1 does not specify executions for any of the output ports of S.
0.926	[*A*]the output ports of S[*R*]can not be[*A*]output ports of the input ports of M	context()	negated: True ,passive: True
0.991	[*A*]1[*R*][number of] does not specify[*A*]executions for any of the output ports of S.	context()	negated: False ,passive: False
0.928	[*A*]Ei - 1[*R*]does not specify[*A*]executions for any of the output ports of S.	context()	negated: True ,passive: False
0.926	[*A*]the output ports of S[*R*]can not be[*A*]output ports of other modules	context()	negated: True ,passive: True
[LINE#191] We apply that S is FS-forgetful to the restriction of E to the ports of S on the interval [t-+FS,M-FS,t+) and the input execution given by the restriction of Ei-1 to the input ports of S, which is possible since we observed that the restrictions of these executions to the input ports of S on [t-+FS,M-FS,t+) are identical.
0.896	[*A*]the restrictions of these executions to the input ports of S on [ t - +FS[*R*]are[*A*]identical	context(we observed)	negated: False ,passive: True
0.317	[*A*]we[*R*]observed[*A*]that the restrictions of these executions to the input ports of S on [ t - +FS , M - FS , t+ ) are identical	context()	negated: False ,passive: False
0.817	[*A*]the input ports of[*R*]is[*A*]possible	context()	negated: False ,passive: True
0.952	[*A*]the input execution[*R*]given[*A*]by the restriction of Ei - 1 to the input ports of S	context()	negated: False ,passive: True
0.926	[*A*]S[*R*]is[*A*]FS - forgetful to the restriction of E to the ports of S on the interval the input execution	context()	negated: False ,passive: True
0.367	[*A*]We[*R*]apply[*A*]that S is FS - forgetful to the restriction of E to the ports of S on the interval the input execution	context()	negated: False ,passive: False
0.926	[*A*]S[*R*]is[*A*]FS - forgetful to the restriction of E to the ports of S on the interval [ t - +FS	context()	negated: False ,passive: True
0.367	[*A*]We[*R*]apply[*A*]that S is FS - forgetful to the restriction of E to the ports of S on the interval [ t - +FS	context()	negated: False ,passive: False
[LINE#192+193]  We obtain a feasible execution of S on R whose restriction to the input ports matches the restriction of Ei-1 to these ports and whose restriction to the output ports and[t-+FS,M,t+) matches the respective restriction of E.
0.498	[*A*]We[*R*]obtain[*A*]a feasible execution of S on R	context()	negated: False ,passive: False
[LINE#194] We define Ei by adding these executions of the output ports of S to Ei-1.
0.498	[*A*]We[*R*]define[*A*]Ei	context()	negated: False ,passive: False
[LINE#195] Overall, the first, second, and fourth claim of the induction hypothesis thus hold by construction.
0.833	[*A*]the fourth claim of the induction hypothesis[*R*]hold	context()	negated: False ,passive: False
0.833	[*A*]the second claim of the induction hypothesis[*R*]hold	context()	negated: False ,passive: False
0.833	[*A*]the first claim of the induction hypothesis[*R*]hold	context()	negated: False ,passive: False
[LINE#196] Taking into account that [t-+FS,M,t+)[t-+F,t+) and Eout is a restriction of E, the same holds for the third claim.
0.820	[*A*]t - +FS[*R*]is[*A*]a restriction of E	context(that [ t - +FS , M , t+ ) Eout is a restriction of E holds)	negated: False ,passive: True
0.977	[*A*]that [ t - +FS , M , t+ ) Eout is a restriction of E[*R*]holds[*A*]for the third claim	context()	negated: False ,passive: True
0.636	[*A*]the same[*R*]holds[*A*]for the third claim	context()	negated: False ,passive: True
[LINE#197] Hence the induction step succeeds, finishing the proof.
0.895	[*A*]the induction step[*R*]succeeds[*A*]finishing the proof	context()	negated: False ,passive: False
[LINE#198]  As a consequence, any feedback-free compound module will eventually "forget" about transient faults and behave according to some fault-free history.
0.930	[*A*]any feedback - free compound module[*R*]will forget[*A*]about transient faults[*A*]eventually	context()	negated: False ,passive: False
[LINE#199] Note that in general that does not mean that if the module's execution is feasible on two separate intervals there is any guaranteed relation between the behavior on these intervals, as arbitrary transient faults result in arbitrary modifications of the module's state.
0.937	[*A*]the module's execution[*R*]is[*A*]feasible on two separate intervals	context()	negated: False ,passive: True
0.911	[*A*]arbitrary transient faults[*R*]result[*A*]in arbitrary modifications of the module's state	context()	negated: False ,passive: True
[LINE#200] However, we can assume that such a module, once it becomes non-faulty and thus follows its specification, eventually behaves correctly in the strong sense given by the specification of its corresponding idealized basic module.
0.866	[*A*]such a module[*R*]behaves[*A*]correctly[*A*]in the strong sense[*A*]once it thus follows its specification[*A*]eventually	context(we can assume)	negated: False ,passive: False
0.168	[*A*]we[*R*]can assume[*A*]that such a module , once it thus follows its specification , eventually behaves correctly in the strong sense	context()	negated: False ,passive: False
0.274	[*A*]it[*R*]follows[*A*]its specification	context()	negated: False ,passive: False
0.866	[*A*]such a module[*R*]behaves[*A*]correctly[*A*]in the strong sense[*A*]once it becomes non-faulty[*A*]eventually	context(we can assume)	negated: False ,passive: False
0.168	[*A*]we[*R*]can assume[*A*]that such a module , once it becomes non-faulty , eventually behaves correctly in the strong sense	context()	negated: False ,passive: False
0.848	[*A*]the strong sense[*R*]given[*A*]by the specification of its corresponding idealized basic module	context()	negated: False ,passive: True
0.225	[*A*]it[*R*]becomes[*A*]non-faulty	context()	negated: False ,passive: True
[LINE#201] The bad news is that we have to introduce feedback-loops into the system at some point: After all, any clock source is some kind of oscillator.
0.769	[*A*]The bad news[*R*]is[*A*]that we have to introduce feedback-loops into the system at some point	context(any clock source is)	negated: False ,passive: True
0.913	[*A*]any clock source[*R*]is[*A*]some kind of oscillator	context()	negated: False ,passive: True
0.411	[*A*]we[*R*]to introduce[*A*]feedback-loops[*A*]into the system[*A*]at some point	context()	negated: False ,passive: False
[LINE#202] As demonstrated by Osc, we cannot expect a strong generic result like Theorem 3.7 for compound modules that are not feedback-free.
0.887	[*A*]compound modules[*R*]are not[*A*]feedback-free	context()	negated: True ,passive: True
0.614	[*A*]we[*R*]can not expect[*A*]a strong generic result like Theorem 3.7 for compound modules	context()	negated: True ,passive: False
[LINE#203] Also, clearly such a structure cannot be forgetful.
0.783	[*A*]such a structure[*R*]can not be[*A*]forgetful	context()	negated: True ,passive: True
[LINE#204] Hence, let us turn to a less restrictive concept of recovery from transient faults.
[LINE#205] -stabilization is the property of a system to recover from arbitrary transient faults in finite time, provided that all transient faults cease.
0.819	[*A*]-stabilization[*R*]is[*A*]the property of a system[*A*]provided that all transient faults cease	context()	negated: False ,passive: True
[LINE#206] Since arbitrary transient faults may result in arbitrary states, this requirement can be rephrased as the need to reach a valid state within finite time from any initial state.
0.903	[*A*]this requirement[*R*]can be rephrased[*A*]as the need	context()	negated: False ,passive: True
0.911	[*A*]arbitrary transient faults[*R*]may result[*A*]in arbitrary states	context()	negated: False ,passive: True
[LINE#207] For basic modules, our framework encapsulates this concept by the notion of feasibility; executions completely hide the internal state of a basic module, and we assume (or hope) that the utilized implementation of the module will recover from faults that are considered transient, e.g. particle hits, crosstalk, magnetic fields, or power outages.
0.932	[*A*]the utilized implementation of the module[*R*]will recover[*A*]from faults	context()	negated: False ,passive: True
0.195	[*A*]we[*R*]assume	context()	negated: False ,passive: False
0.576	[*A*]our framework[*R*]encapsulates[*A*]this concept	context(executions hide)	negated: False ,passive: False
0.846	[*A*]executions[*R*]hide[*A*]the internal state of a basic module	context()	negated: False ,passive: False
[LINE#208] For compound modules, one possible meaning of "valid state" in our context is given by the specification of the corresponding idealized basic module: If, viewed from the outside, the execution is indistinguishable from one that could occur if the module was entirely fault-free, we can safely assume that its state is valid; any fault that is masked is irrelevant to the higher layers of the system anyway, as it solely relies on the guarantees of the utilized model specification on the module's ports' executions.
0.503	[*A*]one[*R*]could occur[*A*]if the module was entirely fault-free	context()	negated: False ,passive: True
0.698	[*A*]any fault[*R*]is masked	context()	negated: False ,passive: False
0.813	[*A*]the execution[*R*]is[*A*]indistinguishable from one	context()	negated: False ,passive: True
0.388	[*A*]its state[*R*]is[*A*]valid	context(we can safely assume any fault that is masked is)	negated: False ,passive: True
0.112	[*A*]we[*R*]can safely assume[*A*]that its state is valid	context(any fault that is masked is)	negated: False ,passive: False
0.917	[*A*]any fault that is masked[*R*]is[*A*]irrelevant to the higher layers of the system[*A*]anyway[*A*]as it solely relies on the guarantees of the utilized model specification on the module's ports' executions	context()	negated: False ,passive: True
0.569	[*A*]it[*R*]solely relies[*A*]on the guarantees of the utilized model specification on the module's ports' executions	context()	negated: False ,passive: False
0.925	[*A*]the module[*R*]was[*A*]entirely fault-free	context()	negated: False ,passive: True
0.808	[*A*]one possible meaning of "valid state" in our context[*R*]is given[*A*]by the specification of the corresponding idealized basic module	context()	negated: False ,passive: True
[LINE#209] A more general concretization of the same underlying idea is the notion of self-stabilization we present next.
0.225	[*A*]we[*R*]present[*A*]next	context()	negated: False ,passive: False
0.930	[*A*]A more general concretization of the same underlying idea[*R*]is[*A*]the notion of self-stabilization we present next	context()	negated: False ,passive: True
[LINE#210] It introduces two relaxations of the constraints on the behavior of a module.
0.569	[*A*]It[*R*]introduces[*A*]two relaxations of the constraints on the behavior of a module	context()	negated: False ,passive: False
[LINE#211] Firstly, we do not expect that the recovering module is perceived as functional by an outsider immediately after its execution becomes feasible.
0.888	[*A*]the recovering module[*R*]is perceived[*A*]as functional[*A*]by an outsider	context(we do not expect)	negated: False ,passive: True
0.168	[*A*]we[*R*]do not expect[*A*]that the recovering module is perceived as functional by an outsider immediately after its execution becomes feasible	context()	negated: True ,passive: False
[LINE#212] Rather, we allow for some stabilization time during which the module can "clean up" its internal state.
0.831	[*A*]the module[*R*]can clean up[*A*]its internal state[*A*]some stabilization time	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]allow[*A*]for some stabilization time	context()	negated: False ,passive: False
[LINE#213] Secondly, we do not require that the module fulfills its corresponding idealized basic module specification.
0.796	[*A*]the module[*R*]fulfills[*A*]its corresponding idealized basic module specification	context(we do not require)	negated: False ,passive: False
0.168	[*A*]we[*R*]do not require[*A*]that the module fulfills its corresponding idealized basic module specification	context()	negated: True ,passive: False
[LINE#214] Instead, we choose another, weaker specification that is sufficient for our purposes.
0.850	[*A*]weaker specification[*R*]is[*A*]sufficient for our purposes	context()	negated: False ,passive: True
0.225	[*A*]we[*R*]choose[*A*]another	context()	negated: False ,passive: False
[LINE#215] One specification being stronger than another is captured by the following notion.
0.767	[*A*]One specification[*R*]being[*A*]stronger than another	context()	negated: False ,passive: True
[LINE#216+217]  We define that module M implements module M iffboth modules have the same sets of input and output ports and M(Ein)M(Ein) for all Ein.
0.959	[*A*]module M iffboth modules[*R*]have[*A*]the same sets of M ( Ein ) M ( Ein ) for all Ein	context(We define M implements)	negated: False ,passive: False
0.901	[*A*]M[*R*]implements[*A*]module M iffboth modules have the same sets of M ( Ein ) M ( Ein ) for all Ein	context(We define)	negated: False ,passive: False
0.937	[*A*]module M iffboth modules[*R*]have[*A*]the same sets of output ports for all Ein	context(We define M implements)	negated: False ,passive: False
0.901	[*A*]M[*R*]implements[*A*]module M iffboth modules have the same sets of output ports for all Ein	context(We define)	negated: False ,passive: False
0.937	[*A*]module M iffboth modules[*R*]have[*A*]the same sets of input for all Ein	context(M implements)	negated: False ,passive: False
0.901	[*A*]M[*R*]implements[*A*]module M iffboth modules have the same sets of input for all Ein	context()	negated: False ,passive: False
0.231	[*A*]We[*R*]define[*A*]that module	context()	negated: False ,passive: False
[LINE#218+219+220+221]  in the sense that it imposes at least as many constraints on the output executions as M. For TR0 +, module M now is a T-stabilizing implementation of module M, iff the restriction of each feasible execution of M on [t-,t+)R to [t-+T,t+) is a feasible execution of M. Clearly, for T>0, this allows for M(Ein)M(Ein), i.e., a T-stabilizing implementation of M needs not be an implementation of M.
0.932	[*A*]-,t+)R to [t-+T,t+[*R*]is[*A*]a feasible execution of M. Clearly	context(this allows)	negated: False ,passive: True
0.372	[*A*]this[*R*]allows[*A*]for M	context()	negated: False ,passive: False
0.954	[*A*]a T-stabilizing implementation of M[*R*]not be[*A*]an implementation of M.	context()	negated: True ,passive: True
0.195	[*A*]it[*R*]imposes	context()	negated: False ,passive: False
[LINE#222] For brevity, we may say that "M is T-stabilizing" to express that M is a T-stabilizing implementation of its corresponding idealized basic module.
0.842	[*A*]M[*R*]is[*A*]T-stabilizing	context(we may say)	negated: False ,passive: True
0.195	[*A*]we[*R*]may say[*A*]that "M is T-stabilizing" to express that M is a T-stabilizing implementation of its corresponding idealized basic module	context()	negated: False ,passive: False
[LINE#223+224]  We simply say M is a self-stabilizing (implementation of M)it is a T-stabilizing (implementation of M) for some TR0+.From our previous definitions and results, we immediately can derive the following statements.
0.879	[*A*]M[*R*]is[*A*]a self - stabilizing ( implementation of M	context(We say it is we can derive)	negated: False ,passive: True
0.508	[*A*]We[*R*]say[*A*]M is a self - stabilizing ( implementation of M	context(it is we can derive)	negated: False ,passive: False
0.503	[*A*]it[*R*]is[*A*]a T - stabilizing ( implementation of M	context(we can derive)	negated: False ,passive: True
0.879	[*A*]M[*R*]is[*A*]a self - stabilizing ( implementation of M	context(We say it is we can derive)	negated: False ,passive: True
0.508	[*A*]We[*R*]say[*A*]M is a self - stabilizing ( implementation of M	context(it is we can derive)	negated: False ,passive: False
0.503	[*A*]it[*R*]is[*A*]a T - stabilizing ( implementation of M	context(we can derive)	negated: False ,passive: True
0.489	[*A*]we[*R*]can derive[*A*]the following statements[*A*]immediately	context()	negated: False ,passive: False
[LINE#225]  Lemma 3.81.Every F-forgetful module is.
0.879	[*A*]Lemma 3.81.Every F-forgetful module[*R*]is	context()	negated: False ,passive: False
[LINE#226] F-stabilizing.2.Every feedback-free compound module is self-stabilizing.3.If M is a self-stabilizing implementation of M and M is extendable, then M is an implementation of M.4.Every feedback-free compound module whose specification is extendable implements its corresponding idealized basic module.
0.950	[*A*]self-stabilizing.3.If M[*R*]is[*A*]a self-stabilizing implementation of M	context(F - stabilizing.2.Every feedback - free compound module is M is)	negated: False ,passive: True
0.978	[*A*]F-stabilizing.2.Every feedback-free compound module[*R*]is[*A*]self-stabilizing.3.If M is a self-stabilizing implementation of M	context(M is)	negated: False ,passive: True
0.879	[*A*]M[*R*]is[*A*]an implementation of M.4.Every feedback-free compound module	context()	negated: False ,passive: True
0.919	[*A*]M.4.Every feedback-free compound module[*R*]is[*A*]extendable implements its corresponding idealized basic module	context()	negated: False ,passive: True
0.734	[*A*]M[*R*]is[*A*]extendable	context()	negated: False ,passive: True
[LINE#227] ProofThe first statement follows directly from the definition of F-forgetfulness.
0.925	[*A*]ProofThe first statement[*R*]follows directly[*A*]from the definition of F-forgetfulness	context()	negated: False ,passive: True
[LINE#228] The second statement follows from Theorem 3.7 and the first statement.
0.911	[*A*]The second statement[*R*]follows[*A*]from the first statement	context()	negated: False ,passive: True
0.925	[*A*]The second statement[*R*]follows[*A*]from Theorem 3.7	context()	negated: False ,passive: True
[LINE#229+230]  Regarding the third statement, by extendability every feasible execution of M on some interval IR is the restriction of a feasible execution E of M on R. By the definition of self-stabilizing implementations, there is some TR0 such that E restricted to (-+T,)=R.
0.840	[*A*]E[*R*]restricted[*A*]to (-+T	context()	negated: False ,passive: True
[LINE#231] By properness, restricting E to I yields a feasible execution of M.
0.720	[*A*]restricting E to I[*R*]yields[*A*]a feasible execution of M.	context()	negated: False ,passive: False
[LINE#232] Since this restriction equals the original feasible execution of M, it follows that every feasible execution of M is a feasible execution of M.
0.918	[*A*]this restriction[*R*]equals[*A*]the original feasible execution of M	context()	negated: False ,passive: True
[LINE#233] The last statement follows from the second and third.
0.783	[*A*]The last statement[*R*]follows[*A*]from the third	context()	negated: False ,passive: True
0.783	[*A*]The last statement[*R*]follows[*A*]from the second	context()	negated: False ,passive: True
[LINE#234] from Example 3.5 behaves like a fixed-delay channel with delay 2d.
[LINE#235] As InvChain is feedback-free and its specification is extendable, we could also infer this statement directly from Lemma 3.8.
0.388	[*A*]its specification[*R*]is[*A*]extendable	context(we could infer directly)	negated: False ,passive: True
0.393	[*A*]we[*R*]could infer directly[*A*]from Lemma 3.8	context()	negated: False ,passive: False
0.938	[*A*]InvChain[*R*]is[*A*]feedback - free	context()	negated: False ,passive: True
[LINE#236+237]  In contrast, Osc is not self-stabilizing at all, i.e., it is not self-stabilizing for any TR0+, which follows from the same arguments that we used to show that its specification is not extendable.
0.332	[*A*]its specification[*R*]is not[*A*]extendable	context(we to show)	negated: True ,passive: True
0.100	[*A*]we[*R*]to show[*A*]that its specification is not extendable	context()	negated: False ,passive: False
0.914	[*A*]any TR0+[*R*]follows[*A*]from the same arguments	context()	negated: False ,passive: True
[LINE#238]  In general, determining whether a module.
[LINE#239+240]  M is a self-stabilizing implementation of some other module M (or even bounding the stabilization time)requires a detailed stabilization analysis.
0.894	[*A*]even bounding the stabilization time[*R*]requires[*A*]a detailed stabilization analysis	context(M is)	negated: False ,passive: False
0.924	[*A*]M[*R*]is[*A*]a self-stabilizing implementation of some other module M	context()	negated: False ,passive: True
[LINE#241] One may as well generalize the above definition to also account for probabilistic stabilization by defining an appropriate probability space on the set of executions of M. For the sake of brevity and better readability, we only informally state the probability space in this work by introducing basic modules that act in a probabilistic manner, namely the Randomized Watchdog Timers.
0.375	[*A*]One[*R*]may generalize[*A*]the above definition	context(we only informally state)	negated: False ,passive: False
0.375	[*A*]One[*R*]may generalize[*A*]the above definition	context(we only informally state)	negated: False ,passive: False
0.388	[*A*]we[*R*]only informally state[*A*]the probability space in this work	context()	negated: False ,passive: False
0.870	[*A*]the above definition[*R*]to account[*A*]for probabilistic stabilization	context()	negated: False ,passive: False
0.754	[*A*]basic modules[*R*]act	context()	negated: False ,passive: False
[LINE#242] Probabilistic bounds on the stabilization time of compound implementations then are naturally derived from the respective distributions of their submodules.
0.916	[*A*]Probabilistic bounds on the stabilization time of compound implementations then[*R*]are naturally derived[*A*]from the respective distributions of their submodules	context()	negated: False ,passive: True
[LINE#243] The interested reader is referred to [13], where we give a precise definition of the probability space over which our probabilistic stabilization guarantees are expressed. .
0.993	[*A*]The interested reader[*R*]is referred to[*A*]over 13	context()	negated: False ,passive: False
0.761	[*A*]our probabilistic stabilization guarantees[*R*]are expressed[*A*]the probability space	context()	negated: False ,passive: True
0.452	[*A*]we[*R*]give[*A*]a precise definition of the probability space	context()	negated: False ,passive: False
0.783	[*A*]The interested reader[*R*]is referred[*A*]to [13	context()	negated: False ,passive: True
[LINE#244] Persistent faultsWe next generalize the definition of feasibility for compound modules to potentially faulty submodules.
0.950	[*A*]Persistent faultsWe[*R*]generalize[*A*]the definition of feasibility for compound modules[*A*]next	context()	negated: False ,passive: False
[LINE#245] For a compound module M and f0, we define the corresponding f-faulty basic module f(M) as follows: f(M)'s input and output ports are the input and output ports of M.
[LINE#246] Let E be any execution of M on IR and denote by Ein and Eout its restrictions to the input and output ports of M, respectively.
[LINE#247+248]  Then Eoutf(M)(Ein), iff there exists an execution EM,SM of all ports of modules in {M}SM and a subset F of SM of size at most f, such that, for each module S in SMF, the restriction of execution EM,SM to the ports of S is feasible, and EM ,SM restricted to M's input and output ports is equal to.
0.877	[*A*]SM[*R*]restricted[*A*]to M 's output ports	context()	negated: False ,passive: False
0.877	[*A*]SM[*R*]restricted[*A*]to M 's input ports	context()	negated: False ,passive: False
[LINE#249] E. As in the fault-free case, we require that f(M) fulfills non-emptiness.
0.793	[*A*]f[*R*]fulfills[*A*]non-emptiness	context(we require)	negated: False ,passive: False
0.332	[*A*]we[*R*]require[*A*]that f(M) fulfills non-emptiness[*A*]As in the fault-free case	context()	negated: False ,passive: False
[LINE#250+251]  For compound module M and f0, we say an execution E of M is f-faulty feasible iffit is feasible for the corresponding f-faulty basic module f(M).
0.859	[*A*]an execution E of M[*R*]is[*A*]f	context(we say faulty feasible iffit is)	negated: False ,passive: True
0.787	[*A*]faulty feasible iffit[*R*]is[*A*]feasible	context(we say)	negated: False ,passive: True
0.686	[*A*]we[*R*]say[*A*]an execution E of M is f - faulty feasible iffit is feasible for the corresponding f[*A*]For f0	context()	negated: False ,passive: False
0.859	[*A*]an execution E of M[*R*]is[*A*]f	context(we say faulty feasible iffit is)	negated: False ,passive: True
0.787	[*A*]faulty feasible iffit[*R*]is[*A*]feasible	context(we say)	negated: False ,passive: True
0.686	[*A*]we[*R*]say[*A*]an execution E of M is f - faulty feasible iffit is feasible for the corresponding f - faulty basic module f ( M[*A*]For compound module M	context()	negated: False ,passive: False
[LINE#252]  Modules whose behavior is unrestricted in execution E (i.e., that belong to the set F) are called faulty (in execution E).Clearly, a compound module M cannot mask faults of submodules that have an output port that is also output port of.
0.723	[*A*]submodules[*R*]have[*A*]an output port that is also output port of	context()	negated: False ,passive: False
0.919	[*A*]a compound module M[*R*]can not mask[*A*]faults of submodules	context()	negated: True ,passive: False
0.934	[*A*]execution E[*R*]are called[*A*]faulty[*A*]Modules whose behavior is unrestricted in	context()	negated: False ,passive: True
0.920	[*A*]an output port[*R*]is[*A*]also[*A*]output port of	context()	negated: False ,passive: True
[LINE#253] M. Consequently, tolerance of ongoing faults necessitates to weaken the constraints on M's output.
[LINE#254+255]  Hence, for f0, compound module M, and some other module M with the same set of input and output ports, we say that M is an f-tolerant implementation of M iffevery f-faulty feasible execution of M is a feasible execution of M, i.e., the corresponding f-faulty basic module of M implements M. Analogously, M is an f-tolerant T-stabilizing implementation of M iff its corresponding f-faulty basic module is a T-stabilizing implementation of M.Note that this entails that the union of output ports of any set consisting of f submodules of M can be arbitrary.
0.799	[*A*]the union of output ports of any set[*R*]can be[*A*]arbitrary	context(this entails)	negated: False ,passive: True
0.963	[*A*]f - faulty feasible execution of M[*R*]is[*A*]a feasible execution of M	context(M is)	negated: False ,passive: True
0.927	[*A*]faulty basic module[*R*]is[*A*]a T - stabilizing implementation of M.Note	context(we say)	negated: False ,passive: True
0.903	[*A*]any set[*R*]consisting[*A*]of f submodules of M	context()	negated: False ,passive: True
0.799	[*A*]the union of output ports of any set[*R*]can be[*A*]arbitrary	context(this entails)	negated: False ,passive: True
0.224	[*A*]this[*R*]entails[*A*]that the union of output ports of any set consisting of f submodules of M can be arbitrary	context()	negated: False ,passive: False
0.963	[*A*]f - faulty feasible execution of M[*R*]is[*A*]a feasible execution of M	context(M is)	negated: False ,passive: True
0.883	[*A*]M[*R*]is[*A*]an f - tolerant implementation of M iffevery	context()	negated: False ,passive: True
0.927	[*A*]faulty basic module[*R*]is[*A*]a T - stabilizing implementation of M.Note	context(we say)	negated: False ,passive: True
0.356	[*A*]we[*R*]say[*A*]i.e. , the corresponding f - faulty basic module of M implements M. Analogously , M is an f - tolerant T - stabilizing implementation of M iff its corresponding f - faulty basic module is a T - stabilizing implementation of M.Note	context()	negated: False ,passive: False
[LINE#256] The module specification of M thus must not put concurrent restrictions on all its output ports to allow for fault-tolerance.
0.886	[*A*]The module specification of M[*R*]must not put[*A*]concurrent restrictions[*A*]on all its output ports[*A*]to allow for fault-tolerance	context()	negated: True ,passive: False
[LINE#257] Hence, one demands constraints on the outputs of non-faulty submodules of M (i.e., those whose executions are feasible) only.
0.084	[*A*]those[*R*]are[*A*]feasible	context()	negated: False ,passive: True
0.590	[*A*]one[*R*]demands[*A*]constraints on the outputs of non-faulty submodules of M	context()	negated: False ,passive: False
[LINE#258] We present the first implementation of a distributed clock generation scheme for Systems-on-Chip that recovers from an unbounded number of arbitrary transient faults despite a large number of arbitrary permanent faults.
0.614	[*A*]We[*R*]present[*A*]the first implementation of a distributed clock generation scheme for Systems-on-Chip	context()	negated: False ,passive: False
[LINE#259] We devise self-stabilizing hardware building blocks and a hybrid synchronous/asynchronous state machine enabling metastability-free transitions of the algorithm's states.
0.938	[*A*]a hybrid synchronous / asynchronous state machine[*R*]enabling[*A*]metastability - free transitions of the algorithm 's states	context()	negated: False ,passive: False
0.569	[*A*]We[*R*]devise[*A*]a hybrid synchronous / asynchronous state machine enabling metastability - free transitions of the algorithm 's states	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]devise[*A*]self - stabilizing hardware building blocks	context()	negated: False ,passive: False
[LINE#260] We provide a comprehensive modeling approach that permits to prove, given correctness of the constructed low-level building blocks, the high-level properties of the synchronization algorithm (which have been established in a more abstract model).
0.948	[*A*]a comprehensive modeling approach that permits to prove,[*R*]given[*A*]correctness of the constructed low-level building blocks	context()	negated: False ,passive: False
0.939	[*A*]the high-level properties of the synchronization algorithm[*R*]have been established[*A*]in a more abstract model	context()	negated: False ,passive: True
0.326	[*A*]We[*R*]provide[*A*]a comprehensive modeling approach that permits to prove, given correctness of the constructed low-level building blocks,	context()	negated: False ,passive: False
[LINE#261] We believe this approach to be of interest in its own right, since this is the first technique permitting to mathematically verify, at manageable complexity, high-level properties of a fault-prone system in terms of its very basic components.
0.796	[*A*]this approach[*R*]to be[*A*]of interest in its own right[*A*]since this is the first technique	context(We believe)	negated: False ,passive: True
0.356	[*A*]We[*R*]believe[*A*]this approach to be of interest in its own right[*A*]since this is the first technique	context()	negated: False ,passive: False
0.943	[*A*]the first technique[*R*]permitting[*A*]to mathematically verify, at manageable complexity, high-level properties of a fault-prone system	context()	negated: False ,passive: False
0.415	[*A*]this[*R*]is[*A*]the first technique permitting to mathematically verify, at manageable complexity, high-level properties of a fault-prone system in terms of its very basic components	context()	negated: False ,passive: True
[LINE#262] We evaluate a prototype implementation, which has been designed in VHDL, using the Petrify tool in conjunction with some extensions, and synthesized for an Altera Cyclone FPGA.
0.498	[*A*]We[*R*]synthesized[*A*]for an Altera Cyclone FPGA	context()	negated: False ,passive: False
0.913	[*A*]a prototype implementation[*R*]has been designed[*A*]in VHDL[*A*]using the Petrify tool in conjunction with some extensions	context()	negated: False ,passive: True
0.614	[*A*]We[*R*]evaluate[*A*]a prototype implementation , which has been designed in VHDL ,	context()	negated: False ,passive: False
[LINE#263] In this case, the module specification is a function M that, for all I, maps every execution of the module's input ports on I to a set of executions of the module's output ports on I.
0.446	[*A*]I[*R*]maps[*A*]every execution of the module's input ports on I	context()	negated: False ,passive: False
0.960	[*A*]the module specification[*R*]is[*A*]a function[*A*]In this case	context()	negated: False ,passive: True
[LINE#264] The intended meaning of M is to map each and every conceivable execution of M's input ports on I to the resulting possible reactions of M during the same time, which may be many different ones.
0.958	[*A*]the resulting possible reactions of M during[*R*]may be[*A*]many different ones[*A*]the same time	context()	negated: False ,passive: True
0.959	[*A*]The intended meaning of M[*R*]is[*A*]to map every conceivable execution of M 's input ports on I to the resulting possible reactions of M during the same time	context()	negated: False ,passive: True
0.888	[*A*]The intended meaning of M[*R*]is[*A*]to map each	context()	negated: False ,passive: True
[LINE#265] For example, a module that may behave arbitrarily for some input execution Ein is specified by setting M(Ein) to be the set of all conceivable output executions.
0.833	[*A*]M[*R*]to be[*A*]the set of all conceivable output executions	context()	negated: False ,passive: True
0.899	[*A*]a module that may behave arbitrarily for some input execution Ein[*R*]is specified	context()	negated: False ,passive: False
0.887	[*A*]a module[*R*]may behave[*A*]arbitrarily[*A*]for some input execution	context()	negated: False ,passive: False
[LINE#266]  M we say that execution E of M on some.
0.551	[*A*]we[*R*]say[*A*]M	context()	negated: False ,passive: False
[LINE#267] I is feasible iff EoutM(Ein), where Ein and Eout are the restrictions of execution E to M's input and output ports, respectively.
0.975	[*A*]Eout[*R*]are[*A*]the restrictions of execution E to M 's output ports[*A*]EoutM	context()	negated: False ,passive: True
0.678	[*A*]I[*R*]is[*A*]feasible[*A*]iff EoutM ( Ein ) , where Eout are the restrictions of execution E to M 's output ports , respectively	context()	negated: False ,passive: True
0.975	[*A*]Eout[*R*]are[*A*]the restrictions of execution E to M 's input ports[*A*]EoutM	context()	negated: False ,passive: True
0.678	[*A*]I[*R*]is[*A*]feasible[*A*]iff EoutM ( Ein ) , where Eout are the restrictions of execution E to M 's input ports , respectively	context()	negated: False ,passive: True
0.975	[*A*]Ein[*R*]are[*A*]the restrictions of execution E to M 's output ports[*A*]EoutM	context()	negated: False ,passive: True
0.678	[*A*]I[*R*]is[*A*]feasible[*A*]iff EoutM ( Ein ) , where Ein are the restrictions of execution E to M 's output ports , respectively	context()	negated: False ,passive: True
0.975	[*A*]Ein[*R*]are[*A*]the restrictions of execution E to M 's input ports[*A*]EoutM	context()	negated: False ,passive: True
0.678	[*A*]I[*R*]is[*A*]feasible[*A*]iff EoutM ( Ein ) , where Ein are the restrictions of execution E to M 's input ports , respectively	context()	negated: False ,passive: True
[LINE#268+269]  We require two properties for M to hold:(i)Non-emptiness : (Ein) for all executions Ein of M's input ports.(ii)Properness:.
0.944	[*A*]two properties[*R*]to hold[*A*]M	context()	negated: False ,passive: True
0.498	[*A*]We[*R*]require[*A*]two properties for M to hold	context()	negated: False ,passive: False
[LINE#270] Any restriction (in time) of a feasible execution of M is feasible.
0.939	[*A*]Any restriction (in time) of a feasible execution of M[*R*]is[*A*]feasible	context()	negated: False ,passive: True
[LINE#271] These properties are motivated by the facts that (i) any given input of a correctly operating module will produce some output and (ii) correct operation on a given time interval implies correct operation on any subinterval of this interval.
0.868	[*A*]These properties[*R*]will produce[*A*]correct operation[*A*]on a given time interval	context()	negated: False ,passive: False
0.887	[*A*]These properties[*R*]will produce[*A*]some output	context()	negated: False ,passive: False
0.913	[*A*]the facts[*R*](i)[*A*]any given input of a correctly operating module	context()	negated: False ,passive: False
[LINE#272+273+274]  Example 3.1A simple basic module is a (zero-time) inverter with (binary) i, (binary) output port o, and module specification Inv defined by: For each interval IR and each execution Ein of input port i, an execution Eout of output port o on I is in Inv(Ein) iff for all tI.
0.955	[*A*]3.1A simple basic module[*R*]is[*A*]a ( zero - time ) inverter with ( binary ) i , ( binary ) output module specification Inv defined by : IR and each execution Ein of input port i , an execution Eout of output port o on I is in Inv ( Ein ) iff	context()	negated: False ,passive: True
0.868	[*A*]binary ) output module specification Inv[*R*]defined[*A*]by	context()	negated: False ,passive: True
0.947	[*A*]3.1A simple basic module[*R*]is[*A*]a ( zero - time ) inverter with ( binary ) i	context()	negated: False ,passive: True
0.955	[*A*]3.1A simple basic module[*R*]is[*A*]a ( zero - time ) inverter with ( binary ) i , ( binary ) output port o IR and each execution Ein of input port i , an execution Eout of output port o on I is in Inv ( Ein ) iff for all tI	context()	negated: False ,passive: True
0.568	[*A*]I[*R*]is[*A*]in Inv	context()	negated: False ,passive: True
0.955	[*A*]3.1A simple basic module[*R*]is[*A*]a ( zero - time ) inverter with ( binary ) i , ( binary ) output port o For each interval and each execution Ein of input port i , an execution Eout of output port o on I is in Inv ( Ein ) iff for all tI	context()	negated: False ,passive: True
[LINE#275] Example 3.2As an example of a timed basic module, consider a fixed-delay channel with input port i, output port o, and delay d>0.
0.802	[*A*]Example[*R*]3.2As[*A*]an > 0	context()	negated: False ,passive: False
0.934	[*A*]Example[*R*]3.2As[*A*]an example of a timed basic module , consider a fixed - delay channel with	context(input port i o)	negated: False ,passive: False
0.757	[*A*]input port i[*R*]o[*A*]0	context()	negated: False ,passive: False
[LINE#276+277+278]  Its module specification C is defined by: For each interval [t-,t+)R and each execution Ein of input port i on [t-,t+), an execution Eout of output port o on I is in C(Ein)we have that o(t)=i(t-d).Clearly, a basic module needs to adhere to M only on intervals I during which it is correct, and may behave arbitrarily when it is faulty.
0.905	[*A*]a basic module[*R*]needs to adhere[*A*]to M[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.868	[*A*]a basic module[*R*]needs to adhere[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.162	[*A*]we[*R*]have	context(an execution Eout of output port is)	negated: False ,passive: False
0.631	[*A*]Its module specification C[*R*]is defined[*A*]by : For each interval [ t	context(an execution Eout of output port is)	negated: False ,passive: True
0.937	[*A*]an execution Eout of output port[*R*]is[*A*]in C	context()	negated: False ,passive: True
0.905	[*A*]a basic module[*R*]needs to adhere[*A*]to M[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.691	[*A*]Its module specification C[*R*]is defined[*A*]by : For each interval [ t - each execution [ t - , t+ ) , an execution Eout of output port o on I is in C	context()	negated: False ,passive: True
0.868	[*A*]a basic module[*R*]needs to adhere[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.838	[*A*]a basic module[*R*]needs[*A*]to adhere to M only on intervals I	context()	negated: False ,passive: False
0.825	[*A*]a basic module[*R*]may behave[*A*]arbitrarily[*A*]when it is faulty	context()	negated: False ,passive: False
0.681	[*A*]Its module specification C[*R*]is defined[*A*]by : For each interval [ t	context()	negated: False ,passive: True
0.278	[*A*]it[*R*]is[*A*]correct	context()	negated: False ,passive: True
0.905	[*A*]a basic module[*R*]needs to adhere[*A*]to M[*A*]only on intervals	context(a basic module needs)	negated: False ,passive: False
0.905	[*A*]a basic module[*R*]needs[*A*]to adhere to M only on intervals	context()	negated: False ,passive: False
0.278	[*A*]it[*R*]is[*A*]faulty	context()	negated: False ,passive: True
0.568	[*A*]I[*R*]is[*A*]in C	context()	negated: False ,passive: True
0.274	[*A*]I[*R*]may behave[*A*]arbitrarily[*A*]when it is faulty	context()	negated: False ,passive: False
0.691	[*A*]Its module specification C[*R*]is defined[*A*]by : For each interval [ t - , t+ ) R [ t - , t+ ) , an execution Eout of output port o on I is in C	context()	negated: False ,passive: True
[LINE#279] Subtle issues originate in the fact that a module may become correct after an earlier (transient) fault, in the sense that its internal components work as intended afterwards.
0.903	[*A*]a module[*R*]may become[*A*]correct[*A*]after an earlier (transient) fault	context()	negated: False ,passive: True
0.845	[*A*]Subtle issues[*R*]originate[*A*]in the fact that a module may become correct after an earlier (transient) fault, in the sense	context()	negated: False ,passive: True
[LINE#280] At this point in time, it may or may not be the case that all traces of the transient fault have been vanished from the internal state of the module.
0.932	[*A*]all traces of the transient fault[*R*]have been vanished[*A*]from the internal state of the module	context()	negated: False ,passive: True
0.422	[*A*]it[*R*]may not be[*A*]the case that all traces of the transient fault have been vanished from the internal state of the module[*A*]At this point in time	context()	negated: True ,passive: True
[LINE#281] The typical use of basic modules is the description of a (sub)problem.
0.948	[*A*]The typical use of basic modules[*R*]is[*A*]the description of a (sub)problem	context()	negated: False ,passive: True
[LINE#282] For instance, the module specification of a threshold module will be such that the output is required to indicate whether a certain number of binary input ports is in state 1.
0.941	[*A*]a certain number of binary input ports[*R*]is[*A*]in state 1	context(the output to indicate)	negated: False ,passive: True
0.910	[*A*]the output[*R*]to indicate[*A*]whether a certain number of binary input ports is in state 1	context()	negated: False ,passive: False
0.937	[*A*]the output[*R*]is required[*A*]to indicate whether a certain number of binary input ports is in state 1	context()	negated: False ,passive: True
0.898	[*A*]the module specification of a threshold module[*R*]will be[*A*]such that the output is required to indicate whether a certain number of binary input ports is in state 1	context()	negated: False ,passive: True
[LINE#283] Basic modules are then employed with the understanding that they require an implementation matching their specification.
0.835	[*A*]an implementation[*R*]matching[*A*]their specification	context()	negated: False ,passive: False
0.465	[*A*]they[*R*]require[*A*]an implementation matching their specification	context()	negated: False ,passive: False
0.683	[*A*]Basic modules[*R*]are employed[*A*]with the understanding that they require an implementation[*A*]then	context()	negated: False ,passive: True
[LINE#284] This use of basic modules in our algorithms entails that correct modules have correct internal states.
0.882	[*A*]correct modules[*R*]have[*A*]correct internal states	context(This use of basic modules in our algorithms entails)	negated: False ,passive: False
0.479	[*A*]This use of basic modules in our algorithms[*R*]entails[*A*]that correct modules have correct internal states	context()	negated: False ,passive: False
[LINE#285+286]  Although a basic module description abstracts away its internal state, this property can be characterized in a natural way by another constraint on the module specification : We say that the specification of some module.
0.686	[*A*]this property[*R*]can be characterized	context(We say)	negated: False ,passive: False
0.162	[*A*]We[*R*]say	context()	negated: False ,passive: False
0.860	[*A*]a basic module description[*R*]abstracts[*A*]away[*A*]its internal state	context()	negated: False ,passive: False
[LINE#287+288]  M is extendable iff each feasible execution of M on some interval[t-,t+)R is the restriction of a feasible execution of M on R.
0.986	[*A*]M is extendable iff each feasible execution of M on some interval[*R*]is[*A*]the restriction of a feasible execution of M on R.	context()	negated: False ,passive: True
0.918	[*A*]M[*R*]is[*A*]extendable iff each feasible execution of M on some interval	context()	negated: False ,passive: True
[LINE#289+290+291+292]  In other words, for each execution on some interval [t-,t+), (i) a fault-free history exists that leads to the internal state of the module at time t- (and therefore, for the given input signals, to the same execution on [t-,t+)), and (ii) the module is capable of continuing to operate correctly in the future(i.e., there is no fault-free execution that eventually cannot be continued in a way that adheres to M).
0.869	[*A*]no fault-free execution[*R*]can not be continued[*A*]eventually	context()	negated: True ,passive: True
0.905	[*A*]a way[*R*]adheres[*A*]to M	context()	negated: False ,passive: False
[LINE#293] While (ii) should always be true for essentially the same reason that we demand non-emptiness for, (i) can be seen as the requirement of a correct internal state: For a correct module with an extensible specification, it is required that both all internal components of a physical implementation of the module operate according to their specification and all traces of an earlier transient fault (if any) from the internal state must have worn off, in the sense that it could have been reached by a non-faulty history.
0.834	[*A*]both all internal components of a physical implementation of the module[*R*]operate	context(it is required)	negated: False ,passive: False
0.399	[*A*]it[*R*]is required[*A*]that both all internal components of a physical implementation of the module operate according to all traces of an earlier transient fault[*A*]For a correct module with an extensible specification	context()	negated: False ,passive: True
0.958	[*A*]both all internal components of a physical implementation of the module[*R*]operate[*A*]if any ) from the internal state must have worn off , in the sense	context(it is required)	negated: False ,passive: True
0.265	[*A*]it[*R*]is required[*A*]that both all internal components of a physical implementation of the module operate according to their specification if any ) from the internal state must have worn off , in the sense[*A*]For a correct module with an extensible specification	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]could have been reached[*A*]by a non-faulty history	context()	negated: False ,passive: True
0.225	[*A*]we[*R*]demand[*A*]non-emptiness	context()	negated: False ,passive: False
0.920	[*A*]any ) from the internal state[*R*]must have worn off[*A*]in the sense	context()	negated: False ,passive: True
[LINE#294] Most of the basic module specifications we are going to introduce will be extendable.
0.803	[*A*]Most of the basic module specifications[*R*]will be[*A*]extendable	context()	negated: False ,passive: True
0.885	[*A*]the basic module specifications[*R*]to introduce[*A*]we	context()	negated: False ,passive: True
[LINE#295] However, there are also basic modules with non-extendable specifications; we will provide an example later on.
0.388	[*A*]we[*R*]will provide[*A*]an example[*A*]later on	context()	negated: False ,passive: False
[LINE#296+297]  The next lemma shows that any extendable module specification is uniquely characterized by its values on input executions of the respective module on R.Lemma 3.3Any function  that maps each execution Ein of a set of input ports Pin on R to a non-empty set of executions Eout of a set of output ports.
0.905	[*A*]any extendable module specification[*R*]is uniquely characterized[*A*]by its values on input executions of the respective module on R.Lemma 3.3Any function	context(The next lemma shows)	negated: False ,passive: True
0.807	[*A*]The next lemma[*R*]shows[*A*]that any extendable module specification is uniquely characterized by its values on input executions of the respective module on R.Lemma 3.3Any function	context()	negated: False ,passive: False
0.940	[*A*]R.Lemma 3.3Any function[*R*]maps[*A*]each execution	context()	negated: False ,passive: False
[LINE#298+299]  Pout on R specifies a unique module such that (i) M is extendable and (ii) M(Ein)=(Ein) for each execution of M's input ports Pin on R. Conversely, for each module.
0.879	[*A*]Pout on R[*R*]specifies[*A*]a unique module such that ( ii ) M ( Ein ) = ( Ein ) for each execution of M 's input ports Pin on R. Conversely , for each module	context()	negated: False ,passive: False
0.734	[*A*]M[*R*]is[*A*]extendable[*A*]Conversely	context()	negated: False ,passive: True
0.911	[*A*]Pout on R[*R*]specifies[*A*]a unique module such	context()	negated: False ,passive: False
[LINE#300+301]  M whose specification is extendable, M is uniquely characterized by its values on executions of ports Pin on R.ProofWe show first that for a function  as assumed by the lemma there exists a module.
0.647	[*A*]Pin on R.ProofWe[*R*]show[*A*]first[*A*]that	context(M is uniquely characterized)	negated: False ,passive: False
0.711	[*A*]M[*R*]is uniquely characterized[*A*]by its values on executions of ports	context()	negated: False ,passive: True
0.632	[*A*]M[*R*]is[*A*]extendable	context()	negated: False ,passive: True
[LINE#302] M such that M(Ein)=(Ein) for executions Ein of ports Pin on R and M is extendable.
0.915	[*A*]M ( Ein ) = ( Ein ) for executions[*R*]is[*A*]extendable	context()	negated: False ,passive: True
[LINE#303+304]  To this end, we simply define that M is a module with input ports Pin and output ports Pout whose specification M is given by EoutM(Ein) iff Ein and Eout are restrictions of executions Ein and Eout on R, respectively,.
0.879	[*A*]M[*R*]is[*A*]a module with input ports output ports Pout	context(we define)	negated: False ,passive: True
0.403	[*A*]we[*R*]define[*A*]that M is a module with input ports output ports Pout[*A*]To this end	context()	negated: False ,passive: False
0.877	[*A*]M[*R*]is given[*A*]by EoutM	context()	negated: False ,passive: True
0.921	[*A*]M[*R*]is[*A*]a module with input ports Pin ports Pout whose specification M is given by EoutM ( Ein ) iff Eout	context(we define)	negated: False ,passive: True
0.934	[*A*]Pin ports Pout[*R*]are[*A*]restrictions of Eout on R[*A*]respectively	context()	negated: False ,passive: True
0.921	[*A*]M[*R*]is[*A*]a module with input ports Pin ports Pout whose specification M is given by EoutM ( Ein ) iff Ein	context(we define)	negated: False ,passive: True
0.296	[*A*]we[*R*]define[*A*]that M is a module with input ports[*A*]To this end	context()	negated: False ,passive: False
0.934	[*A*]Pin ports Pout[*R*]are[*A*]restrictions of executions Ein on R[*A*]respectively	context()	negated: False ,passive: True
0.944	[*A*]whose specification M[*R*]is given[*A*]by EoutM	context()	negated: False ,passive: True
[LINE#305] Clearly, M satisfies properness and extendability by construction.
0.855	[*A*]M[*R*]satisfies[*A*]extendability	context()	negated: False ,passive: False
0.855	[*A*]M[*R*]satisfies[*A*]properness	context()	negated: False ,passive: False
[LINE#306]  Regarding non-emptiness, we can extend any input execution Ein on some interval.
0.452	[*A*]we[*R*]can extend[*A*]any input execution[*A*]on some interval	context()	negated: False ,passive: False
[LINE#307] I arbitrarily to an execution Ein on R. By assumption, (Ein), so there must be some execution Eout(Ein).
[LINE#308] By definition, its restriction Eout to I is in M(Ein), proving non-emptiness.
0.704	[*A*]its restriction[*R*]is[*A*]in M(Ein[*A*]proving non-emptiness	context()	negated: False ,passive: True
[LINE#309]  Hence M is a valid specification of a module M with input ports.
0.926	[*A*]M[*R*]is[*A*]a valid specification of a module M with input ports	context()	negated: False ,passive: True
[LINE#310] We now establish the second claim of the lemma, which will also show that the module M we constructed from  is unique and thus complete the proof.
0.837	[*A*]the lemma[*R*]will complete[*A*]the proof	context()	negated: False ,passive: False
0.483	[*A*]the module M we constructed from[*R*]is[*A*]unique	context(the lemma will show)	negated: False ,passive: True
0.440	[*A*]the lemma[*R*]will show[*A*]that the module M we constructed from is unique	context()	negated: False ,passive: False
0.754	[*A*]the module M[*R*]constructed[*A*]from	context()	negated: False ,passive: True
0.554	[*A*]We[*R*]establish[*A*]the second claim of the lemma[*A*]now	context()	negated: False ,passive: False
[LINE#311] To this end, let Ein and Eout be any executions of the input and output ports of M, respectively.
[LINE#312+313]  If EoutM(Ein), by extendability Ein and Eout are restrictions ofexecutions Ein and Eout on R, respectively, such that EoutM(Ein).
0.878	[*A*]EoutM ( Ein ) , by Eout[*R*]are[*A*]such	context()	negated: False ,passive: True
0.774	[*A*]EoutM[*R*]are[*A*]such	context()	negated: False ,passive: True
0.961	[*A*]EoutM ( Ein ) , by Eout[*R*]are[*A*]Eout	context()	negated: False ,passive: True
0.921	[*A*]EoutM[*R*]are[*A*]Eout	context()	negated: False ,passive: True
0.921	[*A*]EoutM[*R*]are[*A*]restrictions ofexecutions Ein	context()	negated: False ,passive: True
[LINE#314]  On the other hand, if EoutM(Ein), properness necessitates that there are no such executions.
[LINE#315] This shows the second statement and the lemma follows.
0.732	[*A*]the lemma[*R*]follows	context()	negated: False ,passive: False
0.449	[*A*]This[*R*]shows[*A*]the second statement	context()	negated: False ,passive: False
[LINE#316] Enabled by this lemma, we will specify most of our basic modules by defining M(Ein) for input executions Ein on R only.
0.309	[*A*]we[*R*]will specify[*A*]most of our basic modules	context()	negated: False ,passive: False
[LINE#317] For instance, the fixed delay channel from Example 3.2 can now be specified equivalently as follows.
0.894	[*A*]the fixed delay channel from Example 3.2[*R*]can be specified[*A*]equivalently[*A*]as follows[*A*]now	context()	negated: False ,passive: True
[LINE#318+319+320+321]  Example 3.4A fixed-delay channel with input port i, output port o, and delay d>0 is a basic module with extendable module specification C defined by: For each execution Ein of input port i on R, an execution Eout of output port o on R is in C(Ein) we have that o(t)=i(t-d).Because we do not need to describe partial feasible executions on a finite interval I=[t-,t+) here, the fact that the condition o(t)=i(t-d) applies only to a subinterval of I in Example 3.2 becomes superfluous:(-+d;)=R, so no additional specification is required to describe the module's behavior near the lower bound of intervals [t-,t+) with t-.
0.388	[*A*]we[*R*]do not need to describe[*A*]partial feasible executions[*A*]on a finite interval I=	context(we do not need)	negated: True ,passive: False
0.504	[*A*]we[*R*]do not need[*A*]to describe partial feasible executions on a finite interval I=	context()	negated: True ,passive: False
0.637	[*A*]i on R[*R*]is[*A*]in C[*A*]Because we do not need to describe partial feasible executions on a finite interval I= : ( - +d ; ) =R , so no additional specification is required to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: False ,passive: True
0.388	[*A*]we[*R*]do not need to describe[*A*]partial feasible executions[*A*]on a finite interval	context(we do not need)	negated: True ,passive: False
0.388	[*A*]we[*R*]do not need[*A*]to describe partial feasible executions on a finite interval	context()	negated: True ,passive: False
0.188	[*A*]we[*R*]have[*A*]that o ( t	context(i on R is)	negated: False ,passive: False
0.637	[*A*]i on R[*R*]is[*A*]in C[*A*]t - d ) . Because we do not need to describe partial feasible executions on a finite interval I= [ t ; ) =R , so no additional specification is required to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: False ,passive: True
0.943	[*A*]no additional specification[*R*]is required[*A*]to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: False ,passive: True
0.388	[*A*]we[*R*]do not need to describe[*A*]partial feasible executions	context(we do not need)	negated: True ,passive: False
0.504	[*A*]we[*R*]do not need[*A*]to describe partial feasible executions on a finite interval I= : ( - +d ; ) =R , so no additional specification is required to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: True ,passive: False
0.925	[*A*]an execution Eout of output port[*R*]is[*A*]in C[*A*]Because we do not need to describe partial feasible executions on a finite interval I= : ( - +d ; ) =R , so no additional specification is required to describe the module 's behavior near the lower bound of intervals [ - , t+ ) t	context()	negated: False ,passive: True
0.388	[*A*]we[*R*]do not need to describe[*A*]partial feasible executions on a finite interval	context(we do not need)	negated: True ,passive: False
0.550	[*A*]we[*R*]do not need[*A*]to describe partial feasible executions on a finite interval I= [ t	context()	negated: True ,passive: False
0.188	[*A*]we[*R*]have[*A*]that o ( t	context(an execution Eout of output port is)	negated: False ,passive: False
0.925	[*A*]an execution Eout of output port[*R*]is[*A*]in C[*A*]Because we do not need to describe partial feasible executions on a finite interval I= [ t	context()	negated: False ,passive: True
0.943	[*A*]no additional specification[*R*]is required[*A*]to describe the module 's behavior near the lower bound of intervals	context()	negated: False ,passive: True
0.933	[*A*]no additional specification[*R*]to describe[*A*]the module 's behavior near the lower bound of intervals	context()	negated: False ,passive: False
[LINE#322] By contrast, in Example 3.2, we had to specify this explicitly, by stating that any behavior of the output in [t-,t-+d) is feasible (by leaving the behavior unspecified in this interval).Whereas the specification in Example 3.4 simplifies the one of Example 3.2 only marginally, this is very different for the modules exhibiting more complex relations between input and output introduced later on: Accurately describing all suffixes of a non-trivial partial execution can be error-prone and may result in unnecessarily involved module specifications.
0.381	[*A*]By[*R*]may result[*A*]in unnecessarily involved module specifications	context()	negated: False ,passive: True
0.783	[*A*]input and output[*R*]introduced[*A*]later on	context()	negated: False ,passive: True
0.903	[*A*]the modules[*R*]exhibiting[*A*]more complex relations between input and output	context()	negated: False ,passive: False
0.891	[*A*]any behavior of the output in [ t - , t - +d[*R*]is[*A*]feasible	context(we to specify explicitly by stating)	negated: False ,passive: True
0.170	[*A*]we[*R*]to specify explicitly by stating[*A*]that any behavior of the output in [ t - , t - +d ) is feasible ( by leaving the behavior unspecified in this interval	context(we to specify explicitly)	negated: False ,passive: False
0.155	[*A*]we[*R*]to specify explicitly[*A*]this	context()	negated: False ,passive: False
0.386	[*A*]this[*R*]is[*A*]very different for the modules	context(Accurately describing all suffixes of a non-trivial partial execution can be)	negated: False ,passive: True
0.934	[*A*]Accurately describing all suffixes of a non-trivial partial execution[*R*]can be[*A*]error - prone	context()	negated: False ,passive: True
0.952	[*A*]the specification in Example 3.4[*R*]simplifies only marginally[*A*]the one of Example 3.2	context()	negated: False ,passive: False
[LINE#323] In this work, we introduced a novel modeling framework for self-stabilizing, fault-tolerant asynchronous digital circuits and demonstrated its applicability to our recently introduced FATAL+ clock generation scheme for multi-synchronous GALS architectures.
0.863	[*A*]fault - tolerant asynchronous digital circuits[*R*]demonstrated[*A*]its applicability	context()	negated: False ,passive: False
0.566	[*A*]we[*R*]demonstrated[*A*]its applicability[*A*]to our recently introduced FATAL+ clock generation scheme for multi-synchronous GALS architectures[*A*]In this work	context()	negated: False ,passive: False
0.595	[*A*]we[*R*]introduced[*A*]a novel modeling framework for self - stabilizing[*A*]In this work	context()	negated: False ,passive: False
[LINE#324] Our framework enables to reason about high-level properties of the system based on the behavior of basic building blocks, at arbitrary granularity and in a seamless manner.
0.960	[*A*]high - level properties of the system[*R*]based[*A*]on the behavior of basic building blocks in a seamless manner	context()	negated: False ,passive: True
0.960	[*A*]high - level properties of the system[*R*]based[*A*]on the behavior of basic building blocks , at arbitrary granularity	context()	negated: False ,passive: True
0.739	[*A*]Our framework[*R*]enables[*A*]to reason about high - level properties of the system	context()	negated: False ,passive: False
[LINE#325] At the same time, the hierarchical structure of the model permits to do this in a fashion amenable to formal analysis.
[LINE#326] We believe this to be the first approach concurrently providing all these features, and therefore consider it as a promising foundation for future research in the area of fault-tolerant digital circuits.
0.273	[*A*]We[*R*]believe consider[*A*]it[*A*]as a promising foundation for future research in the area of fault - tolerant digital circuits	context(We believe)	negated: False ,passive: False
0.365	[*A*]We[*R*]believe[*A*]therefore consider it as a promising foundation for future research in the area of fault - tolerant digital circuits	context()	negated: False ,passive: False
0.330	[*A*]this[*R*]to be[*A*]the first approach concurrently providing all these features	context(We believe)	negated: False ,passive: True
0.397	[*A*]We[*R*]believe[*A*]this to be the first approach	context()	negated: False ,passive: False
0.911	[*A*]the first approach[*R*]concurrently providing[*A*]all these features	context()	negated: False ,passive: False
[LINE#327] As the conclusion of our paper, we now assess to which extent the properties of our implementation of the FATAL+ algorithm, which have been expressed and verified within our modeling framework and tested experimentally, meet our design goals.
0.584	[*A*]the properties of our implementation of the FATAL+ algorithm[*R*]have been tested[*A*]experimentally	context()	negated: False ,passive: True
0.566	[*A*]we[*R*]assess[*A*]to which extent the properties of our implementation of the FATAL+ algorithm , which have been tested experimentally , meet our design goals[*A*]As the conclusion of our paper[*A*]now	context()	negated: False ,passive: False
0.683	[*A*]the properties of our implementation of the FATAL+ algorithm[*R*]have been verified[*A*]within our modeling framework	context()	negated: False ,passive: True
0.566	[*A*]we[*R*]assess[*A*]to which extent the properties of our implementation of the FATAL+ algorithm , which have been verified within our modeling framework , meet our design goals[*A*]As the conclusion of our paper[*A*]now	context()	negated: False ,passive: False
0.683	[*A*]the properties of our implementation of the FATAL+ algorithm[*R*]meet[*A*]our design goals	context()	negated: False ,passive: False
0.539	[*A*]the properties of our implementation of the FATAL+ algorithm[*R*]have been expressed	context()	negated: False ,passive: False
0.566	[*A*]we[*R*]assess[*A*]to which extent the properties of our implementation of the FATAL+ algorithm , which have been expressed , meet our design goals[*A*]As the conclusion of our paper[*A*]now	context()	negated: False ,passive: False
[LINE#328] Furthermore, we will discuss a number of potential improvements and future research avenues.
0.452	[*A*]we[*R*]will discuss[*A*]a number of potential future research avenues	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]will discuss[*A*]a number of potential improvements	context()	negated: False ,passive: False
[LINE#329] Our exposition will follow the optimization criteria listed in Section 2.1.7.Area consumption: For a suitable implementation, the total number of gates is O(nlogn) per node.
0.576	[*A*]Our exposition[*R*]will follow[*A*]the optimization criteria listed in Section 2.1.7.Area consumption	context(the total number of gates is)	negated: False ,passive: False
0.939	[*A*]the total number of gates[*R*]is[*A*]O(nlogn) per node	context()	negated: False ,passive: True
0.911	[*A*]the optimization criteria[*R*]listed[*A*]in Section 2.1.7.Area consumption	context()	negated: False ,passive: True
[LINE#330] This can be seen by observing that the complexity of the threshold gates is dominating the asymptotic number of gates, since the O(n) remaining components of a node have a constant number of gates each; using sorting networks to implement threshold gates, the stated complexity bound follows [48].
0.999	[*A*]the stated complexity bound[*R*]follows[*A*]48 ]	context()	negated: False ,passive: False
0.965	[*A*]the O(n) remaining components of a node[*R*]have[*A*]a constant number of gates	context()	negated: False ,passive: False
0.928	[*A*]the O(n[*R*]remaining[*A*]components of a node	context()	negated: False ,passive: True
0.751	[*A*]the stated complexity[*R*]bound	context()	negated: False ,passive: False
0.917	[*A*]the complexity of the threshold gates[*R*]is dominating[*A*]the asymptotic number of gates	context(This by observing)	negated: False ,passive: False
0.196	[*A*]This[*R*]by observing[*A*]that the complexity of the threshold gates is dominating the asymptotic number of gates	context()	negated: False ,passive: False
0.217	[*A*]This[*R*]can be seen[*A*]by observing that the complexity of the threshold gates is dominating the asymptotic number of gates	context(the stated complexity bound follows)	negated: False ,passive: True
0.719	[*A*]the stated complexity bound[*R*]follows[*A*]48	context()	negated: False ,passive: True
[LINE#331] Trivially, this number of gates is a factor of O(logn) from optimal.
0.381	[*A*]gates[*R*]is a factor of[*A*]O ( logn )	context()	negated: False ,passive: False
0.947	[*A*]this number of gates[*R*]is[*A*]a factor of O(logn) from optimal	context()	negated: False ,passive: True
[LINE#332] We conjecture that in fact this complexity is asymptotically optimal, unless one is willing to sacrifice other desirable properties of the algorithm (e.g. optimal resilience).
0.941	[*A*]this complexity[*R*]is[*A*]asymptotically optimal[*A*]unless one is willing to sacrifice other desirable properties of the algorithm (e.g. optimal resilience	context(We conjecture)	negated: False ,passive: True
0.279	[*A*]We[*R*]conjecture[*A*]that in fact this complexity is asymptotically optimal, unless one is willing to sacrifice other desirable properties of the algorithm (e.g. optimal resilience	context()	negated: False ,passive: False
0.618	[*A*]one[*R*]to sacrifice[*A*]other desirable properties of the algorithm (e.g. optimal resilience	context()	negated: False ,passive: False
0.718	[*A*]one[*R*]is[*A*]willing to sacrifice other desirable properties of the algorithm (e.g. optimal resilience	context()	negated: False ,passive: True
[LINE#333] Assuming that the gate complexity of the nodes adequately represents the area consumption of our algorithm, we conclude that our solution is satisfactory in that regard.Communication complexity: Our implementation uses 7 (1-bit) wires per channel, and sequential encoding of the states of the main state machine would reduce this number to 5.
0.953	[*A*]sequential encoding of the states of the main state machine[*R*]would reduce[*A*]this number[*A*]to 5	context()	negated: False ,passive: False
0.388	[*A*]our solution[*R*]is[*A*]satisfactory	context(we conclude)	negated: False ,passive: True
0.168	[*A*]we[*R*]conclude[*A*]that our solution is satisfactory in that regard.Communication complexity : Our implementation uses 7 ( 1 - bit ) wires per channel	context()	negated: False ,passive: False
0.638	[*A*]Our implementation[*R*]uses[*A*]7 ( 1 - bit ) wires per channel	context()	negated: False ,passive: False
[LINE#334] All communication are broadcasts.
0.903	[*A*]All communication[*R*]are[*A*]broadcasts	context()	negated: False ,passive: True
[LINE#335] Considering the complexity of the task, there seems to be very limited room for improvement.Stabilization time: Our algorithm has a stabilization time of O(n) in the worst case.
[LINE#336] Recent findings [49] show that a polylogarithmic stabilization time can be achieved at a low communication complexity; however, this comes at the expense of suboptimal resilience, a weaker adversarial model, and, most importantly, constants in the complexity bounds that make the resulting algorithm inferior to our solution for any practical range of parameters.
0.321	[*A*]this[*R*]comes[*A*]at constants in the complexity bounds	context()	negated: False ,passive: True
0.897	[*A*]the complexity bounds[*R*]make[*A*]the resulting algorithm inferior	context()	negated: False ,passive: False
0.897	[*A*]a polylogarithmic stabilization time[*R*]can be achieved[*A*]at a low communication complexity	context(Recent findings show this comes)	negated: False ,passive: True
0.825	[*A*]Recent findings[*R*]show[*A*]that a polylogarithmic stabilization time can be achieved at a low communication complexity	context(this comes)	negated: False ,passive: False
0.122	[*A*]this[*R*]comes	context()	negated: False ,passive: False
[LINE#337] Moreover, as formalized in [13] and demonstrated in Section 7, for a wide range of scenarios our algorithm achieves constant stabilization time.
0.638	[*A*]our algorithm[*R*]achieves[*A*]constant stabilization time	context()	negated: False ,passive: False
[LINE#338]  Considering the severe fault model, we conclude that despite not being optimal, our algorithm performs satisfactory with respect to this quality.
0.285	[*A*]our algorithm[*R*]performs satisfactory	context(we conclude)	negated: False ,passive: False
0.168	[*A*]we[*R*]conclude[*A*]that despite not being optimal, our algorithm performs satisfactory with respect to this quality	context()	negated: False ,passive: False
[LINE#339] It is known that 3f+1 nodes are necessary to tolerate f faults [25,14] unless cryptographic tools are available.
0.767	[*A*]cryptographic tools[*R*]are[*A*]available	context()	negated: False ,passive: True
0.887	[*A*]3f+1 nodes[*R*]to tolerate[*A*]f faults	context()	negated: False ,passive: False
[LINE#340]  Since the complexity incurred by cryptographic tools is prohibitive in our setting, our algorithm features optimal resilience.Delays:.
0.660	[*A*]our algorithm features[*R*]optimal[*A*]resilience	context()	negated: False ,passive: False
0.908	[*A*]the complexity incurred by cryptographic tools[*R*]is[*A*]prohibitive in our setting	context()	negated: False ,passive: True
0.903	[*A*]the complexity[*R*]incurred[*A*]by cryptographic tools	context()	negated: False ,passive: True
[LINE#341] As mentioned, the delay of wires is outside our control.
0.891	[*A*]the delay of wires[*R*]is[*A*]outside our control	context()	negated: False ,passive: True
[LINE#342] Taking dmin+ and dmax+ into account in the quick cycle machine, we make best use of the available bounds in terms of the final frequency/synchrony trade-off.
0.388	[*A*]we[*R*]make[*A*]best use of the available bounds	context()	negated: False ,passive: False
[LINE#343] The delays incurred by the computations performed at nodes are proportional to the depths of the involved circuits.
0.921	[*A*]The delays incurred by the computations[*R*]are[*A*]proportional to the depths of the involved circuits	context()	negated: False ,passive: True
0.903	[*A*]the computations[*R*]performed[*A*]at nodes	context()	negated: False ,passive: True
0.903	[*A*]The delays[*R*]incurred[*A*]by the computations	context()	negated: False ,passive: True
[LINE#344] Again, the implementation of the threshold gates is the dominant cost factor here.
0.948	[*A*]the implementation of the threshold gates[*R*]is[*A*]the dominant cost factor here	context()	negated: False ,passive: True
[LINE#345] The sorting network by Ajtai et al.
[LINE#346] Assuming constant fan-in of gates, this is clearly asymptotically optimal if the decision when to increase the logical clock Lv next indeed depends on all n-1 input signals of v from remote nodes.
0.942	[*A*]the decision when to increase the logical clock Lv[*R*]next depends[*A*]on all n-1 input signals of	context()	negated: False ,passive: False
0.612	[*A*]this[*R*]is[*A*]clearly[*A*]asymptotically optimal[*A*]if the decision when to increase the logical clock Lv next indeed depends on all n-1 input signals of v from remote nodes	context()	negated: False ,passive: True
[LINE#347]  We conclude that, so far as within our control, the design goal of minimizing the incurred delays is met by our algorithm.Metastability:.
0.096	[*A*]We[*R*]conclude[*A*]that	context()	negated: False ,passive: False
[LINE#348] We discussed several effective measures to prevent metastability in Section 6.
0.911	[*A*]several effective measures[*R*]to prevent[*A*]metastability	context()	negated: False ,passive: True
0.452	[*A*]We[*R*]discussed[*A*]several effective measures to prevent metastability in Section 6	context()	negated: False ,passive: False
[LINE#349] Our experiments support our theoretical finding that, after stabilization, metastability may not occur in absence of further faults.
0.938	[*A*]metastability[*R*]may not occur[*A*]in absence of further faults[*A*]after stabilization	context()	negated: True ,passive: True
0.359	[*A*]Our experiments[*R*]support[*A*]our theoretical finding that, after stabilization, metastability may not occur in absence of further faults	context()	negated: False ,passive: False
[LINE#350] However, since metastability is an elusive problem for which it is difficult to transfer insights and observations to other modes of operation of a given system-let alone to different implementation technology-a mathematical treatment of metastability is highly desirable.
0.907	[*A*]metastability[*R*]is[*A*]an elusive problem for which it is difficult to transfer observations to other modes of operation of a given system - let alone to different implementation technology - a mathematical treatment of metastability	context()	negated: False ,passive: True
0.844	[*A*]since metastability is an elusive problem[*R*]is[*A*]highly desirable	context()	negated: False ,passive: True
0.907	[*A*]metastability[*R*]is[*A*]an elusive problem for which it is difficult to transfer insights to other modes of operation of a given system - let alone to different implementation technology - a mathematical treatment of metastability	context()	negated: False ,passive: True
[LINE#351] Our model opens up various possible approaches to this issue.
[LINE#352] For one, it is feasible to switch to a more accurate description of signals in terms of signals' voltages as continuous functions of time.
[LINE#353] Another option choosing an intermediate level of complexity would be to add an additional signal state (e.g. ) for "invalid" signals, representing e.g. creeping or oscillating signals.
0.897	[*A*]invalid" signals[*R*]representing[*A*]e.g. creeping or oscillating signals	context()	negated: False ,passive: False
0.964	[*A*]Another option choosing an intermediate level of complexity[*R*]would be[*A*]to add an additional signal state (e.g. ) for "invalid" signals	context()	negated: False ,passive: True
0.903	[*A*]Another option[*R*]choosing[*A*]an intermediate level of complexity	context()	negated: False ,passive: False
[LINE#354] Assigning appropriate probabilities of metastability propagation and decay to modules, this would enable a unified probabilistic analysis of metastability generation, propagation, and decay within a modeling framework using discrete state representations.
0.911	[*A*]a modeling framework[*R*]using[*A*]discrete state representations	context()	negated: False ,passive: False
0.497	[*A*]this[*R*]would enable[*A*]a unified probabilistic analysis of decay within a modeling framework	context()	negated: False ,passive: False
0.381	[*A*]this[*R*]would enable[*A*]a unified probabilistic analysis of propagation	context()	negated: False ,passive: False
0.381	[*A*]this[*R*]would enable[*A*]a unified probabilistic analysis of metastability generation	context()	negated: False ,passive: False
[LINE#355] Such an approach could yield entirely unconditional guarantees on system recovery; in contrast, our current description requires an a priori guarantee that metastability is sufficiently contained during the stabilization process.Connectivity: The algorithm presented in this work requires to connect all pairs of nodes and is therefore not scalable.
0.828	[*A*]Such an approach[*R*]is[*A*]therefore[*A*]not scalable	context()	negated: False ,passive: True
0.891	[*A*]Such an approach[*R*]could yield[*A*]entirely unconditional guarantees on system recovery	context(our current description requires The algorithm presented in this work requires)	negated: False ,passive: False
0.477	[*A*]our current description[*R*]requires[*A*]an a priori guarantee that metastability is sufficiently contained during the stabilization process.Connectivity	context(The algorithm presented in this work requires)	negated: False ,passive: False
0.917	[*A*]The algorithm presented in this work[*R*]requires[*A*]to connect all pairs of nodes	context()	negated: False ,passive: False
0.903	[*A*]The algorithm[*R*]presented[*A*]in this work	context()	negated: False ,passive: True
0.862	[*A*]an a priori guarantee[*R*]is contained[*A*]during the stabilization process.Connectivity	context()	negated: False ,passive: False
[LINE#356] Unfortunately, it is known that (n2) links are required for tolerating f(n) faults in the worst case [26,27].
0.929	[*A*]n2) links[*R*]are required[*A*]for tolerating f(n) faults in the worst case	context(it is known)	negated: False ,passive: True
0.162	[*A*]it[*R*]is known	context()	negated: False ,passive: False
0.825	[*A*]n2) links[*R*]for tolerating n[*A*]faults	context()	negated: False ,passive: False
[LINE#357] We argued for the assumption of worst-case behavior of faulty nodes; however, it appears reasonable that typical systems will not exhibit a worst-case distribution of faults within the system.
[LINE#358] Indeed, many interesting scenarios justify to assume a much more benign distribution of faults.
0.888	[*A*]many interesting scenarios[*R*]justify to assume[*A*]a much more benign distribution of faults	context(many interesting scenarios justify)	negated: False ,passive: False
0.888	[*A*]many interesting scenarios[*R*]justify[*A*]to assume a much more benign distribution of faults	context()	negated: False ,passive: False
[LINE#359] In the extreme case where faults are distributed uniformly and independently at random with a constant probability, say, 10%, of a node being faulty, node degrees of O(clogn) would suffice to guarantee (at a given point in time) that the probability that more than /9 neighbors of any node are faulty, is at most 1-1/nc.
0.813	[*A*]10 % , of a node[*R*]would suffice to guarantee[*A*]that the probability that more than / 9 neighbors of any node are faulty , is at most 1-1 / nc .	context(10 % , of a node would suffice)	negated: False ,passive: False
0.938	[*A*]faults[*R*]are distributed independently[*A*]at random[*A*]the extreme case	context()	negated: False ,passive: True
0.813	[*A*]10 % , of a node[*R*]would suffice to guarantee[*A*]that the probability that more than / 9 neighbors of any node are faulty , is at most 1-1 / nc .	context(10 % , of a node would suffice)	negated: False ,passive: False
0.839	[*A*]10 % , of a node[*R*]would suffice[*A*]to guarantee ( at a given point in time ) that the probability	context()	negated: False ,passive: False
0.977	[*A*]that the probability that more than / 9 neighbors of any node are faulty ,[*R*]is[*A*]at most 1-1 / nc	context()	negated: False ,passive: True
0.903	[*A*]a node[*R*]being[*A*]faulty , node degrees of O ( clogn	context()	negated: False ,passive: True
0.854	[*A*]more than / 9 neighbors of any node[*R*]are[*A*]faulty	context()	negated: False ,passive: True
0.938	[*A*]faults[*R*]are distributed uniformly[*A*]at random[*A*]the extreme case	context()	negated: False ,passive: True
[LINE#360] Note that this implies that the mean time until this property is violated polynomially grows with system size.
0.933	[*A*]this property[*R*]is violated[*A*]the mean time	context()	negated: False ,passive: True
[LINE#361] Using the FATAL+ protocol in small subsystems (of less than  nodes), system-wide synchronization will be much easier to achieve than if one would start from scratch.
0.616	[*A*]one[*R*]would start[*A*]from scratch	context()	negated: False ,passive: False
0.908	[*A*]system-wide synchronization[*R*]will be[*A*]much easier to achieve than if one would start from scratch	context()	negated: False ,passive: True
[LINE#362] In this setting, O(logn) would replace n in all complexity bounds of the FATAL+ algorithm, resulting in particular in gate complexity O(lognloglogn) per node, computational delay O(loglogn), and stabilization time O(clogn) with probability 1-1/nc.
0.968	[*A*]O ( logn[*R*]would replace n[*A*]in all complexity bounds of the FATAL+ algorithm[*A*]resulting in particular in gate complexity O ( lognloglogn ) per node[*A*]In this setting	context()	negated: False ,passive: True
[LINE#363]  Thus, this approach promises "local" fault-tolerance of () faults in each neighborhood in combination with excellent scalability in all complexity measures, and realizing this is a major goal of our future work.Clock size:.
0.422	[*A*]realizing this[*R*]is[*A*]a major goal of our future work.Clock	context(this approach promises)	negated: False ,passive: True
0.839	[*A*]this approach[*R*]promises[*A*]realizing this is a major goal of our future work.Clock	context()	negated: False ,passive: False
0.926	[*A*]this approach[*R*]promises[*A*]faults in each neighborhood in combination with excellent scalability in all complexity measures	context()	negated: False ,passive: False
0.886	[*A*]this approach[*R*]promises[*A*]local " fault - tolerance of	context()	negated: False ,passive: False
[LINE#364] The constraint (1) entails that either clock size is bounded or large clocks result in larger stabilization time.
0.787	[*A*]The constraint[*R*]entails[*A*]that either clock size is bounded or large clocks result in larger stabilization time	context()	negated: False ,passive: False
0.903	[*A*]large clocks[*R*]result[*A*]in larger stabilization time	context()	negated: False ,passive: True
[LINE#365] This restriction can be overcome if we use the clocks of bounded size generated by FATAL+ as input to another layer that runs a synchronous consensus algorithm in order to agree on exponentially larger clocks [41].
0.913	[*A*]another layer[*R*]runs[*A*]a synchronous consensus algorithm	context()	negated: False ,passive: False
0.918	[*A*]bounded size[*R*]generated[*A*]by FATAL+	context()	negated: False ,passive: True
0.452	[*A*]we[*R*]use[*A*]the clocks of bounded size	context()	negated: False ,passive: False
0.835	[*A*]This restriction[*R*]can be overcome[*A*]if we use the clocks of bounded size	context()	negated: False ,passive: True
[LINE#366] Finally, we would like to mention two more prospective extensions of our work.
0.256	[*A*]we[*R*]would like to mention[*A*]two more prospective extensions of our work	context(we would like)	negated: False ,passive: False
0.381	[*A*]we[*R*]would like[*A*]to mention two more prospective extensions of our work[*A*]Finally	context()	negated: False ,passive: False
[LINE#367] First, building on our modeling framework, it seems feasible to tackle an even more strict verification of the algorithm's properties than "standard" mathematical analysis.
0.528	[*A*]it[*R*]to tackle[*A*]an even more strict verification of the algorithm's properties than "standard" mathematical analysis	context()	negated: False ,passive: False
[LINE#368] The hierarchical structure and formal specifications of modules seem amenable to formal verification methods.
[LINE#369] Such an approach should benefit from the possibilities to adjust the granularity of the model by the distinction between basic and compound modules as well as the restrictions imposed by the module specifications; more restrictive modules may be simpler to analyze, yet will guarantee the same properties as the stated variants.
0.903	[*A*]the restrictions[*R*]imposed[*A*]by the module specifications	context()	negated: False ,passive: True
[LINE#370] Second, it should be noted that it is straightforward to derive clocks of even higher frequency from the FATAL+ clocks.
[LINE#371] This is essentially done by frequency multiplication, at the expense of increasing the clock skew.
0.392	[*A*]This[*R*]is done[*A*]by frequency multiplication, at the expense of increasing the clock skew	context()	negated: False ,passive: True
[LINE#372] Overall, we consider the present work an important step towards a practical, ultra-robust clocking scheme for SoC.
0.614	[*A*]we[*R*]consider[*A*]the present work an important step towards a practical, ultra-robust clocking scheme for SoC	context()	negated: False ,passive: False
[LINE#373] We plan to address the open problems discussed above in the future, and hope that this will ultimately lead to dependable real-world systems clocked by variants of the scheme proposed in this article.
0.243	[*A*]this[*R*]will lead[*A*]to dependable real - world systems	context(We hope)	negated: False ,passive: False
0.279	[*A*]We[*R*]hope[*A*]that this will ultimately lead to dependable real - world systems	context()	negated: False ,passive: False
0.903	[*A*]the scheme[*R*]proposed[*A*]in this article	context()	negated: False ,passive: True
0.926	[*A*]dependable real - world systems[*R*]clocked[*A*]by variants of the scheme	context()	negated: False ,passive: True
0.397	[*A*]We[*R*]plan to address[*A*]the open problems discussed above in the future	context(We plan)	negated: False ,passive: False
0.467	[*A*]We[*R*]plan[*A*]to address the open problems	context()	negated: False ,passive: False
0.911	[*A*]the open problems[*R*]discussed[*A*]above[*A*]in the future	context()	negated: False ,passive: True
[LINE#374+375]  The operation of the TSM clock circuit shown in Fig. 13 is straightforward: In its initial state, TSMCStop=1 andthe Muller C-gate has 1 at its output, so TSMClock=0.
0.970	[*A*]The operation of the TSM clock circuit[*R*]shown[*A*]TSMClock=0	context()	negated: False ,passive: False
0.999	[*A*]TSMCStop=1[*R*]has[*A*]1	context()	negated: False ,passive: False
0.862	[*A*]The operation of the TSM clock circuit[*R*]is[*A*]straightforward	context(TSMCStop=1 has)	negated: False ,passive: True
0.906	[*A*]TSMCStop=1[*R*]has[*A*]1[*A*]at its output[*A*]In its initial state	context()	negated: False ,passive: False
0.961	[*A*]the TSM clock circuit[*R*]shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#376] Note that the circuit also stabilizes to the initial state if the Muller C-gate was erroneously initialized to 0, as the ring oscillator would eventually generate TSMClock=1, enforcing the correct initial value 1 of the C-gate.
0.861	[*A*]the ring oscillator[*R*]would generate TSMClock=1 enforcing[*A*]the correct initial value 1 of the C-gate	context(the ring oscillator would generate)	negated: False ,passive: False
0.917	[*A*]the ring oscillator[*R*]would generate[*A*]TSMClock=1[*A*]eventually	context()	negated: False ,passive: False
0.831	[*A*]the Muller C-gate[*R*]was erroneously initialized[*A*]to 0	context()	negated: False ,passive: True
[LINE#377] When the ASM requests a state transition, at some arbitrary time when a transition guard becomes true, it just sets TSMCStop=LOW.
0.761	[*A*]it[*R*]sets[*A*]TSMCStop=LOW[*A*]When the ASM requests a state transition, at some arbitrary time	context()	negated: False ,passive: False
0.948	[*A*]a transition guard[*R*]becomes[*A*]true[*A*]some arbitrary time	context()	negated: False ,passive: True
0.927	[*A*]the ASM[*R*]requests[*A*]a state transition, at some arbitrary time	context()	negated: False ,passive: False
[LINE#378] This starts the TSM clock and produces the first rising edge of TSMClock half a clock cycle time later.
0.495	[*A*]This[*R*]starts[*A*]the TSM clock	context()	negated: False ,passive: False
[LINE#379] As long as TSMCStop remains 0, the ring oscillator runs freely.
0.751	[*A*]the ring oscillator[*R*]runs freely	context()	negated: False ,passive: False
0.675	[*A*]TSMCStop[*R*]remains[*A*]0	context()	negated: False ,passive: True
[LINE#380] The stopping of TSMClock is regularly initiated by the TSM itself: With the rising edge of TSMClock that moves the TSM into Trm, TSMCStop is set to 1.
0.934	[*A*]The stopping of TSMClock[*R*]is regularly initiated[*A*]by the TSM	context(TSMCStop is set)	negated: False ,passive: True
0.616	[*A*]TSMCStop[*R*]is set[*A*]to 1	context()	negated: False ,passive: True
0.945	[*A*]the rising edge of TSMClock[*R*]moves[*A*]the TSM[*A*]into Trm	context()	negated: False ,passive: False
[LINE#381] Since TSMClock is also 1 after the rising edge,2626Obviously, we only have to take care in the timing analysis that setting TSMCStop=1 occurs well within the first half period.
0.913	[*A*]the timing analysis[*R*]setting[*A*]TSMCStop=1	context()	negated: False ,passive: False
0.887	[*A*]TSMClock[*R*]is[*A*]also[*A*]1 after the rising edge	context()	negated: False ,passive: True
[LINE#382] the output of the C-gate is forced to 1 as well.
0.993	[*A*]the output of the C-gate[*R*]is forced to[*A*]1 as well	context()	negated: False ,passive: False
0.856	[*A*]the output of the C-gate[*R*]is forced[*A*]to 1 as well	context()	negated: False ,passive: True
[LINE#383] Hence, after having finished the half period of this final clock cycle, the feedback loop is frozen and TSMClock remains 0.
0.675	[*A*]TSMClock[*R*]remains[*A*]0	context()	negated: False ,passive: True
0.961	[*A*]the feedback loop[*R*]is frozen[*A*]after having finished the half period of this final clock cycle	context()	negated: False ,passive: True
[LINE#384] Experimental evaluationOur prototype implementation has been written in VHDL and compiled for an Altera Cyclone IV FPGA using the Quartus tool, see [47].Since FPGAs neither natively provide the basic elements required for asynchronous designs nor allow the designer to exercise control over the actual mapping of functions to the available LUTs (we implemented threshold modules via LUTs rather than via combinational AND-OR networks for complexity reasons), we had to make sure that properties that hold naturally in "real" asynchronous implementations also hold here.
0.452	[*A*]we[*R*]implemented[*A*]threshold modules[*A*]via LUTs[*A*]for complexity reasons	context()	negated: False ,passive: False
0.846	[*A*]properties[*R*]hold naturally[*A*]in "real" asynchronous implementations	context(properties that hold naturally in " real " asynchronous implementations hold)	negated: False ,passive: False
0.860	[*A*]properties that hold naturally in "real" asynchronous implementations[*R*]hold[*A*]here	context()	negated: False ,passive: False
0.792	[*A*]Experimental evaluationOur prototype implementation[*R*]compiled	context()	negated: False ,passive: False
0.290	[*A*]we[*R*]to make[*A*]sure that properties that hold naturally in "real" asynchronous implementations also hold here	context()	negated: False ,passive: False
0.911	[*A*]the basic elements[*R*]required[*A*]for asynchronous designs	context()	negated: False ,passive: True
0.949	[*A*]Experimental evaluationOur prototype implementation[*R*]has been written[*A*]in VHDL	context()	negated: False ,passive: True
[LINE#385+386]  Apart from standard functional and timing verification via Modelsim, we therefore conducted some preliminary experiments for verifying the assumed properties (glitch-freeness, monotonicity, etc.)of the synthesized implementations of our core building blocks.
0.377	[*A*]we[*R*]conducted[*A*]some preliminary experiments for verifying the assumed properties ( glitch - freeness , monotonicity , etc. ) of the synthesized implementations of our core building blocks	context()	negated: False ,passive: False
[LINE#387+388]  Backed up by the (positive) results of these experiments, complete systems consisting of n=4tolerating at most f=1 respectively f=2 Byzantine faulty nodes) have been built and verified to work as expected; overall, they consume 23000 respectively 55000 logic blocks.
0.870	[*A*]complete systems consisting of n=4tolerating at most f=1 respectively f=2 Byzantine faulty nodes[*R*]have been built	context()	negated: False ,passive: False
0.937	[*A*]complete systems[*R*]consisting[*A*]of n=4tolerating at most f=1 respectively f=2 Byzantine faulty nodes	context()	negated: False ,passive: True
[LINE#389] Note however, that both designs also include the test environment, which makes up a significant part of the setup.
0.897	[*A*]the test environment[*R*]makes up[*A*]a significant part of the setup	context()	negated: False ,passive: False
[LINE#390] To facilitate systematic experiments, we developed a custom test bench that provides the following functionality:(1)Measurement of pulse frequency and skew at different nodes.(2)Continuous monitoring of the potential for generating metastability in HSM state transitions.(3)Starting the entire system from an arbitrary state (including memory flags and timers), either specified deterministically or chosen at random.(4)Resetting a single node to some initial state, at arbitrary times.(5)Varying the clock frequency of any oscillator, at arbitrary times.(6)Choosing the communication delay between each pair of sender and receiver.
0.480	[*A*]we[*R*]skew[*A*]at different nodes	context()	negated: False ,passive: False
0.905	[*A*]a custom test bench[*R*]provides[*A*]the following functionality	context()	negated: False ,passive: False
0.411	[*A*]we[*R*]Resetting[*A*]a single node[*A*]to some initial state[*A*]at arbitrary times	context()	negated: False ,passive: False
[LINE#391] All these experiments can be performed with Byzantine nodes.
0.751	[*A*]All these experiments[*R*]can be performed	context()	negated: False ,passive: False
[LINE#392] To this end, the HSMs of the Byzantine nodes can be replaced by special devices that allow to (possibly inconsistently) communicate, via the communication data buses, any HSM state to any receiver HSM at any time.
0.602	[*A*]special devices[*R*]allow possibly inconsistently	context()	negated: False ,passive: False
0.971	[*A*]the HSMs of the Byzantine nodes[*R*]can be replaced[*A*]by special devices[*A*]To this end	context()	negated: False ,passive: True
[LINE#393+394]  Points (1) to (6) are achieved as follows:(1) is accomplished using standard measurement equipment (logic analyzer, oscilloscope, frequency counter)attached to the appropriate signals routed via output pins.(2) is implemented by memorizing any event where more than one guard is enabled (at the time when the TSM locks a state transition) in a flag that can be externally monitored.(3) is realized by adding a scan-chain to the FPGA implementation, which allows us to serially shift-in arbitrary initial system states at run-time.
0.718	[*A*]standard measurement equipment[*R*]attached	context()	negated: False ,passive: False
0.944	[*A*]more than one guard[*R*]is enabled[*A*]at the time[*A*]any event	context()	negated: False ,passive: True
0.157	[*A*]us[*R*]to serially shift	context(a scan - chain allows)	negated: False ,passive: False
0.865	[*A*]a scan-chain[*R*]allows[*A*]us to serially shift-in arbitrary initial system states at run-time	context()	negated: False ,passive: False
0.939	[*A*]the TSM[*R*]locks[*A*]a state transition[*A*]the time	context()	negated: False ,passive: False
0.698	[*A*]a flag[*R*]can be externally monitored	context()	negated: False ,passive: False
0.751	[*A*]the appropriate signals[*R*]routed	context()	negated: False ,passive: False
0.818	[*A*]Points (1) to (6[*R*]are achieved[*A*]as follows	context()	negated: False ,passive: True
[LINE#395] Repeated random experiments are controlled via a Python script executed at a PC workstation, which is connected via USB to an ATMega 16 microcontroller (C) that acts as a scan-controller towards the FPGA.
0.954	[*A*]an ATMega 16 microcontroller[*R*]acts[*A*]as a scan-controller towards the FPGA	context()	negated: False ,passive: False
0.718	[*A*]a PC workstation[*R*]is connected	context()	negated: False ,passive: False
0.933	[*A*]a Python script[*R*]executed[*A*]at a PC workstation	context()	negated: False ,passive: True
0.751	[*A*]Repeated random experiments[*R*]are controlled	context()	negated: False ,passive: False
[LINE#396] For each experiment, the Python script generates a bit-stream representing an initial configuration.
0.919	[*A*]a bit-stream[*R*]representing[*A*]an initial configuration	context()	negated: False ,passive: False
0.933	[*A*]the Python script[*R*]generates[*A*]a bit-stream representing an initial configuration	context()	negated: False ,passive: False
[LINE#397] The C takes this stream, sends it to the FPGA via the serial scan-chain interface, and finally signals the FPGA to start execution of FATAL+.
0.897	[*A*]The C[*R*]signals[*A*]the FPGA[*A*]to start execution of FATAL+[*A*]finally	context()	negated: False ,passive: False
0.806	[*A*]The C[*R*]sends[*A*]it[*A*]to the FPGA	context()	negated: False ,passive: False
0.827	[*A*]The C[*R*]takes[*A*]this stream	context()	negated: False ,passive: False
[LINE#398] Simultaneously, it starts a timer.
0.522	[*A*]it[*R*]starts[*A*]a timer	context()	negated: False ,passive: False
[LINE#399] When a timeout occurs or the FPGA signals completion of the experiment, the C informs the Python script which records the time until completion together with the outcome of the experiment and proceeds with sending the next initial configuration.
0.922	[*A*]the Python script[*R*]records[*A*]the time	context()	negated: False ,passive: False
0.957	[*A*]the C[*R*]informs[*A*]the Python script[*A*]When a timeout occurs or the FPGA signals completion of the experiment	context()	negated: False ,passive: False
0.732	[*A*]a timeout[*R*]occurs	context()	negated: False ,passive: False
[LINE#400] To enable (4) to (6), the testbench provides a global high-resolution clock that can be used for triggering mode changes.
0.921	[*A*]a global high-resolution clock[*R*]can be used[*A*]for triggering mode changes	context()	negated: False ,passive: True
0.845	[*A*]the testbench[*R*]provides[*A*]a global high-resolution clock that can be used for triggering mode changes	context()	negated: False ,passive: False
[LINE#401] the various nodes' clocks, we replaced all start/stoppable ring oscillators by start/stoppable oscillators that derive their output from the global clock signal.
0.838	[*A*]start/stoppable oscillators[*R*]derive[*A*]their output from the global clock signal	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]replaced[*A*]all start/stoppable ring oscillators[*A*]by start/stoppable oscillators	context()	negated: False ,passive: False
[LINE#402] Point (4) is achieved by just forcing a node to reset to its initial state for this run at any time during the current execution.
0.835	[*A*]a node[*R*]to reset[*A*]to its initial state[*A*]for this run[*A*]at any time during the current execution	context()	negated: False ,passive: True
0.718	[*A*]Point (4[*R*]is achieved	context()	negated: False ,passive: False
[LINE#403] In order to facilitate (5), dividers combined with clock multipliers (PLLs) are used: For any oscillator, it is possible to choose one of five different frequencies (0, excessively slow, slow, fast, excessively fast) at any time.
0.894	[*A*]dividers[*R*]combined[*A*]with clock multipliers	context()	negated: False ,passive: True
[LINE#404] For (6), a variable delay line implemented as a synchronous shift register of length X[0,15], driven by the global clock, can be inserted in any data bus connecting different HSMs individually.
0.923	[*A*]any data bus[*R*]connecting individually[*A*]different HSMs	context()	negated: False ,passive: False
0.927	[*A*]a synchronous shift register of length X[*R*]driven[*A*]by the global clock	context()	negated: False ,passive: True
0.919	[*A*]a variable delay line[*R*]implemented[*A*]as a synchronous shift register of length X	context()	negated: False ,passive: True
[LINE#405+406]  In order to exercise also complex test scenarios in a reproducible way, a dedicated testbed execution state machine (TESM), driven by the global clock, is used to control the times and nodes when and where clock speeds,transmission delays, and communicated fault states are changed and when a single node is reset throughout an execution of the system.
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]nodes where fault states are changed	context()	negated: False ,passive: False
0.933	[*A*]fault states[*R*]are changed[*A*]nodes	context()	negated: False ,passive: True
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]nodes where communicated	context()	negated: False ,passive: False
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]nodes where transmission delays are changed	context()	negated: False ,passive: False
0.933	[*A*]transmission delays[*R*]are changed[*A*]nodes	context()	negated: False ,passive: True
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]nodes where clock speeds are changed	context()	negated: False ,passive: False
0.933	[*A*]clock speeds[*R*]are changed[*A*]nodes	context()	negated: False ,passive: True
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]nodes when fault states are changed	context()	negated: False ,passive: False
0.732	[*A*]fault states[*R*]are changed	context()	negated: False ,passive: False
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]is used[*A*]to control nodes when communicated	context()	negated: False ,passive: True
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]nodes when transmission delays are changed	context()	negated: False ,passive: False
0.732	[*A*]transmission delays[*R*]are changed	context()	negated: False ,passive: False
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]nodes when clock speeds are changed	context()	negated: False ,passive: False
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]is used[*A*]to control nodes	context()	negated: False ,passive: True
0.732	[*A*]clock speeds[*R*]are changed	context()	negated: False ,passive: False
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]the times where fault states are changed	context()	negated: False ,passive: False
0.933	[*A*]fault states[*R*]are changed[*A*]the times	context()	negated: False ,passive: True
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]the times where communicated	context()	negated: False ,passive: False
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]the times where transmission delays are changed	context()	negated: False ,passive: False
0.933	[*A*]transmission delays[*R*]are changed[*A*]the times	context()	negated: False ,passive: True
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]the times where clock speeds are changed	context()	negated: False ,passive: False
0.933	[*A*]clock speeds[*R*]are changed[*A*]the times	context()	negated: False ,passive: True
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]the times when fault states are changed	context()	negated: False ,passive: False
0.933	[*A*]fault states[*R*]are changed[*A*]the times	context()	negated: False ,passive: True
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]the times when communicated	context()	negated: False ,passive: False
0.917	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]are changed	context()	negated: False ,passive: False
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]the times when transmission delays are changed	context()	negated: False ,passive: False
0.933	[*A*]transmission delays[*R*]are changed[*A*]the times	context()	negated: False ,passive: True
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]to control[*A*]the times when clock speeds are changed	context()	negated: False ,passive: False
0.974	[*A*]a dedicated testbed execution state machine ( TESM ) , driven by the global clock[*R*]is used[*A*]to control the times	context()	negated: False ,passive: True
0.921	[*A*]a dedicated testbed execution state machine[*R*]driven[*A*]by the global clock	context()	negated: False ,passive: True
0.933	[*A*]clock speeds[*R*]are changed[*A*]the times	context()	negated: False ,passive: True
0.911	[*A*]a single node[*R*]is reset[*A*]throughout an execution of the system	context()	negated: False ,passive: True
[LINE#407] Transition guards may involve global time and any combinatorial expression of signals used in the implementation of FATAL+, i.e., any predicate on the current system state.
0.911	[*A*]signals[*R*]used[*A*]in the implementation of FATAL+	context()	negated: False ,passive: True
0.903	[*A*]Transition guards[*R*]may involve[*A*]any combinatorial expression of signals	context()	negated: False ,passive: True
0.903	[*A*]Transition guards[*R*]may involve[*A*]global time	context()	negated: False ,passive: True
[LINE#408] Using our testbench, it was not too difficult to get our FATAL+ implementation up and running.
0.350	[*A*]it[*R*]was not[*A*]too difficult to get our FATAL+ implementation running	context()	negated: True ,passive: True
0.350	[*A*]it[*R*]was not[*A*]too difficult to get our FATAL+ implementation up	context()	negated: True ,passive: True
[LINE#409]  With the implementation parameters =1.3, d=13T, dmin+=dmax+=3T, where T=400ns (2.5 MHz) is the experimental clock period, and minimal timeouts according to the constraints listed in [13].
0.767	[*A*]the constraints[*R*]listed[*A*]in [13	context()	negated: False ,passive: True
0.928	[*A*]T=400ns[*R*]is[*A*]the experimental clock period	context()	negated: False ,passive: True
[LINE#410]  Section 5.7), pulses of an 8 node.
0.896	[*A*]pulses[*R*]have an node of[*A*]8	context()	negated: False ,passive: False
[LINE#411] FATAL respectively FATAL+ system (including the quick cycle) occur at a frequency of about 62 Hz respectively 10 kHz.
0.929	[*A*]FATAL respectively FATAL+ system (including the quick cycle[*R*]occur[*A*]at a frequency of about 62 Hz	context()	negated: False ,passive: True
[LINE#412]  A logic analyzer screenshot is depicted in Fig..
0.931	[*A*]A logic analyzer screenshot[*R*]is depicted[*A*]in Fig	context()	negated: False ,passive: True
[LINE#413] Note that the quite low values for the frequency stem from the fact that we were intentionally slowing down the system, enabling better control of the execution.
0.293	[*A*]we[*R*]were intentionally slowing down the system enabling[*A*]better control of the execution	context(we were intentionally slowing down)	negated: False ,passive: False
0.388	[*A*]we[*R*]were intentionally slowing down[*A*]the system[*A*]enabling better control of the execution	context()	negated: False ,passive: False
[LINE#414] As to be expected from such a fairly complex setup, we spotted several hidden design errors that showed up during our experiments, but also some minor, yet problematic errors in our theoretical analysis (like a missing factor of  in one of our timeouts due to a typo).
0.905	[*A*]several hidden design errors[*R*]showed[*A*]problematic errors	context()	negated: False ,passive: False
0.208	[*A*]we[*R*]spotted[*A*]several hidden design errors that showed problematic errors in our theoretical analysis ( like a missing factor of in one of our timeouts due to a typo	context()	negated: False ,passive: False
0.905	[*A*]several hidden design errors[*R*]showed[*A*]some minor ( like a missing factor of	context()	negated: False ,passive: False
0.208	[*A*]we[*R*]spotted[*A*]several hidden design errors that showed some minor ( like a missing factor of in one of our timeouts due to a typo )	context()	negated: False ,passive: False
0.838	[*A*]several hidden design errors[*R*]showed up[*A*]during our experiments ( like a missing factor of	context()	negated: False ,passive: True
0.208	[*A*]we[*R*]spotted[*A*]several hidden design errors that showed up during our experiments ( like a missing factor of in one of our timeouts due to a typo )	context()	negated: False ,passive: False
[LINE#415] In the original setup, these issues manifested in deviations of the measured w.r.t. the predicted performance.
0.952	[*A*]these issues[*R*]manifested[*A*]in deviations of the measured w.r.t.[*A*]In the original setup	context()	negated: False ,passive: True
[LINE#416] After resolving them, we conducted the following experiments, observing the behavior of both the overall FATAL+ and the underlying FATAL pulse generation protocol..
0.333	[*A*]we[*R*]conducted the following experiments observing[*A*]the behavior of the underlying FATAL pulse generation protocol	context(we conducted)	negated: False ,passive: False
0.543	[*A*]we[*R*]conducted[*A*]the following experiments[*A*]observing the behavior of the underlying FATAL pulse generation protocol[*A*]After resolving them	context()	negated: False ,passive: False
0.333	[*A*]we[*R*]conducted the following experiments observing[*A*]the behavior of both the overall FATAL+	context(we conducted)	negated: False ,passive: False
0.425	[*A*]we[*R*]conducted[*A*]the following experiments[*A*]observing the behavior of both the overall FATAL+[*A*]After resolving them	context()	negated: False ,passive: False
[LINE#417+418]  skew experimentTo drive an 8-node FATAL system into a worst-case skewmaximal imprecision is meaningful in connection with the system's frequency only.
0.938	[*A*]skew experimentTo[*R*]drive[*A*]an 8-node FATAL system	context()	negated: False ,passive: False
[LINE#419] In contrast, the skew captures the maximal time difference between corresponding signal transitions at the nodes, which reflects the quality of synchronization without requiring additional context.
0.921	[*A*]corresponding signal transitions at the nodes[*R*]reflects[*A*]the quality of synchronization	context()	negated: False ,passive: True
[LINE#420] the set of nodes was split into four sets:A set A of two nodes with slow clock sources.
0.613	[*A*]sets:A[*R*]set[*A*]A of two nodes with slow clock sources	context()	negated: False ,passive: False
0.799	[*A*]the set of nodes[*R*]was split[*A*]into four	context()	negated: False ,passive: True
[LINE#421] All communication to these nodes is maximally delayed.A set B of two nodes with fast clock sources.
0.963	[*A*]delayed.A[*R*]set[*A*]B[*A*]of two nodes with fast clock sources[*A*]maximally	context(All communication to these nodes is)	negated: False ,passive: False
0.962	[*A*]All communication to these nodes[*R*]is[*A*]maximally delayed.A set B of two nodes with fast clock sources	context()	negated: False ,passive: True
[LINE#422+423]  All communication to these nodes is minimallydelayed.Another set C of two nodes with fast clock sources.
0.970	[*A*]All communication to these nodes[*R*]is[*A*]minimallydelayed.Another set C of two nodes with fast clock sources	context()	negated: False ,passive: True
[LINE#424] All communication to these nodes is maximally delayed.A set D of two faulty nodes.
0.963	[*A*]delayed.A[*R*]set[*A*]D[*A*]maximally	context(All communication to these nodes is)	negated: False ,passive: False
0.941	[*A*]All communication to these nodes[*R*]is[*A*]maximally delayed.A set D of two faulty nodes	context()	negated: False ,passive: True
[LINE#425+426+427]  These nodes always send propose to the nodes in B and do not send any other signals.3232In our model, this behavior is mapped to a default signal at the receivers, e.g. resync in the main state machine.
0.882	[*A*]These nodes[*R*]do not send[*A*]any other signals.3232	context(this behavior is mapped)	negated: True ,passive: False
0.937	[*A*]These nodes[*R*]send[*A*]propose[*A*]to the nodes in B[*A*]always	context(this behavior is mapped)	negated: False ,passive: False
0.909	[*A*]this behavior[*R*]is mapped[*A*]at the receivers , e.g. resync in the main state machine	context()	negated: False ,passive: True
[LINE#428] This setup leads to the following behavior of the main state machine (Fig. 8) once the system is stabilized.
0.732	[*A*]the system[*R*]is stabilized	context()	negated: False ,passive: False
0.903	[*A*]This setup[*R*]leads[*A*]to the following behavior of the main state machine	context()	negated: False ,passive: False
[LINE#429] The nodes in BC will always switch to propose first because their timeouts T3 expire (it is shown in [13] that at this time nexti=1 at all non-faulty nodes), and due to the "help" of the faulty nodes, the threshold of n-f=6 for switching to accept is reached at the nodes in B after the minimal delay.
0.966	[*A*]the threshold of n-f=6 for switching to accept[*R*]is reached[*A*]at the nodes in B[*A*]at this time	context(their timeouts T3 expire it is shown)	negated: False ,passive: True
0.188	[*A*]it[*R*]is shown[*A*]in [13	context(their timeouts T3 expire)	negated: False ,passive: True
0.292	[*A*]their timeouts[*R*]T3 expire	context()	negated: False ,passive: False
0.731	[*A*]The nodes in BC[*R*]will switch to propose[*A*]first	context(The nodes in BC will switch)	negated: False ,passive: False
0.814	[*A*]The nodes in BC[*R*]will switch[*A*]to propose first[*A*]because their timeouts T3 expire (it is shown in [13] that at this time nexti=1 at all non-faulty nodes), and due to the "help" of the faulty nodes, the threshold of n-f=6 for switching to accept is reached at the nodes in B[*A*]always	context()	negated: False ,passive: False
[LINE#430] It takes the maximal delay until the nodes in A realize that 4f+1 nodes reached state propose and switch to this state.
0.894	[*A*]nodes[*R*]reached[*A*]state switch to this state	context()	negated: False ,passive: False
0.894	[*A*]nodes[*R*]reached[*A*]state propose	context()	negated: False ,passive: False
0.452	[*A*]It[*R*]takes[*A*]the maximal delay until the nodes in A realize	context()	negated: False ,passive: False
[LINE#431] Since 4<n-f, the nodes in AC require the support of the nodes in A to follow to state accept.
0.816	[*A*]the support of the nodes in A[*R*]to follow	context()	negated: False ,passive: False
0.965	[*A*]the nodes in AC[*R*]require[*A*]the support of the nodes in A[*A*]Since 4	context()	negated: False ,passive: False
[LINE#432] Hence, this happens another maximal delay later.
0.381	[*A*]this[*R*]happens[*A*]another maximal delay later	context()	negated: False ,passive: True
[LINE#433] The resulting scenario is depicted in Fig. 16.
0.925	[*A*]The resulting scenario[*R*]is depicted[*A*]in Fig	context()	negated: False ,passive: True
[LINE#434] Assuming that the communication delay is at most d and at least dmin0, we predict a skew of at most 2d-dmin between the nodes in B switching to accept and the nodes in AC catching up.
0.550	[*A*]we[*R*]predict[*A*]a skew of at most 2d - dmin between the nodes in B switching to accept and the nodes in AC	context()	negated: False ,passive: False
[LINE#435] The experimental results confirmed the analytic predictions as being essentially tight: Letting the fast nodes run at a speed of 3 MHz and the slow nodes at 2.5 MHz, and setting the maximum delay d to about 3.6 s (9 clock cycles), we observed a skew of about 6 s.
0.888	[*A*]The experimental results[*R*]confirmed[*A*]the analytic predictions[*A*]as being essentially tight	context(we observed)	negated: False ,passive: False
0.888	[*A*]The experimental results[*R*]confirmed[*A*]the analytic predictions[*A*]as being essentially tight	context(we observed)	negated: False ,passive: False
0.626	[*A*]we[*R*]have a skew of[*A*]about 6 s	context()	negated: False ,passive: False
0.888	[*A*]The experimental results[*R*]confirmed[*A*]the analytic predictions[*A*]as being essentially tight	context(we observed)	negated: False ,passive: False
0.388	[*A*]we[*R*]observed[*A*]a skew of about 6	context()	negated: False ,passive: False
0.903	[*A*]a speed[*R*]setting[*A*]the maximum delay d[*A*]to about 3.6 s	context()	negated: False ,passive: False
[LINE#436] This is consistent with the relatively large minimum delay dmin arising in our testbed.
0.882	[*A*]the relatively large minimum delay dmin[*R*]arising[*A*]in our testbed	context()	negated: False ,passive: True
0.449	[*A*]This[*R*]is[*A*]consistent with the relatively large minimum delay dmin	context()	negated: False ,passive: True
[LINE#437+438]  A logic analyzer screenshot is depicted in Fig.17.The figure also demonstrates the capability of FATAL+ to generate pulses with significantly less skew (1 s) on top of the FATAL pulses with worst-case skew. .
0.931	[*A*]A logic analyzer screenshot[*R*]is depicted[*A*]in Fig.17.The figure	context()	negated: False ,passive: True
[LINE#439] Metastability experimentsWe run a series of experiments dedicated to finding situations that potentially lead to metastable upsets.
0.877	[*A*]situations[*R*]lead[*A*]to metastable upsets	context()	negated: False ,passive: False
0.894	[*A*]experiments[*R*]dedicated[*A*]to finding situations	context()	negated: False ,passive: True
0.925	[*A*]Metastability experimentsWe[*R*]run[*A*]a series of experiments	context()	negated: False ,passive: False
[LINE#440] We repeatedly set up 8-node systems with randomly chosen clock speeds between 2.5 MHz and 3.25 MHz and communication delays of at most 16 clock cycles.
0.999	[*A*]We[*R*]set[*A*]8 - node systems	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]repeatedly set up[*A*]8-node systems	context()	negated: False ,passive: False
[LINE#441] While the system stabilized from these random initial states, we monitored the nodes' HSM state transitions after stabilization for multiple active conflicting state transitions during a period of over 60 h in total.
0.498	[*A*]we[*R*]monitored[*A*]the nodes' HSM state transitions[*A*]after stabilization for multiple active conflicting state transitions[*A*]during a period of over 60 h in total	context()	negated: False ,passive: False
0.903	[*A*]the system[*R*]stabilized[*A*]from these random initial states	context()	negated: False ,passive: True
[LINE#442] As predicted by our theoretical findings, in none of the experiments two conflicting guards were ever active at the same (global testbench) time after stabilization. .
0.948	[*A*]two conflicting guards[*R*]were[*A*]ever active[*A*]at the same (global testbench[*A*]in none of the experiments	context()	negated: False ,passive: True
[LINE#443] Stabilization time experimentsWe evaluated stabilization time both in the absence and in the presence of faulty nodes.
0.953	[*A*]experimentsWe[*R*]evaluated[*A*]stabilization time[*A*]both in the presence of faulty nodes[*A*]Stabilization time	context()	negated: False ,passive: False
0.953	[*A*]experimentsWe[*R*]evaluated[*A*]stabilization time[*A*]both in the absence[*A*]Stabilization time	context()	negated: False ,passive: False
[LINE#444] In the latter case, we demonstrated the influence of the choice of the random timeout R3 on the stabilization time..
0.702	[*A*]we[*R*]demonstrated[*A*]the influence of the choice of the random timeout R3 on the stabilization time[*A*]In the latter case	context()	negated: False ,passive: False
[LINE#445+446]  Stabilization in the absence of faulty nodesTo evaluate stabilization times in the absence of faulty nodes, we set up an 8 node system and run over 250000 experiments in each of which the nodes booted from random initial states, with randomly chosen clock speeds between 2.5 MHz and 3.25MHz=2.5MHz, and message delays of up to d=16 clock cycles.
0.435	[*A*]we[*R*]run[*A*]up to d=16 clock cycles	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]set up[*A*]an 8 node system	context()	negated: False ,passive: False
0.932	[*A*]Stabilization in the absence of faulty[*R*]nodesTo evaluate[*A*]stabilization times[*A*]in the absence of faulty nodes	context()	negated: False ,passive: False
[LINE#447] As soon as all nodes switched to state accept within 2d time, the FPGA signaled the C to record the elapsed time and start the next experiment.
0.907	[*A*]the FPGA[*R*]signaled the C to start[*A*]the next experiment	context(the FPGA signaled)	negated: False ,passive: False
0.965	[*A*]the FPGA[*R*]signaled[*A*]the C[*A*]to start the next experiment[*A*]As soon as all nodes switched to state accept within 2 d time	context()	negated: False ,passive: False
0.907	[*A*]the FPGA[*R*]signaled the C to record[*A*]the elapsed time	context(the FPGA signaled)	negated: False ,passive: False
0.965	[*A*]the FPGA[*R*]signaled[*A*]the C[*A*]to record the elapsed time[*A*]As soon as all nodes switched to state accept within 2 d time	context()	negated: False ,passive: False
0.903	[*A*]all nodes[*R*]switched[*A*]to state	context()	negated: False ,passive: False
[LINE#448] A considerable fraction of the scenarios (over 45%) stabilizes within less than 0.035 s (less than 5500d), which can be credited to the fast stabilization mechanism intended for individual nodes resynchronizing to a running system (see Fig. 18).
0.903	[*A*]individual nodes[*R*]resynchronizing[*A*]to a running system	context()	negated: False ,passive: False
0.919	[*A*]the fast stabilization mechanism[*R*]intended[*A*]for individual nodes	context()	negated: False ,passive: True
0.905	[*A*]less than 0.035 s[*R*]can be credited[*A*]to the fast stabilization mechanism	context()	negated: False ,passive: True
0.773	[*A*]A considerable fraction of the scenarios[*R*]stabilizes	context()	negated: False ,passive: False
[LINE#449+450]  The remaining runs (see Fig. 19; please mind the different y-axis scale) stabilize, supported by the resynchronization routine, in less than 12 s (about 1.9106d), which is less than the system's upper bound on R3 of approximately 14.9 s (about 2.3106d) and significantly less than the system's upper bound on Tslow given in Theorem 5.2, which is no more than 44.5 s (about 7106d) in this scenario.
0.934	[*A*]Theorem 5.2[*R*]is[*A*]no more than 44.5 s	context()	negated: False ,passive: True
0.961	[*A*]the system 's upper bound on Tslow[*R*]given[*A*]in Theorem 5.2	context()	negated: False ,passive: True
0.961	[*A*]less than 12 s[*R*]is[*A*]less than the system significantly less than the system 's upper bound on Tslow	context()	negated: False ,passive: True
0.927	[*A*]less than 12 s[*R*]is[*A*]less than the system 's	context()	negated: False ,passive: True
[LINE#451+452]  Note that the stabilization time is inversely proportional to the frequency,i.e., in a system that is not artificially slowed down, stabilization is orders of magnitude faster.
0.698	[*A*]a system[*R*]is not artificially slowed down	context()	negated: True ,passive: False
[LINE#453] For example, assuming d=1ns, we obtain that over 45% of the experiments stabilize within 5.5 s, and all experiments stabilize within 1.9 ms.
0.756	[*A*]over 45 % of all experiments[*R*]stabilize	context(we obtain)	negated: False ,passive: False
0.271	[*A*]we[*R*]obtain[*A*]that over 45 % of all experiments stabilize within 1.9 ms.	context()	negated: False ,passive: False
0.756	[*A*]over 45 % of the experiments[*R*]stabilize	context(we obtain)	negated: False ,passive: False
0.271	[*A*]we[*R*]obtain[*A*]that over 45 % of the experiments stabilize within 5.5 s	context()	negated: False ,passive: False
[LINE#454] Experimental results carried out for a 4-node system were analogous.
0.814	[*A*]a 4-node system[*R*]were[*A*]analogous	context()	negated: False ,passive: True
0.903	[*A*]Experimental results[*R*]carried out[*A*]for a 4-node system	context()	negated: False ,passive: False
[LINE#455] Either the main algorithm was capable to stabilize by itself (as for a large fraction the experiments in the head of the distribution), or once the resynchronization algorithm provided support after R3 expired at some node and n-f nodes switched to resync in approximate synchrony (the experiments in the tail of the distribution).
0.919	[*A*]n-f nodes[*R*]switched[*A*]to resync[*A*]in approximate synchrony	context()	negated: False ,passive: True
0.855	[*A*]R3[*R*]expired[*A*]at some node and n-f nodes	context()	negated: False ,passive: True
0.952	[*A*]the resynchronization algorithm[*R*]provided[*A*]support[*A*]after R3 expired at some node and n-f nodes	context()	negated: False ,passive: False
0.718	[*A*]the main algorithm[*R*]to stabilize	context()	negated: False ,passive: False
0.922	[*A*]the main algorithm[*R*]was[*A*]capable to stabilize by itself (as for a large fraction the experiments in the head of the distribution	context()	negated: False ,passive: True
[LINE#456]  20 shows stabilization by the resynchronization algorithm in a 4-node system:.
[LINE#457] Eventually, all nodes switch to state none.
0.957	[*A*]all nodes[*R*]switch[*A*]to state none[*A*]Eventually	context()	negated: False ,passive: False
[LINE#458] A node whose timeout R3 expires at a time when all timeouts (R2,supp) are expired, say node 1, forces all nodes from none into supp1.
0.863	[*A*]node 1[*R*]forces[*A*]all nodes from none into supp1	context(A node whose timeout R3 expires at a time say)	negated: False ,passive: False
0.952	[*A*]A node whose timeout R3 expires at a time[*R*]say[*A*]node 1, forces all nodes from none into supp1	context()	negated: False ,passive: False
0.921	[*A*]all timeouts[*R*]are expired[*A*]a time	context()	negated: False ,passive: True
0.887	[*A*]A node[*R*]expires[*A*]at a time	context()	negated: False ,passive: True
[LINE#459] Additional R3 timers, expiring at other nodes, may only force nodes into suppj, with j1, but do not prevent nodes from eventually communicating supp to all other nodes.
0.927	[*A*]nodes[*R*]communicating[*A*]supp[*A*]to all other nodes[*A*]eventually	context()	negated: False ,passive: False
0.903	[*A*]Additional R3[*R*]do not prevent[*A*]nodes[*A*]from eventually communicating supp to all other nodes	context()	negated: True ,passive: False
0.902	[*A*]Additional R3 timers , expiring at other nodes[*R*]may force[*A*]nodes[*A*]into suppj	context()	negated: False ,passive: False
0.897	[*A*]Additional R3 timers[*R*]expiring[*A*]at other nodes	context()	negated: False ,passive: True
[LINE#460] Thus nodes finally switch to suppresync and from there to resync, in synchrony.
0.705	[*A*]nodes[*R*]switch[*A*]from there[*A*]to resync[*A*]finally	context()	negated: False ,passive: True
[LINE#461] This again suffices to deterministically stabilize the nodes' main algorithm (as shown in [13]).
0.391	[*A*]This[*R*]suffices to deterministically stabilize[*A*]the nodes' main algorithm (as shown in [13]	context(This suffices)	negated: False ,passive: False
0.417	[*A*]This[*R*]suffices[*A*]to deterministically stabilize the nodes' main algorithm[*A*]again	context()	negated: False ,passive: False
[LINE#462] Note that the condition that all corresponding R2 timeouts are expired when a timeout R3 expires (actually, n-f suffice) will eventually be satisfied.
0.939	[*A*]that the condition that all corresponding R2 timeouts are expired when a timeout R3 expires[*R*]will be[*A*]satisfied[*A*]eventually	context()	negated: False ,passive: True
0.698	[*A*]a timeout[*R*]expires	context()	negated: False ,passive: False
0.818	[*A*]all corresponding R2 timeouts[*R*]are expired	context()	negated: False ,passive: False
[LINE#463] This happens at the latest when R3 expires for the second time at some node, simply because the distribution of the randomized timeout R3 guarantees that the picked duration is always larger than (roughly) R2. .
0.942	[*A*]the picked duration[*R*]is[*A*]always[*A*]larger than (roughly) R2	context()	negated: False ,passive: True
0.855	[*A*]R3[*R*]expires[*A*]for the second time[*A*]at some node	context()	negated: False ,passive: True
0.543	[*A*]This[*R*]happens[*A*]at the latest[*A*]when R3 expires for the second time at some node	context()	negated: False ,passive: True
[LINE#464] Stabilization with Byzantine nodes and deterministic timeoutsThe importance of timeout R3 being randomly distributed is demonstrated in the following experiment.
0.934	[*A*]Stabilization with deterministic timeoutsThe importance of timeout R3[*R*]is demonstrated[*A*]in the following experiment	context()	negated: False ,passive: True
0.801	[*A*]deterministic timeoutsThe importance of timeout R3[*R*]being randomly distributed	context()	negated: False ,passive: False
0.905	[*A*]Stabilization with Byzantine nodes[*R*]is demonstrated[*A*]in the following experiment	context()	negated: False ,passive: True
0.732	[*A*]Byzantine nodes[*R*]being randomly distributed	context()	negated: False ,passive: False
[LINE#465+466]  We set up a 4-node FATAL+ system with one Byzantine faulty node, say node 4, and chose all R3 to be equal and initially synchronized, i.e., all R3 timeouts expire at about the same time at all correct nodes.
0.817	[*A*]all R3[*R*]to be[*A*]initially synchronized	context()	negated: False ,passive: True
0.498	[*A*]We[*R*]chose[*A*]all R3[*A*]to be initially synchronized	context()	negated: False ,passive: False
0.817	[*A*]all R3[*R*]to be[*A*]equal	context()	negated: False ,passive: True
0.498	[*A*]We[*R*]chose[*A*]all R3[*A*]to be equal	context()	negated: False ,passive: False
0.933	[*A*]all R3 timeouts[*R*]expire[*A*]at about the same time	context()	negated: False ,passive: True
0.442	[*A*]We[*R*]set up[*A*]a 4 - node FATAL+ system[*A*]node 4	context(We set up a 4 - node FATAL+ system with one Byzantine faulty node say)	negated: False ,passive: False
0.437	[*A*]We set up a 4 - node FATAL+ system with one Byzantine faulty node[*R*]say	context()	negated: False ,passive: False
[LINE#467] If the Byzantine node knows when R3 is going to expire, it can prohibit correct nodes from simultaneously switching to resync, thereby preventing synchronization of the Main Algorithm and thus stabilization: Shortly before R3 expires at the correct nodes, it sends init to two nodes, say 1 and 3, making them switch to supp4.
0.798	[*A*]correct nodes[*R*]switching to resync preventing[*A*]synchronization of thus stabilization	context(correct nodes switching)	negated: False ,passive: False
0.457	[*A*]them[*R*]switch[*A*]to supp4	context(it can prohibit correct nodes from simultaneously switching to resync , thereby preventing synchronization of the Main Algorithm : Shortly before R3 expires at the correct nodes , it sends init to two nodes say 3 making)	negated: False ,passive: False
0.178	[*A*]3[*R*]making[*A*]them switch to supp4	context(it can prohibit correct nodes from simultaneously switching to resync , thereby preventing synchronization of the Main Algorithm : Shortly before R3 expires at the correct nodes , it sends init to two nodes say)	negated: False ,passive: False
0.388	[*A*]it[*R*]can prohibit[*A*]correct nodes[*A*]from simultaneously switching to resync	context(it can prohibit correct nodes from simultaneously switching to resync , thereby preventing synchronization of the Main Algorithm : Shortly before R3 expires at the correct nodes , it sends init to two nodes say)	negated: False ,passive: False
0.457	[*A*]it[*R*]sends[*A*]init[*A*]to two nodes	context(it can prohibit correct nodes from simultaneously switching to resync , thereby preventing synchronization of the Main Algorithm : Shortly before R3 expires at the correct nodes , it sends init to two nodes say)	negated: False ,passive: False
0.924	[*A*]it can prohibit correct nodes from simultaneously switching to resync , thereby preventing synchronization of the Main Algorithm : Shortly before R3 expires at the correct nodes , it sends init to two nodes[*R*]say[*A*]3	context()	negated: False ,passive: True
0.826	[*A*]correct nodes[*R*]switching to resync preventing[*A*]synchronization of the Main Algorithm	context(correct nodes switching)	negated: False ,passive: False
0.915	[*A*]correct nodes[*R*]switching[*A*]to resync[*A*]simultaneously	context()	negated: False ,passive: False
0.388	[*A*]it[*R*]can prohibit[*A*]correct nodes[*A*]from simultaneously switching to resync	context(it sends)	negated: False ,passive: False
0.457	[*A*]it[*R*]sends[*A*]init[*A*]to two nodes	context()	negated: False ,passive: False
0.594	[*A*]R3[*R*]to expire	context()	negated: False ,passive: False
0.947	[*A*]the Byzantine node[*R*]knows[*A*]when R3 is going to expire	context()	negated: False ,passive: False
[LINE#468] Subsequently, however, it only supports node 1 by sending supp to it.
0.554	[*A*]it[*R*]supports[*A*]node 1[*A*]Subsequently	context()	negated: False ,passive: False
[LINE#469] This forces node 1 to switch to suppresync and then resync alone.
0.999	[*A*]This forces[*R*]node[*A*]1 then resync alone	context()	negated: False ,passive: False
0.761	[*A*]This forces[*R*]node then resync alone[*A*]1	context()	negated: False ,passive: False
0.999	[*A*]This forces[*R*]node[*A*]1	context()	negated: False ,passive: False
0.878	[*A*]This forces[*R*]node 1 to switch[*A*]to suppresync	context(This forces node)	negated: False ,passive: False
0.878	[*A*]This forces[*R*]node[*A*]1[*A*]to switch to suppresync	context()	negated: False ,passive: False
[LINE#470] While node 1 is in resync (i.e., while R1 is running), it does not support other nodes by sending supp.
0.452	[*A*]it[*R*]does not support[*A*]other nodes	context()	negated: True ,passive: False
0.937	[*A*]node 1[*R*]is[*A*]in resync (i.e., while R1 is running	context()	negated: False ,passive: True
[LINE#471] Specifically, it does not support nodes 2 and 3 when they switch to supp1.
0.309	[*A*]it[*R*]does not support[*A*]nodes 3[*A*]when they switch to supp1	context()	negated: True ,passive: False
0.680	[*A*]they[*R*]switch[*A*]to supp1	context()	negated: False ,passive: False
0.309	[*A*]it[*R*]does not support[*A*]nodes 2[*A*]when they switch to supp1	context()	negated: True ,passive: False
[LINE#472] Eventually all nodes switch back to none, and the scenario can be repeated.
0.732	[*A*]the scenario[*R*]can be repeated	context()	negated: False ,passive: False
0.957	[*A*]all nodes[*R*]switch[*A*]back to none[*A*]Eventually	context()	negated: False ,passive: False
[LINE#473+474]  21 depicts the scenario and Fig.22 shows a logic analyzer screenshot of this experiment.
0.918	[*A*]Fig.22[*R*]shows[*A*]a logic analyzer screenshot of this experiment	context()	negated: False ,passive: False
0.544	[*A*]21[*R*]depicts[*A*]the scenario	context()	negated: False ,passive: False
[LINE#475] Note, however, that by definition of the probability distribution of R3, executions where R3 expires in synchrony at all correct nodes forever occur with probability 0.We remark that there is always a nonzero probability that the randomly chosen durations of the timeouts R3 at non-faulty nodes align in a fortunate manner, so that stabilization could not be prevented even by an omniscient adversary orchestrating clock drifts, message delays, and faulty nodes.
0.911	[*A*]an omniscient adversary[*R*]orchestrating[*A*]clock faulty nodes	context()	negated: False ,passive: False
0.903	[*A*]omniscient adversary[*R*]orchestrating[*A*]clock message delays	context()	negated: False ,passive: True
0.894	[*A*]stabilization[*R*]could not be prevented[*A*]even by an omniscient adversary orchestrating clock message delays	context()	negated: True ,passive: True
0.911	[*A*]an omniscient adversary[*R*]orchestrating[*A*]clock drifts	context()	negated: False ,passive: False
0.894	[*A*]stabilization[*R*]could not be prevented[*A*]even by an omniscient adversary	context()	negated: True ,passive: True
0.855	[*A*]R3[*R*]expires[*A*]in synchrony[*A*]at all correct nodes	context()	negated: False ,passive: True
0.789	[*A*]the randomly chosen durations of the timeouts[*R*]align	context()	negated: False ,passive: False
[LINE#476+477]  While the probability of such a convenient event occurring in O(n) time decreases exponentially in the number of nodes n, it is reasonably likely for n=7 andin particular n=4 (i.e., systems that tolerate f=2 or f=1 faults, respectively).
0.894	[*A*]i.e., systems[*R*]tolerate respectively[*A*]f=2 or f=1 faults	context()	negated: False ,passive: False
0.522	[*A*]it[*R*]is[*A*]reasonably likely for n=7 andin particular n=4	context()	negated: False ,passive: True
0.925	[*A*]the probability of such a convenient event[*R*]decreases n[*A*]exponentially[*A*]in the number of nodes	context()	negated: False ,passive: True
0.931	[*A*]such a convenient event[*R*]occurring[*A*]in O[*A*]n) time	context()	negated: False ,passive: True
[LINE#478] This observation has been verified for n=4 by the first of the two experiments below. .
0.903	[*A*]This observation[*R*]has been verified[*A*]for n=4[*A*]by the first of the two experiments below	context()	negated: False ,passive: True
[LINE#479] Stabilization with Byzantine nodes and probabilistic timeoutsTwo experimental setups were chosen to test stabilization in the presence of Byzantine nodes, using probabilistic timeouts R3 for correct nodes.
0.887	[*A*]experimental setups[*R*]using[*A*]probabilistic timeouts	context()	negated: False ,passive: False
0.905	[*A*]experimental setups[*R*]to test[*A*]stabilization in the presence of Byzantine nodes	context()	negated: False ,passive: False
0.918	[*A*]experimental setups[*R*]were chosen[*A*]to test stabilization in the presence of Byzantine nodes	context()	negated: False ,passive: True
[LINE#480] In the first experiment, a Byzantine node has access to the timeout values of all nodes as soon as they start their R3 timers.
0.535	[*A*]they[*R*]start[*A*]their R3 timers	context()	negated: False ,passive: False
0.930	[*A*]a Byzantine node[*R*]has[*A*]access to the timeout values of all nodes[*A*]as soon as they start their R3 timers[*A*]In the first experiment	context()	negated: False ,passive: False
[LINE#481] In this case, the Byzantine node followed the strategy from before, obstructing any stabilization attempt that would otherwise be successful.
0.666	[*A*]any stabilization attempt[*R*]would be[*A*]successful	context()	negated: False ,passive: True
0.760	[*A*]the Byzantine node[*R*]obstructing[*A*]any stabilization attempt that would otherwise be successful	context()	negated: False ,passive: False
0.948	[*A*]the Byzantine node[*R*]followed[*A*]the strategy[*A*]obstructing any stabilization attempt[*A*]In this case	context()	negated: False ,passive: True
[LINE#482] We observed that the Byzantine node was able to block at most one stabilization attempt of each non-faulty node.
0.960	[*A*]the Byzantine node[*R*]was[*A*]able to block at most one stabilization attempt of each non-faulty node	context(We observed)	negated: False ,passive: True
0.317	[*A*]We[*R*]observed[*A*]that the Byzantine node was able to block at most one stabilization attempt of each non-faulty node	context()	negated: False ,passive: False
0.922	[*A*]the Byzantine node[*R*]to block[*A*]at most one stabilization attempt of each non-faulty node	context()	negated: False ,passive: False
[LINE#483] Then it failed to prevent stabilization because the R2 timeouts corresponding to the Byzantine node did not expire on time before some non-faulty node successfully initialized stabilization.
0.911	[*A*]some non-faulty node[*R*]successfully initialized[*A*]stabilization	context()	negated: False ,passive: False
0.922	[*A*]the R2 timeouts[*R*]did not expire[*A*]on time[*A*]before some non-faulty node successfully initialized stabilization	context()	negated: True ,passive: True
0.944	[*A*]the R2 timeouts[*R*]corresponding[*A*]to the Byzantine node	context()	negated: False ,passive: True
0.411	[*A*]it[*R*]to prevent[*A*]stabilization	context()	negated: False ,passive: False
0.740	[*A*]it[*R*]failed[*A*]to prevent stabilization because the R2 timeouts corresponding to the Byzantine node did not expire on time[*A*]Then	context()	negated: False ,passive: True
[LINE#484] In the second experiment, the Byzantine node has no access to timeout values, and therefore simply sends inconsistent init and supp signals as often as allowed by the timeouts R2 corresponding to it.
0.810	[*A*]the timeouts[*R*]corresponding[*A*]to it	context()	negated: False ,passive: True
0.960	[*A*]the Byzantine node[*R*]has[*A*]no access to timeout values[*A*]In the second experiment	context()	negated: False ,passive: False
[LINE#485] We did not observe any inhibited synchronized switch to resync when R3 expired at a correct node, however.
0.855	[*A*]R3[*R*]expired[*A*]at a correct node	context()	negated: False ,passive: True
0.498	[*A*]We[*R*]did not observe[*A*]any inhibited synchronized switch to resync[*A*]when R3 expired at a correct node[*A*]however	context()	negated: True ,passive: False
[LINE#486]  It should be noted that weaker adversaries and "better" initial configurations result in a constant stabilization time, irrespectively of the number of nodes n.
[LINE#487] The second experiment above demonstrates such a case; Theorem 5.3 states another.
0.919	[*A*]The second experiment above[*R*]demonstrates[*A*]such a case	context()	negated: False ,passive: False
[LINE#488] The common-case stabilization time will therefore be considerably smaller than the (probabilistic) worst-case bound that is linear in n.
0.868	[*A*]the (probabilistic) worst-case bound[*R*]is[*A*]linear	context()	negated: False ,passive: True
0.935	[*A*]The common-case stabilization time[*R*]will be[*A*]considerably smaller than the (probabilistic) worst-case	context()	negated: False ,passive: True
[LINE#489] Formal specification of clock synchronization protocolsIn the formal framework introduced above, a node is simply a compound module that will operate according to some specification whenever it is non-faulty.
0.278	[*A*]it[*R*]is[*A*]non-faulty	context()	negated: False ,passive: True
0.797	[*A*]a compound module[*R*]will operate[*A*]whenever it is non-faulty	context()	negated: False ,passive: True
0.879	[*A*]a node[*R*]is[*A*]simply[*A*]a compound module that will operate according to some specification	context()	negated: False ,passive: True
0.783	[*A*]the formal framework[*R*]introduced[*A*]above	context()	negated: False ,passive: True
[LINE#490] We now specify the submodules of a node introduced informally in Section 2.2 and reveal how they are connected.
0.903	[*A*]a node[*R*]introduced informally[*A*]in Section 2.2	context()	negated: False ,passive: True
0.554	[*A*]We[*R*]specify[*A*]the submodules of a node[*A*]now	context()	negated: False ,passive: False
[LINE#491+492]  The reader might want to take a look at Fig.5 to get an idea of the general layout of a node at this point.
0.882	[*A*]The reader[*R*]might want to take to get[*A*]an idea of the general layout of a node at this point	context(The reader might want to take)	negated: False ,passive: False
0.920	[*A*]The reader[*R*]might want to take[*A*]a look at Fig.5[*A*]to get an idea of the general layout of a node at this point	context(The reader might want)	negated: False ,passive: False
0.920	[*A*]The reader[*R*]might want[*A*]to take a look at Fig.5 to get an idea of the general layout of a node at this point	context()	negated: False ,passive: False
[LINE#493] Si,j, where j[1..n], and n+1 output ports, namely Li and Sj,i for all j[1..n].
0.999	[*A*]Si[*R*]j[*A*]1 .. n	context()	negated: False ,passive: False
0.867	[*A*]Si[*R*]j[*A*]1 .. n ] , and n+1 output ports	context()	negated: False ,passive: False
[LINE#494] We present all submodules as basic modules whose specifications are sufficiently strong to implement the model used in [13].
0.767	[*A*]the model[*R*]used[*A*]in [13	context()	negated: False ,passive: True
0.887	[*A*]basic modules[*R*]are[*A*]sufficiently strong to implement the model	context()	negated: False ,passive: True
0.452	[*A*]We[*R*]present[*A*]all submodules as basic modules	context()	negated: False ,passive: False
[LINE#495] As a result, not all specifications can be satisfied by (physical) implementations of the modules for all input executions; we discuss these limitations and their implications in Section 6.
0.256	[*A*]we[*R*]discuss[*A*]their implications[*A*]in Section 6	context()	negated: False ,passive: False
0.929	[*A*]not all specifications[*R*]can be satisfied[*A*]by ( physical ) implementations of the modules for all input executions	context(we discuss)	negated: False ,passive: True
0.397	[*A*]we[*R*]discuss[*A*]these limitations	context()	negated: False ,passive: False
[LINE#496] All of the following specifications are extendable and therefore, by Lemma 3.3, are uniquely characterized by describing them on executions on R only.
0.814	[*A*]All of the following specifications[*R*]are[*A*]extendable	context()	negated: False ,passive: True
[LINE#497] It is trivial to verify non-emptyness for the given specifications, hence omit respective discussions.Communication channels.
[LINE#498]  For each j[1..n], there is a communication channel of delay dChanR+ from node i's internal port.
[LINE#499] Formally, this communication channel is a basic module with input port Si and output port Sj,i.
0.942	[*A*]this communication channel[*R*]is[*A*]a basic module with input output port Sj	context()	negated: False ,passive: True
0.942	[*A*]this communication channel[*R*]is[*A*]a basic module with input port Si	context()	negated: False ,passive: True
[LINE#500] The module specification Chan of the communication channel is as follows.
0.913	[*A*]The module specification Chan of the communication channel[*R*]is[*A*]as follows	context()	negated: False ,passive: True
[LINE#501] Let Ein be an execution of input port Si and Eout an execution of output port Sj,i.
[LINE#502+503]  Then EoutChan(Ein) iff there exists a continuous, strictly increasing (and thus invertible) delay function .
[LINE#504] Sj,i(t)=Si(-1(t)) and (ii) 0t--1(t)<dChan hold.
0.697	[*A*]dChan[*R*]hold	context()	negated: False ,passive: False
0.717	[*A*]< dChan[*R*]hold	context()	negated: False ,passive: False
[LINE#505] It is important to note that the assumptions on the communication channels are strictly weaker than those on fixed-delay channels, as the delay of a communication channel may vary arbitrarily (within bounds) during an execution.Memory flags.
0.920	[*A*]the delay of a communication channel[*R*]may vary arbitrarily[*A*]during an execution.Memory flags	context()	negated: False ,passive: True
[LINE#506] For each state sS and each node j[1..n], there is a memory flag Memi,j,s at node i.
0.929	[*A*]For each state sS[*R*]j[*A*]1 .. n ] , there is a memory flag Memi , j , s at node	context()	negated: False ,passive: True
[LINE#507] It has two input ports, namely Si,j and a binary reset port, as well as a binary output port Memi,j,s whose name is for simplicity identical to the memory flag's name.
0.522	[*A*]It[*R*]has[*A*]two input ports , j	context()	negated: False ,passive: False
0.522	[*A*]It[*R*]has[*A*]two input ports	context()	negated: False ,passive: False
0.522	[*A*]It[*R*]has[*A*]a binary output port	context()	negated: False ,passive: False
[LINE#508+509]  Given an execution Ein of the flag's input ports, an execution Eout of the output port is in Mem(Ein) iff properties (Reset) and (Set) hold:-(Reset).
[LINE#510+511]  For all times tR, Memi,j,s(t)=0 iff the reset port has been in state 1 at some time between sup{t(-,t]|Si,j(t)=s} and t.-(Set).
0.977	[*A*]For all times ( t ) =0 iff the reset port[*R*]has been[*A*]in state 1[*A*]at some time between sup { t ( - , t ] | Si , j ( t ) =s } and t	context()	negated: False ,passive: True
0.938	[*A*]j[*R*]has been[*A*]in state 1[*A*]at some time between sup { t ( - , t ] | Si , j ( t ) =s } and t[*A*]For all times	context()	negated: False ,passive: True
0.975	[*A*]Memi[*R*]has been[*A*]in state 1[*A*]at some time between sup { t ( - , t ] | Si , j ( t ) =s } and t[*A*]For all times	context()	negated: False ,passive: True
[LINE#512+513]  For all times tR, Memi,j,s(t)=1 iff the reset port continuously has been in state 0 between sup{t(-,t]|Si,j(t)=s} andat time t iff Memi,j,s(t)=1.Threshold gates.
[LINE#514] Node i may comprise an arbitrary number of threshold gates with arbitrary thresholds.
0.452	[*A*]i[*R*]may comprise[*A*]an arbitrary number of threshold gates with arbitrary thresholds	context()	negated: False ,passive: True
[LINE#515]  The module specification Thr of a threshold gate with binary input ports a1,,am, binary output port o, and threshold.
0.972	[*A*]The module specification Thr of a threshold gate with binary input ports a1[*R*]am[*A*]binary output port o	context()	negated: False ,passive: True
[LINE#516] Let Ein be an execution of the input ports and Eout an execution of output port o.
[LINE#517+518]  Then EoutThr(EI) iff for all tR, o(t)=1if at least k input ports are in state 1 at time t, and o(t)=0 otherwise.Watchdog timers.
0.948	[*A*]k input ports[*R*]are[*A*]in state 1[*A*]Then	context()	negated: False ,passive: True
[LINE#519+520]  For each state sS, there can be watchdog timers (T,s,C) at nodei, where TR+ is the duration of the timer and C is a clock.
0.944	[*A*]TR+[*R*]is[*A*]the duration of C[*A*]nodei	context()	negated: False ,passive: True
0.869	[*A*]TR+[*R*]is[*A*]a clock	context()	negated: False ,passive: True
0.933	[*A*]TR+[*R*]is[*A*]the duration of the timer[*A*]nodei	context()	negated: False ,passive: True
[LINE#521]  The watchdog timer has input port.
0.932	[*A*]The watchdog timer[*R*]has[*A*]input port	context()	negated: False ,passive: False
[LINE#522] Si,i and a binary output port TimeT,s,C.
[LINE#523] The timer's module specification Time is defined as follows.
0.868	[*A*]The timer's module specification Time[*R*]is defined[*A*]as follows	context()	negated: False ,passive: True
[LINE#524]  Let Ein be an execution of the timer's input port.
[LINE#525] Si,i and Eout an execution of its output port TimeT,s,C.
[LINE#526]  Then EoutTime(Ein), iff the following holds:-(Clock).
[LINE#527]  Clock C is correct at all times, i.e., t-tC(t)-C(t)(t-t) for all t,tR, t<t.-(Reset).
0.896	[*A*]Clock C[*R*]is[*A*]correct[*A*]at all times	context()	negated: False ,passive: True
[LINE#528+529+530]  There exists a (binary) signal T,s,C[TimeT,s,C] (the equivalence class of the output port's signal) when Si,i switches to state s, there is a time t[ts,ts+dTime] such that (T,s,C) is reset, i.e., event (0,t)T,s,.
0.717	[*A*]T,s,C[*R*]is[*A*]reset	context()	negated: False ,passive: True
[LINE#531+532+533]  This is a one-to-one correspondence, i.e., for each such ts this time t is unique and (T,s,C) is not reset at any other times.-(Expire)the set of times when (T,s,C) is reset.
0.717	[*A*]T , s , C[*R*]is[*A*]reset	context()	negated: False ,passive: True
0.912	[*A*]t[*R*]is[*A*]unique[*A*]this time	context()	negated: False ,passive: True
[LINE#534] For each time tRR, denote by tE(tR) the unique time satisfying that C(tE(tR))-C(tR)=T.
0.863	[*A*]tRR[*R*]satisfying[*A*]that C(tE(tR))-C(tR)=T[*A*]For each time	context()	negated: False ,passive: False
0.857	[*A*]tRR[*R*]denote[*A*]by tE[*A*]the unique time	context()	negated: False ,passive: True
[LINE#535] Then, for each tR, TimeT,s,C(t)=0 iff ttRR[tR,tE(tR)).
[LINE#536+537]  Iff (tE(tR),1)TimeT,s,C, i.e., (T,s,C) is not reset during (tR,tE(tR)]again and hence TimeT,s,C switches to 1 at time tE(tR), we say that (T,s,C) expires at time tE(tR).
0.807	[*A*]T , s , C[*R*]expires[*A*]at time	context(we say)	negated: False ,passive: True
0.972	[*A*]Iff ( tE ( tR ) , 1 ) TimeT[*R*]is not reset[*A*]during ( tR , tE ( tR ) ] hence TimeT	context(C switches we say)	negated: True ,passive: True
0.820	[*A*]C[*R*]switches[*A*]to 1[*A*]at time	context(we say)	negated: False ,passive: False
0.807	[*A*]T , s , C[*R*]expires[*A*]at time	context(we say)	negated: False ,passive: True
0.955	[*A*]Iff ( tE ( tR ) , 1 ) TimeT[*R*]is not reset[*A*]during ( tR , tE ( tR[*A*]again	context(C switches we say)	negated: True ,passive: True
0.820	[*A*]C[*R*]switches[*A*]to 1[*A*]at time	context(we say)	negated: False ,passive: False
0.271	[*A*]we[*R*]say[*A*]that ( T , s , C ) expires at time	context()	negated: False ,passive: False
[LINE#538] (T,s,C) is expired at time tR iff TimeT,s,C(t)=1.
0.844	[*A*]T,s,C[*R*]is expired[*A*]at time	context()	negated: False ,passive: True
[LINE#539] For notational convenience, we will omit the clock C and simply write (T,s) for both the timeout and its signal.Randomized watchdog timers.
0.136	[*A*]we[*R*]will write	context()	negated: False ,passive: False
0.310	[*A*]we[*R*]will write[*A*]for both the timeout	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]will omit[*A*]the clock C	context()	negated: False ,passive: False
[LINE#540]  A randomized watchdog timer (D,s,C) is a module with input port.
0.927	[*A*]A randomized watchdog timer[*R*]is[*A*]a module with input port	context()	negated: False ,passive: True
[LINE#541] Si,i and output port TimeD,s,C, where D is a bounded random distribution on (0,D]R+, s is a state, and C a clock.
0.852	[*A*]s[*R*]is[*A*]a state	context()	negated: False ,passive: True
[LINE#542+543]  The module specification of (D,s,C) is analogous to the module specification of a watchdog timer, except that property (Expire) is replaced by:-(Expire')the set of times when (T,s,C) is reset.
0.717	[*A*]T,s,C[*R*]is[*A*]reset	context()	negated: False ,passive: True
0.896	[*A*]property[*R*]is replaced[*A*]by:-(Expire	context()	negated: False ,passive: True
0.954	[*A*]The module specification of (D[*R*]is[*A*]analogous to the module specification of a watchdog timer	context()	negated: False ,passive: True
[LINE#544] For each time tRR, denote by tE(tR) the unique time satisfying that C(tE)-C(tR)=T(tR), where T(tR) is drawn (independently) from D.
0.919	[*A*]T(tR[*R*]is drawn independently[*A*]from D.[*A*]C(tE)-C(tR)=T	context()	negated: False ,passive: True
0.935	[*A*]tRR[*R*]satisfying[*A*]C(tE)-C(tR)=T[*A*]For each time	context()	negated: False ,passive: False
0.857	[*A*]tRR[*R*]denote[*A*]by tE[*A*]the unique time	context()	negated: False ,passive: True
[LINE#545] Then, for each tR, TimeT,s,C(t)=0 iff ttRR[tR,tE(tR)).
[LINE#546] We apply the same notational conventions as for watchdog timers.State transition modules.
0.452	[*A*]We[*R*]apply[*A*]the same notational conventions[*A*]as for watchdog timers.State transition modules	context()	negated: False ,passive: False
[LINE#547+548]  state transition module has input portsj[1..n] as well as one binary input port for each of the memory flags, (randomized) watchdog timers and threshold gates it uses.
0.911	[*A*]randomized ) watchdog threshold gates[*R*]uses[*A*]it	context()	negated: False ,passive: True
0.894	[*A*]watchdog threshold gates[*R*]uses[*A*]it	context()	negated: False ,passive: True
0.930	[*A*]state transition module[*R*]has n[*A*]input portsj	context()	negated: False ,passive: False
0.932	[*A*]state transition module[*R*]has[*A*]input portsj	context()	negated: False ,passive: False
[LINE#549]  Furthermore it has an output port.
0.522	[*A*]it[*R*]has[*A*]an output port	context()	negated: False ,passive: False
[LINE#550] Si as well as one binary Reset output port for each of the memory flags it uses.
0.894	[*A*]the memory flags[*R*]uses[*A*]it	context()	negated: False ,passive: True
[LINE#551+552+553]  A node's state transition module executes a state machine specified by (i) a finite set S of states, (ii) a function tr, called the transition function, from TS2 to the set of Boolean predicates on the alphabet consisting of expressions of the form "p=s" (used for expressing guards), where p is from the state transition module's input ports and s is from the set of possible states of signal p, and(iii) a function re, called the reset function, from T to the power set of the node's memory flags.
0.852	[*A*]p[*R*]is[*A*]from the state ( iii	context()	negated: False ,passive: True
0.897	[*A*]a function re[*R*]called[*A*]the reset function	context()	negated: False ,passive: True
0.830	[*A*]p[*R*]is[*A*]from the set of possible states of signal p	context()	negated: False ,passive: True
0.629	[*A*]p[*R*]is	context()	negated: False ,passive: False
0.925	[*A*]a finite[*R*]set[*A*]S of states	context()	negated: False ,passive: False
0.911	[*A*]a state machine[*R*]specified[*A*]by (i) a finite	context()	negated: False ,passive: True
0.903	[*A*]the alphabet[*R*]consisting[*A*]of expressions of the form	context()	negated: False ,passive: True
0.932	[*A*]A node 's state transition module[*R*]executes[*A*]a state machine specified by (i) a finite	context()	negated: False ,passive: False
[LINE#554] Intuitively, the transition function specifies the conditions (guards) under which a node switches states, and the reset function determines which memory flags to reset upon the state change.
0.911	[*A*]the reset function[*R*]determines[*A*]which memory flags to reset upon the state change	context()	negated: False ,passive: False
0.911	[*A*]the transition function[*R*]specifies[*A*]the conditions[*A*]under a node switches states	context()	negated: False ,passive: False
0.911	[*A*]the reset function[*R*]determines[*A*]which memory flags[*A*]to reset	context()	negated: False ,passive: False
0.911	[*A*]the transition function[*R*]specifies[*A*]the conditions	context()	negated: False ,passive: False
[LINE#555]  Formally, let P be a predicate on the input ports of node.
[LINE#556+557+558]  We define P holds at time t by structural induction: If P is equal to p =s, where p is an input port of node, then P holds at time t iff p(t)=s.
0.385	[*A*]P[*R*]is equal to[*A*]p =s	context()	negated: False ,passive: False
0.388	[*A*]We[*R*]define[*A*]P holds[*A*]at time	context(P holds)	negated: False ,passive: False
0.888	[*A*]P[*R*]holds[*A*]at time[*A*]t iff p(t)=s[*A*]then	context()	negated: False ,passive: False
0.852	[*A*]p[*R*]is[*A*]an input port of node	context()	negated: False ,passive: True
0.852	[*A*]P[*R*]is[*A*]equal to p =s	context()	negated: False ,passive: True
[LINE#559] Otherwise, if P is of the form P1, P1P2, or P1P2, we define P holds at time t in the straightforward manner.
0.452	[*A*]we[*R*]define[*A*]P holds	context()	negated: False ,passive: False
0.874	[*A*]P[*R*]is[*A*]of the form P1, P1P2, or P1P2	context()	negated: False ,passive: True
[LINE#560+561]  For a given transition delay dTrans>0, the module specification STM of nodestate transition module is defined as follows.
0.888	[*A*]the module specification STM of nodestate transition module[*R*]is defined[*A*]as follows	context()	negated: False ,passive: True
[LINE#562] Let Ein be an execution of the state transition module's input ports and Eout an execution of its output ports.
[LINE#563+564]  Then EoutSTM(Ein) iff there is some >0 anda signal locked such that the following requirements are met.
0.751	[*A*]the following requirements[*R*]are met	context()	negated: False ,passive: False
0.785	[*A*]some >0 anda signal[*R*]locked	context()	negated: False ,passive: False
[LINE#565+566]  (The intuition is that locked(t)=0 means that the node is ready to perform the next state transition once a guard becomes true, whereas in case of locked(t)=1 the node is currently executing a previously "locked" transition.)-(Safety).
0.887	[*A*]the node[*R*]to perform[*A*]the next state transition[*A*]once a guard becomes true	context()	negated: False ,passive: False
0.916	[*A*]the node[*R*]is executing[*A*]a previously "locked" transition[*A*]currently	context()	negated: False ,passive: False
0.908	[*A*]the node[*R*]is[*A*]ready to perform the next state transition	context(The intuition is locked ( t ) =0 means)	negated: False ,passive: True
0.854	[*A*]locked(t)=0[*R*]means[*A*]that the node is ready to perform the next state transition	context(The intuition is)	negated: False ,passive: False
0.853	[*A*]The intuition[*R*]is[*A*]that locked(t)=0 means that the node is ready to perform the next state transition once a guard becomes true, whereas in case of locked(t)=1 the node is currently executing a previously "locked" transition	context()	negated: False ,passive: True
[LINE#567] The node (i.e., Si) does not switch states at any time t with locked(t)=0.
0.927	[*A*]The node[*R*]does not switch[*A*]states[*A*]at any time t with locked(t)=0	context()	negated: True ,passive: False
[LINE#568+569]  In every maximal interval [tl,tu)R satisfying that locked1 on [tl,tu) , it switches states exactly once.-(Delay).
0.595	[*A*]it[*R*]switches[*A*]states[*A*]exactly once[*A*]In every maximal interval	context()	negated: False ,passive: False
0.760	[*A*]every maximal interval[*R*]satisfying[*A*]that locked1[*A*]on [tl,tu	context()	negated: False ,passive: False
[LINE#570]  For each interval [tl,tu) as above, tu-tldTrans-.-(Guard).
[LINE#571+572]  For each interval [tl,tu) as above, (Si(tl),Si(tu))T and tr(Si(t),Si(tu)) is satisfied at some time t[tl-,tl].-(Responsiveness) such that (Si(t),s)T and tr(Si(t),s) holds at time t, then locked(t+)=1.-(Flags).
0.998	[*A*]tr ( Si ( t ) , Si ( tu ) ) is satisfied at some time t [ tl - , tl ] . - ( Responsiveness ) such that tr ( Si ( t ) , s[*R*]holds[*A*]at time	context()	negated: False ,passive: False
0.998	[*A*]tr ( Si ( t ) , Si ( tu ) ) is satisfied at some time t [ tl - , tl ] . - ( Responsiveness ) such that ( Si ( t ) , s ) T ( Si ( t ) , s[*R*]holds[*A*]at time	context()	negated: False ,passive: False
0.982	[*A*]as above , tr ( Si ( t ) , Si[*R*]is[*A*]satisfied at some time t [ tl - , tl	context()	negated: False ,passive: True
0.929	[*A*]tr ( Si ( t ) , s[*R*]holds[*A*]at time	context()	negated: False ,passive: False
0.980	[*A*]Si ( t ) , s ) T ( Si ( t ) , s[*R*]holds[*A*]at time	context()	negated: False ,passive: False
0.982	[*A*]Si ( tl ) , Si ( tu ) ) T[*R*]is[*A*]satisfied at some time t [ tl - , tl	context()	negated: False ,passive: True
[LINE#573] For an arbitrary interval [tl,tu) as above, suppose that the node switches from state Si(tl) to state Si(tu) at time ts[tl,tu).
[LINE#574] Then for each memory flag specified by re(Si(tl),Si(tu)), the corresponding reset output port of the state transition module is in state 1 at some time in (tl,ts] (and therefore the flag is reset).
[LINE#575] Outside these time intervals, reset ports are in state 0.
0.943	[*A*]reset ports[*R*]are[*A*]in state 0[*A*]Outside these time intervals	context()	negated: False ,passive: True
[LINE#576] A node may run multiple, say kN, state machines in parallel (i.e., contain several state machines as submodules).
0.884	[*A*]state machines in parallel[*R*]contain[*A*]several state machines	context(A node may run multiple say)	negated: False ,passive: False
0.724	[*A*]A node[*R*]may run[*A*]multiple	context(A node may run multiple say)	negated: False ,passive: False
0.910	[*A*]A node may run multiple[*R*]say[*A*]kN	context()	negated: False ,passive: True
[LINE#577] In this case, its state signal is the joint signal Si=(Si1,,Sik), where Sil, l[1..k], denotes the lth state machine of the node.
0.914	[*A*]where Sil[*R*]denotes[*A*]the lth state machine of the node	context()	negated: False ,passive: False
0.922	[*A*]where Sil[*R*]l[*A*]1..k	context()	negated: False ,passive: False
0.899	[*A*]its state signal[*R*]is[*A*]the joint signal Si=(Si1,,Sik), where Sil, l[1..k], denotes the lth state machine of the node[*A*]In this case	context()	negated: False ,passive: True
[LINE#578] Throughout this article, the different state machines of each node i have disjoint state spaces.
0.452	[*A*]i[*R*]have disjoint[*A*]state spaces	context()	negated: False ,passive: False
[LINE#579+580+581]  For simplicity, we hence may say "node t" instead of "state machine l of nodei is in state s at time t" when referring to Sil(t)=s, etc.
0.970	[*A*]state machine l of nodei[*R*]is[*A*]in state s at time t[*A*]s at time t " when referring to Sil ( t ) =s , etc.	context()	negated: False ,passive: True
0.367	[*A*]we[*R*]may say[*A*]node t	context()	negated: False ,passive: False
[LINE#582] To account for the latency of the memory flags, threshold gates and (randomized) watchdog timers, their ports are not directly connected to the state transition module's ports, but via binary communication channels with respective delays.
0.638	[*A*]their ports[*R*]are not[*A*]directly connected via binary communication channels with respective delays	context()	negated: True ,passive: True
0.341	[*A*]their ports[*R*]are not directly connected	context()	negated: True ,passive: False
0.305	[*A*]their ports[*R*]directly connected	context()	negated: True ,passive: False
0.638	[*A*]their ports[*R*]are not[*A*]directly connected to the state transition module 's ports	context()	negated: True ,passive: True
[LINE#583]  The resulting structure of the compound module node.
[LINE#584] Note that additional communication channels at the threshold gates' and memory flags' input ports allow to model the fact that memory flags are not necessarily reset at the same time, and signals may arrive shifted in time at the threshold gates.
0.859	[*A*]memory flags[*R*]are not reset[*A*]signals	context()	negated: True ,passive: False
0.859	[*A*]memory flags[*R*]are not reset[*A*]at the same time	context()	negated: True ,passive: True
[LINE#585] As mentioned earlier, for simplicity we consider the outgoing channels to remote nodes as part of the node.
0.888	[*A*]the outgoing channels[*R*]to remote[*A*]nodes as part of the node	context(we consider)	negated: False ,passive: False
0.504	[*A*]we[*R*]consider[*A*]the outgoing channels to remote nodes as part of the node	context()	negated: False ,passive: False
[LINE#586] Hence, the output ports of node i comprise the output ports Sj,i, j[1..n], of the channels disseminating its state Si.
0.859	[*A*]the channels[*R*]disseminating[*A*]its state Si	context()	negated: False ,passive: False
[LINE#587+588]  In addition, in order to solve the actual problem of clock generation, we include the locally computed discrete clock value Li as an output port.. Protocols and problemformulationWe next formalize the concept of a protocol, like the one presented in Section 5, followed by what it means for a protocol to solve self-stabilizing clock synchronization in spite of f faults.
0.550	[*A*]we[*R*]include[*A*]the locally computed discrete clock value Li as an output port	context(Protocols and problemformulationWe formalize)	negated: False ,passive: True
0.901	[*A*]Protocols and problemformulationWe[*R*]formalize[*A*]the concept of a protocol	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]means[*A*]for a protocol	context()	negated: False ,passive: False
0.773	[*A*]the one presented in Section 5[*R*]followed	context()	negated: False ,passive: False
[LINE#589] Formally, a protocol (for an n-node system) is a compound module consisting of n modules referred to as nodes.
0.911	[*A*]a compound module[*R*]consisting[*A*]of n modules	context()	negated: False ,passive: True
0.954	[*A*]a protocol (for an n-node system[*R*]is[*A*]a compound module consisting of n modules	context()	negated: False ,passive: True
[LINE#590] The nodes are to be specified as modules themselves, and in our case will follow the layout we just described.
0.509	[*A*]we[*R*]described[*A*]the layout	context()	negated: False ,passive: False
0.887	[*A*]The nodes[*R*]to be specified[*A*]as modules	context()	negated: False ,passive: True
0.903	[*A*]The nodes[*R*]are[*A*]to be specified as modules	context()	negated: False ,passive: True
[LINE#591] It thus remains to state in Section 5 which (randomized) watchdog timers, memory flags and threshold gates our protocol uses as well as the state transition modules' transition and reset functions.
0.821	[*A*]threshold[*R*]gates[*A*]our protocol	context()	negated: False ,passive: False
0.698	[*A*]Section 5[*R*]randomized	context()	negated: False ,passive: False
0.868	[*A*]Section 5[*R*]randomized[*A*]watchdog timers	context()	negated: False ,passive: False
0.411	[*A*]It[*R*]remains[*A*]to state	context()	negated: False ,passive: True
[LINE#592+593]  A clock synchronization module with nN nodes, clock imprecision , amortized frequency bounds A-,A+R+, slacks -,+R0+, maximum frequency F+, and at most fN faults is a module without input ports and with output ports Li.
0.937	[*A*]at most fN faults[*R*]is[*A*]a module with output ports	context()	negated: False ,passive: True
0.933	[*A*]A clock synchronization module with nN nodes[*R*]amortized[*A*]frequency bounds	context()	negated: False ,passive: False
0.937	[*A*]at most fN faults[*R*]is[*A*]a module without input ports	context()	negated: False ,passive: True
[LINE#594] Its module specification is extendable.
0.476	[*A*]Its module specification[*R*]is[*A*]extendable	context()	negated: False ,passive: True
[LINE#595+596+597+598]  An execution of the module on R is feasible, iff there exists a subset C of [1..n] of size at least n-f satisfying thattR, i,jC: |Li(t)-Lj(t)|,t, tR, t<t, iC: A-(t-t)--Li(t)-Li(t)A+(t-t)++, andt, tR,t<t, iC: Li(t)-Li(t)F+(t-t).We say a protocol  (for an n-node system) with no input ports and output ports , solves self-stabilizing clock synchronization with clock imprecision , amortized frequency bounds A-,A+, slacks -,+R0+, maximum frequency F+, at most f faults, and stabilization time T (with probability pit is an f-tolerant, (with probability at least p) T-stabilizing implementation of the clock synchronization module with the respective parameters.
0.946	[*A*]a protocol ( for an n - node system ) with output ports[*R*]solves[*A*]self - stabilizing clock synchronization with clock imprecision	context(maximum frequency F+ is)	negated: False ,passive: False
0.931	[*A*]An execution of the module on R[*R*]is[*A*]feasible[*A*]iff there exists a subset C of [ 1 .. n ] of size	context(maximum frequency F+ is)	negated: False ,passive: True
0.195	[*A*]We[*R*]say	context()	negated: False ,passive: False
0.951	[*A*]a protocol ( for an n - node system ) with no input ports[*R*]solves[*A*]self - stabilizing clock synchronization with clock imprecision	context(maximum frequency F+ is)	negated: False ,passive: False
0.931	[*A*]An execution of the module on R[*R*]is[*A*]feasible[*A*]iff there exists a subset C of [ 1 .. n ] of size	context(maximum frequency F+ is)	negated: False ,passive: True
0.955	[*A*]maximum frequency F+[*R*]is[*A*]an f - tolerant[*A*]at most f faults	context()	negated: False ,passive: True
[LINE#599] A (real-world) implementation will output bounded clocks of size KN only.
0.948	[*A*]A (real-world) implementation[*R*]will output[*A*]bounded clocks of size[*A*]KN only	context()	negated: False ,passive: False
[LINE#600] In this case the output ports do not yield Li(t), but only Li(t)modK.
0.957	[*A*]the output ports[*R*]do not yield[*A*]only Li ( t ) modK[*A*]In this case	context()	negated: True ,passive: False
0.925	[*A*]the output ports[*R*]do not yield[*A*]Li ( t	context()	negated: True ,passive: False
[LINE#601] Nevertheless, we introduced the signals Li as abstract functions in this setting, as they allow to state the frequency bounds concisely.
0.555	[*A*]they[*R*]allow to state concisely[*A*]the frequency bounds	context(they allow)	negated: False ,passive: False
0.562	[*A*]they[*R*]allow[*A*]to state the frequency bounds concisely	context()	negated: False ,passive: False
0.498	[*A*]we[*R*]introduced[*A*]the signals Li[*A*]as abstract functions	context()	negated: False ,passive: False
[LINE#602] Note that there is no physical counterpart of these values in the real-world system; to be strictly accurate, it would be necessary to qualify the above definitions further by "with bounded clocks of size K" in order to distinguish this version of the problem from the abstract one with unbounded clocks. .
0.569	[*A*]it[*R*]would be[*A*]necessary[*A*]to qualify the above definitions further by "with bounded clocks of size K	context()	negated: False ,passive: True
0.879	[*A*]no physical counterpart of these values in the real-world system[*R*]to be[*A*]strictly accurate	context()	negated: False ,passive: True
[LINE#603] issuesOur formal model incorporates a precise semantics of what it means for a module to implement some other module, namely, inclusion of all feasible (sub-)executions.
0.903	[*A*]a module[*R*]to implement[*A*]some other module	context()	negated: False ,passive: False
0.452	[*A*]it[*R*]means[*A*]for a module to implement some other module	context()	negated: False ,passive: False
0.883	[*A*]issuesOur formal model[*R*]incorporates[*A*]a precise semantics of what it means	context()	negated: False ,passive: False
[LINE#604] Unfortunately, however, this strong requirement must often be relaxed when it comes to real implementations.
0.452	[*A*]it[*R*]comes[*A*]to real implementations	context()	negated: False ,passive: True
0.867	[*A*]this strong requirement[*R*]must be[*A*]relaxed[*A*]when it comes to real implementations[*A*]often	context()	negated: False ,passive: True
[LINE#605] This is primarily a consequence of the fact that there is no physical implementation of a circuit that can avoid metastability.
0.887	[*A*]a circuit[*R*]can avoid[*A*]metastability	context()	negated: False ,passive: False
0.206	[*A*]This[*R*]is[*A*]primarily[*A*]a consequence of the fact that there is no physical implementation of a circuit	context()	negated: False ,passive: True
[LINE#606] Since preventing certain inputs to a module requires output guarantees from others, this is a challenging problem to systems that are self-stabilizing or tolerate persistent faults; combining these properties complicates this issue further.
0.877	[*A*]systems[*R*]are[*A*]self-stabilizing	context()	negated: False ,passive: True
0.911	[*A*]combining these properties[*R*]complicates[*A*]this issue[*A*]further	context()	negated: False ,passive: False
0.449	[*A*]this[*R*]is[*A*]a challenging problem to systems	context()	negated: False ,passive: True
0.932	[*A*]preventing certain inputs to a module[*R*]requires[*A*]output guarantees from others	context()	negated: False ,passive: False
0.877	[*A*]systems[*R*]tolerate[*A*]persistent faults	context()	negated: False ,passive: False
[LINE#607] More specifically, in order to faithfully implement their specifications, basic modules must be able to (i) deal with all possible inputs and (ii) recover reliably from transient faults.
0.927	[*A*]basic modules[*R*]to (i)[*A*]deal with ( ii ) recover reliably from transient faults	context()	negated: False ,passive: False
0.937	[*A*]basic modules[*R*]must be[*A*]able to (i) deal with ( ii ) recover reliably from transient faults	context()	negated: False ,passive: True
0.887	[*A*]basic modules[*R*]to (i)[*A*]deal with all possible inputs	context()	negated: False ,passive: False
0.903	[*A*]basic modules[*R*]must be[*A*]able to (i) deal with all possible inputs	context()	negated: False ,passive: True
[LINE#608] Unfortunately, (i) is often impossible to achieve with real circuits.
[LINE#609] For example, simultaneous input changes may drive any implementation of a Muller C-gate into a metastable state, which implies that its output ports do not even carry signals according to our definition, and are hence not feasible.
0.345	[*A*]its output ports[*R*]are[*A*]hence not feasible	context(a metastable state implies)	negated: False ,passive: True
0.570	[*A*]a metastable state[*R*]implies[*A*]that its output ports are hence not feasible	context()	negated: False ,passive: False
0.346	[*A*]its output ports[*R*]do not carry[*A*]signals[*A*]according to our definition	context(a metastable state implies)	negated: True ,passive: False
0.680	[*A*]a metastable state[*R*]implies[*A*]that its output ports do not even carry signals according to our definition	context()	negated: False ,passive: False
0.925	[*A*]simultaneous input changes[*R*]may drive[*A*]any implementation of a Muller C-gate	context()	negated: False ,passive: False
[LINE#610] Of course, metastability can also be caused by physical faults affecting the module; such faults can obviously not be analyzed within our model either.
0.810	[*A*]metastability[*R*]can be caused[*A*]by physical faults	context(such faults can not be analyzed)	negated: False ,passive: True
0.718	[*A*]such faults[*R*]can not be analyzed[*A*]within our model[*A*]either	context()	negated: True ,passive: True
0.903	[*A*]physical faults[*R*]affecting[*A*]the module	context()	negated: False ,passive: False
[LINE#611] This possibility obviously invalidates any guarantees that compound implementations containing this instance may provide, unless they can mask the error due to fault-tolerance.
0.858	[*A*]any guarantees[*R*]compound[*A*]implementations containing this instance	context(This possibility invalidates any guarantees that compound implementations may provide)	negated: False ,passive: False
0.855	[*A*]any guarantees that compound implementations[*R*]may provide[*A*]unless they can mask the error due to fault-tolerance	context(This possibility invalidates)	negated: False ,passive: False
0.658	[*A*]This possibility[*R*]invalidates[*A*]any guarantees that compound implementations containing this instance may provide, unless they can mask the error due to fault-tolerance	context()	negated: False ,passive: False
0.616	[*A*]they[*R*]can mask[*A*]the error[*A*]due to fault-tolerance	context()	negated: False ,passive: False
0.894	[*A*]implementations[*R*]containing[*A*]this instance	context()	negated: False ,passive: False
[LINE#612] Moreover, real circuits cannot guarantee (ii) under all circumstances either, as it is impossible to always prohibit the propagation of metastable inputs to the outputs and the system may contain feedback-loops.
0.875	[*A*]real circuits[*R*]can not guarantee either[*A*]under all circumstances	context()	negated: True ,passive: False
[LINE#613]  In principle, it would be possible to extend the presented model to cover also generation and propagation of metastability explicitly, by replacing the finite alphabet S and discrete events with a continuous range of signal values (the voltages).
0.909	[*A*]the presented model[*R*]to cover explicitly[*A*]also generation of metastability	context()	negated: False ,passive: True
[LINE#614] Since this would dramatically increase the complexity of any analysis, we choose a different approach that also allows us to handle other implementation intricacies in a pragmatic way.
0.388	[*A*]us[*R*]to handle[*A*]other implementation intricacies	context(a different approach allows)	negated: False ,passive: False
0.853	[*A*]a different approach[*R*]allows[*A*]us to handle other implementation intricacies in a pragmatic way	context()	negated: False ,passive: False
0.208	[*A*]we[*R*]choose[*A*]a different approach that also allows us to handle other implementation intricacies in a pragmatic way	context()	negated: False ,passive: False
0.381	[*A*]this[*R*]would dramatically increase[*A*]the complexity of any analysis	context()	negated: False ,passive: False
[LINE#615] In fact, even in the absence of metastability, it is not necessarily simple and even possible for real implementations to guarantee (ii) under all circumstances.
0.702	[*A*]it[*R*]is not[*A*]necessarily[*A*]even possible[*A*]for real implementations to guarantee ( ii ) under all circumstances[*A*]even in the absence of metastability	context()	negated: True ,passive: True
0.886	[*A*]real implementations[*R*]to guarantee[*A*]under all circumstances	context()	negated: False ,passive: False
0.595	[*A*]it[*R*]is not[*A*]necessarily[*A*]simple[*A*]even in the absence of metastability	context()	negated: True ,passive: True
[LINE#616] Apart from the fact that transient faults may lead to permanent errors by damaging physical components,1616We remark that, technically speaking, excessively high voltages on the input wires could also be interpreted as an "input violation", as this violates the definition of our signals.
0.250	[*A*]this[*R*]violates[*A*]the definition of our signals	context()	negated: False ,passive: False
0.929	[*A*]technically speaking, excessively high voltages on the input wires[*R*]could be interpreted[*A*]as an "input violation	context()	negated: False ,passive: True
0.903	[*A*]transient faults[*R*]may lead[*A*]to permanent errors	context()	negated: False ,passive: False
[LINE#617] However, it makes sense to interpret such (hopefully exceptional) events as a fault of the module.
0.452	[*A*]it[*R*]makes[*A*]sense	context()	negated: False ,passive: False
[LINE#618] our model does not prohibit that temporarily infeasible inputs result in permanent infeasibility, i.e., even when inputs become benign again at a later state of the execution of the module in question, there is no suffix of the execution that is feasible.
0.888	[*A*]temporarily infeasible inputs[*R*]result[*A*]in permanent infeasibility	context(our model does not prohibit)	negated: False ,passive: True
0.149	[*A*]our model[*R*]does not prohibit[*A*]that	context()	negated: True ,passive: False
0.786	[*A*]the execution[*R*]is[*A*]feasible	context()	negated: False ,passive: True
[LINE#619] The oscillator implementation given in Example 3.6 demonstrates this issue, and further modules exhibiting persistently faulty behavior after temporary violations of input constraints are easily conceived.
0.878	[*A*]further modules exhibiting persistently faulty behavior after temporary violations of input constraints[*R*]are easily conceived	context()	negated: False ,passive: False
0.903	[*A*]further modules[*R*]exhibiting[*A*]persistently faulty behavior after temporary violations of input constraints	context()	negated: False ,passive: False
0.953	[*A*]The oscillator implementation given in Example 3.6[*R*]demonstrates[*A*]this issue	context()	negated: False ,passive: False
0.925	[*A*]The oscillator implementation[*R*]given[*A*]in Example 3.6	context()	negated: False ,passive: True
[LINE#620] As we aim for self-stabilization, it is clear that we cannot allow implementations that suffer from such drawbacks: Neither transient faults nor their consequences, i.e., temporarily arbitrary executions, may result in permanent faults.
0.877	[*A*]implementations[*R*]suffer[*A*]from such drawbacks	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]aim[*A*]for self-stabilization	context()	negated: False ,passive: False
[LINE#621] Clearly, both recovery from transient failures and resilience of a basic module to erroneous inputs, and hence the whole definition of what actually constitutes a transient fault in our model, is implicitly defined by the physical realization of an implementation.
[LINE#622] These observations have important consequences.
0.903	[*A*]These observations[*R*]have[*A*]important consequences	context()	negated: False ,passive: False
[LINE#623] On the one hand, careful design of the basic modules is of paramount importance.
0.948	[*A*]careful design of the basic modules[*R*]is[*A*]of paramount importance	context()	negated: False ,passive: True
[LINE#624+625]  For instance, in a final product, a watchdog timer must not have its duration stored in a memory register that can be corrupted by a temporary charge injection (e.g. due to a particle hit), a ring oscillator should not be able to run unchecked at e.g. twice its frequency indefinitely(e.g. triggered by a voltage pulse), and one has to make sure that stateful components like memory flags or state transition modules eventually "forget" about potentially erroneous inputs in the past, and eventually behave according to their specification again.
0.825	[*A*]a ring oscillator[*R*]to run unchecked[*A*]at e.g.[*A*]twice[*A*]its frequency[*A*]indefinitely	context()	negated: False ,passive: False
0.958	[*A*]stateful components like memory flags or state transition modules[*R*]forget[*A*]about potentially erroneous inputs in the past[*A*]eventually	context()	negated: False ,passive: False
0.899	[*A*]a ring oscillator[*R*]should not be[*A*]able to run unchecked at e.g. twice its frequency indefinitely	context()	negated: True ,passive: True
0.442	[*A*]one[*R*]to make[*A*]sure that stateful components like memory flags or state transition modules eventually "forget" about potentially erroneous inputs in the past	context()	negated: False ,passive: False
0.933	[*A*]a memory register[*R*]can be corrupted[*A*]by a temporary charge injection (e.g. due to a particle hit	context()	negated: False ,passive: True
0.576	[*A*]its duration[*R*]stored[*A*]in a memory register	context(a watchdog timer must not have)	negated: False ,passive: True
0.811	[*A*]a watchdog timer[*R*]must not have[*A*]its duration stored in a memory register	context()	negated: True ,passive: False
[LINE#626] As discussed above, however, this cannot usually be perfect: There will always be (rare) scenarios, where an implemented circuit will not work like an ideal one, i.e., violate its specification.
0.939	[*A*]an implemented circuit[*R*]will not work[*A*]rare) scenarios	context()	negated: True ,passive: False
[LINE#627] We incorporate this in our model, in a pragmatic well-known from critical system design, by means of the notion of imperfect implementation coverage.
0.309	[*A*]We[*R*]incorporate[*A*]this[*A*]in our model[*A*]in	context()	negated: False ,passive: False
[LINE#628] For a given module implementation, the coverage implicitly or explicitly determines the fraction of all possibly executions in which the implementation works as specified.
0.948	[*A*]the implementation[*R*]works[*A*]all possibly executions	context()	negated: False ,passive: False
0.859	[*A*]the coverage[*R*]implicitly determines[*A*]the fraction of all possibly executions	context()	negated: False ,passive: False
[LINE#629] Since exceptional scenarios like metastability are usually extremely rare, we do not bother with defining the notion of coverage formally here: The coverage should be very close to 100% anyway.
0.388	[*A*]we[*R*]do not bother with defining[*A*]the notion of coverage formally here	context(we do not bother The coverage should be)	negated: True ,passive: False
0.388	[*A*]we[*R*]do not bother[*A*]with defining the notion of coverage formally here	context(The coverage should be)	negated: True ,passive: False
0.878	[*A*]The coverage[*R*]should be[*A*]very close to 100%[*A*]anyway	context()	negated: False ,passive: True
0.799	[*A*]exceptional scenarios like metastability[*R*]are[*A*]usually[*A*]extremely rare	context()	negated: False ,passive: True
[LINE#630] In Section 6, we will argue that each of our basic modules will work as specified, except for very rare situations that may trigger metastability due to a violation of input timing constraints.
0.348	[*A*]each of our basic modules[*R*]will work	context(we will argue)	negated: False ,passive: False
0.265	[*A*]we[*R*]will argue[*A*]that each of our basic modules will work as specified, except for very rare situations[*A*]In Section 6	context()	negated: False ,passive: False
0.897	[*A*]very rare situations[*R*]may trigger[*A*]metastability due to a violation of input timing constraints	context()	negated: False ,passive: False
[LINE#631] Thanks to this approach, algorithms and proofs can rely on sufficiently simple specifications of basic modules, which usually also admit robust and efficient implementations in practice.
0.911	[*A*]Thanks to proofs[*R*]can rely[*A*]on sufficiently simple specifications of basic modules	context()	negated: False ,passive: False
0.911	[*A*]Thanks to algorithms[*R*]can rely[*A*]on sufficiently simple specifications of basic modules	context()	negated: False ,passive: False
0.934	[*A*]basic modules[*R*]admit[*A*]efficient implementations[*A*]usually	context()	negated: False ,passive: False
0.934	[*A*]basic modules[*R*]admit[*A*]robust implementations[*A*]usually	context()	negated: False ,passive: False
0.919	[*A*]Thanks to this approach[*R*]can rely[*A*]on sufficiently simple specifications of basic modules	context()	negated: False ,passive: False
[LINE#632] Any unhandled scenarios are relegated to imperfect implementation coverage.
0.911	[*A*]Any unhandled scenarios[*R*]are relegated[*A*]to imperfect implementation coverage	context()	negated: False ,passive: True
[LINE#633] This feature is essential for devising proofs of reasonable complexity that show self-stabilization of all compound modules, implying that the system indeed will recover once transient faults of (basic) modules cease.
0.927	[*A*]proofs of reasonable complexity[*R*]show[*A*]self-stabilization of all compound modules	context()	negated: False ,passive: False
0.925	[*A*]This feature[*R*]is[*A*]essential for devising proofs of reasonable complexity	context()	negated: False ,passive: True
[LINE#634] Due to the hierarchical composition of modules, compound modules fully derive their behavior from their submodules and can therefore be analyzed based on the properties of their submodules, while we may switch at will between viewing a module as given (i.e., basic), analyzing it in more detail as a compound implementation, or (for low-level modules) analyzing it in an even more detailed model.
0.184	[*A*]we[*R*]may switch analyzing[*A*]it	context(we may switch)	negated: False ,passive: False
0.157	[*A*]we[*R*]may switch	context()	negated: False ,passive: False
0.810	[*A*]compound modules[*R*]derive[*A*]their behavior[*A*]from their submodules	context()	negated: False ,passive: False
[LINE#635] This way, our approach also inherently supports tight interaction between algorithmic design and design of the basic building blocks used in the algorithms.
0.919	[*A*]the basic building blocks[*R*]used[*A*]in the algorithms	context()	negated: False ,passive: True
0.705	[*A*]our approach[*R*]inherently supports[*A*]tight interaction between algorithmic design and design of the basic building blocks	context()	negated: False ,passive: False
[LINE#636] In this section, we present the cornerstones of our FPGA prototype implementation of the FATAL+ protocol.
0.607	[*A*]we[*R*]present[*A*]the cornerstones of our FPGA prototype implementation of the FATAL+ protocol[*A*]In this section	context()	negated: False ,passive: False
[LINE#637] The objectives of this implementation are (i) to serve as a proof of concept, (ii) to validate the predictions of the theoretical analysis, and (iii) to form a basis for the future development of protocol variants and engineering improvements.
0.913	[*A*]The objectives of this implementation[*R*]to serve[*A*]as a proof of concept	context()	negated: False ,passive: False
0.785	[*A*]The objectives of this implementation[*R*]are (i)	context()	negated: False ,passive: False
[LINE#638] Rather than striving for optimizing performance, area, or power efficiency, our primary goal is hence to essentially provide a direct mapping of the algorithmic description to hardware, and to evaluate its properties in various operating scenarios.
0.692	[*A*]our primary goal[*R*]is[*A*]hence[*A*]to essentially provide a direct mapping of the algorithmic description to hardware, and to evaluate its properties in various operating scenarios	context()	negated: False ,passive: True
[LINE#639] Not surprisingly, traditional design principles for digital circuits are not adequate for our purposes.
0.882	[*A*]traditional design principles for digital circuits[*R*]are not[*A*]adequate for our purposes	context()	negated: True ,passive: True
[LINE#640]  This is true for three major reasons:Asynchrony:.
0.223	[*A*]This[*R*]is[*A*]true for three major reasons:Asynchrony	context()	negated: False ,passive: True
[LINE#641] Targeting ultra-reliable clock generation in SoCs, the implementation of FATAL+ itself cannot rely on the availability of a synchronous clock.
0.928	[*A*]the implementation of FATAL+[*R*]can not rely[*A*]on the availability of a synchronous clock	context()	negated: True ,passive: False
[LINE#642] Moreover, many guards, like the one of the transition from propose to accept in Fig. 8, depend on remote nodes' states and should hence not be synchronized to a local clock in order to maximize performance.
0.859	[*A*]many guards[*R*]should not be synchronized[*A*]to a local clock[*A*]in order	context()	negated: True ,passive: True
0.918	[*A*]many guards , like the one of the transition from propose[*R*]to accept depend[*A*]on remote nodes ' states	context(many guards , like the one of the transition from propose to accept)	negated: False ,passive: False
0.954	[*A*]many guards , like the one of the transition from propose[*R*]to accept[*A*]in Fig	context()	negated: False ,passive: False
[LINE#643] Testing for activated guards synchronized to a local clock source also increases the risk of generating metastability, as remote signals originate in different clock domains.
0.903	[*A*]remote signals[*R*]originate[*A*]in different clock domains	context()	negated: False ,passive: True
0.905	[*A*]Testing for activated guards[*R*]increases[*A*]the risk of generating metastability[*A*]as remote signals originate in different clock domains	context()	negated: False ,passive: False
0.903	[*A*]activated guards[*R*]synchronized[*A*]to a local clock source	context()	negated: False ,passive: True
[LINE#644+645]  On the other hand, conventional asynchronous state machines (ASM) are not well-suited for implementing the state machines from Fig.due to the possibility of choice w.r.t. successor states and continuously enabled (i.e., non-alternating) guards.
0.949	[*A*]conventional asynchronous state machines[*R*]are not[*A*]well - suited for implementing the state machines from Fig.due to the possibility of choice continuously enabled ( i.e. , non-alternating ) guards	context()	negated: True ,passive: True
0.949	[*A*]conventional asynchronous state machines[*R*]are not[*A*]well - suited for implementing the state machines from Fig.due to the possibility of choice w.r.t. successor states	context()	negated: True ,passive: True
[LINE#646+647]  Our prototype hence relies on hybrid state machines (HSM) that combine ASM with synchronous transition state machines (TSM) that are started on demandonly.Fault tolerance: The consideration of Byzantine faulty nodes forced us to abandon the classic "wait for all" paradigm traditionally used for enforcing the indication principle in asynchronous designs: Failures may easily inhibit the completion of the request/acknowledge cycles typically used for transition-based flow control.
0.452	[*A*]us[*R*]to abandon[*A*]the classic "wait for all" paradigm	context()	negated: False ,passive: False
0.923	[*A*]The consideration of Byzantine faulty nodes[*R*]forced[*A*]us[*A*]to abandon the classic "wait for all" paradigm	context()	negated: False ,passive: False
0.576	[*A*]Our prototype[*R*]hence relies[*A*]on hybrid state machines	context(Failures may easily inhibit)	negated: False ,passive: False
0.867	[*A*]Failures[*R*]may easily inhibit[*A*]the completion of the request	context()	negated: False ,passive: False
0.893	[*A*]synchronous transition state machines[*R*]are started[*A*]on demandonly.Fault tolerance: The consideration of Byzantine faulty nodes forced us to abandon the classic "wait for all" paradigm	context()	negated: False ,passive: True
0.877	[*A*]cycles[*R*]used[*A*]for transition-based flow control	context()	negated: False ,passive: True
0.913	[*A*]hybrid state machines[*R*]combine[*A*]ASM[*A*]with synchronous transition state machines	context()	negated: False ,passive: False
0.897	[*A*]all" paradigm[*R*]used[*A*]for enforcing the indication principle in asynchronous designs	context()	negated: False ,passive: True
[LINE#648] A few timing constraints, established by our theoretical analysis, in conjunction with state-based communication are resorted to in order to establish event ordering and synchronized executions in FATAL+.Self-stabilization: In sharp contrast to non-stabilizing algorithms, which can always assume that there is a (substantial) number of non-faulty nodes that run approximately synchronously and hence jointly adhere to certain timing constraints, self-stabilizing algorithms cannot even assume this.
0.852	[*A*]A few timing constraints , established by our theoretical analysis[*R*]are resorted[*A*]in conjunction with state - based communication	context()	negated: False ,passive: True
0.902	[*A*]A few timing constraints , established by our theoretical analysis[*R*]are resorted[*A*]to in order to establish event ordering . Self - stabilization[*A*]in conjunction with state - based communication	context()	negated: False ,passive: True
0.722	[*A*]self - stabilizing algorithms[*R*]can not assume[*A*]this	context()	negated: True ,passive: False
0.877	[*A*]order[*R*]hence jointly adhere[*A*]to certain timing constraints	context()	negated: False ,passive: False
0.770	[*A*]order[*R*]run[*A*]approximately synchronously	context()	negated: False ,passive: True
0.852	[*A*]A few timing constraints , established by our theoretical analysis[*R*]are resorted[*A*]in order[*A*]in conjunction with state - based communication	context()	negated: False ,passive: True
0.838	[*A*]A few timing constraints[*R*]established[*A*]by our theoretical analysis	context()	negated: False ,passive: True
[LINE#649] Although FATAL+ guarantees that non-faulty nodes will eventually execute synchronously, even when started from an arbitrary state, the violation of timing constraints and hence metastability cannot be avoided during stabilization [44].
0.843	[*A*]FATAL+[*R*]guarantees[*A*]that non-faulty nodes will eventually execute synchronously , even when started from an arbitrary state , hence metastability can not be avoided during stabilization [ 44	context()	negated: False ,passive: False
0.894	[*A*]metastability[*R*]can not be avoided[*A*]during stabilization [ 44	context()	negated: True ,passive: True
0.879	[*A*]non-faulty nodes[*R*]will execute synchronously[*A*]when started from an arbitrary state[*A*]eventually	context(FATAL+ guarantees)	negated: False ,passive: False
0.843	[*A*]FATAL+[*R*]guarantees[*A*]that non-faulty nodes will eventually execute synchronously , even when started from an arbitrary state , the violation of timing constraints can not be avoided during stabilization [ 44	context()	negated: False ,passive: False
[LINE#650+651]  For example, state accept in Fig. 8has two successors sleep and recover, the guards of which could become true arbitrarily close to each other in certain stabilization scenarios.
0.799	[*A*]the guards of which[*R*]could become[*A*]true[*A*]arbitrarily close to each other	context()	negated: False ,passive: True
0.732	[*A*]two successors[*R*]recover	context()	negated: False ,passive: False
[LINE#652] This is acceptable, though, as long as such problematic events are neither systematic nor frequent, which is ensured by the design and implementation of FATAL+ (see Section 6.1).
0.783	[*A*]such problematic events[*R*]are[*A*]neither systematic nor frequent	context()	negated: False ,passive: True
0.567	[*A*]This[*R*]is[*A*]acceptable[*A*]though[*A*]as long as such problematic events are neither systematic nor frequent	context()	negated: False ,passive: True
[LINE#653+654+655]  6-10 reveals that the state transitions of the FATAL+ state machines are triggered by AND/OR combinations of the following different types of conditions:(1)A watchdog timer expires ["(T2,accept)"].(2)The state machines of a certain number (1, f+1, or n-f) of nodes reached a particular (subset of) state(s) at least once since the reset of the corresponding memory flags ["n-f accept"].(3)The state machines of a certain number (1, f+1, or n-f) of nodes are currently in (one of) a particular (subset of) state(s)["in resync"].(4)Always ["true"].These requirements reveal the need for the following major building blocks (cf.
0.818	[*A*]The state machines of a certain number[*R*]are[*A*]currently in	context()	negated: False ,passive: True
0.903	[*A*]These requirements[*R*]reveal[*A*]the need for the following major building blocks	context()	negated: False ,passive: False
[LINE#656] Section 4):Concurrent HSMs, implementing the states and transitions specified in the protocol.
0.894	[*A*]transitions[*R*]specified[*A*]in the protocol	context()	negated: False ,passive: True
0.887	[*A*]Section 4[*R*]implementing[*A*]transitions specified in the protocol	context()	negated: False ,passive: False
0.903	[*A*]the states[*R*]specified[*A*]in the protocol	context()	negated: False ,passive: True
0.887	[*A*]Section 4[*R*]implementing[*A*]the states specified in the protocol	context()	negated: False ,passive: False
[LINE#657] An ideal HSM would always provide feasible executions of its state transition module.Communication infrastructure between these state machines, continuously conveying state information.
0.912	[*A*]An ideal HSM[*R*]would provide[*A*]feasible executions of its state transition module.Communication infrastructure between these state machines[*A*]continuously conveying state information[*A*]always	context()	negated: False ,passive: False
[LINE#658]  This is simply done by the channels.
0.286	[*A*]This[*R*]is done[*A*]by the channels	context()	negated: False ,passive: True
[LINE#659] Si,j propagating the signal Si to all receivers.Watchdog timers (also with random timeouts) for implementing type (1) guards.Threshold modules and memory flags for implementing type (2) and type (3) guards.
0.857	[*A*]Si[*R*]j propagating[*A*]the signal[*A*]to all receivers.Watchdog timers ( also with random timeouts[*A*]for implementing type	context()	negated: False ,passive: False
[LINE#660] If we could provide implementations of all these building blocks that match the specifications of the formal model in Section 2.2 under all circumstances, in the sense that all executions at non-faulty nodes are always feasible, the theoretical guarantees derived in [13] would apply without restriction.
0.830	[*A*]the theoretical guarantees derived in [13][*R*]would apply	context()	negated: False ,passive: False
0.783	[*A*]the theoretical guarantees[*R*]derived[*A*]in [13	context()	negated: False ,passive: True
0.814	[*A*]all executions at non-faulty nodes[*R*]are[*A*]always[*A*]feasible	context()	negated: False ,passive: True
0.788	[*A*]all these building blocks[*R*]match	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]could provide[*A*]implementations of all these building blocks	context()	negated: False ,passive: False
[LINE#661] As already noted, however, this is impossible to guarantee, since there is no way to rule out metastable upsets with complete certainty, and there are no elements available for our purpose whose behavior is specified for metastable inputs.
0.687	[*A*]no elements available for our purpose[*R*]is specified[*A*]for metastable inputs	context()	negated: False ,passive: True
0.307	[*A*]this[*R*]is[*A*]impossible to guarantee[*A*]since there is no way	context()	negated: False ,passive: True
[LINE#662] Nevertheless, it is possible to design our basic modules in a way that keeps the probability of such events acceptably low.
0.887	[*A*]a way[*R*]keeps[*A*]the probability of such events acceptably low	context()	negated: False ,passive: False
[LINE#663] Moreover, all stateful components must be implemented in a self-stabilizing way: They must be able to eventually recover from an arbitrary erroneous internal state, including metastability, when facing sufficiently long executions on their input ports that do not induce metastability.
0.699	[*A*]all stateful components[*R*]must be implemented	context(They must be)	negated: False ,passive: False
0.664	[*A*]They[*R*]must be[*A*]able to eventually recover from an arbitrary erroneous internal state, including metastability	context()	negated: False ,passive: True
0.621	[*A*]their input ports[*R*]do not induce[*A*]metastability	context()	negated: True ,passive: False
0.317	[*A*]They[*R*]to recover[*A*]eventually	context()	negated: False ,passive: True
[LINE#664] Before we proceed with a description of the implementations of the required basic modules, we discuss how FATAL+ deals with the threat of metastability arising from our extreme fault scenarios..
0.898	[*A*]FATAL+[*R*]deals[*A*]with the threat of metastability	context(we discuss)	negated: False ,passive: False
0.543	[*A*]we[*R*]discuss[*A*]how FATAL+ deals with the threat of metastability[*A*]Before we proceed with a description of the implementations of the required basic modules	context()	negated: False ,passive: False
0.821	[*A*]metastability[*R*]arising[*A*]from our extreme fault scenarios	context()	negated: False ,passive: True
0.569	[*A*]we[*R*]proceed[*A*]with a description of the implementations of the required basic modules	context()	negated: False ,passive: False
[LINE#665] Metastability issuesReducing the potential for both metastability generation and metastability propagation are important goals in the design and implementation of FATAL+.
0.948	[*A*]Metastability issuesReducing the potential for metastability propagation[*R*]are[*A*]important goals in the implementation of FATAL+	context()	negated: False ,passive: True
0.938	[*A*]Metastability issuesReducing the potential for metastability propagation[*R*]are[*A*]important goals in the design	context()	negated: False ,passive: True
0.894	[*A*]Metastability[*R*]issuesReducing[*A*]the potential for metastability propagation	context()	negated: False ,passive: False
0.952	[*A*]Metastability issuesReducing the potential for both metastability generation[*R*]are[*A*]important goals in the implementation of FATAL+	context()	negated: False ,passive: True
0.943	[*A*]Metastability issuesReducing the potential for both metastability generation[*R*]are[*A*]important goals in the design	context()	negated: False ,passive: True
0.894	[*A*]Metastability[*R*]issuesReducing[*A*]the potential for both metastability generation	context()	negated: False ,passive: False
[LINE#666] Although it is impossible to completely rule out metastability generation in the presence of Byzantine faulty nodes (which may issue signal transitions at arbitrary times anyway) and during self-stabilization (where all nodes may be completely unsynchronized), we nevertheless achieve the following properties.
0.554	[*A*]we[*R*]achieve[*A*]the following properties[*A*]during self - stabilization	context()	negated: False ,passive: False
0.411	[*A*]we[*R*]achieve[*A*]the following properties	context()	negated: False ,passive: False
0.767	[*A*]all nodes[*R*]may be[*A*]completely unsynchronized	context()	negated: False ,passive: True
[LINE#667] Robustness against metastable upsets and their propagation:(I)Guaranteed metastability-freedom in fault-free executions after stabilization.(II)Low probability of metastable upsets: We have taken care to keep the windows of vulnerability of our implementations of basic modules as small as possible.
0.356	[*A*]We[*R*]have taken care to keep[*A*]the windows of vulnerability of our implementations of basic modules as small as possible	context(We have taken)	negated: False ,passive: False
0.534	[*A*]their propagation[*R*]Guaranteed[*A*]metastability - freedom	context(We have taken)	negated: False ,passive: False
0.265	[*A*]We[*R*]have taken to keep[*A*]the windows of vulnerability of our implementations of basic modules as small as possible	context(We have taken)	negated: False ,passive: False
0.356	[*A*]We[*R*]have taken[*A*]care[*A*]to keep the windows of vulnerability of our implementations of basic modules as small as possible	context()	negated: False ,passive: False
[LINE#668] Thus, desynchronized or faulty nodes must be very lucky to actually trigger a metastable upset.
0.862	[*A*]desynchronized or faulty nodes[*R*]to trigger[*A*]a metastable upset	context()	negated: False ,passive: False
0.919	[*A*]desynchronized or faulty nodes[*R*]must be[*A*]very lucky to actually trigger a metastable upset	context()	negated: False ,passive: True
[LINE#669]  In addition, mechanisms for decreasing the upset probability even further could be incorporated, if required in particularly critical applications.(III)Metastability containment:.
0.920	[*A*]mechanisms for decreasing the upset probability[*R*]even further could be incorporated[*A*]if required in particularly critical applications	context()	negated: False ,passive: True
[LINE#670] Non-faulty nodes are very robust against propagation of metastable upsets due to the algorithm's control flow.
0.937	[*A*]Non-faulty nodes[*R*]are[*A*]very robust[*A*]against propagation of metastable upsets due to the algorithm's control flow	context()	negated: False ,passive: True
[LINE#671]  Limited consequences of metastable upsets:(IV)Limited impact of metastable upsets during stabilization:.
[LINE#672] Metastable upsets that occur at non-faulty nodes during the stabilization phase can only delay stabilization.
0.936	[*A*]Metastable upsets that occur at non-faulty nodes during the stabilization phase[*R*]can delay[*A*]stabilization	context()	negated: False ,passive: False
0.887	[*A*]Metastable upsets[*R*]occur[*A*]at non-faulty nodes during the stabilization phase	context()	negated: False ,passive: True
[LINE#673] Since these are rare events even then, the respective effect on the (average) stabilization time is very small.(V)Fast recovery from metastability after stabilization: As long as n-f non-faulty nodes remain synchronized, a metastable upset at a node may disrupt its synchrony towards the other nodes only for a short time.
0.879	[*A*]the respective effect on the (average) stabilization time[*R*]is[*A*]very small	context(a metastable upset at a node may disrupt)	negated: False ,passive: True
0.851	[*A*]a metastable upset at a node[*R*]may disrupt[*A*]its synchrony towards the other nodes[*A*]only for a short time	context()	negated: False ,passive: False
0.756	[*A*]n-f non-faulty nodes[*R*]synchronized	context()	negated: False ,passive: False
0.814	[*A*]n-f non-faulty nodes[*R*]remain[*A*]synchronized	context()	negated: False ,passive: True
0.537	[*A*]these[*R*]are even then[*A*]rare events	context()	negated: False ,passive: True
[LINE#674]  Due to the fast stabilization mechanism the node will fully recover within O(1) time once metastability ceases.(VI)Masking of metastable upsets as faults:.
0.859	[*A*]the node[*R*]will recover[*A*]within O	context()	negated: False ,passive: True
[LINE#675] Provided that the measures ensuring (II) and (III) are effective (i.e., metastability does not spread) and the system-level fault-tolerance of f nodes operating outside their specification is not exhausted, metastable upsets at some nodes do not affect the correctness of other nodes.
0.905	[*A*]metastable upsets at some nodes[*R*]do not affect[*A*]the correctness of other nodes	context(Provided the system - level fault - tolerance of f nodes is not)	negated: True ,passive: False
0.836	[*A*]Provided the system - level fault - tolerance of f nodes[*R*]is not[*A*]exhausted	context()	negated: True ,passive: True
0.835	[*A*]f nodes[*R*]operating[*A*]outside their specification	context()	negated: False ,passive: True
0.713	[*A*]metastability[*R*]does not spread	context()	negated: True ,passive: False
0.774	[*A*]III[*R*]are[*A*]effective	context()	negated: False ,passive: True
[LINE#676+677]  The following approaches have been used in FATAL+ to accomplish these goals (additional details will be given in the subsequent sections):(I)If all nodes are synchronized and fault-free, we can satisfy timing constraints on the modules' input ports' signals that ensure that even our (necessarily imperfect)implementations of the abstract modules maintain feasibility at all times.
0.732	[*A*]all nodes[*R*]are synchronized	context()	negated: False ,passive: False
0.903	[*A*]additional details[*R*]will be given[*A*]in the subsequent sections	context()	negated: False ,passive: True
0.764	[*A*]even our (necessarily imperfect)implementations of the abstract modules[*R*]maintain[*A*]feasibility[*A*]at all times	context(timing constraints on the modules ' input ports ' signals ensure)	negated: False ,passive: False
0.807	[*A*]timing constraints on the modules' input ports' signals[*R*]ensure[*A*]that even our (necessarily imperfect)implementations of the abstract modules maintain feasibility at all times	context()	negated: False ,passive: False
0.925	[*A*]The following approaches[*R*]have been used[*A*]in FATAL+[*A*]to accomplish these goals	context()	negated: False ,passive: True
0.208	[*A*]we[*R*]can satisfy[*A*]timing constraints on the modules' input ports' signals that ensure that even our (necessarily imperfect)implementations of the abstract modules maintain feasibility at all times	context()	negated: False ,passive: False
[LINE#678] Essentially, the argument is that since there is no initial violation of the constraints and no faults are imposed by external events, we can conclude that the constraints will be satisfied at later points in time as well.
0.878	[*A*]the constraints[*R*]will be[*A*]satisfied[*A*]at later points[*A*]in time[*A*]as well	context(we can conclude)	negated: False ,passive: True
0.878	[*A*]no faults[*R*]are imposed[*A*]by external events	context(the argument is we can conclude)	negated: False ,passive: True
0.752	[*A*]the argument[*R*]is[*A*]that since there is no faults are imposed by external events	context(we can conclude)	negated: False ,passive: True
0.271	[*A*]we[*R*]can conclude[*A*]that the constraints will be satisfied at later points in time as well	context()	negated: False ,passive: False
0.878	[*A*]the constraints[*R*]will be[*A*]satisfied[*A*]at later points[*A*]in time	context(the argument is we can conclude)	negated: False ,passive: True
0.271	[*A*]we[*R*]can conclude[*A*]that the constraints will be satisfied at later points in time as well	context(the argument is)	negated: False ,passive: False
0.752	[*A*]the argument[*R*]is[*A*]that since there is no initial violation of the constraints , we can conclude that the constraints will be satisfied at later points in time as well	context()	negated: False ,passive: True
[LINE#679] This property is formally proved in [13].(II)All building blocks that are susceptible to metastable upsets, like memory flags, are implemented in a way that minimizes the time span during which they are vulnerable.
0.741	[*A*]they[*R*]are[*A*]vulnerable[*A*]the time span	context()	negated: False ,passive: True
0.810	[*A*]a way[*R*]minimizes[*A*]the time span during which they are vulnerable	context()	negated: False ,passive: False
0.897	[*A*]All building blocks that are susceptible to metastable upsets, like memory flags,[*R*]are implemented	context()	negated: False ,passive: False
0.897	[*A*]All building blocks[*R*]are[*A*]susceptible to metastable upsets, like memory flags	context()	negated: False ,passive: True
0.767	[*A*]This property[*R*]is formally proved[*A*]in [13	context()	negated: False ,passive: True
[LINE#680] Moreover, elastic pipelines acting as metastability filters [40] or synchronizers could be added easily to our design to further protect such elements.(III)We enforce (standard) error containment by avoiding any explicit control flow between ASMs: Since the communication is exclusively performed by virtue of states, a faulty receiver cannot impact a non-faulty sender, and a faulty sender, in turn, cannot directly interfere with the operation of a non-faulty receiver (apart from conveying an incorrect state, of course).
0.897	[*A*]a faulty sender[*R*]can not directly interfere[*A*]with the operation of a non-faulty receiver	context()	negated: True ,passive: False
0.925	[*A*]elastic pipelines acting as metastability filters [40] or synchronizers[*R*]to protect[*A*]such elements	context()	negated: False ,passive: False
0.333	[*A*]We[*R*]enforce by avoiding[*A*]any explicit control flow between ASMs	context(elastic pipelines acting as metastability filters [ 40 ] or synchronizers could be added easily We enforce a faulty receiver can not impact)	negated: False ,passive: False
0.346	[*A*]We[*R*]enforce[*A*]standard) error containment	context(elastic pipelines acting as metastability filters [ 40 ] or synchronizers could be added easily a faulty receiver can not impact)	negated: False ,passive: False
0.888	[*A*]a faulty receiver[*R*]can not impact[*A*]a non-faulty sender	context(elastic pipelines acting as metastability filters [ 40 ] or synchronizers could be added easily)	negated: True ,passive: False
0.903	[*A*]elastic pipelines acting as metastability filters [40] or synchronizers[*R*]could be added easily[*A*]to our design[*A*]to further protect such elements	context()	negated: False ,passive: True
0.901	[*A*]the communication[*R*]is exclusively performed apart[*A*]by virtue of states	context()	negated: False ,passive: True
0.903	[*A*]elastic pipelines[*R*]acting[*A*]as metastability filters [40] or synchronizers	context()	negated: False ,passive: False
[LINE#681] To extend error containment to also cover metastability to the best possible extent, several forms of logical masking are employed.
0.785	[*A*]several forms of logical masking[*R*]are employed	context()	negated: False ,passive: False
[LINE#682] One example is the combination of memory flags and threshold gates, which ensure that possibly upset memory flags are always overruled quickly by correct ones at the threshold output.1818It is not self-evident that this type of masking is very effective for metastability as well.
0.910	[*A*]possibly upset memory flags[*R*]are overruled quickly[*A*]by correct ones[*A*]at the threshold output.1818It[*A*]always	context(threshold gates ensure)	negated: False ,passive: True
0.780	[*A*]threshold gates[*R*]ensure[*A*]that possibly upset memory flags are always overruled quickly by correct ones at the threshold output.1818It	context()	negated: False ,passive: False
[LINE#683] Later on we will discuss why this is indeed the case.
[LINE#684] A higher-level form of logical masking occurs due to the fact that, after stabilization, all non-faulty nodes execute the outer cycle of the main state machine (Fig. 8) only.
0.948	[*A*]all non-faulty nodes[*R*]execute[*A*]the outer cycle of the main state machine[*A*]after stabilization	context()	negated: False ,passive: False
0.830	[*A*]A higher-level form of logical masking[*R*]occurs	context()	negated: False ,passive: False
[LINE#685] The outer cycle's guards do not involve any of the timeouts, states, or flags accessed by the resynchronization routine (Fig. 10) or the extension of the main state machine (Fig. 9); hence any metastability of the corresponding signals does not affect the logic of the main state machine and the layers on top of it (including the logical clocks).(IV)The measures outlined in (II) and (III) are complemented by adding time masking using randomization.
0.918	[*A*]The measures[*R*]outlined[*A*]in (II	context()	negated: False ,passive: True
0.729	[*A*]The measures outlined in (II) and (III[*R*]are complemented	context(any metastability of the corresponding signals does not affect)	negated: False ,passive: False
0.905	[*A*]The outer cycle's guards[*R*]do not involve[*A*]any of the timeouts, states, or flags	context(any metastability of the corresponding signals does not affect)	negated: True ,passive: True
0.917	[*A*]any metastability of the corresponding signals[*R*]does not affect[*A*]the logic of the main state machine and the layers on top of it (including the logical clocks).(IV	context()	negated: True ,passive: False
0.922	[*A*]The measures outlined in (II) and (III[*R*]by adding[*A*]time masking	context()	negated: False ,passive: False
0.938	[*A*]the timeouts, states, or flags[*R*]accessed[*A*]by the resynchronization routine	context()	negated: False ,passive: True
[LINE#686] The resynchronization routine (Fig. 10) tries to initialize recovery from arbitrary states at random, sufficiently sparse points in time.
0.865	[*A*]Fig[*R*]tries to initialize[*A*]recovery from arbitrary states at random, sufficiently sparse points in time	context(Fig tries)	negated: False ,passive: False
0.865	[*A*]Fig[*R*]tries[*A*]to initialize recovery from arbitrary states at random, sufficiently sparse points in time	context()	negated: False ,passive: False
[LINE#687] Hence non-faulty nodes cannot be systematically kept from stabilizing.
0.767	[*A*]non-faulty nodes[*R*]can not be systematically kept[*A*]from stabilizing	context()	negated: True ,passive: True
[LINE#688] The proofs in [13] reveal that within O(n) time in fact it is likely that there are multiple events that will imply subsequent stabilization.
0.756	[*A*]The proofs in [13[*R*]reveal[*A*]that within O(n) time in fact it is likely that there are multiple events	context()	negated: False ,passive: False
0.887	[*A*]multiple events[*R*]will imply[*A*]subsequent stabilization	context()	negated: False ,passive: False
[LINE#689]  Considering that metastable upsets are rare events in our setting, their impact thus becomes negligible.(V)This property directly follows from the results shown in [13]:.
0.878	[*A*]This property[*R*]directly follows[*A*]from the results	context(their impact becomes)	negated: False ,passive: True
0.288	[*A*]their impact[*R*]becomes[*A*]negligible	context()	negated: False ,passive: True
0.813	[*A*]the results[*R*]shown[*A*]in [13	context()	negated: False ,passive: True
[LINE#690+691]  If n-f nodes faithfully execute the basic cycle, any non-faulty node will (re)synchronize within O(1) time, irrespectively of its currentmetastability does not spread to a given receiver, the latter will observe for each sender some execution, even if the sender does not send a valid signal in terms of our system model.
0.534	[*A*]the latter[*R*]will observe[*A*]for each sender[*A*]some execution[*A*]even if the sender does not send a valid signal in terms of our system model	context()	negated: False ,passive: False
0.923	[*A*]any non-faulty node[*R*]will re irrespectively[*A*]synchronize within O(1	context()	negated: False ,passive: False
0.919	[*A*]n-f nodes[*R*]faithfully execute[*A*]the basic cycle	context()	negated: False ,passive: False
[LINE#692+693]  Since we assume that faulty nodes may output arbitrary signals at their output ports, our model thus makes no distinction between a "conventionally" faulty node and one that behaves erratically due to metastable upsets.1919To match our model, invalid signal states are simply mapped to some default state, e.g. resync for the main state machine.
0.602	[*A*]invalid signal states[*R*]are mapped	context(our model makes)	negated: False ,passive: False
0.648	[*A*]our model[*R*]makes[*A*]no distinction between a "conventionally" faulty node and one	context()	negated: False ,passive: False
0.802	[*A*]faulty nodes[*R*]may output[*A*]arbitrary signals[*A*]at their output ports	context(we assume)	negated: False ,passive: False
0.173	[*A*]we[*R*]assume[*A*]that faulty nodes may output arbitrary signals at their output ports	context()	negated: False ,passive: False
0.805	[*A*]a "conventionally" faulty node and one[*R*]behaves erratically due	context()	negated: False ,passive: False
[LINE#694+695]  As the algorithm is resilient to , such upsets are masked as long as the total number of nodes operating outside their module specification is at most.
0.831	[*A*]the total number of nodes[*R*]is[*A*]at most	context()	negated: False ,passive: True
0.821	[*A*]nodes[*R*]operating[*A*]outside their module specification	context()	negated: False ,passive: True
0.890	[*A*]such upsets[*R*]are masked[*A*]as long as the total number of nodes operating outside their module specification is at most	context()	negated: False ,passive: True
0.813	[*A*]the algorithm[*R*]is[*A*]resilient to	context()	negated: False ,passive: True
[LINE#696+697]  State machine communicationAccording to our system model, an HSM of nodei must continuously communicate its current state system-wide via the channels Sj,i.
0.752	[*A*]State machine communicationAccording to our system model, an HSM of nodei[*R*]must continuously communicate wide[*A*]Sj	context()	negated: False ,passive: False
0.835	[*A*]State machine[*R*]communicationAccording[*A*]to our system model	context()	negated: False ,passive: True
[LINE#698+699]  For simplicity, we use parallel communication, by means of a suitably sized data bus, in our implementation.2020It is, however, possible to replace parallel communication by serial communication, e.g., by extending the (synchronous) TSM(see Section 6.3) appropriately.
0.614	[*A*]we[*R*]use[*A*]parallel communication[*A*]to replace parallel communication by serial communication, e.g., by extending the (synchronous) TSM(see Section 6.3) appropriately	context()	negated: False ,passive: False
[LINE#700] A complete receiver as described below is employed for every state machine in the system.
0.932	[*A*]A complete receiver as described below[*R*]is employed[*A*]for every state machine[*A*]in the system	context()	negated: False ,passive: True
[LINE#701] Since a node treats itself like any other node in type (2) and type (3) guards with thresholds, every node receives its own state as well.. .
0.890	[*A*]a node[*R*]treats[*A*]itself[*A*]like any other node in type ( type ( 3 ) guards with thresholds	context()	negated: False ,passive: False
0.831	[*A*]every node[*R*]receives as well[*A*]its own state	context()	negated: False ,passive: False
0.890	[*A*]a node[*R*]treats[*A*]itself[*A*]like any other node in type ( 2 ) guards with thresholds	context()	negated: False ,passive: False
[LINE#702+703]  11 shows the circuitry used for communicating the current state of the main algorithm in Fig.8.The sender consists of a simple array of flip-flops, which drive the parallel data bus that thus continuously reflects the current state of the sender's HSM.
0.859	[*A*]flip-flops[*R*]drive[*A*]the parallel data bus that thus continuously reflects the current state of the sender's HSM	context()	negated: False ,passive: False
0.947	[*A*]the circuitry[*R*]used[*A*]for communicating the current state of the main algorithm in Fig.8.The sender	context()	negated: False ,passive: True
0.920	[*A*]the parallel data bus[*R*]continuously reflects[*A*]the current state of the sender's HSM	context()	negated: False ,passive: True
0.973	[*A*]the circuitry used for communicating the current state of the main algorithm in Fig.8.The sender[*R*]consists[*A*]of a simple array of flip-flops	context(11 shows)	negated: False ,passive: True
0.710	[*A*]11[*R*]shows[*A*]the circuitry used for communicating the current state of the main algorithm in Fig.8.The sender consists of a simple array of flip-flops	context()	negated: False ,passive: False
[LINE#704] Technically speaking, the flip-flops are not part of the channel but rather the sender's HSM; they are the "physical location" of the HSM's state in the sense of our model.
0.900	[*A*]the flip - flops[*R*]are not[*A*]part of the sender 's HSM	context(they are)	negated: True ,passive: True
0.900	[*A*]the flip - flops[*R*]are not[*A*]part of the channel	context(they are)	negated: True ,passive: True
0.573	[*A*]they[*R*]are[*A*]the " physical location " of the HSM 's state in the sense of our model	context()	negated: False ,passive: True
[LINE#705] The channel thus "begins" with the wires conveying the stored values.2121Note that there is some freedom with respect to the mapping of module ports to the physical system, which also affects which module(s) become(s) infeasible due to a (physical) fault.
0.718	[*A*]the physical system[*R*]affects	context()	negated: False ,passive: False
0.748	[*A*]the wires[*R*]conveying[*A*]the stored values.2121Note that there is some freedom with respect to the mapping of module ports to the physical system	context()	negated: False ,passive: False
0.868	[*A*]The channel[*R*]begins[*A*]with the wires	context()	negated: False ,passive: True
[LINE#706] However, no matter what the precise mapping, care has to be taken to avoid correlated failures.
0.877	[*A*]care[*R*]to be taken[*A*]to avoid correlated failures	context()	negated: False ,passive: True
[LINE#707] For instance, if all channels meet in a single spot due to bad routing, manufacturing defects or electromigration could connect several channels, therefore rendering our system-level fault-tolerance (i.e., the resilience to f node failures) ineffective.
0.784	[*A*]the resilience[*R*]to f	context()	negated: False ,passive: False
0.937	[*A*]all channels[*R*]meet[*A*]in a single spot due to bad routing, manufacturing defects or electromigration	context()	negated: False ,passive: False
[LINE#708] In sharp contrast to handshake-based communication, reading at the receiver occurs without any direct coordination with the sender.
0.769	[*A*]reading at the receiver[*R*]occurs	context()	negated: False ,passive: False
[LINE#709] To avoid the unacceptable risk of reading and capturing false intermediate sender states, which might be perceived by the receiver upon a sender state transition in case of different delays on the data bus wires, delay-insensitive state coding [45] must be used.
0.713	[*A*]state[*R*]coding	context()	negated: False ,passive: False
0.939	[*A*]false intermediate sender states[*R*]might be perceived[*A*]by the receiver upon a sender state transition in case of different delays on the data bus wires	context()	negated: False ,passive: True
0.229	[*A*]45[*R*]must be used	context()	negated: False ,passive: False
[LINE#710+711]  We have chosen the following encoding for the main state machine in Fig. 8:propose0000accept1001sleep1011sleepwaking0011waking0101ready0110recover1100join1010The receiver comprises a simple combinational decoder consisting of AND gates, which generate a 1-out-of-m encoding of the binary representation of the state communicated via the data bus.
0.920	[*A*]gates[*R*]generate[*A*]a 1-out-of-m encoding of the binary representation of the state communicated via the data bus	context()	negated: False ,passive: False
0.919	[*A*]a simple combinational decoder[*R*]consisting[*A*]of AND gates	context()	negated: False ,passive: True
0.914	[*A*]a 1-out-of-m encoding of the binary representation of the state[*R*]communicated	context()	negated: False ,passive: False
[LINE#712] The decoded signals correspond to a single sender state each.
0.911	[*A*]The decoded signals[*R*]correspond[*A*]to a single sender state each	context()	negated: False ,passive: True
[LINE#713] This information is directly used for type (3) guards, and fed into memory flags for type (2) guards.
0.903	[*A*]This information[*R*]is fed[*A*]into memory flags	context()	negated: False ,passive: True
0.903	[*A*]This information[*R*]is directly used[*A*]for type ( 3 ) guards	context()	negated: False ,passive: True
[LINE#714+715]  For the other state machines making up FATAL+, it suffices to communicate only a single bit of state information (supp or none in Fig. 9, init or wait in Fig. 10, and propose+ or none+ in Fig..
0.737	[*A*]state information[*R*]has only of[*A*]10	context()	negated: False ,passive: False
0.397	[*A*]it[*R*]suffices to communicate[*A*]only a single bit of state information	context(it suffices)	negated: False ,passive: False
0.397	[*A*]it[*R*]suffices[*A*]to communicate only a single bit of state information	context()	negated: False ,passive: False
0.931	[*A*]the other state machines[*R*]making up[*A*]FATAL+	context()	negated: False ,passive: False
[LINE#716] Hence, every bus consists of a single sender flip-flop plus a wire here, and the decoder in the receiver becomes trivial.
0.903	[*A*]every bus[*R*]consists[*A*]of a wire here	context()	negated: False ,passive: True
0.903	[*A*]every bus[*R*]consists[*A*]of a single sender flip - flop	context()	negated: False ,passive: True
0.814	[*A*]the decoder in the receiver[*R*]becomes[*A*]trivial	context()	negated: False ,passive: True
[LINE#717] In the sequel, we restrict our discussion to the main state machine's channel, as the simpler single-bit channels clearly meet the specification of a channel.
0.932	[*A*]the simpler single-bit channels[*R*]clearly meet[*A*]the specification of a channel	context()	negated: False ,passive: False
0.562	[*A*]we[*R*]restrict[*A*]our discussion to the main state machine's channel[*A*]as the simpler single-bit channels clearly meet the specification of a channel[*A*]In the sequel	context()	negated: False ,passive: False
[LINE#718] Note that in both cases the (physical) channels used in our implementation trivially recover from any inputs and transient faults, as they are obviously forgetful.
0.361	[*A*]they[*R*]are[*A*]obviously[*A*]forgetful	context()	negated: False ,passive: True
0.871	[*A*]the ( physical ) channels[*R*]used[*A*]in our implementation	context()	negated: False ,passive: True
[LINE#719] The memory flags at the receiver's side contain feedback-loops, however, which do not allow us to apply Theorem 3.7 and Lemma 3.8.Correctness.
0.433	[*A*]us[*R*]to apply[*A*]Lemma 3.8.Correctness	context(feedback - loops , however do not allow)	negated: False ,passive: False
0.841	[*A*]feedback - loops , however[*R*]do not allow[*A*]us to apply Lemma 3.8.Correctness	context()	negated: True ,passive: False
0.946	[*A*]The memory flags at the receiver 's side[*R*]contain[*A*]feedback - loops , however , which do not allow us to apply Lemma 3.8.Correctness	context()	negated: False ,passive: False
0.433	[*A*]us[*R*]to apply[*A*]Theorem 3.7	context(feedback - loops , however do not allow)	negated: False ,passive: False
0.841	[*A*]feedback - loops , however[*R*]do not allow[*A*]us to apply Theorem 3.7	context()	negated: True ,passive: False
0.946	[*A*]The memory flags at the receiver 's side[*R*]contain[*A*]feedback - loops , however , which do not allow us to apply Theorem 3.7	context()	negated: False ,passive: False
[LINE#720] We now argue informally2222Our basic modules appear simple enough to be amenable to formal verification.
0.699	[*A*]informally2222Our basic modules[*R*]appear	context(We argue)	negated: False ,passive: False
0.606	[*A*]We[*R*]argue[*A*]informally2222Our basic modules appear simple enough to be amenable to formal verification[*A*]now	context()	negated: False ,passive: False
0.897	[*A*]informally2222Our basic modules[*R*]to be[*A*]amenable to formal verification	context()	negated: False ,passive: True
[LINE#721] Still, there are complications: Besides the fact that we assume not only continuous time but also continuous computations, which rules out using standard verification approaches, there is the challenge of finding and expressing suitable input port execution constraints required for implementation correctness.
0.452	[*A*]we[*R*]assume[*A*]continuous computations	context()	negated: False ,passive: False
0.858	[*A*]continuous computations[*R*]rules out using[*A*]standard verification approaches	context(continuous computations rules out)	negated: False ,passive: False
0.858	[*A*]continuous computations[*R*]rules out[*A*]using standard verification approaches	context()	negated: False ,passive: False
0.569	[*A*]we[*R*]assume[*A*]continuous computations , which rules out using standard verification approaches	context()	negated: False ,passive: False
0.926	[*A*]suitable input port execution constraints[*R*]required[*A*]for implementation correctness	context()	negated: False ,passive: True
0.452	[*A*]we[*R*]assume[*A*]not only continuous time	context()	negated: False ,passive: False
[LINE#722] Exploring this avenue is part of our future work.
0.881	[*A*]Exploring this avenue[*R*]is[*A*]part of our future work	context()	negated: False ,passive: True
[LINE#723] why and when the above implementation matches the specifications given in Section 4.
0.903	[*A*]the specifications[*R*]given[*A*]in Section 4	context()	negated: False ,passive: True
0.751	[*A*]the above implementation[*R*]matches	context()	negated: False ,passive: False
[LINE#724] Note that when affected by faults or provided with illegal inputs, modules may of course exhibit arbitrary behavior.
[LINE#725] In that case we rely on (a) the system-level fault tolerance properties (for fault masking), (b) the self-stabilization properties of the affected modules (for recovery), and (c) the rare occurrence of these situations (in order to not exhaust the system-level fault tolerance limits).
0.504	[*A*]we[*R*]rely on (a)[*A*]the system-level fault tolerance properties (for fault masking	context(we rely)	negated: False ,passive: False
0.399	[*A*]we[*R*]rely[*A*]on (a) the system-level fault tolerance properties (for fault masking), (b) the self-stabilization properties of the affected modules (for recovery), and (c) the rare occurrence of these situations (in order[*A*]In that case	context()	negated: False ,passive: False
[LINE#726] In addition to considering the fault-free behavior, it hence suffices to restrict our attention to (b) and (c) here.
0.225	[*A*]it[*R*]suffices to restrict[*A*]our attention[*A*]to (b) and (c)[*A*]here	context(it suffices)	negated: False ,passive: False
0.225	[*A*]it[*R*]suffices[*A*]to restrict our attention to (b) and (c) here	context()	negated: False ,passive: False
[LINE#727] For fault-free operation, the described implementation essentially realizes a channel as specified in Section 4 with some maximum delay dChan, granted that changes of the input provided by the sender are separated in time sufficiently well.
0.903	[*A*]the input[*R*]provided[*A*]by the sender	context()	negated: False ,passive: True
0.718	[*A*]some maximum delay[*R*]granted	context()	negated: False ,passive: False
0.897	[*A*]the described implementation[*R*]realizes[*A*]a channel[*A*]as specified in Section 4 with some maximum delay	context()	negated: False ,passive: False
0.903	[*A*]changes of the input[*R*]are separated sufficiently well[*A*]in time	context()	negated: False ,passive: True
[LINE#728+729]  To see this, consider an input switch from state s to s(note that not all flip-flops will switch their output signals at exactly the same instant), where initially the signal is stable also on the receiver's side.
0.957	[*A*]the signal[*R*]is[*A*]stable[*A*]also[*A*]on the receiver's side[*A*]where initially	context()	negated: False ,passive: True
0.871	[*A*]not all flip-flops[*R*]will switch[*A*]their output signals	context()	negated: False ,passive: False
[LINE#730] Once the signal change propagated through the wires and the AND gates, the decoder output signal corresponding to state s will be 1, while all other signals will be 0.
0.967	[*A*]the decoder output signal corresponding to state s[*R*]will be[*A*]1[*A*]while all other signals will be 0[*A*]Once the signal change propagated through the AND gates	context()	negated: False ,passive: True
0.973	[*A*]the decoder output signal corresponding to state s[*R*]will be[*A*]1	context()	negated: False ,passive: False
0.783	[*A*]all other signals[*R*]will be[*A*]0	context()	negated: False ,passive: True
0.967	[*A*]the decoder output signal corresponding to state s[*R*]will be[*A*]1[*A*]while all other signals will be 0[*A*]Once the signal change propagated through the wires	context()	negated: False ,passive: True
0.919	[*A*]the decoder output signal[*R*]corresponding[*A*]to state s	context()	negated: False ,passive: True
0.751	[*A*]the signal change[*R*]propagated	context()	negated: False ,passive: False
[LINE#731] Due to the use of delay-insensitive state encoding, there are no glitches and the signals for all other states s{s,s} will continuously be 0.
0.458	[*A*]s[*R*]will be[*A*]0	context()	negated: False ,passive: True
[LINE#732] Nevertheless, formally, this behavior does not yet fully match the definition of our communication channels in Section 4: It is possible that temporarily both s and s are 1.
[LINE#733+734]  Since our algorithms are completely oblivious to the exact point in time when the perceived Si,j changes after the sender's state Sj changed(the analysis in [13] only requires that this happens within d time), however, this problem can easily be abstracted away.2323Formally, this abstraction builds upon a weakened definition of lower-level channels, which attain values from S(S2).
0.321	[*A*]this[*R*]happens[*A*]within d time	context(the perceived Si requires)	negated: False ,passive: True
0.768	[*A*]the perceived Si[*R*]requires[*A*]that this happens within d time	context()	negated: False ,passive: False
0.920	[*A*]lower-level channels[*R*]attain[*A*]values[*A*]from S	context()	negated: False ,passive: False
0.949	[*A*]j changes after the sender's state Sj[*R*]changed[*A*]the analysis in [13	context()	negated: False ,passive: False
0.687	[*A*]this problem[*R*]can easily be abstracted away.2323Formally	context(this abstraction builds)	negated: False ,passive: False
0.882	[*A*]this abstraction[*R*]builds[*A*]upon a weakened definition of lower-level channels	context()	negated: False ,passive: False
0.638	[*A*]our algorithms[*R*]are[*A*]completely oblivious to the exact point in time	context()	negated: False ,passive: True
[LINE#735+736]  Alternatively, it would also be possible to use an explicit transition state (encoded by any bit sequence not corresponding to a state), and force the sender to always perform state transition via . All that is needed here is to interpret, in a static way, the situation where both s and s are valid as, say, s.
0.698	[*A*]the sender[*R*]to interpret	context()	negated: False ,passive: False
0.155	[*A*]All[*R*]is needed[*A*]here	context()	negated: False ,passive: True
0.911	[*A*]any bit sequence[*R*]not corresponding[*A*]to a state	context()	negated: True ,passive: True
0.895	[*A*]both s[*R*]are[*A*]valid[*A*]the situation	context()	negated: False ,passive: True
0.905	[*A*]an explicit transition state[*R*]encoded[*A*]by any bit sequence	context()	negated: False ,passive: True
0.451	[*A*]All that is needed here[*R*]is[*A*]to interpret	context()	negated: False ,passive: True
[LINE#737] The attentive reader will have noticed that the 1-out-of-m decoder outputs (i.e., the state signals at the inputs of the memory flags) may temporarily be all 0 during the reception of a sender state transition as well.
0.952	[*A*]the 1-out-of-m decoder outputs[*R*]may be[*A*]all 0[*A*]during the reception of a sender state transition[*A*]as well[*A*]temporarily	context()	negated: False ,passive: True
[LINE#738] Fortunately, this behavior is completely masked from becoming visible to our algorithms: The memory flags prohibit this from becoming visible in type (2) guards at all, and all state transition conditions involving type (3) guards refer to a single state only.
0.953	[*A*]all state transition conditions involving type ( 3 ) guards[*R*]refer[*A*]to a single state only	context()	negated: False ,passive: False
0.919	[*A*]all state transition conditions[*R*]involving[*A*]type ( 3 ) guards	context()	negated: False ,passive: True
0.718	[*A*]this behavior[*R*]is masked[*A*]from becoming visible to our algorithms	context(The memory flags prohibit)	negated: False ,passive: True
0.927	[*A*]The memory flags[*R*]prohibit[*A*]this[*A*]from becoming visible in type ( 2 ) guards at all	context()	negated: False ,passive: False
[LINE#739] Hence, in terms of the transition condition, a similar abstraction as above is valid (i.e., for a remote state transition from s to s with a "gap" we can define an equivalent execution without gap in which the node in question behaves identically).The above arguments critically rely on the assumption that states change not too rapidly.
0.713	[*A*]states[*R*]change not too rapidly	context()	negated: True ,passive: False
0.789	[*A*]The above arguments[*R*]critically rely[*A*]on the assumption that states change not too rapidly	context()	negated: False ,passive: False
0.953	[*A*]the node in question[*R*]behaves[*A*]identically[*A*]gap	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]can define[*A*]an equivalent execution	context()	negated: False ,passive: False
[LINE#740] Otherwise, the receiver could e.g. fail to observe states that the sender assumed for a too short period of time only, or even decode a state that has not been attained.
0.698	[*A*]a state[*R*]has not been attained	context()	negated: True ,passive: False
0.742	[*A*]the sender[*R*]decode[*A*]a state that has not been attained	context()	negated: False ,passive: False
0.903	[*A*]the sender[*R*]assumed[*A*]for a too short period of time only	context()	negated: False ,passive: False
0.822	[*A*]the receiver[*R*]to observe[*A*]states that the sender assumed for a too short period of time only, or even decode a state	context()	negated: False ,passive: False
0.859	[*A*]the receiver[*R*]could fail[*A*]to observe states	context()	negated: False ,passive: True
[LINE#741] For non-faulty nodes, this is guaranteed in our implementation because the minimal amount of time an HSM needs to complete a state transition is greater than the maximum end-to-end delay variation of the signals employed in the communication channel.
0.839	[*A*]an HSM[*R*]needs to complete[*A*]a state transition	context(an HSM needs)	negated: False ,passive: False
0.839	[*A*]an HSM[*R*]needs[*A*]to complete a state transition	context()	negated: False ,passive: False
0.903	[*A*]the signals[*R*]employed[*A*]in the communication channel	context()	negated: False ,passive: True
0.987	[*A*]the minimal amount of time an HSM needs to complete a state transition[*R*]is[*A*]greater than the maximum end-to-end delay variation of the signals	context()	negated: False ,passive: True
0.392	[*A*]this[*R*]is guaranteed[*A*]in our implementation[*A*]because the minimal amount of time an HSM needs to complete a state transition is greater than the maximum end-to-end delay variation of the signals	context()	negated: False ,passive: True
[LINE#742] This constraint is easy to ensure by proper circuit design rules.
0.925	[*A*]This constraint[*R*]is[*A*]easy to ensure by proper circuit design rules	context()	negated: False ,passive: True
[LINE#743] Within the communication channels themselves, metastable upsets could only occur in the senders' flip-flops and in the receivers' memory flags; everything else is stateless combinational logic.
0.946	[*A*]metastable upsets[*R*]could occur[*A*]in the senders' flip-flops and in the receivers' memory flags[*A*]Within the communication channels	context()	negated: False ,passive: True
[LINE#744] The flip-flops are clocked by the sender's own clock, hence could become metastable only in case of a faulty sender.
[LINE#745] The issue of upsets of the memory flags is discussed in Section 6.2.2.Viewed at the node level, it is obvious that if the sender's state signal becomes metastable or changes too quickly (which can only happen if the sender is faulty), this can also induce metastability at the receiver side by propagation over the channel.
0.926	[*A*]the sender's state signal[*R*]becomes[*A*]metastable or changes too quickly	context()	negated: False ,passive: True
0.894	[*A*]Section[*R*]6.2.2.Viewed[*A*]at the node level	context()	negated: False ,passive: True
0.813	[*A*]the sender[*R*]is[*A*]faulty	context()	negated: False ,passive: True
[LINE#746] During the stabilization phase, the receiver could also experience a channel-induced metastable upset in memory flags and/or in its HSMs due to the arbitrary desynchronization between sender and receiver; since the windows of vulnerability are very small, the upset probability is very low, though.
0.828	[*A*]the upset probability[*R*]is[*A*]very low[*A*]though	context()	negated: False ,passive: True
0.799	[*A*]the windows of vulnerability[*R*]are[*A*]very small	context()	negated: False ,passive: True
0.916	[*A*]the receiver[*R*]could experience[*A*]a channel - induced metastable upset in memory flags[*A*]During the stabilization phase	context()	negated: False ,passive: False
[LINE#747] Eventually, after stabilization, the synchrony between non-faulty nodes guaranteed by the FATAL+ protocol ensures that the received state data will always be stable when read in a transition condition in the main algorithm's outer cycle, recall item (I) in Section 6.1. .
0.942	[*A*]the received state data[*R*]will be[*A*]stable[*A*]when read in a transition condition in the main algorithm's outer cycle[*A*]always	context(the synchrony between non-faulty nodes ensures)	negated: False ,passive: True
0.894	[*A*]the synchrony between non-faulty nodes[*R*]ensures[*A*]that the received state data will always be stable when read in a transition condition in the main algorithm's outer cycle, recall item[*A*]Eventually[*A*]after stabilization	context()	negated: False ,passive: False
0.918	[*A*]non-faulty nodes[*R*]guaranteed[*A*]by the FATAL+ protocol	context()	negated: False ,passive: True
[LINE#748]  Memory flagsEvery memory flag is just an SR-latch with dominant reset, whose functional equivalents are also depicted in Fig..
0.961	[*A*]Memory flagsEvery memory flag[*R*]is[*A*]just an SR-latch with dominant reset	context()	negated: False ,passive: True
[LINE#749] Note that a memory flag is set depending on the state communicated by the sender, but (dominantly) cleared under the receiver's control.
0.903	[*A*]the state[*R*]communicated[*A*]by the sender	context()	negated: False ,passive: True
[LINE#750] A memory flag may become metastable when the inputs change during stabilization of its feedback loop, which can occur due to (a) input glitches and/or (b) simultaneous falling transitions on both inputs.
0.621	[*A*]its feedback loop[*R*]can occur[*A*]due to (b) simultaneous falling transitions on both inputs	context()	negated: False ,passive: True
0.621	[*A*]its feedback loop[*R*]can occur[*A*]due to (a) input glitches	context()	negated: False ,passive: True
0.835	[*A*]the inputs[*R*]change[*A*]during stabilization of its feedback loop	context()	negated: False ,passive: True
0.899	[*A*]A memory flag[*R*]may become[*A*]metastable[*A*]when the inputs change during stabilization of its feedback loop	context()	negated: False ,passive: True
[LINE#751]  However, for correct receivers, (a) can only occur in case of a faulty sender, and (b) is again only possible during stabilization:.
0.734	[*A*](b)[*R*]is[*A*]again[*A*]only possible	context()	negated: False ,passive: True
0.350	[*A*](a)[*R*]can occur[*A*]in case of a faulty sender	context()	negated: False ,passive: True
[LINE#752] Once non-faulty nodes execute the outer cycle of Fig. 8, it is guaranteed that e.g. all non-faulty nodes enter accept before the first one leaves.
0.299	[*A*]the first one[*R*]leaves	context()	negated: False ,passive: False
0.952	[*A*]non-faulty nodes[*R*]execute[*A*]the outer cycle of Fig[*A*]Once	context()	negated: False ,passive: False
[LINE#753] Overall, the upset probability is thus very small.
0.828	[*A*]the upset probability[*R*]is[*A*]thus[*A*]very small	context()	negated: False ,passive: True
[LINE#754] It could be further reduced by diverse known means for metastability filtering, like using an elastic pipeline or Schmitt-trigger stages (which must be accounted for in the delay bounds, though).
0.928	[*A*]Schmitt-trigger stages[*R*]must be accounted[*A*]for[*A*]in the delay bounds	context()	negated: False ,passive: True
0.350	[*A*]It[*R*]could be reduced[*A*]by diverse known means for metastability filtering	context()	negated: False ,passive: True
[LINE#755+756]  Finally, it is well-known that a metastable flip-flop will recover in finite time with probability one[44].Any SR latch matches the specification of a memory flag according to Section 4 followed by a channel with some maximum delay dMem, provided that it starts from a clean initial state and the set/reset signals avoid (a) and (b) above.
0.522	[*A*]it[*R*]starts[*A*]from the set / reset signals	context()	negated: False ,passive: True
0.522	[*A*]it[*R*]starts[*A*]from a clean initial state	context()	negated: False ,passive: True
0.903	[*A*]Section 4[*R*]followed[*A*]by a channel with some maximum delay	context()	negated: False ,passive: True
0.926	[*A*]a metastable flip - flop[*R*]will recover[*A*]in finite time[*A*]with probability one	context()	negated: False ,passive: True
[LINE#757] As argued above, the latter is guaranteed by our algorithm except in case of a metastable upset.
0.835	[*A*]the latter[*R*]is guaranteed[*A*]by our algorithm	context()	negated: False ,passive: True
[LINE#758+759]  In case of the memory flag implementation shown in Fig.11, dMem is primarily determined by the end-to-end settling time of the feedback loop.
0.917	[*A*]dMem[*R*]is determined[*A*]by the end-to-end settling time of the feedback loop[*A*]In case of the memory flag implementation	context()	negated: False ,passive: True
0.937	[*A*]the memory flag implementation[*R*]shown[*A*]in Fig.11	context()	negated: False ,passive: True
[LINE#760] This delay also determines the vulnerability window with respect to metastability (i.e. critical glitch length, and "simultaneity" of transitions).
0.927	[*A*]This delay[*R*]determines[*A*]the vulnerability window with respect to " simultaneity " of transitions	context()	negated: False ,passive: False
0.887	[*A*]This delay[*R*]determines[*A*]the vulnerability window with respect to metastability	context()	negated: False ,passive: False
[LINE#761] Hence, making dMem small, which is easy to achieve by design, contributes to both speed and robustness.
[LINE#762] Except in case of metastability, discussed before, our memory flag implementation is self-stabilizing since it is dMem-forgetful in the presence of input executions that avoid (a) and (b). .
0.698	[*A*]input executions[*R*]avoid	context()	negated: False ,passive: False
0.522	[*A*]it[*R*]is[*A*]dMem-forgetful[*A*]in the presence of input executions	context()	negated: False ,passive: True
0.712	[*A*]our memory flag implementation[*R*]is[*A*]self-stabilizing[*A*]since it is dMem-forgetful in the presence of input executions	context()	negated: False ,passive: True
[LINE#763]  Threshold modulesThe most straightforward implementation of the threshold modules used for generating the f+1 and n-f thresholds in type (2) and type (3) guards is a simple sum-of-product network, which just builds the OR of all AND combinations of f+1.
0.944	[*A*]a simple sum-of-product network[*R*]builds[*A*]the OR of all	context()	negated: False ,passive: False
0.975	[*A*]Threshold modulesThe most straightforward implementation of the threshold modules[*R*]is[*A*]a simple sum-of-product network, which just builds the OR of all AND combinations of f+1	context()	negated: False ,passive: True
0.943	[*A*]the threshold modules[*R*]used[*A*]for generating the f+1 and n-f thresholds in type (2) and type (3) guards	context()	negated: False ,passive: True
[LINE#764]  This implementation however quickly becomes highly expensive, as it requires ((nf)).
0.195	[*A*]it[*R*]requires	context()	negated: False ,passive: False
0.835	[*A*]This implementation[*R*]however quickly becomes[*A*]highly expensive[*A*]as it requires ((nf	context()	negated: False ,passive: True
[LINE#765] A more efficient alternative is a sorting network, where the kth output indicates whether a threshold of k is reached.
0.719	[*A*]a threshold of k[*R*]is reached	context(the kth output indicates)	negated: False ,passive: False
0.934	[*A*]the kth output[*R*]indicates[*A*]whether a threshold of k is reached[*A*]a sorting network	context()	negated: False ,passive: False
0.960	[*A*]A more efficient alternative[*R*]is[*A*]a sorting network, where the kth output indicates whether a threshold of k is reached	context()	negated: False ,passive: True
[LINE#766] For simplicity, in our FPGA implementation, threshold modules are built by means of lookup-tables (LUT).Correctness.
0.916	[*A*]threshold modules[*R*]are built[*A*]by means of lookup-tables[*A*]in our FPGA implementation	context()	negated: False ,passive: True
[LINE#767] Similar to our memory flag implementation, it is impossible to implement the properties of a threshold module as stated in Section 4, followed by a channel with some maximum delay dTh, in case of arbitrary inputs: Finding out whether a certain number of inputs is 1 exactly at the same time cannot be implemented with real circuits.
[LINE#768] All implementations proposed above are forgetful and their outputs will stabilize quickly if their inputs do not change.
0.341	[*A*]their inputs[*R*]do not change	context()	negated: True ,passive: False
0.489	[*A*]their outputs[*R*]will stabilize quickly[*A*]if their inputs do not change	context()	negated: False ,passive: True
0.799	[*A*]All implementations proposed above[*R*]are[*A*]forgetful	context()	negated: False ,passive: True
0.767	[*A*]All implementations[*R*]proposed[*A*]above	context()	negated: False ,passive: True
[LINE#769] Moreover, after stabilization type (2) guards are irrelevant, since neither the basic cycle of the main state machine nor the quick cycle evaluate such guards.
0.980	[*A*]neither the basic cycle of the main state machine nor the quick cycle[*R*]evaluate[*A*]such guards[*A*]after stabilization type (2) guards are irrelevant	context()	negated: False ,passive: False
0.829	[*A*]stabilization type (2) guards[*R*]are[*A*]irrelevant	context()	negated: False ,passive: True
[LINE#770] Hence, in this case we can restrict our attention to input executions where inputs may change from 0 to 1 only, not back.
0.743	[*A*]inputs[*R*]may change not back[*A*]from 0	context()	negated: False ,passive: True
0.444	[*A*]we[*R*]can restrict[*A*]our attention[*A*]to input executions[*A*]in this case	context()	negated: False ,passive: False
[LINE#771] The reset of the memory flags to 0 is performed during state transitions (when the guards' signals are suppressed by the locked signal) and therefore safe.
0.799	[*A*]the guards ' signals[*R*]are[*A*]therefore safe	context()	negated: False ,passive: True
0.919	[*A*]the guards ' signals[*R*]are suppressed[*A*]by the locked signal	context()	negated: False ,passive: True
0.943	[*A*]The reset of the memory flags to 0[*R*]is performed[*A*]during state transitions	context()	negated: False ,passive: True
[LINE#772]  As any of the proposed threshold module implementations involve combinational logic only, they are trivially self-stabilizing:.
0.616	[*A*]they[*R*]are[*A*]trivially self-st	context()	negated: False ,passive: True
0.938	[*A*]any of the proposed threshold module implementations[*R*]involve[*A*]combinational logic	context()	negated: False ,passive: True
[LINE#773] According to Theorem 3.7, they are forgetful and hence, by Lemma 3.8, self-stabilizing.
0.385	[*A*]Lemma 3.8[*R*][is][*A*]self	context()	negated: False ,passive: False
0.361	[*A*]they[*R*]are[*A*]forgetful	context()	negated: False ,passive: True
[LINE#774] Therefore, provided that the longest path delay does not exceed dTh, the properties stated in Section 4 are satisfied for monotonic inputs.2424Some dedicated experiments confirmed that even our LUT implementation on an FPGA, for which we have no control over the placement, operates glitch-free on monotonic inputs.
0.244	[*A*]even our LUT implementation on an FPGA[*R*]operates free	context()	negated: False ,passive: False
0.878	[*A*]the properties[*R*]stated[*A*]in Section 4[*A*]are satisfied for monotonic inputs.2424Some dedicated experiments	context()	negated: False ,passive: False
[LINE#775] As discussed above, type (2) guards cannot be safely evaluated by threshold gates and may cause glitches or metastable upsets.
0.913	[*A*]type (2) guards[*R*]may cause[*A*]glitches or metastable upsets	context()	negated: False ,passive: False
0.926	[*A*]type (2) guards[*R*]can not be safely evaluated[*A*]by threshold gates	context()	negated: True ,passive: True
[LINE#776] Since this is of relevance before stabilization only, this risk is considered acceptable.
0.449	[*A*]this[*R*]is[*A*]of relevance	context()	negated: False ,passive: True
[LINE#777]  Like our channel implementations, threshold modules can propagate metastability:.
0.767	[*A*]threshold modules[*R*]can propagate[*A*]metastability:.	context()	negated: False ,passive: False
[LINE#778+779]  A metastable input could be propagated to the output when there are exactly k-1 non-faulty inputs in state 1 andthe metastable input therefore makes the difference between output 0 and 1.
0.897	[*A*]andthe metastable input[*R*]makes[*A*]the difference between output 0 and 1	context()	negated: False ,passive: False
0.899	[*A*]A metastable input[*R*]could be propagated[*A*]to the output[*A*]when there are exactly k-1 non-faulty inputs in state 1	context()	negated: False ,passive: True
[LINE#780] In all other cases, however, the metastable input will simply be masked.
0.909	[*A*]the metastable input[*R*]will be masked[*A*]In all other cases	context()	negated: False ,passive: True
[LINE#781] Thus, albeit not perfect, threshold gates are an efficient means for metastability containment. .
0.903	[*A*]threshold gates[*R*]are[*A*]an efficient means for metastability containment	context()	negated: False ,passive: True
[LINE#782]  Hybrid state machinesOur prototype implementation of FATAL+ relies on hybrid state machines (HSM):.
0.622	[*A*]machinesOur prototype implementation of FATAL+[*R*]relies[*A*]on hybrid state machines	context()	negated: False ,passive: False
[LINE#783] An asynchronous state machine (ASM) is used for determining, by asynchronously evaluating the guards, the points in time when a state transition shall occur.
0.751	[*A*]a state transition[*R*]shall occur	context()	negated: False ,passive: False
0.939	[*A*]An asynchronous state machine[*R*]is used[*A*]for determining, by asynchronously evaluating the guards, the points in time	context()	negated: False ,passive: True
[LINE#784] Our ASMs have been built by deriving a state transition graph (STG) specification directly from Figs.
0.742	[*A*]Our ASMs[*R*]by deriving[*A*]a state transition graph (STG) specification directly from Figs	context()	negated: False ,passive: False
0.341	[*A*]Our ASMs[*R*]have been built	context()	negated: False ,passive: False
[LINE#785] 6-10 and generating the delay-insensitive implementation via Petrify [46].
[LINE#786] The actual state transition of an HSM is governed by an underlying synchronous transition state machine (TSM).
0.953	[*A*]The actual state transition of an HSM[*R*]is governed[*A*]by an underlying synchronous transition state machine	context()	negated: False ,passive: True
[LINE#787] The TSM resolves a possibly non-deterministic choice of the successor state and then sequentially performs the required transition actions:1."Locking" the transition, i.e., disabling any other transitions of the ASM (despite possibly satisfied guards); this happens at the start of the TSM and is thus asynchronously triggered.2.Reset of memory flags and watchdog timers.3.Communication of the new state, i.e., writing its representation into the flip-flops whose output is fed into the channels Sj,i.4.Completing the transition to the new state by enabling further transitions of the ASM.
0.954	[*A*]disabling any other transitions of the ASM[*R*]is[*A*]thus[*A*]watchdog timers.3.Communication of the new state	context()	negated: False ,passive: True
0.986	[*A*]i.e. , disabling any other transitions of the ASM is thus watchdog timers.3.Communication of the new state , i.e. , writing its representation into the flip - flops whose output is fed into the channels Sj ,[*R*]i.4.Completing[*A*]the transition to the new state	context()	negated: False ,passive: False
0.964	[*A*]disabling any other transitions of the ASM[*R*]is[*A*]thus[*A*]asynchronously triggered.2.Reset of memory flags	context()	negated: False ,passive: True
0.920	[*A*]the flip - flops[*R*]is fed[*A*]into the channels Sj	context()	negated: False ,passive: True
0.925	[*A*]i.e. , writing its representation into the flip - flops whose output is fed into the channels Sj ,[*R*]i.4.Completing[*A*]the transition to the new state	context()	negated: False ,passive: False
0.920	[*A*]the flip - flops[*R*]is fed[*A*]into the channels[*A*]Sj	context()	negated: False ,passive: True
0.867	[*A*]The TSM[*R*]resolves[*A*]a possibly non-deterministic choice of the successor state	context()	negated: False ,passive: False
[LINE#788] The TSM is driven by a pausable clock (see Section 6.4), which is started dynamically by the ASM upon triggering the transition.
0.954	[*A*]a pausable clock (see Section 6.4[*R*]is started[*A*]dynamically[*A*]by the ASM	context()	negated: False ,passive: True
0.887	[*A*]The TSM[*R*]is driven[*A*]by a pausable clock (see Section 6.4	context()	negated: False ,passive: True
[LINE#789] Note that this avoids the need for synchronization with a free-running clock and hence preserves the ASM's continuous time scale.
[LINE#790]  The TSM works as follows (see Fig. 12):.
0.803	[*A*]The TSM[*R*]works see[*A*]Fig	context(The TSM works)	negated: False ,passive: False
0.893	[*A*]The TSM[*R*]works[*A*]as follows (see Fig	context()	negated: False ,passive: False
[LINE#791] Assume that the ASM is in state A, and that the guard G for the transition from A to B becomes true.
[LINE#792] If no other transition is currently being taken (indicated by the locked signal being 0), the TSM clock is started and the TSM sequence counter is released.
0.818	[*A*]the TSM sequence counter[*R*]is released	context()	negated: False ,passive: False
0.803	[*A*]the TSM clock[*R*]is started	context()	negated: False ,passive: False
0.783	[*A*]the locked signal[*R*]being[*A*]0	context()	negated: False ,passive: True
0.779	[*A*]no other transition[*R*]is being taken[*A*]currently	context()	negated: False ,passive: True
[LINE#793]  With every rising edge of TSMClock, the TSM moves through a sequence of three states: synchronize (Syn), commit (Cmt), and terminate (Trm) shown in the rectangular box in Fig..
0.919	[*A*]synchronize[*R*]shown[*A*]in the rectangular box[*A*]in Fig	context()	negated: False ,passive: True
0.867	[*A*]the TSM[*R*]moves[*A*]through a sequence of three states	context()	negated: False ,passive: True
[LINE#794] In Syn, the locked signal is activated to prevent other choices from being executed in case of more than one guard becoming true.
0.799	[*A*]more than one guard[*R*]becoming[*A*]true	context()	negated: False ,passive: True
0.972	[*A*]the locked signal[*R*]is activated[*A*]to prevent other choices from being executed in case of more than one guard becoming true[*A*]In Syn	context()	negated: False ,passive: True
[LINE#795] Once the TSM has reached Syn, it has decided to actually take the transition to B and hence moves on to state Cmt.
0.577	[*A*]it[*R*]has decided[*A*]hence moves on to state Cmt[*A*]Once the TSM has reached Syn	context()	negated: False ,passive: False
0.639	[*A*]it[*R*]has decided[*A*]to actually take the transition to B[*A*]Once the TSM has reached Syn	context()	negated: False ,passive: False
0.887	[*A*]the TSM[*R*]has reached[*A*]Syn	context()	negated: False ,passive: False
[LINE#796] Here the watchdog timer associated with B and possibly some memory flags are cleared according to the FATAL+ state machine, and the new state B is captured by the output flip-flops driving the state communication data bus (recall Section 6.2).
0.975	[*A*]the watchdog timer associated with possibly some memory flags[*R*]are cleared[*A*]according to the FATAL+ state machine[*A*]Here	context()	negated: False ,passive: True
0.911	[*A*]the watchdog timer[*R*]associated[*A*]with possibly some memory flags	context()	negated: False ,passive: True
0.967	[*A*]the watchdog timer associated with B[*R*]are cleared[*A*]according to the FATAL+ state machine[*A*]Here	context()	negated: False ,passive: True
0.911	[*A*]the watchdog timer[*R*]associated[*A*]with B	context()	negated: False ,passive: True
0.926	[*A*]the output flip - flops[*R*]driving[*A*]the state communication data bus	context()	negated: False ,passive: False
0.939	[*A*]the new state B[*R*]is captured[*A*]by the output flip - flops	context()	negated: False ,passive: True
[LINE#797] Note that the resulting delay must be accounted for in the communication delay bounds d, dmax+ and dmin+.
0.954	[*A*]the communication delay[*R*]d[*A*]bounds	context()	negated: False ,passive: True
[LINE#798] Finally, the TSM moves on to state Trm, in which the reset signals are inactivated again and the TSM clock is halted (and the TSM sequence counter forced to the reset state).
0.939	[*A*]the TSM sequence counter[*R*]forced[*A*]to the reset state	context()	negated: False ,passive: True
0.933	[*A*]the TSM[*R*]moves[*A*]on to state Trm[*A*]Finally	context()	negated: False ,passive: True
0.783	[*A*]the reset signals[*R*]are inactivated[*A*]again	context()	negated: False ,passive: True
0.933	[*A*]the TSM[*R*]moves[*A*]on to state[*A*]Trm[*A*]Finally	context()	negated: False ,passive: True
[LINE#799]  The locked signal is also cleared here, which effectively moves the ASM to state.
0.788	[*A*]the ASM[*R*]to state	context()	negated: False ,passive: False
0.890	[*A*]The locked signal[*R*]is cleared[*A*]here[*A*]which effectively moves the ASM to state	context()	negated: False ,passive: True
[LINE#800] B. It is only now that guards pertaining to state B may become true.
0.772	[*A*]guards pertaining to state B[*R*]may become[*A*]true	context(It is)	negated: False ,passive: True
0.235	[*A*]It[*R*]is[*A*]only now[*A*]that guards pertaining to state B may become true	context()	negated: False ,passive: True
0.894	[*A*]guards[*R*]pertaining[*A*]to state B	context()	negated: False ,passive: False
[LINE#801+802]  Whereas any ambiguity of state transitions due to multiple activated guards can easily be resolved via some priority rule, metastability due to (a) enabled guards that become immediately disabled again or (b)new guards that are enabled close to "locking" time cannot be ruled out in general.
0.905	[*A*]b)new guards[*R*]are enabled[*A*]close to "locking" time	context()	negated: False ,passive: True
0.735	[*A*]enabled guards[*R*]become[*A*]immediately disabled[*A*]again	context()	negated: False ,passive: True
0.773	[*A*]metastability due to (a) enabled guards[*R*]can not be ruled out	context()	negated: True ,passive: False
0.856	[*A*]any ambiguity of state transitions due to multiple activated guards[*R*]can easily be resolved	context()	negated: False ,passive: False
[LINE#803+804]  However, as argued in Section 6.1, in FATAL+ (a) could only occur during stabilization, due to type (3) guards, or due to faulty nodes successfully inducing metastability of memory flags; recall that otherwise type(1) and type (2) guards are always monotonic, with the reset (of watchdog timers and memory flags) being under the control of the local state machine.
0.903	[*A*]faulty nodes[*R*]successfully inducing[*A*]metastability of memory flags	context()	negated: False ,passive: False
0.939	[*A*]the reset (of watchdog timers and memory flags[*R*]being[*A*]under the control of the local state machine	context()	negated: False ,passive: True
[LINE#805] Similarly, our proofs in [13] reveal that upsets due to (b) do not occur after stabilization in the main state machine and the quick cycle (Figs. 6 and 8).
0.519	[*A*]our proofs in [ 13[*R*]reveal[*A*]that upsets due to (b) do not occur after the quick cycle ( Figs . 8	context()	negated: False ,passive: False
0.473	[*A*]our proofs in [ 13[*R*]reveal[*A*]that upsets due to (b) do not occur after the quick cycle	context()	negated: False ,passive: False
0.473	[*A*]our proofs in [ 13[*R*]reveal[*A*]that upsets due to (b) do not occur after stabilization in the main state machine	context()	negated: False ,passive: False
[LINE#806] As the main state machine is logically independent of the lower layers (Figs. 9 and 10) after stabilization, any metastability in these layers is fully masked.
0.949	[*A*]any metastability in these layers[*R*]is fully masked[*A*]after stabilization	context()	negated: False ,passive: True
0.919	[*A*]the main state machine[*R*]is logically[*A*]independent of the lower layers	context()	negated: False ,passive: True
[LINE#807] Thus, after stabilization, metastability of the TSMs we care about can only occur due to unstable inputs, i.e., upsets in memory flags, that are in addition filtered through threshold gates (type (1) guards use local timeouts and are thus considered non-faulty, and all type (2) guards employed by the main state machine and the quick cycle use thresholds).
0.713	[*A*]addition[*R*]filtered	context()	negated: False ,passive: False
0.887	[*A*]unstable inputs[*R*]are[*A*]in addition	context()	negated: False ,passive: True
0.998	[*A*]can only occur due to unstable inputs, i.e., upsets in memory flags, that are in addition filtered through threshold gates (type (1) guards use local timeouts and are thus considered non-faulty, and all type (2) guards[*R*]employed[*A*]by the main state machine	context()	negated: False ,passive: True
0.639	[*A*]we[*R*]care[*A*]about[*A*]after stabilization, metastability of the TSMs	context()	negated: False ,passive: False
[LINE#808] that due to the logical masking of metastability provided by the threshold gates (cf.
0.894	[*A*]metastability[*R*]provided[*A*]by the threshold gates	context()	negated: False ,passive: True
[LINE#809] any memory flag acts as an implicit synchronizer: If a faulty node successfully induces metastability in the flag, this does not matter until the threshold can actually be reached.
0.913	[*A*]any memory flag[*R*]acts[*A*]as an implicit synchronizer	context(this does not matter)	negated: False ,passive: False
0.321	[*A*]this[*R*]does not matter[*A*]until the threshold can actually be reached	context()	negated: True ,passive: True
0.641	[*A*]the threshold[*R*]can be reached	context()	negated: False ,passive: False
0.911	[*A*]a faulty node[*R*]successfully induces[*A*]metastability[*A*]in the flag	context()	negated: False ,passive: False
[LINE#810] If the respective time span is large, the memory flag is likely to have stabilized again already.
0.754	[*A*]the memory flag[*R*]to have stabilized[*A*]again[*A*]already	context()	negated: False ,passive: True
0.828	[*A*]the memory flag[*R*]is[*A*]likely to have stabilized again already	context()	negated: False ,passive: True
0.841	[*A*]the respective time span[*R*]is[*A*]large	context()	negated: False ,passive: True
[LINE#811] Therefore, in addition to succeeding in creating metastability, faulty nodes must do so within a specific window of time.
0.903	[*A*]faulty nodes[*R*]must do[*A*]so[*A*]within a specific window of time	context()	negated: False ,passive: False
[LINE#812] Due to the asynchronously triggered transitions, this window of vulnerability of the synchronizing stage for Syn is very small.
0.928	[*A*]this window of vulnerability of the synchronizing stage for Syn[*R*]is[*A*]very small	context()	negated: False ,passive: True
0.903	[*A*]the asynchronously[*R*]triggered[*A*]transitions	context()	negated: False ,passive: False
[LINE#813] The resulting very low probability of a metastable upset due to a fault is considered acceptable.
[LINE#814] The residual probability of metastable upsets could be further reduced by introducing synchronizer stages.
0.899	[*A*]The residual probability of metastable upsets[*R*]could be reduced[*A*]by introducing synchronizer stages	context()	negated: False ,passive: True
[LINE#815] Considering their performance penalty of one extra clock cycle on the one hand and the low initial risk of metastable upsets (that are handled by the system level fault tolerance with much lower average performance penalty) on the other hand, however, the introduction of synchronizers does not seem beneficial in general.
0.927	[*A*]metastable upsets[*R*]are handled[*A*]by the system level fault tolerance with much lower average performance penalty	context()	negated: False ,passive: True
[LINE#816] Thanks to the synchronous TSM described above, the maximum state transition time dTrans can easily be expressed in terms of the frequency of the pausable clock.
0.801	[*A*]the maximum state transition time dTrans[*R*]can easily be expressed	context()	negated: False ,passive: False
0.831	[*A*]the synchronous TSM[*R*]described[*A*]above	context()	negated: False ,passive: True
[LINE#817] Hence, it is reasonably easy to see that the HSM satisfies the specification given in Section 4, when it starts from a proper initial state and avoids the above scenarios (a) and (b) of unstable guards.
0.407	[*A*]it[*R*]avoids[*A*]of unstable guards	context()	negated: False ,passive: False
0.835	[*A*]the specification[*R*]given[*A*]in Section 4[*A*]when it avoids (b) of unstable guards	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]avoids[*A*]the above scenarios (a) of unstable guards	context()	negated: False ,passive: False
0.522	[*A*]it[*R*]starts[*A*]from a proper initial state	context()	negated: False ,passive: True
0.903	[*A*]the specification[*R*]given[*A*]in Section 4	context()	negated: False ,passive: True
[LINE#818] A careful simulation analysis of the overall HSM design confirms that it can in fact recover from arbitrary initial states, except metastable ones.
0.301	[*A*]it[*R*]can recover[*A*]from arbitrary initial states, except metastable ones	context(A careful simulation analysis of the overall HSM design confirms)	negated: False ,passive: True
0.863	[*A*]A careful simulation analysis of the overall HSM design[*R*]confirms[*A*]that it can in fact recover from arbitrary initial states, except metastable ones	context()	negated: False ,passive: False
[LINE#819] With respect to metastable initial states, we conjecture that eventual recovery occurs with probability 1 due to the fact that the only devices used in the implementation that are not forgetful are flip-flops with dominant reset (in the TSM sequence counter) and Muller C-gates (in the control logic of the ASM), for both of which it is known that metastability eventually resolves. .
0.895	[*A*]the only devices used in the implementation that are not forgetful[*R*]are[*A*]Muller C-gates ( in the control logic of the ASM ) , for both of which it is known that metastability eventually resolves	context()	negated: False ,passive: True
0.776	[*A*]metastability[*R*]resolves[*A*]eventually	context(it is known)	negated: False ,passive: False
0.332	[*A*]it[*R*]is known[*A*]that metastability eventually resolves[*A*]in the control logic of the ASM	context()	negated: False ,passive: True
0.195	[*A*]we[*R*]conjecture[*A*]that eventual recovery occurs with probability 1 due to the fact that the only devices used in the implementation that are not forgetful are Muller C-gates ( in the control logic of the ASM ) , for both of which it is known that metastability eventually resolves	context()	negated: False ,passive: False
0.977	[*A*]the only devices used in the implementation that are not forgetful[*R*]are[*A*]flip - flops with dominant reset ( in the TSM sequence counter	context()	negated: False ,passive: True
0.818	[*A*]the only devices used in the implementation[*R*]are not[*A*]forgetful	context()	negated: True ,passive: True
0.782	[*A*]metastability[*R*]resolves[*A*]eventually	context(it is known)	negated: False ,passive: False
0.162	[*A*]it[*R*]is known	context()	negated: False ,passive: False
0.699	[*A*]that eventual recovery[*R*]occurs	context(we conjecture)	negated: False ,passive: False
0.309	[*A*]we[*R*]conjecture[*A*]that eventual recovery occurs with probability 1 due to the fact that the only devices used in the implementation that are not forgetful are flip - flops with dominant reset ( in the TSM sequence counter	context()	negated: False ,passive: False
[LINE#820] Pausable oscillatorThe TSM clock is an asynchronously startable and synchronously stoppable ring oscillator, which provides a clock signal TSMClock that is 0 when the clock is stopped via an active 1 input signal TSMCStop.
0.927	[*A*]an synchronously stoppable ring oscillator[*R*]provides[*A*]a clock signal TSMClock	context()	negated: False ,passive: False
0.975	[*A*]Pausable oscillatorThe TSM clock[*R*]is[*A*]an synchronously stoppable ring oscillator , which provides a clock signal TSMClock	context()	negated: False ,passive: True
0.918	[*A*]the clock[*R*]is stopped[*A*]via an active 1 input signal TSMCStop	context()	negated: False ,passive: True
0.971	[*A*]a clock signal TSMClock[*R*]is[*A*]0[*A*]when the clock is stopped via an active 1 input signal TSMCStop	context()	negated: False ,passive: True
0.927	[*A*]an asynchronously startable ring oscillator[*R*]provides[*A*]a clock signal TSMClock	context()	negated: False ,passive: False
0.975	[*A*]Pausable oscillatorThe TSM clock[*R*]is[*A*]an asynchronously startable ring oscillator , which provides a clock signal TSMClock	context()	negated: False ,passive: True
[LINE#821] A variant that is also asynchronously stoppable (under certain timing constraints) is used for driving the watchdog timers (see below).
0.964	[*A*]A variant that is also asynchronously stoppable (under certain timing constraints)[*R*]is used[*A*]for driving the watchdog timers	context()	negated: False ,passive: True
0.913	[*A*]A variant[*R*]is[*A*]also[*A*]asynchronously stoppable (under certain timing constraints	context()	negated: False ,passive: True
[LINE#822] The frequency of the ring oscillator is primarily determined by the (odd) number of inverters in the feedback loop.2525In our FPGA implementation, the oscillator frequency is so high that, to reduce the hardware overhead for this proof-of-concept implementation, we also employ a frequency divider at the output.
0.878	[*A*]The frequency of the ring oscillator[*R*]is determined[*A*]by the (odd) number of inverters in the feedback loop.2525In our FPGA implementation	context(the oscillator frequency is we employ)	negated: False ,passive: True
0.860	[*A*]the oscillator frequency[*R*]is[*A*]so high that, to reduce the hardware overhead for this proof-of-concept implementation	context(we employ)	negated: False ,passive: True
0.349	[*A*]we[*R*]employ[*A*]a frequency divider[*A*]at the output	context()	negated: False ,passive: False
[LINE#823] It varies heavily with the operating conditions, in particular with supply voltage and temperature: The resulting (two-sided) clock drift  is typically in the range of 7 to 9% for uncompensated ring oscillators like ours; in ASICs, it could be lowered down of 1 to 2% by special compensation techniques [15].
0.993	[*A*]it[*R*]could be lowered of[*A*]1 to 2 %	context()	negated: False ,passive: False
0.968	[*A*]The resulting ( two - sided ) clock drift[*R*]is[*A*]typically[*A*]in the range of 7 to 9 % for uncompensated ring oscillators like ours	context(it could be lowered down)	negated: False ,passive: True
0.532	[*A*]it[*R*]could be lowered down[*A*]by special compensation techniques[*A*]in ASICs	context()	negated: False ,passive: True
0.957	[*A*]two - sided ) clock drift[*R*]is[*A*]typically[*A*]in the range of 7 to 9 % for uncompensated ring oscillators like ours	context(It varies heavily it could be lowered down)	negated: False ,passive: True
0.532	[*A*]it[*R*]could be lowered down[*A*]by special compensation techniques[*A*]in ASICs	context(It varies heavily)	negated: False ,passive: True
0.356	[*A*]It[*R*]varies heavily[*A*]two - sided ) clock drift is typically in the range of 7 to 9 % for uncompensated ring oscillators like ours ; in ASICs , it could be lowered down of 1 to 2 % by special compensation techniques	context()	negated: False ,passive: False
[LINE#824] Note that the two-sided clock drifts map to =(1+)/(1-) bounds roughly between 1.15 and 1.19 or 1.02 and 1.04, respectively.
[LINE#825+826]  The operation of the TSM clock circuit shown in Fig. 13 is straightforward: In its initial state, TSMCStop=1 andthe Muller C-gate has 1 at its output, so TSMClock=0.
0.970	[*A*]The operation of the TSM clock circuit[*R*]shown[*A*]TSMClock=0	context()	negated: False ,passive: False
0.999	[*A*]TSMCStop=1[*R*]has[*A*]1	context()	negated: False ,passive: False
0.862	[*A*]The operation of the TSM clock circuit[*R*]is[*A*]straightforward	context(TSMCStop=1 has)	negated: False ,passive: True
0.906	[*A*]TSMCStop=1[*R*]has[*A*]1[*A*]at its output[*A*]In its initial state	context()	negated: False ,passive: False
0.961	[*A*]the TSM clock circuit[*R*]shown[*A*]in Fig	context()	negated: False ,passive: True
[LINE#827] Note that the circuit also stabilizes to the initial state if the Muller C-gate was erroneously initialized to 0, as the ring oscillator would eventually generate TSMClock=1, enforcing the correct initial value 1 of the C-gate.
0.861	[*A*]the ring oscillator[*R*]would generate TSMClock=1 enforcing[*A*]the correct initial value 1 of the C-gate	context(the ring oscillator would generate)	negated: False ,passive: False
0.917	[*A*]the ring oscillator[*R*]would generate[*A*]TSMClock=1[*A*]eventually	context()	negated: False ,passive: False
0.831	[*A*]the Muller C-gate[*R*]was erroneously initialized[*A*]to 0	context()	negated: False ,passive: True
[LINE#828] When the ASM requests a state transition, at some arbitrary time when a transition guard becomes true, it just sets TSMCStop=LOW.
0.761	[*A*]it[*R*]sets[*A*]TSMCStop=LOW[*A*]When the ASM requests a state transition, at some arbitrary time	context()	negated: False ,passive: False
0.948	[*A*]a transition guard[*R*]becomes[*A*]true[*A*]some arbitrary time	context()	negated: False ,passive: True
0.927	[*A*]the ASM[*R*]requests[*A*]a state transition, at some arbitrary time	context()	negated: False ,passive: False
[LINE#829] This starts the TSM clock and produces the first rising edge of TSMClock half a clock cycle time later.
0.495	[*A*]This[*R*]starts[*A*]the TSM clock	context()	negated: False ,passive: False
[LINE#830] As long as TSMCStop remains 0, the ring oscillator runs freely.
0.751	[*A*]the ring oscillator[*R*]runs freely	context()	negated: False ,passive: False
0.675	[*A*]TSMCStop[*R*]remains[*A*]0	context()	negated: False ,passive: True
[LINE#831] The stopping of TSMClock is regularly initiated by the TSM itself: With the rising edge of TSMClock that moves the TSM into Trm, TSMCStop is set to 1.
0.934	[*A*]The stopping of TSMClock[*R*]is regularly initiated[*A*]by the TSM	context(TSMCStop is set)	negated: False ,passive: True
0.616	[*A*]TSMCStop[*R*]is set[*A*]to 1	context()	negated: False ,passive: True
0.945	[*A*]the rising edge of TSMClock[*R*]moves[*A*]the TSM[*A*]into Trm	context()	negated: False ,passive: False
[LINE#832] Since TSMClock is also 1 after the rising edge,2626Obviously, we only have to take care in the timing analysis that setting TSMCStop=1 occurs well within the first half period.
0.913	[*A*]the timing analysis[*R*]setting[*A*]TSMCStop=1	context()	negated: False ,passive: False
0.887	[*A*]TSMClock[*R*]is[*A*]also[*A*]1 after the rising edge	context()	negated: False ,passive: True
[LINE#833] the output of the C-gate is forced to 1 as well.
0.993	[*A*]the output of the C-gate[*R*]is forced to[*A*]1 as well	context()	negated: False ,passive: False
0.856	[*A*]the output of the C-gate[*R*]is forced[*A*]to 1 as well	context()	negated: False ,passive: True
[LINE#834] Hence, after having finished the half period of this final clock cycle, the feedback loop is frozen and TSMClock remains 0.Metastability.
0.855	[*A*]TSMClock[*R*]remains[*A*]0.Metastability	context()	negated: False ,passive: True
0.961	[*A*]the feedback loop[*R*]is frozen[*A*]after having finished the half period of this final clock cycle	context()	negated: False ,passive: True
[LINE#835] The problem of devising a proof that the pausable clock will eventually recover when it starts from a metastable initial state is intricate (and outside the scope of this paper); this is not obvious due to the quite complex feedback loop involved in this circuit.
0.959	[*A*]The problem of devising a proof that the pausable clock will eventually recover[*R*]is[*A*]outside the scope of this paper	context(this is not)	negated: False ,passive: True
0.891	[*A*]The problem of devising a proof that the pausable clock will eventually recover[*R*]is[*A*]intricate	context(this is not)	negated: False ,passive: True
0.143	[*A*]this[*R*]is not[*A*]obvious	context()	negated: True ,passive: True
0.522	[*A*]it[*R*]starts[*A*]from a metastable initial state	context()	negated: False ,passive: True
0.867	[*A*]the pausable clock[*R*]will recover[*A*]when it starts from a metastable initial state[*A*]eventually	context()	negated: False ,passive: True
0.926	[*A*]the quite complex feedback loop[*R*]involved[*A*]in this circuit	context()	negated: False ,passive: True
[LINE#836+837+838]  We conjecture that similar arguments as in [44] can be used to show that this will happen with probability 1; with this result established one could hope to infer that the HSM as a whole recovers from arbitrary metastable states with probability 1.For metastability-free operation of the C-gate in Fig. 13, (a) the falling transition of TSMCStop must not occur simultaneously with a rising edge of TSMClock, and (b)the rising transition of TSMCStop must not occur simultaneously with the falling edge of TSMClock.
0.970	[*A*]the HSM as a whole recovers from arbitrary metastable states with probability 1.For metastability - free operation of the C-gate in Fig . 13 ( b ) the rising transition of TSMCStop[*R*]must not occur[*A*]simultaneously	context(this result established)	negated: True ,passive: True
0.266	[*A*]one[*R*]could hope to infer to infer	context(this result established one could hope)	negated: False ,passive: False
0.303	[*A*]one[*R*]could hope[*A*]to infer	context(this result established)	negated: False ,passive: False
0.796	[*A*]this result[*R*]established[*A*]one could hope to infer	context()	negated: False ,passive: False
0.821	[*A*]the falling transition of TSMCStop[*R*]must not occur[*A*]simultaneously	context(this result established one could hope to infer the HSM as a whole recovers from arbitrary metastable states with probability 1.For metastability - free operation of the C-gate in Fig (a))	negated: True ,passive: True
0.987	[*A*]the HSM as a whole recovers from arbitrary metastable states with probability 1.For metastability - free operation of the C-gate in Fig[*R*](a)[*A*]the falling transition of TSMCStop must not occur simultaneously with a rising edge of TSMClock	context(this result established one could hope to infer)	negated: False ,passive: False
0.465	[*A*]one[*R*]could hope to infer[*A*]that the HSM as a whole recovers from arbitrary metastable states with probability 1.For metastability - free operation of the C-gate in Fig . 13 , (a) the falling transition of TSMCStop must not occur simultaneously with a rising edge of TSMClock	context(this result established one could hope)	negated: False ,passive: False
0.465	[*A*]one[*R*]could hope[*A*]to infer that the HSM as a whole recovers from arbitrary metastable states with probability 1.For metastability - free operation of the C-gate in Fig . 13 , (a) the falling transition of TSMCStop must not occur simultaneously with a rising edge of TSMClock	context(this result established)	negated: False ,passive: False
0.765	[*A*]similar arguments as in [ 44[*R*]can be used[*A*]to show that this will happen with probability 1	context(We conjecture this result established)	negated: False ,passive: True
0.271	[*A*]We[*R*]conjecture[*A*]that similar arguments as in [ 44 ] can be used to show that this will happen with probability 1	context(this result established)	negated: False ,passive: False
0.733	[*A*]this result[*R*]established[*A*]one could hope to infer that the HSM as a whole recovers from arbitrary metastable states with probability 1.For metastability - free operation of the C-gate in Fig . 13 , (a) the falling transition of TSMCStop must not occur simultaneously with a rising edge of TSMClock	context()	negated: False ,passive: False
0.330	[*A*]this[*R*]will happen[*A*]with probability 1	context(similar arguments as in [ 44 to show)	negated: False ,passive: True
0.772	[*A*]similar arguments as in [ 44[*R*]to show[*A*]that this will happen with probability 1	context()	negated: False ,passive: False
[LINE#839] (a) is guaranteed by stopping the clock in state Trm of the TSM, since the output of the C-gate is permanently forced to 1 on this occasion; TSMClock cannot hence generate a rising transition before TSMCStop goes to 0 again.
0.572	[*A*](a)[*R*]is guaranteed	context(TSMClock can not generate)	negated: False ,passive: False
0.781	[*A*]TSMClock[*R*]can not generate[*A*]a rising transition[*A*]before TSMCStop goes to 0 again	context()	negated: True ,passive: False
0.944	[*A*]the output of the C-gate[*R*]is permanently forced[*A*]to 1[*A*]on this occasion	context()	negated: False ,passive: True
0.857	[*A*](a)[*R*]by stopping[*A*]the clock[*A*]in state Trm of the TSM	context()	negated: False ,passive: False
0.675	[*A*]TSMCStop[*R*]goes[*A*]to 0[*A*]again	context()	negated: False ,passive: True
[LINE#840] Whereas this synchronous stopping normally also ensures (b), we cannot always rule out the possibility of getting TSMCStop=1 close to the first rising edge of TSMClock: (b) could thus occur due to prematurely disabled type (3) guards, which we discussed already with respect to their potential to create metastability in the TSM, recall Section 6.3.
0.588	[*A*]we[*R*]can not rule out[*A*]the possibility of getting TSMCStop=1 close to the first rising edge of TSMClock[*A*]always	context((b) could occur)	negated: True ,passive: False
0.293	[*A*](b)[*R*]could occur[*A*]due to prematurely disabled type	context()	negated: False ,passive: True
0.795	[*A*]guards[*R*]discussed[*A*]already[*A*]with respect to their potential	context()	negated: False ,passive: True
0.718	[*A*]this synchronous stopping[*R*]ensures	context()	negated: False ,passive: False
[LINE#841] Besides being a rare event, this can only do harm during stabilization, however. .
0.286	[*A*]this[*R*]can do[*A*]harm[*A*]during stabilization[*A*]however	context()	negated: False ,passive: False
[LINE#842] Watchdog timer designEvery ASM state, except for accept in Fig. 8, is associated with at most one watchdog timer required for type (1) guards; accept is associated with three timers (for T1 and T2 as well as for T2+ in Fig. 6).
0.535	[*A*]accept[*R*]is associated[*A*]with three timers ( for T2	context()	negated: False ,passive: True
0.535	[*A*]accept[*R*]is associated[*A*]with three timers ( for T1	context()	negated: False ,passive: True
0.913	[*A*]Watchdog timer designEvery ASM state , except for accept in Fig[*R*]is associated[*A*]with at most one watchdog timer	context(accept is associated)	negated: False ,passive: True
0.535	[*A*]accept[*R*]is associated[*A*]with three timers ( for T2+ in Fig	context()	negated: False ,passive: True
0.926	[*A*]at most one watchdog timer[*R*]required[*A*]for type ( 1 ) guards	context()	negated: False ,passive: True
[LINE#843] Recall that a timer is reset by the TSM when its associated state is entered, which does not necessarily happen synchronously with its counting clock.
0.363	[*A*]its associated state[*R*]is entered	context()	negated: False ,passive: False
[LINE#844] 14, every watchdog timer consists of a synchronous, dominantly resettable up-counter that is clocked by its own pausable oscillator (as shown in Fig. 13) and a timeout register that holds the timeout value TO.2727Note that these values must be hard-coded in order to avoid that a fault that intuitively should be transient (e.g. a bit flip in volatile memory) becomes permanent by "altering the algorithm".
0.717	[*A*]these values[*R*]must be[*A*]hard-coded	context(a timeout register holds)	negated: False ,passive: True
0.899	[*A*]a timeout register[*R*]holds[*A*]the timeout value	context()	negated: False ,passive: False
0.730	[*A*]a fault[*R*]should be e.g. flip[*A*]transient	context()	negated: False ,passive: True
0.884	[*A*]a synchronous, dominantly resettable up-counter[*R*]is clocked[*A*]by its own pausable oscillator	context()	negated: False ,passive: True
0.911	[*A*]every watchdog timer[*R*]consists[*A*]of a synchronous, dominantly resettable up-counter	context()	negated: False ,passive: True
[LINE#845] A comparator raises an output signal if the counter value is equal to the TO register value.
0.381	[*A*]the counter value[*R*]is equal to[*A*]the TO register value	context()	negated: False ,passive: False
0.942	[*A*]the counter value[*R*]is[*A*]equal to the TO register value	context()	negated: False ,passive: True
0.947	[*A*]A comparator[*R*]raises[*A*]an output signal[*A*]if the counter value is equal to the TO register value	context()	negated: False ,passive: False
[LINE#846] A "capture flip-flop" with dominant reset memorizes the expired condition until the timer is re-triggered.
0.732	[*A*]the timer[*R*]is re-triggered	context()	negated: False ,passive: False
0.953	[*A*]A "capture flip-flop" with dominant reset[*R*]memorizes[*A*]the expired condition[*A*]until the timer is re-triggered	context()	negated: False ,passive: False
[LINE#847] Note that using a (synchronous) flip-flop instead of an SR latch here allows us to completely mask glitches at the comparator output, which may originate from intermediate inconsistent bit patterns at the counter output.
0.897	[*A*]the comparator output[*R*]may originate[*A*]from intermediate inconsistent bit patterns at the counter output	context()	negated: False ,passive: True
[LINE#848+849]  The reset signal TSMresWD, supplied by the TSM, (: The counter is reset to zero, the capture flip-flop is cleared, and the oscillator is temporarily stopped.
0.719	[*A*]the oscillator[*R*]is stopped[*A*]temporarily	context(the capture flip - flop is)	negated: False ,passive: True
0.777	[*A*]The counter[*R*]is[*A*]reset to zero	context(the capture flip - flop is)	negated: False ,passive: True
0.930	[*A*]the capture flip - flop[*R*]is[*A*]the oscillator is temporarily stopped	context()	negated: False ,passive: True
0.913	[*A*]The reset signal[*R*]supplied[*A*]by the TSM	context()	negated: False ,passive: True
0.785	[*A*]the capture flip - flop[*R*]is cleared	context()	negated: False ,passive: False
0.735	[*A*]The counter[*R*]reset[*A*]to zero	context()	negated: False ,passive: True
0.952	[*A*]The counter[*R*]is[*A*]reset to zero , the capture flip - flop is cleared	context()	negated: False ,passive: True
[LINE#850+851]  Stopping the oscillator is necessary to avoid metastability effects due to the unsynchronized release of the reset signal (recall that this signal originates from the clock domain of the TSM!)and the watchdog's local oscillator.
0.889	[*A*]Stopping the oscillator[*R*]is[*A*]necessary[*A*]to avoid metastability effects due to the unsynchronized release of the reset signal ( recall that this signal originates from the watchdog 's local oscillator	context()	negated: False ,passive: True
0.956	[*A*]Stopping the oscillator[*R*]is[*A*]necessary[*A*]to avoid metastability effects due to the unsynchronized release of the reset signal	context()	negated: False ,passive: True
[LINE#852+853]  Note carefully, however, that the Muller C-gate in Fig.13 must be extended by a dominant reset input connected to its stop input (TSMCStop) to prevent metastable upsets.
0.904	[*A*]a dominant reset input[*R*]connected[*A*]to prevent metastable upsets	context()	negated: False ,passive: True
[LINE#854] Moreover, to ensure a proper reset, one has to make sure that the reset duration is sufficiently large.
0.828	[*A*]the reset duration[*R*]is[*A*]sufficiently large	context()	negated: False ,passive: True
0.331	[*A*]one[*R*]to make[*A*]sure that the reset duration is sufficiently large	context()	negated: False ,passive: False
[LINE#855+856+857]  To guarantee this, TSMresWD is fed into a pulse shaping circuitry (bottom left part of Fig. 14) that makes sure that the reset pulse is longer than one period of the local clock.2828This is why seven inverters are shown in Fig.14, indicating that the output pulse needs to remain active for more than two half periods of the local clock, assuming three inverters in its oscillator's loop.
0.825	[*A*]TSMresWD[*R*]is fed[*A*]into a pulse shaping circuitry	context(bottom left)	negated: False ,passive: True
0.915	[*A*]bottom[*R*]left[*A*]part of Fig	context()	negated: False ,passive: False
0.903	[*A*]seven inverters[*R*]are shown[*A*]in Fig.14	context()	negated: False ,passive: True
0.933	[*A*]the output pulse[*R*]to remain[*A*]active[*A*]for more than two half periods of the local clock	context()	negated: False ,passive: True
0.942	[*A*]the reset pulse[*R*]is[*A*]longer than one period of the local clock.2828This	context()	negated: False ,passive: True
[LINE#858] At the end of this shaped reset pulse, counter and flip-flop have attained a clean reset state, and the local oscillator has safely been brought to a stable stopped state (with its output at 0).
0.912	[*A*]the local oscillator[*R*]has been brought[*A*]to a stable stopped state ( with its output at 0[*A*]safely	context()	negated: False ,passive: True
[LINE#859] When reset is finally released (to 0), the oscillator starts running.
0.698	[*A*]the oscillator[*R*]running	context()	negated: False ,passive: False
0.948	[*A*]the oscillator[*R*]starts[*A*]When reset is finally released (to 0	context()	negated: False ,passive: True
0.743	[*A*]reset[*R*]is released[*A*]finally	context()	negated: False ,passive: True
[LINE#860] As soon as the comparator detects a match between the current count and the timeout register, it will set match to 1.
0.702	[*A*]it[*R*]will set[*A*]match[*A*]to 1[*A*]As soon as the comparator detects a match between the current count and the timeout register	context()	negated: False ,passive: False
0.937	[*A*]the comparator[*R*]detects[*A*]a match between the current count and the timeout register	context()	negated: False ,passive: False
[LINE#861+862]  This rising edge is captured by the flip-flop, thus keeping the watchdog timeout signal WDexpired at 1 even when the comparator reverts its output to 0 later on again(note that the counter keeps on running).
0.732	[*A*]the counter[*R*]keeps	context()	negated: False ,passive: False
0.835	[*A*]the comparator[*R*]reverts[*A*]its output[*A*]to[*A*]later on again	context()	negated: False ,passive: False
0.925	[*A*]This rising edge[*R*]is captured[*A*]by the flip-flop[*A*]thus keeping the watchdog timeout signal WDexpired at 1	context()	negated: False ,passive: True
[LINE#863] This construction ensures that the oscillator continues to operate also after the timeout expires, which is crucial for self-stabilization; in a system where the clocks driving the timeouts can be permanently halted, there is no way to avoid deadlocks for all possible states.
0.686	[*A*]the timeout[*R*]expires	context()	negated: False ,passive: False
0.873	[*A*]the oscillator[*R*]to operate also[*A*]after the timeout expires, which is crucial for self-stabilization; in a system where the clocks driving the timeouts can be permanently halted, there is no way	context()	negated: False ,passive: True
0.949	[*A*]the clocks driving the timeouts[*R*]can be permanently halted[*A*]a system	context()	negated: False ,passive: True
0.903	[*A*]the clocks[*R*]driving[*A*]the timeouts	context()	negated: False ,passive: False
0.687	[*A*]the oscillator[*R*]continues	context(This construction ensures)	negated: False ,passive: False
0.731	[*A*]This construction[*R*]ensures[*A*]that the oscillator continues to operate also	context()	negated: False ,passive: False
[LINE#864+865]  As for the watchdog timer with random timeout R3 in Fig. 10, our implementation uses a linear feedback shift register (LFSR) that is continuously clocked by the watchdog's oscillator:.
0.913	[*A*]a linear feedback shift register[*R*]is continuously clocked[*A*]by the watchdog's o	context()	negated: False ,passive: True
0.554	[*A*]our implementation[*R*]uses[*A*]a linear feedback shift register (LFSR) that is continuously clocked by the watchdog's o	context()	negated: False ,passive: False
[LINE#866] A uniformly distributed random value from the specified range, sampled from the LFSR, is loaded into the timeout register whenever the watchdog timer is re-triggered.2929Note that for many settings, it is reasonable to assume that the new random value remains a secret until the timeout expires, as it is not read or in any other way considered by the node until then.
0.707	[*A*]the watchdog timer[*R*]is re-triggered.2929Note	context()	negated: False ,passive: False
0.732	[*A*]the timeout[*R*]expires	context()	negated: False ,passive: False
0.971	[*A*]A uniformly distributed random value from the specified range, sampled from the LFSR[*R*]is loaded[*A*]into the timeout register	context()	negated: False ,passive: True
0.820	[*A*]A uniformly distributed random value from the specified range[*R*]sampled	context()	negated: False ,passive: False
0.195	[*A*]it[*R*]is not read	context()	negated: True ,passive: False
0.911	[*A*]any other way[*R*]considered[*A*]by the node[*A*]until then	context()	negated: False ,passive: True
[LINE#867] Under this condition, FATAL+ is resilient against the strong adversary specified in [13].
0.783	[*A*]the strong adversary[*R*]specified[*A*]in [13	context()	negated: False ,passive: True
0.965	[*A*]FATAL+[*R*]is[*A*]resilient against the strong adversary[*A*]Under this condition	context()	negated: False ,passive: True
[LINE#868] As our prototype implementation is not meant for studying security issues, however, the simple LFSR implementation is sufficient here.
0.878	[*A*]the simple LFSR implementation[*R*]is[*A*]sufficient[*A*]here	context()	negated: False ,passive: True
0.660	[*A*]our prototype implementation[*R*]is not meant[*A*]for studying security issues	context()	negated: True ,passive: True
[LINE#869] If both the watchdog timer and the LFSR are clocked by the same oscillator, this can be done in a synchronous way.
0.867	[*A*]the LFSR[*R*]are clocked[*A*]by the same oscillator	context()	negated: False ,passive: True
0.153	[*A*]this[*R*]can be done	context()	negated: False ,passive: False
0.919	[*A*]both the watchdog timer[*R*]are clocked[*A*]by the same oscillator	context()	negated: False ,passive: True
[LINE#870+871]  In order to avoid metastable upsets of the LFSR, which might occur when stopping the clock upon retriggering the watchdog as described above, we use a standard pausable oscillator for R3: Since R3 is guaranteed to timeout before it is re-triggered (see Fig. 10), we can stop the oscillator synchronously (as in the TSM)when the timeout occurs, i.e., tie its stop input to the OR of WDexpired and the pulse-shaped reset signal.
0.195	[*A*]it[*R*]is re-triggered	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]can stop[*A*]the oscillator[*A*]synchronously	context()	negated: False ,passive: False
0.762	[*A*]R3[*R*]is guaranteed[*A*]to timeout[*A*]before it is re-triggered	context()	negated: False ,passive: True
0.846	[*A*]the LFSR[*R*]might occur[*A*]when stopping the clock upon retriggering the watchdog	context()	negated: False ,passive: True
0.732	[*A*]the timeout[*R*]occurs	context()	negated: False ,passive: False
[LINE#872] Another add-on is needed for the random timer R3 in order to guarantee that the LFSR recovers from an arbitrary state after a fault: Since an LFSR has a forbidden internal state (all-0 in our case), we use an additional comparator that detects an all-0 LFSR output and forces a (synchronized) reset of the LFSR to a proper initial state.
0.452	[*A*]we[*R*]use[*A*]an additional comparator forces	context()	negated: False ,passive: False
0.896	[*A*]an LFSR[*R*]has[*A*]a forbidden internal state	context()	negated: False ,passive: False
0.913	[*A*]an additional comparator[*R*]detects[*A*]an all - 0 LFSR output	context()	negated: False ,passive: False
0.367	[*A*]we[*R*]use[*A*]an additional comparator that detects an all - 0 LFSR output	context()	negated: False ,passive: False
0.530	[*A*]Another add - on[*R*]is needed[*A*]for the random timer R3[*A*]in order to guarantee that the LFSR recovers from an arbitrary state after a fault	context()	negated: False ,passive: True
[LINE#873] Using a dominant reset in conjunction with a reset pulse of sufficient length guarantees that pausable oscillator, counter, and flip-flop cannot become metastable when a watchdog timer is re-triggered.
0.919	[*A*]pausable flip - flop[*R*]can not become[*A*]metastable[*A*]when a watchdog timer is re-triggered	context()	negated: True ,passive: True
0.903	[*A*]pausable counter[*R*]can not become[*A*]metastable[*A*]when a watchdog timer is re-triggered	context()	negated: True ,passive: True
0.751	[*A*]a watchdog timer[*R*]is re-triggered	context()	negated: False ,passive: False
0.903	[*A*]pausable oscillator[*R*]can not become[*A*]metastable[*A*]when a watchdog timer is re-triggered	context()	negated: True ,passive: True
[LINE#874] Since all other activities are driven by the local oscillator and hence trivially metastability-free, this leaves the pulse-shaping unit as the only component that could possibly suffer from a metastable upset.
0.850	[*A*]the only component[*R*]could suffer[*A*]from a metastable upset	context()	negated: False ,passive: False
0.381	[*A*]this[*R*]leaves[*A*]the pulse - shaping unit[*A*]as the only component	context()	negated: False ,passive: False
0.911	[*A*]all other activities[*R*]are driven[*A*]by the local oscillator	context()	negated: False ,passive: True
[LINE#875] However, TSMresWD is generated by the TSM, which is guaranteed to generate a clean pulse at every correct node.
0.846	[*A*]the TSM[*R*]to generate[*A*]a clean pulse[*A*]at every correct node	context()	negated: False ,passive: False
0.846	[*A*]the TSM[*R*]is guaranteed[*A*]to generate a clean pulse at every correct node	context()	negated: False ,passive: True
0.877	[*A*]TSMresWD[*R*]is generated[*A*]by the TSM	context()	negated: False ,passive: True
[LINE#876] Hence, the pulse shaping unit could become metastable only at a faulty node.
0.799	[*A*]the pulse shaping unit[*R*]could become[*A*]metastable	context()	negated: False ,passive: True
[LINE#877] With respect to the recovery from a metastable state, similar considerations as for the memory flags in Section 6.2.2 suggest that the pulse shaping unit will stabilize to an initial state with reset set to 0 eventually with probability 1.Correctness.
0.897	[*A*]the pulse shaping unit[*R*]will stabilize[*A*]to an initial state with reset	context(With respect to the recovery from a metastable state , similar considerations suggest)	negated: False ,passive: True
0.903	[*A*]With respect to the recovery from a metastable state, similar considerations[*R*]suggest[*A*]that the pulse shaping unit will stabilize to an initial state with reset	context()	negated: False ,passive: False
0.853	[*A*]an initial state with reset[*R*]set[*A*]to 0	context()	negated: False ,passive: True
[LINE#878] Combining the implementations of the pausable oscillator (with additional reset) and the watchdog timer, it is not too difficult to verify that the specification given in Section 4 is met, provided all circuits start from a non-metastable initial state.
0.903	[*A*]the specification[*R*]given[*A*]in Section 4	context()	negated: False ,passive: True
0.925	[*A*]all circuits[*R*]start[*A*]from a non-metastable initial state	context()	negated: False ,passive: False
[LINE#879] With respect to self-stabilization, the pulse shaping unit can be guaranteed to stabilize to an initial state with its reset output 0 from an arbitrary internal state.
0.838	[*A*]the pulse shaping unit[*R*]to stabilize[*A*]to an initial state with its reset output 0	context()	negated: False ,passive: True
0.769	[*A*]the pulse shaping unit[*R*]can be guaranteed	context()	negated: False ,passive: False
[LINE#880] Hence, the pausable oscillator and hence the counter will eventually run.
0.761	[*A*]the counter[*R*]will run[*A*]eventually	context()	negated: False ,passive: True
0.779	[*A*]the pausable oscillator[*R*]will run[*A*]eventually	context()	negated: False ,passive: True
[LINE#881] Provided that the counter implementation guarantees that it cycles through the full (finite) sequence of possible states (unless reset earlier), i.e., there are no deadlock states or alternative cyclic sequences that might be entered in case of a fault, our implementation ensures that WDexpired will eventually be set to 1, even if started from an arbitrary initial state.
0.911	[*A*]WDexpired[*R*]will be set[*A*]to 1[*A*]even if started from an arbitrary initial state[*A*]eventually	context(our implementation ensures)	negated: False ,passive: True
0.374	[*A*]our implementation[*R*]ensures[*A*]that WDexpired will eventually be set to 1	context()	negated: False ,passive: False
0.927	[*A*]no deadlock states or alternative cyclic sequences[*R*]might be entered[*A*]in case of a fault	context()	negated: False ,passive: False
0.195	[*A*]it[*R*]cycles	context()	negated: False ,passive: False
[LINE#882] One should bear in mind, though, that the time to recover a watchdog timer contributes to the overall stabilization time of the system.
0.921	[*A*]the time to recover a watchdog timer[*R*]contributes[*A*]to the overall stabilization time of the system	context(One should bear)	negated: False ,passive: False
0.376	[*A*]One[*R*]should bear[*A*]though[*A*]that the time to recover a watchdog timer contributes to the overall stabilization time of the system	context()	negated: False ,passive: False
[LINE#883] It is hence advisable to make sure that recovering a watchdog timer does not take much longer than the largest timeout value in the system, e.g. by avoiding oversized counter registers. .
0.946	[*A*]recovering a watchdog timer[*R*]does not take e.g.[*A*]much longer than the largest timeout value in the system	context()	negated: True ,passive: False
[LINE#884] Computing the end-to-end delay boundsFrom the implementations of the individual components, it is straightforward to compute the delays d, dmin+, and dmax+.
[LINE#885+886]  Recall that d bounds, for any nodei, the maximal time that passes between a state transition of a remote node and a possibly triggered corresponding state change, i.e., the transition of Si.
0.887	[*A*]d bounds[*R*]triggered[*A*]corresponding state change	context()	negated: False ,passive: False
[LINE#887] This is done by computing the maximal sum of delays of any possible computing path, ranging over all possible state transitions (cf.
0.921	[*A*]delays of any possible computing path[*R*]ranging[*A*]over all possible state transitions	context()	negated: False ,passive: True
0.153	[*A*]This[*R*]is done	context()	negated: False ,passive: False
[LINE#888] Fig. 5), taking into account the delay of the channels Sj,i.
0.922	[*A*]Fig. 5[*R*]taking[*A*]into account[*A*]the delay of the channels	context()	negated: False ,passive: False
[LINE#889+890]  Clearly, the channel delay for the remote channels Sj,i exceeds the delays of the local channels; hence, the longest path to the input ports of the state transition module is bounded by dChan+dMem+dTh>dTime.
[LINE#891] Subsequently, the HSM locks the state transition and the TSM executes, which takes about two and a half clock cycles C of the pausable oscillator.
0.595	[*A*]the TSM[*R*]executes	context(the HSM locks)	negated: False ,passive: False
0.935	[*A*]the HSM[*R*]locks[*A*]the TSM executes[*A*]Subsequently	context()	negated: False ,passive: False
0.933	[*A*]the state transition[*R*]takes[*A*]about a half clock cycles C of the pausable oscillator	context()	negated: False ,passive: False
0.961	[*A*]the HSM[*R*]locks[*A*]the state transition , which takes about a half clock cycles C of the pausable oscillator[*A*]Subsequently	context()	negated: False ,passive: False
0.897	[*A*]the state transition[*R*]takes[*A*]about two clock cycles C of the pausable oscillator	context()	negated: False ,passive: False
0.961	[*A*]the HSM[*R*]locks[*A*]the state transition , which takes about two clock cycles C of the pausable oscillator[*A*]Subsequently	context()	negated: False ,passive: False
[LINE#892+893+894]  Note, however, that the new state is written into the flip-flops holding the state already during the commit cycle, i.e., after at most 1.5C. A more accurate bound on d than dChan+dMem+dTh+2.5C is thusd1.5C+max{C,dChan+dMem+dTh}.For our approach, dmax+d, since the only difference to d is that dChan is replaced by dChan+,the delay of the simpler 1-bit channels (cf.
0.845	[*A*]dChan[*R*]is replaced[*A*]by dChan+	context(A is)	negated: False ,passive: True
0.189	[*A*]A[*R*]is[*A*]that dChan is replaced by dChan+	context()	negated: False ,passive: True
0.956	[*A*]the flip-flops[*R*]holding[*A*]the state[*A*]already during the commit cycle, i.e., after at most 1.5C. A more accurate bound on d than dChan+dMem+dTh+2.5C	context()	negated: False ,passive: False
[LINE#895] If the main state machine's channels would utilize serial encoding, though, one might well have that dChanmax{dChan+,C}.
0.235	[*A*]one[*R*]might have	context()	negated: False ,passive: False
0.932	[*A*]the main state machine's channels[*R*]would utilize[*A*]serial encoding	context()	negated: False ,passive: False
[LINE#896] Finally, dmin+>C/, since this is the minimal time the HSM allows between locking a state transition and actually performing the transition at the port Si.3030Clearly, a more precise analysis would yield tighter bounds.
0.897	[*A*]a more precise analysis[*R*]would yield[*A*]tighter bounds	context(the HSM allows)	negated: False ,passive: False
0.945	[*A*]the HSM[*R*]allows[*A*]between locking a state transition and actually performing the transition at the port Si.3030Clearly[*A*]the minimal time	context()	negated: False ,passive: False
[LINE#897] Introduction & related workIn the past, computers have essentially been viewed as monolithic, synchronous, fault-free systems.
0.908	[*A*]computers[*R*]have been viewed[*A*]as monolithic, synchronous, fault-free systems[*A*]Introduction & related workIn the past	context()	negated: False ,passive: True
[LINE#898] If at all, fault-tolerance has been introduced (i) to deal with limited, specific failures (e.g. errors in communication or data read from storage, which are usually handled via error-correcting codes), and (ii) at the level of distributed systems comprised of multiple machines that are fault-prone or subject to attacks (e.g. data centers or peer-to-peer applications, which use some form of replication).
0.961	[*A*]limited, specific failures (e.g. errors in communication or data read from storage[*R*]are handled[*A*]at the level of distributed systems[*A*]usually	context()	negated: False ,passive: True
0.921	[*A*]peer-to-peer applications[*R*]use[*A*]some form of replication	context()	negated: False ,passive: False
0.932	[*A*]e.g. errors in communication or data[*R*]read[*A*]from storage	context()	negated: False ,passive: False
0.887	[*A*]multiple machines[*R*]are[*A*]fault-prone or subject to attacks	context()	negated: False ,passive: True
0.903	[*A*]distributed systems[*R*]comprised[*A*]of multiple machines	context()	negated: False ,passive: True
[LINE#899] Except for critical systems and extreme operational conditions (e.g. medical or aerospace applications [1]), there has been little motivation to build systems that are robust on all levels from scratch, a process that involves redesigning-or even reinventing-the very basics of how computations are organized and performed.
0.698	[*A*]a process[*R*]redesigning	context()	negated: False ,passive: False
0.927	[*A*]a process[*R*]involves[*A*]redesigning-or even reinventing-the very basics of how computations are organized and performed	context()	negated: False ,passive: True
0.677	[*A*]computations[*R*]performed	context()	negated: False ,passive: False
0.877	[*A*]systems[*R*]are[*A*]robust[*A*]on all levels from scratch	context()	negated: False ,passive: True
0.713	[*A*]computations[*R*]are organized	context()	negated: False ,passive: False
[LINE#900] Due to the tremendous advances of Very Large Scale Integration (VLSI) technology, this situation has changed.
0.732	[*A*]this situation[*R*]has changed	context()	negated: False ,passive: False
[LINE#901] Enabled by ever decreasing feature sizes and supply voltages, modern circuits nowadays accommodate billions of transistors running at GHz speeds [2].
0.713	[*A*]transistors[*R*]running	context()	negated: False ,passive: False
0.903	[*A*]modern circuits[*R*]nowadays accommodate[*A*]billions of transistors	context()	negated: False ,passive: False
[LINE#902] As a consequence, the assumption of chip-global (not to speak of system-global) synchrony [3] and no (or restricted) faults gradually became outdated [4].
0.749	[*A*]faults[*R*]gradually became[*A*]outdated [ 4	context()	negated: False ,passive: True
0.914	[*A*]the assumption of chip - global ( not to speak of system - global ) synchrony[*R*]restricted	context()	negated: False ,passive: False
0.973	[*A*]no faults[*R*]became[*A*]4 ]	context()	negated: False ,passive: False
0.767	[*A*]no faults[*R*]gradually became[*A*]outdated [ 4	context()	negated: False ,passive: True
0.783	[*A*]3 ] faults[*R*]gradually became[*A*]outdated [ 4	context()	negated: False ,passive: True
[LINE#903] Improved process technology and architectural-level fault-tolerance measures are common nowadays, and the lack of global synchrony has been tackled by accepting a certain level of asynchrony between different parts of the system.
0.953	[*A*]architectural - level fault - tolerance measures[*R*]by accepting[*A*]a certain level of asynchrony between different parts of the system	context()	negated: False ,passive: False
0.789	[*A*]architectural - level fault - tolerance measures[*R*]has been tackled	context()	negated: False ,passive: False
0.971	[*A*]Improved process technology fault - tolerance measures the lack of global synchrony[*R*]by accepting[*A*]a certain level of asynchrony between different parts of the system	context()	negated: False ,passive: False
0.878	[*A*]Improved process technology fault - tolerance measures the lack of global synchrony[*R*]has been tackled	context()	negated: False ,passive: False
0.842	[*A*]architectural - level fault - tolerance measures[*R*]are[*A*]common[*A*]nowadays	context()	negated: False ,passive: True
0.842	[*A*]Improved process technology fault - tolerance measures[*R*]are[*A*]common[*A*]nowadays	context()	negated: False ,passive: True
[LINE#904] In the most extreme form of this approach, computations are completely unsynchronized at all levels [5], which requires to synchronize all dependent activities (like sending and receiving of data) explicitly via handshaking.
0.286	[*A*]5[*R*]requires to synchronize[*A*]all dependent activities ( like receiving of data	context(5 requires)	negated: False ,passive: False
0.391	[*A*]5[*R*]requires[*A*]to synchronize all dependent activities ( like receiving of data ) explicitly via handshaking	context()	negated: False ,passive: False
0.999	[*A*]computations[*R*]are[*A*]5 ]	context()	negated: False ,passive: False
0.391	[*A*]5[*R*]requires to synchronize[*A*]all dependent activities ( like sending ) explicitly via handshaking	context(5 requires)	negated: False ,passive: False
0.391	[*A*]5[*R*]requires[*A*]to synchronize all dependent activities ( like sending ) explicitly via handshaking	context()	negated: False ,passive: False
0.938	[*A*]computations[*R*]are[*A*]completely unsynchronized at all levels[*A*]In the most extreme form of this approach	context()	negated: False ,passive: True
[LINE#905] In contrast, Globally Asynchronous Locally Synchronous (GALS) systems [6] make use of local clock sources to drive synchronous computations within each clock domain.
0.940	[*A*]Globally Asynchronous Locally Synchronous (GALS) systems[*R*]make[*A*]use of local clock sources to drive synchronous computations within each clock domain	context()	negated: False ,passive: False
[LINE#906] Note that, in the wider sense, most multiprocessors fall into this category, as there is usually no single common clock that drives all processors.
0.905	[*A*]no single common clock[*R*]drives[*A*]all processors	context()	negated: False ,passive: False
[LINE#907] GALS systems again can be divided into two general classes: One that operates asynchronously at the inter-domain level, and the other consisting of multi-synchronous systems [7,8] that provide some, albeit reduced, degree of synchronization among clock domains.
0.260	[*A*]albeit[*R*]reduced	context()	negated: False ,passive: False
0.735	[*A*]multi-synchronous systems[*R*]provide[*A*]some	context()	negated: False ,passive: False
0.503	[*A*]One[*R*]operates asynchronously[*A*]at the inter-domain level	context()	negated: False ,passive: True
0.892	[*A*]GALS systems[*R*]can be divided[*A*]into two general classes: One that operates asynchronously at the inter-domain level, and the other consisting of multi-synchronous systems[*A*]again	context()	negated: False ,passive: True
[LINE#908] The former class suffers from the drawback that, for inter-domain communication, either strong synchronizers or stoppable clocks must be foreseen [9].
0.911	[*A*]The former class[*R*]suffers[*A*]from the drawback	context()	negated: False ,passive: False
[LINE#909] After all, every bit of the sender's data must have stabilized at the receiver before the clock edge used for reading the data occurs.
0.911	[*A*]the clock edge[*R*]used[*A*]for reading the data	context()	negated: False ,passive: True
0.938	[*A*]every bit of the sender's data[*R*]must have stabilized[*A*]at the receiver[*A*]before the clock edge	context()	negated: False ,passive: True
[LINE#910] This is avoided in multi-synchronous systems, where high-speed inter-domain communication via FIFO buffers can be implemented due to the available global synchronization [10].
0.976	[*A*]high-speed inter-domain communication via FIFO buffers[*R*]can be implemented[*A*]due to the available global synchronization[*A*]multi-synchronous systems	context()	negated: False ,passive: True
0.381	[*A*]This[*R*]is avoided[*A*]in multi-synchronous systems	context()	negated: False ,passive: True
[LINE#911] Since the latter abstraction is also very useful for other purposes, multi-synchronous GALS is preferable from the viewpoint of a system-level designer.
0.964	[*A*]multi-synchronous GALS[*R*]is[*A*]preferable from the viewpoint of a system-level designer	context()	negated: False ,passive: True
0.932	[*A*]the latter abstraction[*R*]is[*A*]also[*A*]very useful for other purposes	context()	negated: False ,passive: True
[LINE#912] Naturally, establishing inter-domain synchronization comes at additional costs.
0.751	[*A*]establishing inter-domain synchronization[*R*]comes	context()	negated: False ,passive: False
[LINE#913] While it is not too difficult to achieve and maintain in the absence of faults [11,12], the issue becomes highly challenging once faults of clocking system components enter the picture..
0.913	[*A*]once faults of clocking system components[*R*]enter[*A*]the picture	context(the issue becomes highly challenging)	negated: False ,passive: False
0.569	[*A*]it[*R*]is not[*A*]too difficult to maintain in the absence of faults [ 11,12	context()	negated: True ,passive: True
0.913	[*A*]once faults of clocking system components[*R*]enter[*A*]the picture	context(the issue becomes highly challenging)	negated: False ,passive: False
0.878	[*A*]the issue[*R*]becomes highly challenging[*A*]once faults of clocking system components	context()	negated: False ,passive: False
0.225	[*A*]it[*R*]is not[*A*]too difficult to achieve	context()	negated: True ,passive: True
[LINE#914] We present an FPGA prototype implementation of a distributed clock generation scheme for SoC that self-stabilizes in the presence of up to f<n/3 faulty nodes.
0.614	[*A*]We[*R*]present[*A*]an FPGA prototype implementation of a distributed clock generation scheme for SoC	context()	negated: False ,passive: False
[LINE#915] It incorporates the pulse algorithm from [13] that tolerates arbitrary clock drifts and allows for deterministic recovery and (re)joining in constant time if n-f nodes are synchronized; it stabilizes within time O(n) with probability 1-2-n from any arbitrary state.
0.618	[*A*]13[*R*]allows[*A*]for deterministic O ( n ) with probability 1-2 - n from any arbitrary state	context()	negated: False ,passive: False
0.159	[*A*]It[*R*]incorporates algorithm[*A*]from [ 13[*A*]n	context()	negated: False ,passive: False
0.503	[*A*]13[*R*]allows[*A*]for deterministic recovery	context()	negated: False ,passive: False
0.503	[*A*]13[*R*]tolerates[*A*]arbitrary clock drifts	context()	negated: False ,passive: False
0.159	[*A*]It[*R*]incorporates algorithm[*A*]from [ 13	context()	negated: False ,passive: False
[LINE#916] An additional algorithmic layer that interacts weakly with the former provides bounded high-frequency clocks atop of it.
0.886	[*A*]An additional algorithmic layer that interacts weakly with the former provides[*R*]bounded[*A*]atop of it	context(An additional algorithmic layer interacts weakly)	negated: False ,passive: False
0.880	[*A*]An additional algorithmic layer[*R*]interacts weakly[*A*]with the former provides	context()	negated: False ,passive: False
[LINE#917] Nodes executing the compound algorithm broadcast a mere constant number of bits in constant time.
0.871	[*A*]Nodes[*R*]executing[*A*]the compound algorithm	context(Nodes executing the compound algorithm broadcast)	negated: False ,passive: False
0.909	[*A*]Nodes executing the compound algorithm[*R*]broadcast[*A*]a mere constant number of bits in constant time	context()	negated: False ,passive: False
[LINE#918+919]  The formal proofs of the properties of the pulse synchronization algorithm and the derived high-frequency clocks are given in [13].Deriving an implementation from the specification of the algorithm in [13] proved to be challenging, as the high-level theoretical model and formulation of the algorithm in [13] abstracts away many details.
0.932	[*A*]the derived high - frequency clocks[*R*]are given[*A*]in [ 13[*A*]as formulation of the algorithm in [ 13	context()	negated: False ,passive: True
0.993	[*A*]the derived high frequency clocks[*R*]are given in[*A*]13 ]	context()	negated: False ,passive: False
0.956	[*A*]the derived high - frequency clocks[*R*]are given[*A*]in [ 13[*A*]as the high - level theoretical model of the algorithm in [ 13	context()	negated: False ,passive: True
0.927	[*A*]formulation of the algorithm in [ 13[*R*]abstracts[*A*]away[*A*]many details	context()	negated: False ,passive: False
0.954	[*A*]the high - level theoretical model of the algorithm in [ 13[*R*]abstracts[*A*]away[*A*]many details	context()	negated: False ,passive: False
0.847	[*A*]The formal proofs of the properties of the pulse synchronization algorithm[*R*]to be challenging	context()	negated: False ,passive: False
[LINE#920] Firstly, it assumes a number of basic self-stabilizing modules above the level of gates and wires to be given.
0.713	[*A*]wires[*R*]to be given	context()	negated: False ,passive: False
0.569	[*A*]it[*R*]assumes[*A*]a number of basic self - stabilizing modules above the level of wires	context()	negated: False ,passive: False
0.713	[*A*]gates[*R*]to be given	context()	negated: False ,passive: False
0.569	[*A*]it[*R*]assumes[*A*]a number of basic self - stabilizing modules above the level of gates	context()	negated: False ,passive: False
[LINE#921] We devise and discuss self-stabilizing implementations of these building blocks meeting the specifications required by the high-level algorithm.
0.903	[*A*]the specifications[*R*]required[*A*]by the high - level algorithm	context()	negated: False ,passive: True
0.911	[*A*]these building blocks[*R*]meeting[*A*]the specifications required by the high - level algorithm	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]discuss[*A*]self - stabilizing implementations of these building blocks	context()	negated: False ,passive: False
0.195	[*A*]We[*R*]devise	context()	negated: False ,passive: False
[LINE#922] Secondly, the algorithm's description is in terms of state machines performing transitions that are non-trivial in the sense that they do not consist of switching a single binary signal or memory bit.
0.552	[*A*]they[*R*]do not consist[*A*]of switching a single binary signal or memory bit	context(the algorithm 's description is)	negated: True ,passive: True
0.920	[*A*]the algorithm's description[*R*]is[*A*]in terms of state machines	context()	negated: False ,passive: True
0.575	[*A*]they[*R*]of switching[*A*]a single binary signal or memory bit	context()	negated: False ,passive: False
0.716	[*A*]transitions[*R*]are[*A*]non-trivial	context()	negated: False ,passive: True
0.773	[*A*]state machines[*R*]performing[*A*]transitions that are non-trivial in the sense	context()	negated: False ,passive: False
[LINE#923] This requires careful consideration of metastability issues, since these state transitions are triggered by information from different clock domains.
0.911	[*A*]these state transitions[*R*]are triggered[*A*]by information from different clock domains	context()	negated: False ,passive: True
0.497	[*A*]This[*R*]requires[*A*]careful consideration of metastability issues[*A*]since these state transitions are triggered by information from different clock domains	context()	negated: False ,passive: False
[LINE#924] In order to resolve this issue, we introduce a generic Hybrid State Transition Machine (HSTM) that asynchronously starts a local synchronous execution of a state transition satisfying the model specification from [13].
0.943	[*A*]a local synchronous execution of a state transition[*R*]satisfying[*A*]the model specification[*A*]from [13	context()	negated: False ,passive: False
0.498	[*A*]we[*R*]introduce[*A*]a generic Hybrid State Transition Machine	context()	negated: False ,passive: False
[LINE#925] Related to this matter, we thirdly discuss in detail how the algorithm and its implementation make a best effort to guard against metastable upsets.
0.195	[*A*]we[*R*]discuss[*A*]how its implementation make a best effort	context()	negated: False ,passive: False
0.878	[*A*]the algorithm[*R*]make[*A*]a best effort to guard against metastable upsets	context(we discuss)	negated: False ,passive: False
0.349	[*A*]we[*R*]discuss[*A*]in detail[*A*]how the algorithm make a best effort	context()	negated: False ,passive: False
[LINE#926] Here, we try to get the best out of the design decisions and rely on synchronizers only where absolutely necessary.
0.388	[*A*]we[*R*]try to rely[*A*]on synchronizers	context(we try)	negated: False ,passive: False
0.600	[*A*]we[*R*]try[*A*]to rely on synchronizers[*A*]Here	context()	negated: False ,passive: False
0.388	[*A*]we[*R*]try to get[*A*]the best[*A*]out of the design decisions	context(we try)	negated: False ,passive: False
0.600	[*A*]we[*R*]try[*A*]to get the best out of the design decisions[*A*]Here	context()	negated: False ,passive: False
[LINE#927+928]  These non-trivial implementation issues and the complex interactions between the basic building blocks raise the question under which circumstances the high-level properties of the algorithm shown in [13]indeed hold for the presented implementation.
0.964	[*A*]the complex interactions between the basic building blocks[*R*]raise[*A*]the question under which circumstances the high - level properties of the algorithm shown in [ 13 ] indeed hold for the presented implementation	context()	negated: False ,passive: False
0.954	[*A*]circumstances the high - level properties of the algorithm[*R*]hold[*A*]for the presented implementation	context()	negated: False ,passive: False
0.813	[*A*]the algorithm[*R*]shown[*A*]in [ 13	context()	negated: False ,passive: True
0.948	[*A*]These non-trivial implementation issues[*R*]raise[*A*]the question under which circumstances the high - level properties of the algorithm shown in [ 13 ] indeed hold for the presented implementation	context()	negated: False ,passive: False
[LINE#929] To answer this question, we devised a model that is able to capture the behavior of the constructed modules, including faults, resilience to faults, and self-stabilization, in a hierarchical fashion.
0.927	[*A*]a model[*R*]to capture[*A*]the behavior of the constructed modules , including self - stabilization , in a hierarchical fashion	context()	negated: False ,passive: False
0.944	[*A*]a model[*R*]is[*A*]able to capture the behavior of the constructed modules , including self - stabilization , in a hierarchical fashion	context()	negated: False ,passive: True
0.326	[*A*]we[*R*]devised[*A*]a model that is able to capture the behavior of the constructed modules , including self - stabilization , in a hierarchical fashion	context()	negated: False ,passive: False
0.927	[*A*]a model[*R*]to capture[*A*]the behavior of the constructed modules , including resilience to faults	context()	negated: False ,passive: False
0.944	[*A*]a model[*R*]is[*A*]able to capture the behavior of the constructed modules , including resilience to faults	context()	negated: False ,passive: True
0.326	[*A*]we[*R*]devised[*A*]a model that is able to capture the behavior of the constructed modules , including resilience to faults	context()	negated: False ,passive: False
0.887	[*A*]a model[*R*]to capture[*A*]the behavior of the constructed modules , including faults	context()	negated: False ,passive: False
0.944	[*A*]a model[*R*]is[*A*]able to capture the behavior of the constructed modules , including faults	context()	negated: False ,passive: True
0.326	[*A*]we[*R*]devised[*A*]a model that is able to capture the behavior of the constructed modules , including faults	context()	negated: False ,passive: False
[LINE#930] By specifying the desired behavior of modules in terms of the feasible output generated in response to their inputs, we can also reason about the behavior of (implementations of) modules in a hierarchical manner.
0.463	[*A*]we[*R*]can reason[*A*]about the behavior of (implementations of) modules in a hierarchical manner	context()	negated: False ,passive: False
0.848	[*A*]the feasible output[*R*]generated[*A*]in response to their inputs	context()	negated: False ,passive: True
[LINE#931] This property is crucial, as it permits to determine conditions under which our implementation indeed satisfies the requirements by the abstract model used in [13], and then soundly conclude that if these conditions are met, all statements made in [13] apply to our implementation.
0.732	[*A*]these conditions[*R*]are met	context()	negated: False ,passive: False
0.783	[*A*]the abstract model[*R*]used[*A*]in [ 13	context()	negated: False ,passive: True
0.727	[*A*]our implementation[*R*]satisfies[*A*]the requirements by the abstract model[*A*]conditions	context()	negated: False ,passive: False
0.870	[*A*]This property[*R*]is[*A*]crucial[*A*]as it permits to determine conditions	context()	negated: False ,passive: True
[LINE#932] Since our approach is highly generic and permits to adjust the granularity of the description in order to focus on specific aspects of the system, we believe it to be of general and independent interest in the context of devising fault-tolerant systems.
0.504	[*A*]it[*R*]to be[*A*]of independent interest in the context of devising fault - tolerant systems	context(we believe)	negated: False ,passive: True
0.504	[*A*]it[*R*]to be[*A*]of general interest in the context of devising fault - tolerant systems	context(we believe)	negated: False ,passive: True
0.660	[*A*]our approach permits[*R*]to adjust[*A*]the granularity of the description in order	context()	negated: False ,passive: False
0.504	[*A*]it[*R*]to be[*A*]of independent interest in the context of devising fault - tolerant systems	context(we believe)	negated: False ,passive: True
0.356	[*A*]we[*R*]believe[*A*]it to be of independent interest in the context of devising fault - tolerant systems	context()	negated: False ,passive: False
0.504	[*A*]it[*R*]to be[*A*]of general interest in the context of devising fault - tolerant systems	context(we believe)	negated: False ,passive: True
0.356	[*A*]we[*R*]believe[*A*]it to be of general interest in the context of devising fault - tolerant systems	context()	negated: False ,passive: False
0.452	[*A*]our approach[*R*]is[*A*]highly generic	context()	negated: False ,passive: True
[LINE#933] In order to verify the predictions from theory,33Or, to be scientifically accurate, we rather successfully failed at falsifying them.
0.274	[*A*]we[*R*]at falsifying[*A*]them	context()	negated: False ,passive: False
0.274	[*A*]we[*R*]successfully failed[*A*]at falsifying them	context()	negated: False ,passive: True
0.847	[*A*]the predictions from theory,33Or[*R*]to be[*A*]scientifically accurate	context()	negated: False ,passive: True
[LINE#934] Our implementation primarily serves as a proof of concept, as clearly an FPGA implementation can merely hint at the properties of an ASIC.
0.534	[*A*]Our implementation[*R*]serves[*A*]as a proof of concept	context(an FPGA implementation can hint)	negated: False ,passive: False
0.894	[*A*]an FPGA implementation[*R*]can hint[*A*]at the properties of an ASIC	context()	negated: False ,passive: False
[LINE#935] we carried out several experiments incorporating drifting clocks, varying delays, and both transient and permanent faults.
0.903	[*A*]several experiments[*R*]incorporating[*A*]permanent faults	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]carried out[*A*]several experiments incorporating permanent faults	context()	negated: False ,passive: False
0.903	[*A*]several experiments[*R*]incorporating[*A*]both transient faults	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]carried out[*A*]several experiments incorporating both transient faults	context()	negated: False ,passive: False
0.903	[*A*]several experiments[*R*]incorporating[*A*]varying delays	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]carried out[*A*]several experiments incorporating varying delays	context()	negated: False ,passive: False
0.903	[*A*]several experiments[*R*]incorporating[*A*]drifting clocks	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]carried out[*A*]several experiments incorporating drifting clocks	context()	negated: False ,passive: False
[LINE#936] This necessitated the development of a testbed that can be efficiently controlled and set up for executing a large number of test runs quickly.
0.903	[*A*]a testbed[*R*]set up[*A*]for executing a large number of test	context()	negated: False ,passive: True
0.884	[*A*]a testbed[*R*]can be efficiently controlled quickly[*A*]runs	context()	negated: False ,passive: False
0.381	[*A*]This[*R*]necessitated[*A*]the development of a testbed	context()	negated: False ,passive: False
[LINE#937+938]  In our 8-node prototype implementation, the compound algorithm generates 8-bit clocks that in all runs stabilized within 1.9106d time(where d is the maximal end-to-end communication delay).
0.999	[*A*]the compound algorithm that in all runs stabilized within 1.9106 d time ( where d is the maximal end - to - end communication delay )[*R*]generates[*A*]8 - bit clocks	context()	negated: False ,passive: False
0.852	[*A*]d[*R*]is[*A*]the maximal end-to-end communication delay	context()	negated: False ,passive: True
0.903	[*A*]all runs[*R*]stabilized[*A*]within 1.9106d time	context()	negated: False ,passive: True
0.909	[*A*]the compound algorithm[*R*]generates[*A*]8-bit clocks[*A*]In our 8-node prototype implementation	context()	negated: False ,passive: False
[LINE#939] In our testbed, which runs at roughly 100 kHz, this amounts to less than 12 s. For a system running at GHz speed, this translates to about a millisecond.
0.315	[*A*]this[*R*]amounts[*A*]to less than 12 s. For a system[*A*]In our testbed	context(In our testbed , which runs at roughly 100 kHz , this amounts to less than 12 s. For a system translates)	negated: False ,passive: True
0.775	[*A*]In our testbed, which runs at roughly 100 kHz, this amounts to less than 12 s. For a system[*R*]translates[*A*]to	context()	negated: False ,passive: True
0.732	[*A*]a system[*R*]running	context()	negated: False ,passive: False
0.704	[*A*]our testbed[*R*]runs[*A*]at roughly 100 kHz	context()	negated: False ,passive: True
[LINE#940] We also observed that the deterministic stabilization mechanism designed for more benign conditions operates as expected, recovering nodes by about two orders of magnitude faster. .
0.922	[*A*]the deterministic stabilization mechanism designed for more benign conditions[*R*]operates[*A*]recovering nodes by about two orders of magnitude faster	context(We observed)	negated: False ,passive: True
0.239	[*A*]We[*R*]observed[*A*]that the deterministic stabilization mechanism designed for more benign conditions operates as expected, recovering nodes by about two orders of magnitude faster	context()	negated: False ,passive: False
0.938	[*A*]the deterministic stabilization mechanism designed for more benign conditions[*R*]recovering faster[*A*]nodes	context()	negated: False ,passive: False
0.919	[*A*]the deterministic stabilization mechanism[*R*]designed[*A*]for more benign conditions	context()	negated: False ,passive: True
[LINE#941] the next section, we summarize the obstacles and design goals that need to be considered for clock synchronization in our setting; we also introduce the basic building blocks assumed in [13], which perform typical operations used by fault-tolerant synchronization algorithms.
0.680	[*A*]the next section[*R*]summarize[*A*]the design goals that need to be considered for clock synchronization in our setting	context(we introduce)	negated: False ,passive: True
0.825	[*A*]the design goals[*R*]to be considered[*A*]for clock synchronization[*A*]in our setting	context()	negated: False ,passive: True
0.825	[*A*]the design goals[*R*]need[*A*]to be considered for clock synchronization in our setting	context()	negated: False ,passive: False
0.870	[*A*]the next section[*R*]summarize[*A*]the obstacles	context(we introduce)	negated: False ,passive: True
0.462	[*A*]we[*R*]introduce[*A*]the basic building blocks assumed in [ 13 ] ,	context()	negated: False ,passive: False
0.903	[*A*]typical operations[*R*]used[*A*]by fault - tolerant synchronization algorithms	context()	negated: False ,passive: True
0.503	[*A*]13[*R*]perform[*A*]typical operations used by fault - tolerant synchronization algorithms	context()	negated: False ,passive: False
0.799	[*A*]the basic building blocks[*R*]assumed[*A*]in [ 13	context()	negated: False ,passive: True
[LINE#942] Section 3 introduces the formal model, alongside illustrating examples and proofs of some basic properties.
0.903	[*A*]Section 3[*R*]introduces[*A*]the formal model	context()	negated: False ,passive: False
[LINE#943] Subsequently, in Section 4 we cast the modules informally discussed earlier in our formal framework, and interpret nodes, protocols, and the synchronization problem as modules as well.
0.810	[*A*]the modules[*R*]discussed[*A*]earlier in our formal framework	context()	negated: False ,passive: True
0.514	[*A*]we[*R*]cast[*A*]the modules informally discussed earlier in our formal framework[*A*]Subsequently[*A*]in Section 4	context()	negated: False ,passive: False
[LINE#944] In Section 5, we move on to the description of the algorithm from [13] in terms of this framework.
0.702	[*A*]we[*R*]move[*A*]on[*A*]to the description of the algorithm from [13] in terms of this framework[*A*]In Section 5	context()	negated: False ,passive: True
[LINE#945] We provide high-level intution on the purpose of its various components and summarize the main statements proved in [13].
0.783	[*A*]the main statements[*R*]proved[*A*]in [ 13	context()	negated: False ,passive: True
0.452	[*A*]We[*R*]summarize[*A*]the main statements proved in [ 13 ]	context()	negated: False ,passive: False
0.309	[*A*]We[*R*]provide[*A*]high - level intution[*A*]on the purpose of its various components	context()	negated: False ,passive: False
[LINE#946] Section 6 follows up with presenting our implementations of the basic modules specified in Section 2.2, including the HSTM.
0.911	[*A*]the basic modules[*R*]specified[*A*]in Section 2.2	context()	negated: False ,passive: True
0.732	[*A*]Section 6[*R*]follows up	context()	negated: False ,passive: False
[LINE#947] In this context, we will also cover our efforts to minimize the probability for metastable upsets.
0.343	[*A*]we[*R*]will cover[*A*]our efforts to minimize the probability for metastable upsets[*A*]In this context	context()	negated: False ,passive: False
[LINE#948] In Section 7 we describe the testbed setup, the experiments, and their results.
0.444	[*A*]we[*R*]describe[*A*]their results[*A*]In Section 7	context()	negated: False ,passive: False
0.595	[*A*]we[*R*]describe[*A*]the experiments[*A*]In Section 7	context()	negated: False ,passive: False
0.595	[*A*]we[*R*]describe[*A*]the testbed setup[*A*]In Section 7	context()	negated: False ,passive: False
[LINE#949] Finally, in Section 8 we evaluate to what extent our design goals are met and give an outlook on future work.
0.305	[*A*]our design goals[*R*]are met	context(we evaluate)	negated: False ,passive: False
0.381	[*A*]we[*R*]evaluate[*A*]to what extent our design goals are met[*A*]Finally[*A*]in Section 8	context()	negated: False ,passive: False
[LINE#950] -chip clock synchronizationOur goal is to design a scalable hardware clock generation scheme that is resilient to arbitrary transient and permanent faults and carefully minimizes the risk of metastability.
0.939	[*A*]a scalable hardware clock generation scheme[*R*]is[*A*]resilient to arbitrary permanent faults	context()	negated: False ,passive: True
0.939	[*A*]a scalable hardware clock generation scheme[*R*]is[*A*]resilient to arbitrary transient faults	context()	negated: False ,passive: True
0.758	[*A*]- chip clock synchronizationOur goal[*R*]is[*A*]to design a scalable hardware clock generation scheme	context()	negated: False ,passive: True
0.844	[*A*]a scalable hardware clock generation scheme[*R*]is[*A*]carefully	context()	negated: False ,passive: True
0.701	[*A*]synchronizationOur goal[*R*]is[*A*]to design a scalable hardware clock generation scheme	context()	negated: False ,passive: True
[LINE#951] We will now discuss our objectives in more detail and explain why tackling them in conjunction proves to be much harder than achieving them individually.
0.343	[*A*]We[*R*]will discuss[*A*]our objectives[*A*]now	context()	negated: False ,passive: False
[LINE#952] In accordance with standard notions, in the following we will refer to clock domains as nodes, as they represent the smallest "independent" algorithmic building block we use.
0.932	[*A*]the smallest "independent" algorithmic building block[*R*]use[*A*]we	context()	negated: False ,passive: True
0.582	[*A*]they[*R*]represent[*A*]the smallest "independent" algorithmic building block we use	context()	negated: False ,passive: False
0.562	[*A*]we[*R*]will refer[*A*]to clock domains[*A*]as nodes[*A*]as they represent the smallest "independent" algorithmic building block[*A*]in the following	context()	negated: False ,passive: False
[LINE#953] This is to be understood in the sense that we consider a node faulty if any one of its components is faulty, and non-faulty otherwise (irrespectively of whether other nodes behave correctly or not).
0.767	[*A*]other nodes[*R*]behave[*A*]correctly	context()	negated: False ,passive: False
0.524	[*A*]any one of its components[*R*]is[*A*]faulty	context()	negated: False ,passive: True
0.445	[*A*]we[*R*]consider irrespectively[*A*]a node faulty	context()	negated: False ,passive: False
0.142	[*A*]This[*R*]to be understood[*A*]in the sense that we consider a node faulty if any one of its components is faulty, and non-faulty otherwise (irrespectively of whether other nodes behave correctly or not	context()	negated: False ,passive: True
0.206	[*A*]This[*R*]is[*A*]to be understood in the sense that we consider a node faulty if any one of its components is faulty, and non-faulty otherwise (irrespectively of whether other nodes behave correctly or not	context()	negated: False ,passive: True
[LINE#954+955]  Denoting by [i..j] the set {kN|ikj}, ultimately, each correct nodei[1..n] must at all times t output a (discrete) logical clock Li(t)N that fulfills certain properties despite the aforementioned obstacles; most obviously, we strive for minimizing maxi,j[1..
0.978	[*A*]must at all times t output a (discrete) logical clock Li(t)N[*R*]fulfills[*A*]certain properties[*A*]despite the aforementioned obstacles	context()	negated: False ,passive: False
0.435	[*A*]i[*R*]j[*A*]the set	context()	negated: False ,passive: False
[LINE#956] n],t0{Li(t)-Lj(t)}.. Inexact local clocks and unknown message delaysWhen synchronizing clocks, one needs to face that clocks are not perfect and that it cannot be exactly determined how much time it takes to communicate a clock reading.
0.695	[*A*]that clocks[*R*]are[*A*]that it can not be exactly determined how much time it takes to communicate a clock reading	context()	negated: False ,passive: True
0.266	[*A*]one[*R*]needs to face to face	context(one needs)	negated: False ,passive: False
0.303	[*A*]one[*R*]needs[*A*]to face	context()	negated: False ,passive: False
0.745	[*A*]clocks[*R*]are not[*A*]perfect how much time it takes to communicate a clock reading	context(one needs to face)	negated: True ,passive: True
0.282	[*A*]one[*R*]needs to face[*A*]that clocks are not perfect how much time it takes to communicate a clock reading	context(one needs)	negated: False ,passive: False
0.933	[*A*]unknown message delaysWhen[*R*]synchronizing[*A*]clocks	context()	negated: False ,passive: False
0.658	[*A*]synchronizing clocks[*R*]are[*A*]that it can not be exactly determined how much time it takes to communicate a clock reading	context()	negated: False ,passive: True
0.319	[*A*]one[*R*]needs to face[*A*]that clocks	context(one needs)	negated: False ,passive: False
0.319	[*A*]one[*R*]needs[*A*]to face that clocks	context()	negated: False ,passive: False
0.752	[*A*]clocks[*R*]are not[*A*]perfect how much time it takes to communicate a clock reading	context(one needs to face)	negated: True ,passive: True
0.290	[*A*]one[*R*]needs to face[*A*]that clocks are not perfect how much time it takes to communicate a clock reading	context(one needs)	negated: False ,passive: False
0.290	[*A*]one[*R*]needs[*A*]to face that clocks are not perfect how much time it takes to communicate a clock reading	context()	negated: False ,passive: False
[LINE#957] These fundamental uncertainties entail that synchronization can never be perfectly accurate and must be an ongoing process [14].
0.919	[*A*]These fundamental uncertainties entail[*R*]must be[*A*]an ongoing process	context()	negated: False ,passive: True
0.705	[*A*]synchronization[*R*]can never be[*A*]perfectly accurate	context(These fundamental uncertainties entail)	negated: True ,passive: True
0.750	[*A*]These fundamental uncertainties[*R*]entail[*A*]that synchronization can never be perfectly accurate	context()	negated: False ,passive: False
[LINE#958] We formalize these notions as follows.
0.452	[*A*]We[*R*]formalize[*A*]these notions[*A*]as follows	context()	negated: False ,passive: False
[LINE#959] Each node i[1..n] can make use of local clocks that are inexact and therefore drift (i.e., do not progress at the same rate).
0.229	[*A*]i.e.[*R*]do not progress	context()	negated: True ,passive: False
0.887	[*A*]local clocks[*R*]are[*A*]therefore drift	context()	negated: False ,passive: True
0.735	[*A*]local clocks[*R*]are[*A*]inexact	context()	negated: False ,passive: True
0.448	[*A*]i[*R*]n can make[*A*]use of local clocks[*A*]Each node	context()	negated: False ,passive: False
[LINE#960] Since we are only concerned with synchronizing clock domains with each other, we do not care about Newtonian time.
0.452	[*A*]we[*R*]do not care[*A*]about Newtonian time	context()	negated: True ,passive: False
0.411	[*A*]we[*R*]with synchronizing[*A*]clock domains[*A*]with each other	context()	negated: False ,passive: False
[LINE#961] Instead, we describe the system in terms of a reference time satisfying that any correctly operating clock progresses at a speed between 1 and some constant  with respect to the reference time tR.
0.719	[*A*]any correctly operating clock[*R*]progresses	context(we describe)	negated: False ,passive: False
0.108	[*A*]we[*R*]describe the system satisfying	context(we describe)	negated: False ,passive: False
0.388	[*A*]we[*R*]describe[*A*]the system	context()	negated: False ,passive: False
[LINE#962+963+964]  A (local) clock C:RR that is correct during a period of reference time [t-,t+]R guarantees that t, t[t-,t+], t<t: t-tC(t)-C(t)(t-t)(in particular, C is continuous and strictly increasing during [t-,t+]).44We use real-valued, unbounded clocks here to simplify the presentation.
0.877	[*A*]C[*R*]is strictly increasing[*A*]during [ t - , t+	context()	negated: False ,passive: True
0.680	[*A*]C[*R*]is[*A*]continuous	context(t , t [ t - , t+ ] , t < t : t - tC ( t ) - C ( t ) ( t - t ) ( in particular use)	negated: False ,passive: True
0.994	[*A*]t , t [ t - , t+ ] , t < t : t - tC ( t ) - C ( t ) ( t - t ) ( in particular[*R*]use[*A*]real - valued , unbounded clocks[*A*]here[*A*]to simplify the presentation	context()	negated: False ,passive: False
0.869	[*A*]RR[*R*]is[*A*]correct[*A*]during a period of reference time	context()	negated: False ,passive: True
[LINE#965] It will later become clear that the algorithm can indeed operate with discrete bounded clocks, as it does not need to access absolute clock values, but rather approximately measures bounded differences in time.
0.769	[*A*]discrete bounded approximately measures[*R*]bounded	context()	negated: False ,passive: False
0.388	[*A*]it[*R*]does not need to access[*A*]absolute clock values	context(it does not need)	negated: True ,passive: False
0.388	[*A*]it[*R*]does not need[*A*]to access absolute clock values	context()	negated: True ,passive: False
[LINE#966] In contrast to many "traditional" synchronization settings, we would like to tolerate quite large relative clock drifts -1 of up to about 20%, as accurate and stable oscillators are not available in a System-on-Chip (SoC) at low costs.
0.666	[*A*]a System on Chip at low costs[*R*]has stable oscillators of[*A*]1 of stable oscillators	context()	negated: False ,passive: False
0.550	[*A*]we[*R*]would like to tolerate[*A*]quite large relative clock drifts - 1 of stable oscillators are not available in a System - on - Chip ( SoC ) at low costs	context(we would like)	negated: False ,passive: False
0.956	[*A*]1 of stable oscillators[*R*]are not[*A*]available[*A*]in a System - on - Chip ( SoC ) at low costs	context()	negated: True ,passive: True
0.550	[*A*]we[*R*]would like to tolerate[*A*]quite large relative clock drifts - 1 of up to about 20 % oscillators are not available in a System - on - Chip ( SoC ) at low costs	context(we would like)	negated: False ,passive: False
0.388	[*A*]we[*R*]would like[*A*]to tolerate quite large relative clock drifts	context()	negated: False ,passive: False
0.682	[*A*]1 of[*R*]are not[*A*]available[*A*]in a System - on - Chip ( SoC ) at low costs	context()	negated: True ,passive: True
[LINE#967+968]  Tolerating such large drifts permits to utilize very simple ring oscillators even under heavily varying conditions (temperature, supply voltage, etc.)i communicates with node j via an abstract FIFO channel that (if correct) continuously makes i's state available to j, albeit delayed by an unknown value between 0 and the maximal delay d.
0.875	[*A*]an abstract FIFO channel[*R*]continuously makes[*A*]i's	context()	negated: False ,passive: False
0.452	[*A*]i[*R*]communicates[*A*]with node j	context()	negated: False ,passive: False
[LINE#969] We denote the input port of the channel from node i to node j by Si and its output port by Sj,i.
0.880	[*A*]node[*R*]j[*A*]by its output port by Sj	context()	negated: False ,passive: True
0.452	[*A*]We[*R*]denote[*A*]the input port of the channel[*A*]from node	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]denote[*A*]the input port of the channel from node	context()	negated: False ,passive: False
[LINE#970] Node i also loops back its own state to itself on a channel.
0.274	[*A*]i[*R*]loops[*A*]back[*A*]its own state[*A*]to itself	context()	negated: False ,passive: False
[LINE#971+972]  The time required for computations that are triggered by some communicated information is accounted for by d as well, i.e., d is an end-to-end delay.55Thisis the reason why we speak of an abstract channel.
0.877	[*A*]computations[*R*]are triggered[*A*]by some communicated information	context()	negated: False ,passive: True
0.452	[*A*]we[*R*]speak[*A*]of an abstract channel	context()	negated: False ,passive: False
0.903	[*A*]The time[*R*]required[*A*]for computations	context()	negated: False ,passive: True
[LINE#973] We will later introduce the (physical) channels that essentially represent the wires on the chip; the maximal delay d is then the sum of the maximal delay of the physical channels and the computing elements of the nodes.
0.302	[*A*]We[*R*]will introduce[*A*]the (physical) channels that essentially represent the wires on the chip[*A*]later	context(the maximal delay d is)	negated: False ,passive: False
0.949	[*A*]the maximal delay d[*R*]is[*A*]then[*A*]the sum of the maximal delay of the physical channels and the computing elements of the nodes	context()	negated: False ,passive: True
0.913	[*A*]the (physical) channels[*R*]represent[*A*]the wires	context()	negated: False ,passive: False
[LINE#974+975]  For the sake of a straightforward presentation, throughout this article we assume that all channels from node i to some nodei, i.e., faults of the channel are mapped to the sender node.
0.684	[*A*]all channels from node[*R*]are mapped	context(we assume)	negated: False ,passive: False
0.265	[*A*]we[*R*]assume[*A*]that all channels from node i to some nodei, i.e., faults of the channel are mapped to the sender node[*A*]throughout this article	context()	negated: False ,passive: False
[LINE#976] We remark, however, that a more detailed treatment (as e.g. in [16]) can be beneficial and is supported by the modeling framework underlying this work..
0.911	[*A*]the modeling framework[*R*]underlying[*A*]this work	context()	negated: False ,passive: False
0.452	[*A*]We[*R*]is supported[*A*]by the modeling framework	context()	negated: False ,passive: True
0.822	[*A*]a more detailed treatment ( as e.g. in [ 16[*R*]can be[*A*]beneficial	context(We remark)	negated: False ,passive: True
0.236	[*A*]We[*R*]remark[*A*]however[*A*]that a more detailed treatment ( as e.g. in [ 16 ] ) can be beneficial	context()	negated: False ,passive: False
[LINE#977] Transient faultsIncreasing soft error rates of modern VLSI circuits [17], originating in ionizing radiation [18-21], cross-talk, and ground bouncing [22,23], make it vital to allow for recovery from transient faults.
0.944	[*A*]Transient faultsIncreasing soft error rates of modern VLSI circuits [ 17 ] , originating in ionizing ground bouncing [ 22,23[*R*]make[*A*]it vital to allow for recovery from transient faults	context()	negated: False ,passive: False
0.713	[*A*]ground[*R*]bouncing	context()	negated: False ,passive: False
0.915	[*A*]Transient faultsIncreasing soft error rates of modern VLSI circuits[*R*]originating[*A*]in ionizing ground	context()	negated: False ,passive: True
0.792	[*A*]Transient faultsIncreasing soft error rates of modern VLSI circuits[*R*]originating[*A*]in ionizing	context()	negated: False ,passive: True
0.854	[*A*]Transient faultsIncreasing soft error rates of modern VLSI circuits[*R*]make[*A*]it vital to allow for recovery from transient faults	context()	negated: False ,passive: False
0.915	[*A*]Transient faultsIncreasing soft error rates of modern VLSI circuits[*R*]originating[*A*]in ionizing radiation [ 18-21 ] bouncing	context()	negated: False ,passive: True
[LINE#978+979]  The most extreme transient fault scenario is that the entire system undergoes a period of an unbounded number of arbitraryfaults.66The only restriction is that transient faults do not affect the non-volatile memory (and in particular not the algorithm itself), as this would induce a permanent fault.
0.861	[*A*]transient faults[*R*]do not affect[*A*]not the algorithm	context(The most extreme transient fault scenario is only restriction is)	negated: True ,passive: False
0.853	[*A*]only restriction[*R*]is[*A*]that transient faults do not affect in particular not the algorithm	context(The most extreme transient fault scenario is)	negated: False ,passive: True
0.911	[*A*]The most extreme transient fault scenario[*R*]is[*A*]that the entire system undergoes a period of an unbounded number of arbitraryfaults.66The	context()	negated: False ,passive: True
0.882	[*A*]transient faults[*R*]do not affect[*A*]the non-volatile memory[*A*]as this would induce a permanent fault	context(The most extreme transient fault scenario is the entire system undergoes only restriction is)	negated: True ,passive: False
0.853	[*A*]only restriction[*R*]is[*A*]that transient faults do not affect the non-volatile memory ( , as this would induce a permanent fault	context(The most extreme transient fault scenario is the entire system undergoes)	negated: False ,passive: True
0.908	[*A*]the entire system[*R*]undergoes[*A*]a period of an unbounded number of arbitraryfaults.66The	context(The most extreme transient fault scenario is)	negated: False ,passive: True
0.911	[*A*]The most extreme transient fault scenario[*R*]is[*A*]that the entire system undergoes a period of an unbounded number of arbitraryfaults.66The only restriction is that transient faults do not affect the non-volatile memory	context()	negated: False ,passive: True
0.381	[*A*]this[*R*]would induce[*A*]a permanent fault	context()	negated: False ,passive: False
[LINE#980] Algorithms that are capable of re-establishing regular operation after transient faults cease are called self-stabilizing [24].
0.911	[*A*]transient faults cease[*R*]are called[*A*]self-stabilizing	context()	negated: False ,passive: True
0.877	[*A*]Algorithms[*R*]are[*A*]capable of re-establishing regular operation	context()	negated: False ,passive: True
[LINE#981] This requirement is equivalent to stating that, if the system is fault-free, the algorithm converges to a valid state from an arbitrary initial configuration within a bounded time; we refer to this period as stabilization time.
0.853	[*A*]This requirement[*R*]is[*A*]equivalent to stating that, if the system is fault-free, the algorithm converges to a valid state from an arbitrary initial configuration within a bounded time	context(we refer)	negated: False ,passive: True
0.397	[*A*]we[*R*]refer[*A*]to this period as stabilization time	context()	negated: False ,passive: False
0.925	[*A*]the system[*R*]is[*A*]fault-free	context()	negated: False ,passive: True
[LINE#982] Due to this equivalency, self-stabilizing algorithms have the additional advantage of requiring no initialization, i.e., a self-stabilizing clocking system does not need to be booted with any initial synchrony.
0.850	[*A*]self-stabilizing algorithms[*R*]have of requiring[*A*]no initialization	context(self - stabilizing algorithms have)	negated: False ,passive: False
0.933	[*A*]self-stabilizing algorithms[*R*]have[*A*]the additional advantage of requiring no initialization, i.e., a self-stabilizing clocking system does not need to be booted with any initial synchrony	context()	negated: False ,passive: False
[LINE#983] For self-stabilizing algorithms, stabilization time is obviously an important quality measure.
0.925	[*A*]stabilization time[*R*]is[*A*]obviously[*A*]an important quality measure	context()	negated: False ,passive: True
[LINE#984+985]  As the fundamental time unit of the system is d, i.e., the time span it takes to effectively communicate and process any piece of information with certainty,guarantees on the stabilization time are clearly always some multiple of d; the respective prefactor typically is a function of the number of nodes n, the number of sustainable or actual permanent faults, and the clock drift .
0.920	[*A*]the respective prefactor[*R*]is[*A*]a function of the number of nodes n	context()	negated: False ,passive: True
0.876	[*A*]the fundamental time unit of the system[*R*]is[*A*]d	context()	negated: False ,passive: True
[LINE#986] In our context, the stabilization time is not only of relevance to whether waiting for stabilization is bearable in terms of the down-time of the system; it is important to understand that a failure of the synchronization layer will quickly result in incoherencies of operations on higher layers, entailing the threat of data loss or corruption, potentially without any possibility of future recovery.
0.828	[*A*]waiting for stabilization[*R*]is[*A*]bearable	context()	negated: False ,passive: True
0.921	[*A*]a failure of the synchronization layer[*R*]entailing[*A*]the threat of data loss or corruption	context()	negated: False ,passive: False
[LINE#987] Because of the need of maintaining accurate synchronization in the presence of drifting clocks, quite a few clock synchronization algorithms are self-stabilizing.
0.932	[*A*]quite a few clock synchronization algorithms[*R*]are[*A*]self-stabilizing	context()	negated: False ,passive: True
[LINE#988] In fact, conventional clock trees [3] are trivially self-stabilizing-after all, they simply disseminate the signal of a single oscillator throughout a chip.
0.870	[*A*]conventional clock trees[*R*]are[*A*]trivially self-stabilizing-after all	context(they disseminate)	negated: False ,passive: True
0.510	[*A*]they[*R*]disseminate[*A*]the signal of a single oscillator[*A*]throughout a chip	context()	negated: False ,passive: False
[LINE#989] However, they cannot cope with any permanent fault of the clock source or the network distributing the clock.
0.903	[*A*]the network[*R*]distributing[*A*]the clock	context()	negated: False ,passive: False
0.720	[*A*]they[*R*]can not cope[*A*]with any permanent fault of the clock source or the network	context()	negated: True ,passive: False
[LINE#990] Similarly, one could easily make a system comprising several clock sources self-stabilizing, by picking one master clock and letting all other clocks synchronize to it.
0.552	[*A*]one[*R*]could easily make a system comprising several clock sources self - stabilizing , by picking[*A*]one master clock	context(one could easily make)	negated: False ,passive: False
0.664	[*A*]one[*R*]could easily make[*A*]a system comprising several clock sources self - stabilizing ,	context()	negated: False ,passive: False
[LINE#991] Again, this simplistic approach will fail if the master or its outgoing communication channels become faulty. .
0.502	[*A*]the master or its outgoing communication channels[*R*]become[*A*]faulty	context()	negated: False ,passive: True
0.941	[*A*]this simplistic approach[*R*]will fail[*A*]if the master or its outgoing communication channels become faulty[*A*]Again	context()	negated: False ,passive: True
[LINE#992] Permanent faultsSustaining functionality in the presence of permanent faults necessitates redundancy.
[LINE#993] More precisely, it is known that tolerating f worst-case faults (traditionally called Byzantine faults in this context) is impossible if n3f (without cryptographic assumptions) [14,25].77Allowing cryptography would still necessitate n>2f [26,27]; we hence discard this option due to the additional complexity incurred.
0.751	[*A*]the additional complexity[*R*]incurred	context()	negated: False ,passive: False
0.905	[*A*]worst-case faults[*R*]called[*A*]Byzantine faults	context()	negated: False ,passive: True
0.867	[*A*]n3f (without cryptographic assumptions) [14,25[*R*]would necessitate n[*A*]2f [26,27[*A*]still	context()	negated: False ,passive: False
[LINE#994] Hence, natural questions are whether assuming worst-case failures is too demanding and whether the fault model could be relaxed in order to circumvent the lower bound.
0.736	[*A*]the fault model[*R*]could be[*A*]relaxed	context(natural questions are)	negated: False ,passive: True
0.878	[*A*]natural questions[*R*]are[*A*]whether the fault model could be relaxed in order	context()	negated: False ,passive: True
0.832	[*A*]natural questions[*R*]bound[*A*]the lower	context()	negated: False ,passive: True
0.937	[*A*]natural questions[*R*]are[*A*]whether assuming worst - case failures is too demanding the lower bound	context()	negated: False ,passive: True
[LINE#995] Unfortunately, examining the lower bound reveals that it originates in the ability of a faulty node to communicate conflicting information to different receivers.
0.452	[*A*]it[*R*]originates[*A*]in the ability of a faulty node	context()	negated: False ,passive: True
[LINE#996] This behavior can easily emerge from a faulty output stage in a circuit: If an analog voltage level in between the range for a valid "1" and that for a valid "0" is evaluated (for example due to a timing fault, a glitch on a signal line, or a defective driver output) by more than one receiver, some might read a "1" while others read a "0".
0.873	[*A*]If an analog voltage level in between the range for[*R*]is evaluated[*A*]for a valid "0	context(some might read)	negated: False ,passive: True
0.479	[*A*]some[*R*]might read[*A*]a "1[*A*]while others read a "0	context()	negated: False ,passive: False
0.749	[*A*]others[*R*]read[*A*]a "0	context()	negated: False ,passive: False
0.903	[*A*]This behavior[*R*]can easily emerge[*A*]from a faulty output stage[*A*]in a circuit	context()	negated: False ,passive: False
[LINE#997] Note that this is a fundamental problem, as mapping the continuous range of possible voltages to discrete binary values entails that there is always a critical threshold close to which it is impossible to ensure that all receivers observe the same binary value.
[LINE#998] It is still an option to argue about the spatial distribution of (permanent) faults within the system, though, as we discuss in Section 8.
0.452	[*A*]we[*R*]discuss[*A*]in Section 8	context()	negated: False ,passive: False
0.637	[*A*]It[*R*]is[*A*]still[*A*]an option to argue about the spatial distribution of (permanent) faults within the system, though	context()	negated: False ,passive: True
[LINE#999] However, in this article, we consider the worst case, which also motivates the choice of full connectivity88We are aware that this constitutes a serious scalability issue; again we refer to the discussion in Section 8.
0.873	[*A*]the worst case, which also motivates the choice of full connectivity88We[*R*]are[*A*]aware that this constitutes a serious scalability issue	context(we consider we refer)	negated: False ,passive: True
0.399	[*A*]we[*R*]consider[*A*]the worst case, which also motivates the choice of full connectivity88We are aware that this constitutes a serious scalability issue[*A*]in this article	context(we refer)	negated: False ,passive: False
0.388	[*A*]we[*R*]refer[*A*]to the discussion in Section 8	context()	negated: False ,passive: False
0.381	[*A*]this[*R*]constitutes[*A*]a serious scalability issue	context()	negated: False ,passive: False
0.897	[*A*]the worst case[*R*]motivates[*A*]the choice of full connectivity88We	context()	negated: False ,passive: False
[LINE#1000] between the nodes due to a respective impossibility result [26,27].This lower bound entails that, due to their low connectivity, most existing distributed clock generation schemes [11,12,28,29] cannot cope with a reasonable number of worst-case faults.
0.899	[*A*]most existing distributed clock generation schemes[*R*]can not cope[*A*]with a reasonable number of worst-case faults	context(This entails)	negated: True ,passive: False
0.185	[*A*]This[*R*]entails[*A*]that, due to their low connectivity, most existing distributed clock generation schemes [11,12,28,29] cannot cope with a reasonable number of worst-case faults[*A*]between the nodes due to a respective impossibility result	context()	negated: False ,passive: False
[LINE#1001] Nonetheless, dealing with up to f faults in a fully connected system of n3f+1 nodes is-at least from a high-level perspective-still fairly easy, provided that we can rely on synchronization already being established.
0.452	[*A*]we[*R*]can rely[*A*]on synchronization	context()	negated: False ,passive: False
0.281	[*A*]dealing with[*R*]is[*A*]at least from a high-level perspective-still fairly easy[*A*]provided that we can rely on synchronization	context()	negated: False ,passive: True
0.818	[*A*]synchronization[*R*]being established[*A*]already	context()	negated: False ,passive: True
[LINE#1002+1003]  To illustrate this, consider the simple state machine of a node given in Fig.the figure, the node's states are depicted in circles and the feasible state transitions are indicated by arrows.
0.919	[*A*]the feasible state transitions[*R*]are indicated[*A*]by arrows	context()	negated: False ,passive: True
0.919	[*A*]the node 's states[*R*]are depicted[*A*]in circles	context()	negated: False ,passive: True
0.918	[*A*]a node[*R*]given[*A*]in Fig.the figure	context()	negated: False ,passive: True
[LINE#1004] A node switches, for example, from state ready to state propose if the condition next to the arrow is satisfied.
0.579	[*A*]A node[*R*]switches ready to state propose	context(A node switches ready)	negated: False ,passive: False
0.875	[*A*]A node[*R*]switches ready[*A*]from state	context()	negated: False ,passive: False
0.865	[*A*]the condition next to the arrow[*R*]is[*A*]satisfied	context()	negated: False ,passive: True
[LINE#1005+1006]  In this example, this means that either 32d time has passed on its local clock since it switched to state ready or its incoming channels (including its loop-back channel)other nodes in state propose since it switched to state ready.
0.637	[*A*]its incoming channels (including its loop-back channel[*R*]propose[*A*]since it switched to state ready	context()	negated: False ,passive: False
0.195	[*A*]it[*R*]switched	context()	negated: False ,passive: False
0.851	[*A*]32d time[*R*]has passed[*A*]since it switched to state ready or its incoming channels (including its loop-back channel)other nodes in state propose	context(this means)	negated: False ,passive: True
0.212	[*A*]this[*R*]means[*A*]that either 32d time has passed on its local clock since it switched to state ready or its incoming channels (including its loop-back channel)other nodes in state propose[*A*]In this example	context()	negated: False ,passive: False
[LINE#1007] This behavior is realized by each node i[1..
0.903	[*A*]This behavior[*R*]is realized[*A*]by each node	context()	negated: False ,passive: True
[LINE#1008+1009+1010]  having (binary) memory flags proposei,j for each node : Node i's flag proposei,j is set to 1 at a timet iff Si,j(t)=propose and the flag was in state 0 before.
0.605	[*A*]j[*R*]is set[*A*]to 1	context()	negated: False ,passive: True
0.760	[*A*]Node i[*R*]'s[*A*]flag proposei	context()	negated: False ,passive: True
0.927	[*A*]binary) memory flags[*R*]j[*A*]for each node	context()	negated: False ,passive: False
0.925	[*A*]the flag[*R*]was[*A*]in state 0[*A*]before	context()	negated: False ,passive: True
[LINE#1011] i's state transition to ready (in the figure indicated by the rectangular box on the respective arrow).
0.903	[*A*]the figure[*R*]indicated[*A*]by the rectangular box on the respective arrow	context()	negated: False ,passive: True
[LINE#1012] Deciding whether the transition condition is satisfied at time t thus boils down to checking whether the timeout condition is satisfied or at least f+1 of the propose memory flags are in state 1.Now assume that each node runs a copy of this state machine, and at least n-f non-faulty nodes enter state increase during some time window [t,t+2d).
0.938	[*A*]at least n-f non-faulty nodes[*R*]enter[*A*]state increase[*A*]during some time window	context()	negated: False ,passive: False
0.908	[*A*]each node[*R*]runs[*A*]a copy of this state machine	context()	negated: False ,passive: False
0.897	[*A*]the timeout condition[*R*]are[*A*]in state 1.Now assume	context()	negated: False ,passive: True
[LINE#1013] As local clocks run at speeds between 1 and , all nodes will switch to state ready during [t+3d,t+2d+3d).
0.878	[*A*]all nodes[*R*]will switch to state[*A*]ready[*A*]during [t+3d	context(all nodes will switch)	negated: False ,passive: False
0.928	[*A*]all nodes[*R*]will switch[*A*]to state ready during [t+3d[*A*]As local clocks run at speeds between 1	context()	negated: False ,passive: False
0.784	[*A*]local clocks[*R*]run	context()	negated: False ,passive: False
[LINE#1014] Hence, at the time when a node switches to ready, the delayed state information on the channels will not show non-faulty nodes in state propose any more.
0.754	[*A*]non-faulty nodes in state[*R*]propose[*A*]any more	context(the delayed state information on the channels will not show)	negated: False ,passive: False
0.954	[*A*]the delayed state information on the channels[*R*]will not show[*A*]non-faulty nodes in state propose any more[*A*]at the time	context()	negated: True ,passive: False
0.943	[*A*]a node[*R*]switches[*A*]to ready[*A*]the time	context()	negated: False ,passive: False
[LINE#1015] Therefore, no non-faulty node will switch to propose again due to memorizing f+1 nodes (at least one of which must be non-faulty) in state propose before the first non-faulty node switches to propose.
0.888	[*A*]no non-faulty node[*R*]will switch to propose[*A*]again[*A*]due to memorizing f+1 nodes	context(no non-faulty node will switch)	negated: False ,passive: False
0.927	[*A*]no non-faulty node[*R*]will switch[*A*]to propose again due to memorizing f+1 nodes (at least one of which must be non-faulty) in state propose before the first non-faulty node switches	context()	negated: False ,passive: False
0.785	[*A*]the first non-faulty node switches[*R*]to propose	context()	negated: False ,passive: False
0.383	[*A*]at least one of which[*R*]must be[*A*]non-faulty	context()	negated: False ,passive: True
[LINE#1016]  Thus, the latter must happen because 32d local time passed on a local clock, which takes at least until time t+3d+3d>.
0.897	[*A*]a local clock[*R*]takes[*A*]at least until time	context()	negated: False ,passive: True
0.679	[*A*]the latter[*R*]must happen[*A*]because 32d local time passed on a local clock	context()	negated: False ,passive: True
[LINE#1017] By this time, all nodes will have switched to ready.
0.943	[*A*]all nodes[*R*]will have switched[*A*]to ready[*A*]By this time	context()	negated: False ,passive: False
[LINE#1018] This implies that at the time when the first node switches to increase again (which eventually happens because all n-f non-faulty nodes switch to propose), all nodes will already have switched to ready.
0.763	[*A*]all n-f non-faulty nodes[*R*]switch to propose to propose	context(all n - f non-faulty nodes switch)	negated: False ,passive: False
0.837	[*A*]all n-f non-faulty nodes[*R*]switch[*A*]to propose	context()	negated: False ,passive: False
0.754	[*A*]all nodes[*R*]will have switched[*A*]to ready[*A*]already	context(This implies)	negated: False ,passive: False
0.224	[*A*]This[*R*]implies[*A*]that at the time when the first node switches to increase again (which eventually happens because all n-f non-faulty nodes switch to propose), all nodes will already have switched to ready	context()	negated: False ,passive: False
0.799	[*A*]the first node switches[*R*]to increase[*A*]again	context()	negated: False ,passive: True
[LINE#1019] Given that n3f+1, we have that n-2ff+1, i.e., if at some non-faulty node n-f channels show state propose, any node will observe f+1 channels in this state (though due to delayed communication maybe not at exactly the same instance in time).
0.162	[*A*]we[*R*]have	context()	negated: False ,passive: False
0.937	[*A*]n-f channels[*R*]show[*A*]state propose	context()	negated: False ,passive: False
[LINE#1020] This implies that at most d time after the first node switched to increase again, all non-faulty nodes have switched to propose.
0.707	[*A*]all non-faulty nodes[*R*]have switched to propose	context(This implies all non-faulty nodes have switched)	negated: False ,passive: False
0.924	[*A*]all non-faulty nodes[*R*]have switched[*A*]at most d time	context(This implies)	negated: False ,passive: False
0.224	[*A*]This[*R*]implies[*A*]that at most d time after the first node switched to increase again, all non-faulty nodes have switched to propose	context()	negated: False ,passive: False
0.754	[*A*]the first node[*R*]to increase[*A*]again	context()	negated: False ,passive: True
0.783	[*A*]the first node[*R*]switched[*A*]to increase again	context()	negated: False ,passive: False
[LINE#1021] Another d time later, all n-f non-faulty nodes will have become aware of this and have switched to increase, i.e., within a time window of 2d.
0.718	[*A*]Another d time[*R*]to increase	context()	negated: False ,passive: False
0.961	[*A*]all n - f non-faulty nodes[*R*]will have become[*A*]aware of this[*A*]Another d time later	context()	negated: False ,passive: True
[LINE#1022+1023]  Repeating this reasoning inductively and assuming that the nodes increase their logical clocks (that initially are 0) by 1whenever they switch to increase, well-synchronized logical clocks are obtained: The maximum difference in time between any two correct nodes performing their kth clock tick, the skew, is at most 2d for the above algorithm.
0.077	[*A*]that[*R*]are[*A*]0[*A*]initially	context()	negated: False ,passive: True
0.860	[*A*]any two correct nodes[*R*]performing[*A*]their kth clock tick	context()	negated: False ,passive: False
[LINE#1024] A variation of this simple technique [30] is known for long and a closely related approach called DARTS has been implemented in hardware [31,32].
0.921	[*A*]A variation of this simple technique[*R*]has been implemented[*A*]in hardware	context()	negated: False ,passive: True
0.931	[*A*]a closely related approach[*R*]called[*A*]DARTS	context()	negated: False ,passive: True
0.921	[*A*]A variation of this simple technique[*R*]is known[*A*]for a closely related approach	context()	negated: False ,passive: True
0.921	[*A*]A variation of this simple technique[*R*]has been implemented[*A*]in hardware [ 31,32	context()	negated: False ,passive: True
0.803	[*A*]A variation of this simple technique[*R*]is known[*A*]for long	context()	negated: False ,passive: True
[LINE#1025] However, all these algorithms are not self-stabilizing.
0.911	[*A*]all these algorithms[*R*]are not[*A*]self-stabilizing	context()	negated: True ,passive: True
[LINE#1026+1027]  In fact, even if clocks would not drift, the delay d was arbitrarily small, and there was only a single faulty node(i.e., even if we allow for f>1, only one node is actually faulty), they still would not stabilize.
0.396	[*A*]they[*R*]would not stabilize[*A*]still	context()	negated: True ,passive: False
0.828	[*A*]the delay d[*R*]was[*A*]arbitrarily small	context()	negated: False ,passive: True
[LINE#1028]  To see this for the algorithm given in Fig. 1, first consider the following execution with n=3f+1, part of which is depicted in Fig..
0.918	[*A*]the algorithm[*R*]given[*A*]in Fig	context()	negated: False ,passive: True
[LINE#1029] The correct nodes are split evenly, into three subsets Ai, i{1,2,3}, of size f. Set A1 initially is in state ready, with all memory flags corresponding to nodes in A3 in state 1 and all other flags in state 0.
0.939	[*A*]Set A1[*R*]is ready[*A*]with all memory flags corresponding to all other flags in state 0[*A*]initially	context()	negated: False ,passive: True
0.911	[*A*]all memory flags[*R*]corresponding[*A*]to all other flags in state 0	context()	negated: False ,passive: True
0.868	[*A*]The correct nodes[*R*]are split evenly[*A*]into three subsets	context(Set A1 is ready)	negated: False ,passive: True
0.949	[*A*]Set A1[*R*]is ready[*A*]with all memory flags corresponding to nodes in A3 in state 1[*A*]initially	context()	negated: False ,passive: True
0.925	[*A*]all memory flags[*R*]corresponding[*A*]to nodes in A3[*A*]in state 1	context()	negated: False ,passive: True
[LINE#1030] The nodes in A2 and A3 are in state increase, with the timers of nodes in A2 having progressed halfway towards expiring and the timers in A3 just started (i.e., these nodes just left propose), and their propose signals are memorized by nodes in A1.
0.939	[*A*]The nodes in A3[*R*]are[*A*]in state increase	context()	negated: False ,passive: True
0.700	[*A*]their propose signals[*R*]are memorized[*A*]by nodes in A1	context()	negated: False ,passive: True
0.640	[*A*]these nodes[*R*]left propose propose	context(these nodes left)	negated: False ,passive: False
0.739	[*A*]these nodes[*R*]left[*A*]propose	context()	negated: False ,passive: False
0.836	[*A*]the timers of the timers in A3[*R*]started	context()	negated: False ,passive: False
0.831	[*A*]nodes in A2[*R*]having progressed halfway[*A*]towards expiring	context()	negated: False ,passive: True
0.939	[*A*]The nodes in A2[*R*]are[*A*]in state increase	context()	negated: False ,passive: True
[LINE#1031] Just when the nodes in A2 are about to switch to ready, the faulty node sends propose signals to the nodes in A1, causing them to switch to propose.
0.962	[*A*]the faulty node[*R*]sends[*A*]propose signals to the nodes in A1[*A*]causing them to switch to propose[*A*]Just when the nodes in A2 are about to switch to ready	context()	negated: False ,passive: False
0.820	[*A*]the nodes in A2[*R*]to switch[*A*]to ready	context()	negated: False ,passive: False
0.844	[*A*]the nodes in A2[*R*]are[*A*]about to switch to ready	context()	negated: False ,passive: True
[LINE#1032+1033]  They will send propose signals, once receiving them memorize 2f+1=n-f nodes in state propose, and thus proceed to state increase.
0.438	[*A*]They[*R*]will send propose signals receiving[*A*]them[*A*]once	context(They will send)	negated: False ,passive: False
0.401	[*A*]They[*R*]will send[*A*]propose signals[*A*]once receiving them[*A*]thus proceed to state increase	context()	negated: False ,passive: False
0.438	[*A*]They[*R*]will send propose signals receiving[*A*]them[*A*]memorize[*A*]once	context(They will send)	negated: False ,passive: False
0.518	[*A*]They[*R*]will send[*A*]propose signals[*A*]once receiving them memorize 2f+1=n - f nodes in state propose	context()	negated: False ,passive: False
0.801	[*A*]2f+1=n - f nodes in state[*R*]propose	context()	negated: False ,passive: False
[LINE#1034] However, the nodes in A2 will still observe the propose signals of the nodes in A1 after resetting their memory flags upon switching to ready.
0.921	[*A*]the nodes in A2[*R*]will observe[*A*]the propose signals of the nodes in A1[*A*]after resetting their memory flags upon switching to ready[*A*]still	context()	negated: False ,passive: False
[LINE#1035] Thus, we end up in the same situation, except that Ai (indices modulo 3) takes the role of Ai-1.
0.945	[*A*]Ai (indices modulo 3[*R*]takes[*A*]the role of Ai-1	context()	negated: False ,passive: False
0.367	[*A*]we[*R*]end up[*A*]in the same situation[*A*]except that Ai (indices modulo 3) takes the role of Ai-1	context()	negated: False ,passive: True
[LINE#1036] Repetition yields an execution that never stabilizes and has 3 sets of grossly desynchronized nodes that are not faulty.
0.908	[*A*]an execution[*R*]has[*A*]3 sets of grossly desynchronized nodes	context(Repetition yields)	negated: False ,passive: False
0.871	[*A*]Repetition[*R*]yields[*A*]an execution has 3 sets of grossly desynchronized nodes	context()	negated: False ,passive: False
0.754	[*A*]grossly desynchronized nodes[*R*]are not[*A*]faulty	context()	negated: True ,passive: True
0.698	[*A*]an execution[*R*]never stabilizes	context()	negated: True ,passive: False
0.755	[*A*]Repetition[*R*]yields[*A*]an execution that never stabilizes	context()	negated: False ,passive: False
[LINE#1037] This execution can be generalized to n=kf+1 for integers k3: we split the correct nodes in k sets of size f and make them proceed equidistantly spread in time through the cycle.
0.411	[*A*]them[*R*]equidistantly spread[*A*]in time	context()	negated: False ,passive: True
0.857	[*A*]This execution[*R*]can be generalized[*A*]for integers	context(we split)	negated: False ,passive: True
0.457	[*A*]we[*R*]split[*A*]the correct nodes[*A*]in k sets of size	context()	negated: False ,passive: False
[LINE#1038] The difference is that now more than one group will linger in states ready or propose upon arrival of the next; the crucial point is that the single faulty node retains control over when groups proceed to state increase.
0.900	[*A*]the single faulty node[*R*]retains[*A*]control over when groups proceed to state increase	context(the crucial point is)	negated: False ,passive: False
0.942	[*A*]more than one group[*R*]will linger[*A*]in states ready[*A*]now	context(The difference is the crucial point is)	negated: False ,passive: True
0.853	[*A*]The difference[*R*]is[*A*]that now more than one group will linger in states ready or propose upon arrival of the next	context(the crucial point is)	negated: False ,passive: True
0.865	[*A*]the crucial point[*R*]is[*A*]that the single faulty node retains control over when groups proceed to state increase	context()	negated: False ,passive: True
0.905	[*A*]more than one group[*R*]propose[*A*]upon arrival of the next	context()	negated: False ,passive: False
0.894	[*A*]groups[*R*]proceed[*A*]to state increase	context()	negated: False ,passive: False
[LINE#1039] kf+3 require more involved constructions; it should be intuitive, though, that with 2 actually failing nodes the above construction can be modified to operate with one or two of the sets containing f+1 nodes. .
0.718	[*A*]the above construction[*R*]to operate	context()	negated: False ,passive: False
0.751	[*A*]the above construction[*R*]can be modified	context()	negated: False ,passive: False
0.516	[*A*]kf+3[*R*]require[*A*]more involved constructions; it should be intuitive, though, that with 2 actually failing nodes the above construction can be modified to operate with one or two of the sets	context(it should be)	negated: False ,passive: False
0.183	[*A*]it[*R*]should be[*A*]intuitive[*A*]though	context()	negated: False ,passive: True
0.903	[*A*]the sets[*R*]containing[*A*]f+1 nodes	context()	negated: False ,passive: False
[LINE#1040] Combining transient and permanent faultsCombining self-stabilization and resilience to permanent faults results in much more robust systems.
[LINE#1041] Both properties synergize in that, as long as at all times there is some sufficiently large set (not necessarily the same!) of nodes that is non-faulty, an arbitrary number of transient faults is transparently masked, i.e., the system remains operational even though over time each individual component may repeatedly undergo transient failures and recover from them.
0.862	[*A*]the system[*R*]remains[*A*]operational[*A*]even though over time each individual component may recover from them	context()	negated: False ,passive: True
0.756	[*A*]an arbitrary number of transient faults[*R*]is transparently masked	context(the system remains)	negated: False ,passive: False
0.695	[*A*]Both properties[*R*]synergize[*A*]in that[*A*]as long as at all times there is some sufficiently large set ( not necessarily the same ! ) of nodes	context(the system remains)	negated: False ,passive: False
0.920	[*A*]the system[*R*]remains[*A*]operational[*A*]even though over time each individual component may repeatedly undergo transient failures	context()	negated: False ,passive: True
0.914	[*A*]some sufficiently large set ( not necessarily the same ! ) of nodes[*R*]is[*A*]non-faulty	context()	negated: False ,passive: True
[LINE#1042] This drastically increases the mean time until overall system failure: In a system that is not resilient to permanent faults, any fault will result in an immediate breakdown of guaranteed properties, whereas a system that is not self-stabilizing will fail (and might not recover without an external reboot) once the sum of faults exceeds one third of the nodes.99One could compromise by guaranteeing that nodes recover in bounded time, provided that the number of faults is never overwhelming.
0.887	[*A*]a system[*R*]is not[*A*]self-stabilizing	context()	negated: True ,passive: True
0.745	[*A*]one third of the nodes.99One[*R*]could compromise	context(the sum of faults exceeds)	negated: False ,passive: False
0.841	[*A*]the sum of faults[*R*]exceeds[*A*]one third of the nodes.99One could compromise by guaranteeing that nodes recover in bounded time, provided that the number of faults is never overwhelming	context()	negated: False ,passive: False
0.799	[*A*]the number of faults[*R*]is never[*A*]overwhelming	context()	negated: True ,passive: True
0.286	[*A*]This[*R*]increases[*A*]the mean time	context(any fault will result)	negated: False ,passive: False
0.882	[*A*]any fault[*R*]will result[*A*]in an immediate breakdown of guaranteed properties[*A*]whereas a system that is not self-stabilizing will fail (and might not recover without an external reboot) once the sum of faults exceeds one third of the nodes.99One could compromise by guaranteeing that nodes recover in bounded time, provided that the number of faults is never overwhelming[*A*]In a system	context()	negated: False ,passive: True
0.805	[*A*]a system that is not self-stabilizing[*R*]might not recover	context()	negated: True ,passive: False
0.887	[*A*]a system[*R*]is not[*A*]resilient to permanent faults	context()	negated: True ,passive: True
0.830	[*A*]a system that is not self-stabilizing[*R*]will fail	context()	negated: False ,passive: False
[LINE#1043] In fact, the algorithm presented in this article has the property that in this case nodes will recover faster and deterministically (in contrast to the slower, probabilistic stabilization from arbitrary system states).
0.960	[*A*]nodes[*R*]will recover[*A*]deterministically ( in contrast to the slower , probabilistic stabilization from arbitrary system states[*A*]in this case	context()	negated: False ,passive: True
0.914	[*A*]the algorithm presented in this article[*R*]has[*A*]the property that in this case nodes will recover deterministically ( in contrast to the slower , probabilistic stabilization from arbitrary system states	context()	negated: False ,passive: False
0.903	[*A*]the algorithm[*R*]presented[*A*]in this article	context()	negated: False ,passive: True
0.713	[*A*]nodes[*R*]will recover faster	context()	negated: False ,passive: False
0.773	[*A*]the algorithm[*R*]presented[*A*]in this article[*A*]that in this case nodes will recover faster	context()	negated: False ,passive: True
[LINE#1044] However, sacrificing stabilization from arbitrary states will not reduce the complexity of the algorithm significantly, and theory strongly indicates that the respective gain is limited to a constant factor in general.
0.888	[*A*]the respective gain[*R*]is limited[*A*]to a constant factor in general	context(theory strongly indicates)	negated: False ,passive: True
0.792	[*A*]theory[*R*]strongly indicates[*A*]that the respective gain is limited to a constant factor in general	context()	negated: False ,passive: False
0.926	[*A*]sacrificing stabilization from arbitrary states[*R*]will not reduce[*A*]the complexity of the algorithm significantly	context()	negated: True ,passive: False
[LINE#1045] There is a considerable body of work on distributed synchronization algorithms that are self-stabilizing as well as resilient to permanent faults.
0.897	[*A*]distributed synchronization algorithms[*R*]are[*A*]resilient to permanent faults	context()	negated: False ,passive: True
0.897	[*A*]distributed synchronization algorithms[*R*]are[*A*]self - stabilizing	context()	negated: False ,passive: True
[LINE#1046] However, until recently, there has been no solution worth considering for hardware implementation.
[LINE#1047+1048+1049]  Known algorithms exhibit a prohibitively large communication complexity (i.e., nodes send (n) bits over each channel in constant time)[33,34], incur an exponential stabilization time [35], require exponentially small clock drifts [36], or require much stronger assumptions on the system's behavior [37].
0.999	[*A*]nodes[*R*]send[*A*]3334	context()	negated: False ,passive: False
[LINE#1050] Recently, we proposed an approach that does not suffer from such drawbacks [13,38,39], whose implementation is the subject of this work. .
0.385	[*A*]whose implementation[*R*]is the subject of[*A*]this work	context()	negated: False ,passive: False
0.954	[*A*]an approach that does not suffer from such drawbacks[*R*]is[*A*]the subject of this work	context()	negated: False ,passive: True
0.463	[*A*]we[*R*]proposed[*A*]an approach that does not suffer from such drawbacks [13,38,39], whose implementation is the subject of this work[*A*]Recently	context()	negated: False ,passive: False
[LINE#1051] In our specific setting, minimizing the potential for metastability is particularly demanding.
0.868	[*A*]minimizing the potential for metastability[*R*]is demanding[*A*]In our specific setting	context()	negated: False ,passive: True
[LINE#1052] Metastability results from violating a stateful circuit's input timing constraints, e.g., by changing the data input of a flip-flop at the time of the clock transition.
[LINE#1053] While this can be safely avoided during normal operation, a faulty node might exhibit arbitrary timing and hence cause such a violation.
0.381	[*A*]this[*R*]can hence cause[*A*]such a violation	context()	negated: False ,passive: False
0.911	[*A*]a faulty node[*R*]might exhibit[*A*]arbitrary timing	context()	negated: False ,passive: False
0.381	[*A*]this[*R*]can be safely avoided[*A*]during normal operation	context()	negated: False ,passive: True
[LINE#1054] As this can never be prevented in the first place if worst-case faults are considered, it is mandatory to guard the channels against propagating metastability, e.g. by using synchronizers.
0.381	[*A*]this[*R*]can never be prevented[*A*]in the first place	context()	negated: True ,passive: True
[LINE#1055] In order to minimize the required length of synchronizer chains, decreasing latency and area consumption (the latter also on higher layers of the system), however, it is beneficial to avoid the potential for upsets by construction wherever possible.
[LINE#1056] Apart from the (unavoidable) threat originating from faulty nodes, safely preventing timing violations is hindered by the lack of a common time base during the stabilization phase after an excessive number of transient faults.
0.926	[*A*]the (unavoidable) threat[*R*]originating[*A*]from faulty nodes	context()	negated: False ,passive: True
[LINE#1057] It has been shown that it is impossible to guarantee with certainty that no metastable upsets occur if the system is in an arbitrary initial state, even if all nodes adhere to the protocol [40].
0.925	[*A*]the system[*R*]is[*A*]in an arbitrary initial state	context()	negated: False ,passive: True
[LINE#1058] Careful design is thus required in order to minimize the probability of upsets during stabilization, in particular since such upsets might obstruct the stabilization process.
0.903	[*A*]such upsets[*R*]might obstruct[*A*]the stabilization process	context()	negated: False ,passive: False
0.859	[*A*]Careful design[*R*]is required[*A*]in order	context()	negated: False ,passive: True
[LINE#1059] Once the system stabilized, i.e., the non-faulty nodes are synchronized, the algorithm can use this synchronization to structure communication in a way that entirely avoids metastable upsets caused by non-faulty nodes.
0.887	[*A*]a way[*R*]entirely avoids[*A*]metastable upsets caused by non-faulty nodes	context()	negated: False ,passive: False
0.751	[*A*]the non-faulty nodes[*R*]are synchronized	context()	negated: False ,passive: False
0.903	[*A*]metastable upsets[*R*]caused[*A*]by non-faulty nodes	context()	negated: False ,passive: True
0.732	[*A*]the system[*R*]stabilized	context()	negated: False ,passive: False
[LINE#1060] Thus, in the absence of faults, we require that the system operates metastability-free.
0.678	[*A*]the system[*R*]operates	context(we require)	negated: False ,passive: False
0.293	[*A*]we[*R*]require[*A*]that the system operates metastability-free[*A*]in the absence of faults	context()	negated: False ,passive: False
[LINE#1061+1062]  Note that even this seemingly simple task is not trivial, as one cannot employ the classical wait-for-all paradigm: Doing so would imply that just a single non-responsive node would cause the entire system to deadlock.
0.905	[*A*]just a single non-responsive node[*R*]would cause[*A*]the entire system	context(Doing so would imply)	negated: False ,passive: False
0.372	[*A*]Doing so[*R*]would imply[*A*]that just a single non-responsive node would cause the entire system to deadlock	context()	negated: False ,passive: False
0.320	[*A*]one[*R*]can not employ	context()	negated: True ,passive: False
[LINE#1063] Therefore, when depending on other nodes in the decision to take a state transition, it is necessary to wait for at most n-f signals.
[LINE#1064] Safely reading signals thus cannot rely on handshaking, but must be based on suitable monotonicity and/or timing conditions (guaranteed by the use of memory flags and local clocks, for example).
0.897	[*A*]Safely reading signals[*R*]can not rely[*A*]on handshaking	context()	negated: True ,passive: False
[LINE#1065+1066]  The bounded-delay "interlocking condition" used in DARTS [32] and the simple algorithm in Fig.1 are showcases for such techniques. .
0.944	[*A*]the simple algorithm in Fig.1[*R*]are[*A*]showcases for such techniques	context()	negated: False ,passive: True
0.954	[*A*]The bounded - delay " interlocking condition " used in DARTS [ 32 ][*R*]are[*A*]showcases for such techniques	context()	negated: False ,passive: True
0.939	[*A*]The bounded - delay " interlocking condition[*R*]used[*A*]in DARTS [ 32	context()	negated: False ,passive: True
[LINE#1067] Operating frequency vs. clock precisionIn order to be practical, the logical clocks need to run at a frequency in the GHz range.
0.925	[*A*]the logical clocks[*R*]need[*A*]to run at a frequency in the GHz range	context()	negated: False ,passive: False
[LINE#1068] While one could obviously utilize frequency multiplication to achieve this goal, this is not straightforward to build in the self-stabilizing context.
0.446	[*A*]one[*R*]could utilize frequency multiplication to achieve[*A*]this goal	context(one could utilize)	negated: False ,passive: False
0.446	[*A*]one[*R*]could utilize[*A*]frequency multiplication[*A*]to achieve this goal	context()	negated: False ,passive: False
0.381	[*A*]this[*R*]is not[*A*]straightforward to build in the self-stabilizing context	context()	negated: True ,passive: True
[LINE#1069] After all, clock multipliers involve complex devices like phase-locked loops and are hence not obviously self-stabilizing.
0.903	[*A*]clock multipliers[*R*]involve[*A*]complex devices like phase - locked loops	context()	negated: False ,passive: True
[LINE#1070] Moreover, for a fixed guaranteed skew (of say 2d), naive frequency amplification also increases the logical clock imprecision maxi,j[1..
0.897	[*A*]naive frequency amplification[*R*]increases[*A*]the logical clock imprecision maxi	context()	negated: False ,passive: False
[LINE#1071] n],t0{Li(t)-Lj(t)} by the scaling factor, which may adversely affect certain services.
0.897	[*A*]the scaling factor[*R*]may adversely affect[*A*]certain services	context()	negated: False ,passive: False
[LINE#1072] For example, the size of the FIFO buffers used for inter-domain communication in [10] depends on the clock imprecision and must hence be adapted accordingly.
0.764	[*A*]the size of the FIFO[*R*]must be adapted accordingly	context()	negated: False ,passive: False
0.940	[*A*]the size of the FIFO buffers[*R*]depends[*A*]on the clock imprecision	context()	negated: False ,passive: False
0.933	[*A*]the FIFO buffers[*R*]used[*A*]for inter-domain communication in [ 10	context()	negated: False ,passive: True
[LINE#1073] On the other hand, by dividing frequencies, it is clearly possible to guarantee that maxi,j[1..n],t0{Li(t)-Lj(t)}=1.
[LINE#1074] Therefore, it is an important design goal to minimize clock imprecision while at the same time maximizing the frequency at which clocks run.
0.949	[*A*]the frequency[*R*]run[*A*]clocks	context()	negated: False ,passive: True
0.522	[*A*]it[*R*]is[*A*]an important design goal to minimize clock imprecision[*A*]at the same time	context()	negated: False ,passive: True
[LINE#1075] Naturally, this becomes much more involved due to the design goals already presented. .
0.845	[*A*]the design goals[*R*]presented[*A*]already	context()	negated: False ,passive: True
0.342	[*A*]this[*R*]involved[*A*]due to the design goals	context()	negated: False ,passive: True
0.381	[*A*]this[*R*]becomes[*A*]much more involved due to the design goals	context()	negated: False ,passive: True
[LINE#1076] Being able to meet all the above design goals is meaningless if one cannot control the amount of resources devoted to the task of clock generation.
0.894	[*A*]resources[*R*]devoted[*A*]to the task of clock generation	context()	negated: False ,passive: True
0.616	[*A*]one[*R*]can not control[*A*]the amount of resources	context()	negated: True ,passive: False
0.930	[*A*]Being able to meet all the above design goals[*R*]is[*A*]meaningless[*A*]if one cannot control the amount of resources	context()	negated: False ,passive: True
[LINE#1077]  Pivotal issues are the following:Area consumption:.
0.903	[*A*]Pivotal issues[*R*]are[*A*]the following:Area co	context()	negated: False ,passive: True
[LINE#1078] The chip area used by the components of the synchronization algorithm decomposes into the area consumed by the nodes and their interconnections.
0.835	[*A*]the area[*R*]consumed[*A*]by their interconnections	context()	negated: False ,passive: True
0.903	[*A*]the area[*R*]consumed[*A*]by the nodes	context()	negated: False ,passive: True
0.957	[*A*]The chip area used by the components of the synchronization algorithm[*R*]decomposes[*A*]into the area	context()	negated: False ,passive: True
0.911	[*A*]The chip area[*R*]used[*A*]by the components of the synchronization algorithm	context()	negated: False ,passive: True
[LINE#1079] The former can be captured by the gate complexity, i.e., the number of (constant fan-in) gates required to perform the algorithm's computations.
0.894	[*A*]gates[*R*]required[*A*]to perform the algorithm's computations	context()	negated: False ,passive: True
0.568	[*A*]The former[*R*]can be captured[*A*]by the gate complexity	context()	negated: False ,passive: True
[LINE#1080] The latter significantly depends on the chip layout, which is highly application-dependent and hence outside our scope of control.
0.920	[*A*]the chip layout[*R*]is[*A*]highly application-dependent	context()	negated: False ,passive: True
0.568	[*A*]The latter[*R*]significantly depends[*A*]on the chip layout	context()	negated: False ,passive: False
[LINE#1081]  It is clear, however, that the number of channels and their bandwidth play a crucial role.Communication complexity:.
[LINE#1082] Apart from whether two nodes are connected or not, it is of interest how many wires are required.
0.699	[*A*]how many wires[*R*]are required	context(it is)	negated: False ,passive: False
0.457	[*A*]it[*R*]is[*A*]of interest	context()	negated: False ,passive: True
0.732	[*A*]two nodes[*R*]are connected	context()	negated: False ,passive: False
[LINE#1083] This is well-represented by the bit complexity of an algorithm, i.e., the number of bits it exchanges per time unit between communication partners.
0.567	[*A*]This[*R*]is[*A*]well-represented by the bit complexity of an algorithm	context()	negated: False ,passive: True
[LINE#1084] Note that while the number of wires can be reduced by means of time division, this will require additional memory and computational resources on the receiver's side and increase the communication delay.
0.919	[*A*]the number of wires[*R*]can be reduced[*A*]by means of time division	context()	negated: False ,passive: True
[LINE#1085] In any case, it is highly desirable to devise algorithms of (small) constant bit complexity.
[LINE#1086] Moreover, broadcasting the same information to all nodes instead of different information to different receivers is to be preferred, as it allows us to use communication buses.Stabilization time: For reasons stated earlier, we would like to minimize the stabilization time.
0.397	[*A*]us[*R*]to use[*A*]communication buses.Stabilization time	context(it allows)	negated: False ,passive: False
0.365	[*A*]it[*R*]allows[*A*]us to use communication buses.Stabilization time: For reasons stated earlier, we would like to minimize the stabilization time	context()	negated: False ,passive: False
0.411	[*A*]we[*R*]to minimize[*A*]the stabilization time	context()	negated: False ,passive: False
0.972	[*A*]broadcasting the same information to all nodes instead of different information to different receivers[*R*]is[*A*]to be preferred, as it allows us to use communication buses.Stabilization time: For reasons stated earlier, we would like to minimize the stabilization time	context()	negated: False ,passive: True
0.749	[*A*]reasons[*R*]stated[*A*]earlier	context()	negated: False ,passive: True
[LINE#1087]  In particular, it is not good enough to know that an algorithm eventually stabilizes, as the required time might be well above what makes the algorithm self-stabilizing in any practical sense.Resilience:.
0.943	[*A*]the required time[*R*]might be well[*A*]above what makes the algorithm self-stabilizing in any practical sense.R	context()	negated: False ,passive: True
0.231	[*A*]it[*R*]is not[*A*]good enough to know that an algorithm eventually stabilizes	context()	negated: True ,passive: True
[LINE#1088] The number f of faults that can be concurrently sustained without losing synchronization or the capability to stabilize should grow with system size, as otherwise a larger system will suffer from more frequent outages.
0.756	[*A*]The number f of faults[*R*]should grow	context()	negated: False ,passive: False
0.677	[*A*]faults[*R*]can be concurrently sustained	context()	negated: False ,passive: False
[LINE#1089] Note that while we must accept that stabilization is a random process (due to the unavoidable probability of metastable upsets), we demand that a system that is stable will always remain so as long as there are not too many faults (including upsets).
0.896	[*A*]stabilization[*R*]is[*A*]a random process	context(we must accept)	negated: False ,passive: True
0.271	[*A*]we[*R*]must accept[*A*]that stabilization is a random process (due to the unavoidable probability of metastable upsets	context()	negated: False ,passive: False
0.786	[*A*]a system[*R*]is[*A*]stable	context()	negated: False ,passive: True
[LINE#1090]  As mentioned earlier, a lower bound shows that always f<n/3, giving a precise meaning to.
0.643	[*A*]that always f<n/3[*R*]giving[*A*]a precise meaning[*A*]to	context()	negated: False ,passive: False
0.283	[*A*]lower[*R*]shows	context()	negated: False ,passive: False
[LINE#1091] As the maximal delay d accounts both for the delay incurred by communication as well as computation, it is vital to minimize both.
0.903	[*A*]the delay[*R*]incurred[*A*]by computation	context()	negated: False ,passive: True
0.903	[*A*]the delay[*R*]incurred[*A*]by communication	context()	negated: False ,passive: True
0.897	[*A*]the maximal delay[*R*]accounts[*A*]both for the delay	context()	negated: False ,passive: False
[LINE#1092] Notwithstanding the fact that the communication delay and computing speed is mostly determined by parameters outside our control (technology, spatial distances, number of nodes, etc.), minimizing the gate complexity and, in particular, the depth of the circuits implementing the nodes' algorithms (that determine the computing delays) is important.Metastability: In larger and faster systems, the number of events per time unit that could cause metastable upsets is obviously larger.
0.915	[*A*]the depth of the circuits[*R*]is[*A*]important.Metastability	context(the number of events per time unit that could cause metastable upsets is)	negated: False ,passive: True
0.915	[*A*]the depth of the circuits[*R*]is[*A*]important.Metastability	context(the number of events per time unit that could cause metastable upsets is)	negated: False ,passive: True
0.841	[*A*]computing speed[*R*]is determined[*A*]by parameters outside our control number of nodes , etc.	context()	negated: False ,passive: True
0.915	[*A*]the depth of the circuits[*R*]is[*A*]important.Metastability	context(the number of events per time unit that could cause metastable upsets is)	negated: False ,passive: True
0.767	[*A*]computing speed[*R*]is determined[*A*]by parameters outside our control spatial distances	context()	negated: False ,passive: True
0.915	[*A*]the depth of the circuits[*R*]is[*A*]important.Metastability	context(the number of events per time unit that could cause metastable upsets is)	negated: False ,passive: True
0.767	[*A*]computing speed[*R*]is determined[*A*]by parameters outside our control	context()	negated: False ,passive: True
0.915	[*A*]the depth of the circuits[*R*]is[*A*]important.Metastability	context(the number of events per time unit that could cause metastable upsets is)	negated: False ,passive: True
0.681	[*A*]parameters outside our control[*R*]minimizing[*A*]the gate complexity	context()	negated: False ,passive: False
0.915	[*A*]the depth of the circuits[*R*]is[*A*]important.Metastability	context(the number of events per time unit that could cause metastable upsets is)	negated: False ,passive: True
0.854	[*A*]the communication delay[*R*]is determined[*A*]by parameters outside our control number of nodes , etc.	context()	negated: False ,passive: True
0.915	[*A*]the depth of the circuits[*R*]is[*A*]important.Metastability	context(the number of events per time unit that could cause metastable upsets is)	negated: False ,passive: True
0.978	[*A*]the number of events per time unit that could cause metastable upsets[*R*]is[*A*]obviously[*A*]larger[*A*]In faster systems	context()	negated: False ,passive: True
0.933	[*A*]the depth of the circuits[*R*]is[*A*]important.Metastability	context()	negated: False ,passive: True
0.983	[*A*]the number of events per time unit that could cause metastable upsets[*R*]is[*A*]obviously[*A*]larger[*A*]In larger systems	context()	negated: False ,passive: True
0.784	[*A*]the communication delay[*R*]is determined[*A*]by parameters outside our control spatial distances	context()	negated: False ,passive: True
0.978	[*A*]the number of events per time unit that could cause metastable upsets[*R*]is[*A*]obviously larger[*A*]In faster systems	context()	negated: False ,passive: True
0.927	[*A*]the number of events per time unit[*R*]could cause[*A*]metastable upsets	context()	negated: False ,passive: False
0.845	[*A*]the circuits[*R*]implementing[*A*]the nodes ' algorithms ( that determine the computing delays	context()	negated: False ,passive: False
0.915	[*A*]the depth of the circuits[*R*]is[*A*]important.Metastability	context(the number of events per time unit that could cause metastable upsets is)	negated: False ,passive: True
0.978	[*A*]the number of events per time unit that could cause metastable upsets[*R*]is[*A*]obviously larger[*A*]In larger systems	context()	negated: False ,passive: True
0.784	[*A*]the communication delay[*R*]is determined[*A*]by parameters outside our control	context()	negated: False ,passive: True
[LINE#1093] Therefore, it is vital to safely exclude metastability from occurring during regular operation by construction.1010Note that in this regard our approach is superior to standard GALS systems using synchronizers, where the risk of metastability is immanent (at every clock transition) also in normal operation.
0.381	[*A*]our approach[*R*]is superior to[*A*]standard GALS systems	context()	negated: False ,passive: False
0.957	[*A*]standard GALS systems[*R*]using[*A*]synchronizers, where the risk of metastability is immanent (at every clock transition) also in normal operation	context()	negated: False ,passive: False
0.841	[*A*]the risk of metastability[*R*]is[*A*]immanent	context()	negated: False ,passive: True
[LINE#1094] We admit metastability only during rare exceptional phases of system operation where it cannot be avoided in principle, like during stabilization or in case of faults.
0.162	[*A*]it[*R*]can not be avoided	context(We admit)	negated: True ,passive: False
0.397	[*A*]We[*R*]admit[*A*]metastability	context()	negated: False ,passive: False
[LINE#1095] As the probabilities for metastable upsets are hard to quantify even in a final product, we do not use a "hard" measure here.1111It is worth mentioning, though, that the asymptotic increase in the number of events per time unit that could cause metastable upsets is clearly at least polynomial in n.
0.871	[*A*]the asymptotic increase in the number of events per time unit[*R*]is[*A*]clearly[*A*]at least polynomial[*A*]in	context(here.1111It is)	negated: False ,passive: True
0.805	[*A*]here.1111It[*R*]is[*A*]worth mentioning[*A*]though	context()	negated: False ,passive: True
0.367	[*A*]we[*R*]do not use[*A*]a "hard" measure here.1111It is worth mentioning, though, that the asymptotic increase in the number of events per time unit that could cause metastable upsets is clearly at least polynomial in	context()	negated: True ,passive: False
0.887	[*A*]time unit[*R*]could cause[*A*]metastable upsets	context()	negated: False ,passive: False
0.926	[*A*]the probabilities for metastable upsets[*R*]are[*A*]hard to quantify even in a final product	context()	negated: False ,passive: True
[LINE#1096]  As synchronizer chains decrease the probability of upsets exponentially, the required length of synchronizer chains will asymptotically grow as (logn), increasing the system cost and (effectively) decreasing its operational frequency.Connectivity:.
0.882	[*A*]the required length of synchronizer chains[*R*]will asymptotically grow[*A*]as (logn[*A*]increasing the system cost[*A*]effectively) decreasing its operational frequency.Connectivity:.	context()	negated: False ,passive: True
0.901	[*A*]synchronizer chains[*R*]decrease exponentially[*A*]the probability of upsets	context()	negated: False ,passive: False
[LINE#1097] In order to facilitate efficient placement and routing on a chip, it is vital to ensure that the communication network is sparse.
[LINE#1098+1099+1100]  Also, a sparse network will consume less area and is beneficial to fault containment.1212If a single event such as e.g. an ionizing particle hit can render multiple nodes faulty, even tolerating a large number of faulty nodes is of little usethe overall resilience of the system.
0.944	[*A*]even tolerating a large number of faulty nodes[*R*]is[*A*]of little usethe overall resilience of the system	context(a sparse network can render)	negated: False ,passive: True
0.838	[*A*]a sparse network[*R*]can render multiple nodes faulty tolerating[*A*]a large number of faulty nodes	context(a sparse network can render)	negated: False ,passive: False
0.888	[*A*]a sparse network[*R*]can render[*A*]multiple nodes faulty[*A*]even tolerating a large number of faulty nodes	context()	negated: False ,passive: False
0.956	[*A*]a sparse network[*R*]is[*A*]beneficial to fault containment.1212If a single event such as e.g. an ionizing particle hit	context()	negated: False ,passive: True
0.911	[*A*]a sparse network[*R*]will consume[*A*]less area	context()	negated: False ,passive: False
[LINE#1101] Tackling this issue is subject to our future work and hence beyond the scope of this article, however.Clock size: If the logical clocks have too few bits, i.e., overflow too frequently, they might be unsuitable for the application logic of the SoC.
0.913	[*A*]Tackling this issue[*R*]is[*A*]subject hence beyond the scope of this article	context(they might be)	negated: False ,passive: True
0.500	[*A*]this issue[*R*]is subject to[*A*]our future work	context()	negated: False ,passive: False
0.850	[*A*]Tackling this issue[*R*]is[*A*]subject to our future work	context(they might be)	negated: False ,passive: True
0.726	[*A*]they[*R*]might be[*A*]unsuitable for the application logic of the SoC[*A*]overflow too frequently	context()	negated: False ,passive: True
0.911	[*A*]the logical clocks[*R*]have[*A*]too few bits	context()	negated: False ,passive: False
[LINE#1102] The algorithm we present in this article can in principle provide clocks of arbitrary bounded size.
0.651	[*A*]The algorithm we present in this article[*R*]can provide[*A*]clocks of arbitrary bounded size	context()	negated: False ,passive: False
0.887	[*A*]The algorithm[*R*]present[*A*]in this article	context()	negated: False ,passive: True
[LINE#1103] However, its stabilization time would grow linearly with the maximum clock value once we scale above 8-bit clocks.
0.452	[*A*]we[*R*]scale[*A*]above 8-bit clocks	context()	negated: False ,passive: False
0.513	[*A*]its stabilization time[*R*]would grow[*A*]linearly[*A*]with the maximum clock value[*A*]once we scale above 8-bit clocks	context()	negated: False ,passive: True
[LINE#1104] In a recent publication, we show how to construct larger clocks efficiently [41]. .
0.381	[*A*]we[*R*]show to construct efficiently[*A*]larger clocks	context(we show)	negated: False ,passive: False
0.600	[*A*]we[*R*]show[*A*]how to construct larger clocks efficiently [41[*A*]In a recent publication	context()	negated: False ,passive: False
[LINE#1105] Typical modules for clock synchronization protocolsWe next introduce the basic modules that are assumed by the model used in [13].
0.767	[*A*]the model[*R*]used[*A*]in [13	context()	negated: False ,passive: True
0.897	[*A*]the basic modules[*R*]are assumed[*A*]by the model	context()	negated: False ,passive: True
0.872	[*A*]Typical modules for clock synchronization protocolsWe[*R*]next introduce[*A*]the basic modules that are assumed by the model	context()	negated: False ,passive: False
[LINE#1106] We first give an intuitive description of the required modules.
0.554	[*A*]We[*R*]give[*A*]an intuitive description of the required modules[*A*]first	context()	negated: False ,passive: False
[LINE#1107] Subsequently, we introduce a novel formal framework for specifying self-stabilizing fault-tolerant modules and specify our basic modules in this framework.
0.702	[*A*]we[*R*]introduce[*A*]a novel formal framework for specifying self - stabilizing fault - tolerant modules[*A*]Subsequently	context()	negated: False ,passive: False
[LINE#1108+1109]  Any implementation satisfying this specification can be plugged into the high-level algorithm in order to yield a system guaranteeing the properties proved in [13].Wenow list the building blocks beyond standard logic gates that will explicitly or implicitly be used by the algorithm presented in Section 5.
0.767	[*A*]the properties[*R*]proved[*A*]in [13	context()	negated: False ,passive: True
0.903	[*A*]a system[*R*]guaranteeing[*A*]the properties proved in [13]	context()	negated: False ,passive: False
0.903	[*A*]the algorithm[*R*]presented[*A*]in Section 5	context()	negated: False ,passive: True
0.926	[*A*]Any implementation satisfying this specification[*R*]can be plugged[*A*]into the high-level algorithm[*A*]in order	context()	negated: False ,passive: True
0.850	[*A*]standard logic gates[*R*]will explicitly be used[*A*]by the algorithm	context()	negated: False ,passive: True
0.903	[*A*]Any implementation[*R*]satisfying[*A*]this specification	context()	negated: False ,passive: False
[LINE#1110] Each of these building blocks computes output signals that are constrained by (the history of) its input signals.
0.810	[*A*]output signals[*R*]are constrained[*A*]by (the history of) its input signals	context()	negated: False ,passive: True
0.798	[*A*]Each of these building blocks[*R*]computes[*A*]output signals that are constrained by (the history of) its input signals	context()	negated: False ,passive: False
[LINE#1111] If the logic function implies an output transition in reaction to an input change, this transition is not required to occur immediately; it must occur within a known time bound, however.
0.717	[*A*]this transition[*R*]is not required[*A*]to occur immediately	context(it must occur)	negated: True ,passive: True
0.388	[*A*]it[*R*]must occur[*A*]within a known time[*A*]however	context()	negated: False ,passive: True
0.887	[*A*]this transition[*R*]to occur[*A*]immediately[*A*]within a known time	context()	negated: False ,passive: True
0.751	[*A*]a known time[*R*]bound	context()	negated: False ,passive: False
0.911	[*A*]the logic function[*R*]implies[*A*]an output transition in reaction to an input change	context()	negated: False ,passive: False
[LINE#1112] Given the time bounds for the individual modules and the connecting wires, one can compute the maximum delay d.
0.616	[*A*]one[*R*]can compute[*A*]the maximum delay	context()	negated: False ,passive: False
[LINE#1113] Moreover, informally speaking, it must be avoided that a single change in the input(s) causes multiple transitions of the output signal, as this could undermine the high-level algorithm's logic.
0.899	[*A*]a single change in the input[*R*]causes[*A*]multiple transitions of the output signal	context(it must be avoided)	negated: False ,passive: False
0.157	[*A*]it[*R*]must be avoided	context()	negated: False ,passive: False
0.381	[*A*]this[*R*]could undermine[*A*]the high-level algorithm's logic	context()	negated: False ,passive: False
[LINE#1114] Note also that statefulness, i.e., any sort of memory (including positive feedback loops), bears the potential for metastable upsets and requires careful attention in order to ensure self-stabilization.1313In other words, the module must recover from arbitrary corruptions of its memory.
0.835	[*A*]the module[*R*]must recover[*A*]from arbitrary corruptions of its memory	context()	negated: False ,passive: True
[LINE#1115] Purely combinational elements, on the other hand, differ in their ability to prevent metastable inputs from reaching the output under certain conditions.
0.903	[*A*]metastable inputs[*R*]from reaching[*A*]the output	context()	negated: False ,passive: False
0.718	[*A*]Purely combinational elements[*R*]differ	context()	negated: False ,passive: False
[LINE#1116] Each node will be a union of state machines that communicate via channels (both among each other and with remote nodes) and are composed of standard logic gates and all other modules we describe below.
0.882	[*A*]Each node[*R*]will be[*A*]a union of state machines	context(we describe below)	negated: False ,passive: True
0.162	[*A*]we[*R*]describe below	context()	negated: False ,passive: False
0.698	[*A*]state machines[*R*]communicate	context()	negated: False ,passive: False
[LINE#1117] 5 depicts such a state machine.Communication channels.
0.381	[*A*]5[*R*]depicts[*A*]such a state machine.Communication channels	context()	negated: False ,passive: False
[LINE#1118] We previously introduced the communication channels from node i to node j as abstract devices that convey the states with a delay of at most d that also accounts for computations.
0.802	[*A*]most d[*R*]accounts[*A*]for computations	context()	negated: False ,passive: False
0.887	[*A*]abstract devices[*R*]convey[*A*]the states	context()	negated: False ,passive: False
0.520	[*A*]We[*R*]introduced[*A*]the communication channels from node i to node j as abstract devices[*A*]previously	context()	negated: False ,passive: False
[LINE#1119] Viewed as a module, the (physical) communication channels do account for the time to communicate the state information only, whereas computations are performed by standard logic gates and the modules we will describe next.
0.735	[*A*]the modules[*R*]will describe[*A*]next	context()	negated: False ,passive: True
0.873	[*A*]the ( physical ) communication channels[*R*]do account to communicate[*A*]the state information	context(the ( physical ) communication channels do)	negated: False ,passive: False
0.933	[*A*]the ( physical ) communication channels[*R*]do[*A*]account[*A*]for the time	context()	negated: False ,passive: False
[LINE#1120] A communication channel of this type simply maps its input signal to its output signal.
0.893	[*A*]A communication channel of this type[*R*]maps[*A*]its input signal	context()	negated: False ,passive: False
[LINE#1121] The reason why communication channels are nonetheless listed as modules here is that encoding a non-binary state signal in a glitch- and metastability-free manner is a non-trivial task, as in the absence of (reliable) synchrony both parallel and sequential communication present challenges.
0.903	[*A*]communication channels[*R*]are nonetheless listed[*A*]as modules here	context()	negated: False ,passive: True
[LINE#1122] In our abstraction, this encoding is performed by the channel, which requires additional logic and thus potentially results in delays beyond the mere wire delays as well as the necessity to consider issues concerning metastability and self-stabilization.Memory flags.
0.894	[*A*]issues[*R*]concerning[*A*]self - stabilization.Memory flags	context()	negated: False ,passive: False
0.894	[*A*]issues[*R*]concerning[*A*]metastability	context()	negated: False ,passive: False
0.887	[*A*]the channel[*R*]results[*A*]in delays beyond the necessity	context()	negated: False ,passive: True
0.900	[*A*]this encoding[*R*]is performed[*A*]by the channel[*A*]In our abstraction	context()	negated: False ,passive: True
0.887	[*A*]the channel[*R*]results[*A*]in delays beyond the mere wire delays	context()	negated: False ,passive: True
0.887	[*A*]the channel[*R*]requires[*A*]additional logic	context()	negated: False ,passive: False
0.883	[*A*]this encoding[*R*]is performed[*A*]In our abstraction	context()	negated: False ,passive: True
[LINE#1123] These are just simple binary storage elements that can be set to 1 by means of one input signal and can be reset to 0 by a second input signal; their state is externally accessible via an output signal.
0.359	[*A*]These[*R*]are[*A*]just simple binary storage elements that can be set to 1 by means of one input signal	context(their state is)	negated: False ,passive: True
0.652	[*A*]their state[*R*]is[*A*]externally accessible via an output signal	context()	negated: False ,passive: True
0.913	[*A*]just simple binary storage elements[*R*]can be set[*A*]to 1[*A*]by means of one input signal	context()	negated: False ,passive: True
[LINE#1124] a memory flag just "remembers" which input signal was 1 most recently.
0.817	[*A*]a memory flag[*R*]just remembers[*A*]which input signal was 1 most recently	context()	negated: False ,passive: False
[LINE#1125] In our algorithms, memory flags will be used to memorize wether an input signal from a remote node was in state 1 at some time after the most recent reset upon a state transition of one of the node's state machines (in Fig. 1, e.g., a node resets its propose flags when switching from increase to ready).Threshold gates.
0.918	[*A*]memory flags[*R*]will be used[*A*]to memorize wether an input signal from a remote node[*A*]In our algorithms	context(a node resets)	negated: False ,passive: True
0.796	[*A*]a node[*R*]resets[*A*]its propose flags[*A*]when switching from increase to ready	context()	negated: False ,passive: False
0.944	[*A*]memory flags[*R*]was[*A*]in state 1[*A*]at some time after the most recent reset upon a state transition of one of the node's state machines	context()	negated: False ,passive: True
0.868	[*A*]memory flags[*R*]to memorize[*A*]an input signal	context()	negated: False ,passive: False
[LINE#1126]  Frequently, nodes will need to decide whether a certain threshold number (f+1 or n-f) of signals (or sets of signals) satisfy some Boolean predicate (e.g., the conditions for switching to propose and increase in Fig..
0.898	[*A*]a certain threshold number[*R*]satisfy[*A*]some Boolean predicate	context(nodes will need to decide)	negated: False ,passive: False
0.926	[*A*]nodes[*R*]will need to decide[*A*]whether a certain threshold number (f+1 or n-f) of signals (or sets of signals) satisfy some Boolean predicate (e.g., the conditions for switching to propose and increase in Fig	context(nodes will need)	negated: False ,passive: False
0.957	[*A*]nodes[*R*]will need[*A*]to decide whether a certain threshold number (f+1 or n-f) of signals (or sets of signals) satisfy some Boolean predicate (e.g., the conditions for switching to propose and increase in Fig[*A*]Frequently	context()	negated: False ,passive: False
[LINE#1127] A threshold gate takes the respective binary input signals and outputs 1 if the threshold is reached and 0 otherwise.Watchdog timers.
0.999	[*A*]A threshold gate[*R*]outputs[*A*]1	context()	negated: False ,passive: False
0.732	[*A*]the threshold[*R*]is reached	context()	negated: False ,passive: False
0.911	[*A*]A threshold gate[*R*]outputs[*A*]1[*A*]if the threshold is reached	context()	negated: False ,passive: False
0.911	[*A*]A threshold gate[*R*]takes[*A*]the respective binary input signals and 0 otherwise.Watchdog timers	context()	negated: False ,passive: False
[LINE#1128] Watchdog timers are the nodes' sense for the progress of time.
0.903	[*A*]Watchdog timers[*R*]are[*A*]the nodes' sense for the progress of time	context()	negated: False ,passive: True
[LINE#1129] Each timer (T,s,C), where T in R+ is a duration and C a clock, is associated with state s and is either expired (output 1) or not expired (output 0).
0.987	[*A*]Each timer (T,s,C), where T in R+ is a duration and C a clock[*R*]is[*A*]either expired (output 1) or not expired (output 0	context()	negated: False ,passive: True
0.972	[*A*]Each timer (T,s,C), where T in R+ is a duration and C a clock[*R*]is associated[*A*]with state s	context()	negated: False ,passive: True
0.913	[*A*]Each timer[*R*]C[*A*]a clock	context()	negated: False ,passive: True
0.905	[*A*]T in R+[*R*]is[*A*]a duration	context()	negated: False ,passive: True
[LINE#1130] The timer is reset to 0 when the node's state switches to s and will expire after T time has passed according to clock C, unless it is reset again beforehand.
0.698	[*A*]The timer[*R*]has passed	context()	negated: False ,passive: False
0.918	[*A*]The timer[*R*]will expire[*A*]after T time[*A*]has passed according to clock C	context()	negated: False ,passive: True
0.225	[*A*]it[*R*]is reset[*A*]again[*A*]beforehand	context()	negated: False ,passive: True
0.860	[*A*]the node 's state[*R*]switches[*A*]to s	context()	negated: False ,passive: False
[LINE#1131] Hence, if it is reset at (reference) time t, it will expire at some time t[t+T/,t+T].
0.452	[*A*]it[*R*]will expire[*A*]at some time t	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]is reset[*A*]at (reference) time t	context()	negated: False ,passive: True
[LINE#1132] For instance, the transition to ready in Fig. 1 is triggered by a watchdog timer.Randomized watchdog timers.
0.958	[*A*]the transition to ready in Fig. 1[*R*]is triggered[*A*]by a watchdog	context()	negated: False ,passive: True
[LINE#1133] A randomized watchdog timer is identical to a regular watchdog timer except that the duration T of the timeout is drawn from a (bounded) random distribution D over R+.
0.964	[*A*]the duration T of the timeout[*R*]is drawn[*A*]from a (bounded) random distribution D over R+	context()	negated: False ,passive: True
0.914	[*A*]A randomized watchdog timer[*R*]is[*A*]identical to a regular watchdog timer except that the duration T of the timeout is drawn from a (bounded) random distribution D over R+	context()	negated: False ,passive: True
[LINE#1134] That is, if randomized timer (D,s,C) is reset at time t, it will expire at time t[t+T/,t+T], where T is drawn from D. How this randomness is implemented subtly affects resilience and security properties of the system, see [13] for a formal definition of the way randomness is to be employed.
0.732	[*A*]this randomness[*R*]is implemented	context()	negated: False ,passive: False
0.677	[*A*]randomness[*R*]to be employed	context()	negated: False ,passive: False
0.840	[*A*]T[*R*]is drawn[*A*]from D.	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]will expire[*A*]at time	context()	negated: False ,passive: True
0.966	[*A*]That is, if randomized timer (D,s,C[*R*]is reset[*A*]at time	context()	negated: False ,passive: True
0.753	[*A*]randomness[*R*]is[*A*]to be employed	context(t+T subtly affects)	negated: False ,passive: True
0.793	[*A*]t+T[*R*]subtly affects[*A*]resilience and security properties of the system	context()	negated: False ,passive: False
[LINE#1135] For the purpose of this article, we confine ourselves to pointing out that, essentially, we require that faulty nodes do not have access to the value T drawn from D before time t.State transition modules.
0.878	[*A*]faulty nodes[*R*]do not have[*A*]access to the value T	context(we confine to pointing out we require)	negated: True ,passive: False
0.271	[*A*]we[*R*]require[*A*]that faulty nodes do not have access to the value T	context(we confine to pointing out)	negated: False ,passive: False
0.168	[*A*]we[*R*]confine ourselves to pointing out[*A*]that, essentially, we require that faulty nodes do not have access to the value T	context(we confine)	negated: False ,passive: False
0.168	[*A*]we[*R*]confine[*A*]ourselves[*A*]to pointing out that, essentially, we require that faulty nodes do not have access to the value T	context()	negated: False ,passive: False
0.932	[*A*]the value T[*R*]drawn[*A*]from D[*A*]before time t.State transition modules	context()	negated: False ,passive: True
[LINE#1136] The algorithm does not demand zero-time state transitions.
0.903	[*A*]The algorithm[*R*]does not demand[*A*]zero-time state transitions	context()	negated: True ,passive: False
[LINE#1137] Nevertheless, it is non-trivial to ensure metastability-free state transitions and consistent memory states in our setting.
[LINE#1138]  On a transition from state s to state s, the node needs to switch its state signal (i.e., the input to its outgoing communication channels) exactly once from s to s and reset any memory flag that is to be reset upon transitioning from s to.
0.897	[*A*]any memory flag[*R*]to be reset[*A*]upon transitioning from s to	context()	negated: False ,passive: True
0.920	[*A*]any memory flag[*R*]is[*A*]to be reset upon transitioning from s to	context()	negated: False ,passive: True
0.796	[*A*]the node[*R*]needs to switch[*A*]its state signal	context(the node needs)	negated: False ,passive: False
0.874	[*A*]the node[*R*]needs[*A*]to switch its state signal[*A*]On a transition from state s to state s	context()	negated: False ,passive: False
0.791	[*A*]the node[*R*]needs to switch exactly once[*A*]its state signal	context(the node needs)	negated: False ,passive: False
0.918	[*A*]the node[*R*]needs[*A*]to switch its state signal ( i.e. , the input to its outgoing communication channels ) exactly once from s to s[*A*]On a transition from state s to state s	context()	negated: False ,passive: False
[LINE#1139+1140]  This is complicated because the condition under which the state transition occurs, a Boolean predicate over a blend of signals from incoming communication channels and local modules' outputs, may be satisfied for a brief period of time only, or a condition for switching to a different states might become satisfied at almost the same instant.
0.992	[*A*]because the condition under which the state transition occurs, a Boolean predicate over a blend of signals from incoming communication channels and local modules' outputs[*R*]might become[*A*]satisfied at almost the same instant	context()	negated: False ,passive: True
0.997	[*A*]because the condition under which the state transition occurs, a Boolean predicate over a blend of signals from incoming communication channels and local modules' outputs[*R*]may be[*A*]the condition under which the state transition occurs, a Boolean predicate over a blend of signals from incoming communication channels and local modules' outputs, may be satisfied for a brief period of time	context()	negated: False ,passive: True
0.939	[*A*]the state transition[*R*]occurs[*A*]the condition	context()	negated: False ,passive: True
0.223	[*A*]This[*R*]is[*A*]complicated	context()	negated: False ,passive: True
[LINE#1141+1142]  Even worse, it may e.g. be required that memory flags whose output is part of a predicate expressing the condition for switching from s to s are to be reset upon the transition tos. Resolving these issues is the purpose of a state transition module that controls the safe transition from one state to another.
0.905	[*A*]a state transition module[*R*]controls[*A*]the safe transition	context()	negated: False ,passive: False
0.932	[*A*]Resolving these issues[*R*]is[*A*]the purpose of a state transition module	context()	negated: False ,passive: True
0.903	[*A*]a predicate[*R*]expressing[*A*]the condition for switching from s to s	context()	negated: False ,passive: False
0.913	[*A*]memory flags[*R*]is[*A*]part of a predicate	context()	negated: False ,passive: True
0.939	[*A*]memory flags whose output is part of a predicate[*R*]to be reset[*A*]upon the transition tos	context()	negated: False ,passive: True
[LINE#1143+1144]  The FATAL+ clock synchronization protocolIn this section, we recast the self-stabilizing clock synchronization algorithm introduced in [13] in the modeling framework of the previous section and summarize its most important properties.
0.938	[*A*]the self - stabilizing clock synchronization algorithm[*R*]introduced[*A*]in [ 13[*A*]in the modeling framework of the previous section	context()	negated: False ,passive: True
0.702	[*A*]we[*R*]recast[*A*]the self - stabilizing clock synchronization algorithm introduced in [ 13 ] in the modeling framework of the previous section[*A*]this section	context()	negated: False ,passive: False
[LINE#1145] Since the main focus of our paper is on the implementation of our algorithm in this model, there is no need to provide a detailed description of the stabilization mechanism, let alone formal proofs of the stated claims; the analysis of the correctness and performance of the algorithm in [13] is based on a simpler abstract system model, assuming a globally valid end-to-end delay bound d covering any (local and remote) communication and processing action, which is fully compatible with our modeling framework.
0.955	[*A*]the analysis of performance of the algorithm in [ 13[*R*]is based[*A*]on a simpler abstract system model[*A*]assuming a globally valid end - to - end delay bound d	context()	negated: False ,passive: True
0.951	[*A*]a globally valid end - to - end delay bound d[*R*]covering[*A*]any ( remote ) communication , which is fully compatible with our modeling framework	context()	negated: False ,passive: False
0.894	[*A*]delay[*R*]bound[*A*]d covering any ( remote ) communication ,	context()	negated: False ,passive: False
0.883	[*A*]any ( remote ) communication[*R*]is[*A*]fully compatible with our modeling framework	context()	negated: False ,passive: True
0.951	[*A*]a globally valid end - to - end delay bound d[*R*]covering[*A*]any ( local ) communication , which is fully compatible with our modeling framework	context()	negated: False ,passive: False
0.894	[*A*]delay[*R*]bound[*A*]d covering any ( local ) communication ,	context()	negated: False ,passive: False
0.883	[*A*]any ( local ) communication[*R*]is[*A*]fully compatible with our modeling framework	context()	negated: False ,passive: True
0.959	[*A*]the analysis of the correctness of the algorithm in [ 13[*R*]is based[*A*]on a simpler abstract system model[*A*]assuming a globally valid end - to - end delay bound d	context()	negated: False ,passive: True
0.955	[*A*]the analysis of performance of the algorithm in [ 13[*R*]is based[*A*]on a simpler abstract system model[*A*]assuming a globally valid end - to - end delay	context()	negated: False ,passive: True
0.948	[*A*]a globally valid end - to - end delay[*R*]bound[*A*]d covering processing action	context()	negated: False ,passive: True
0.850	[*A*]processing action[*R*]is[*A*]fully compatible with our modeling framework	context()	negated: False ,passive: True
0.959	[*A*]the analysis of the correctness of the algorithm in [ 13[*R*]is based[*A*]on a simpler abstract system model[*A*]assuming a globally valid end - to - end delay	context()	negated: False ,passive: True
0.651	[*A*]the main focus of our paper[*R*]is[*A*]on the implementation of our algorithm in this model	context()	negated: False ,passive: True
[LINE#1146] More specifically, all that is needed in order to reuse the results of the analysis in [13] is to compute the maximum end-to-end delay occurring in the implementation of our algorithm in the modeling framework introduced in Section 2.2.Recall from Section 2.2 that our top-level clock synchronization module is implemented as a compound module consisting of n nodes and their connecting top-level channels (with maximum delay dChan).
0.915	[*A*]a compound module[*R*]consisting[*A*]of their connecting top - level channels ( with maximum delay dChan	context()	negated: False ,passive: True
0.935	[*A*]the maximum end - to - end delay[*R*]occurring[*A*]in the implementation of our algorithm in the modeling framework	context()	negated: False ,passive: True
0.925	[*A*]a compound module[*R*]consisting[*A*]of n nodes ( with maximum delay dChan	context()	negated: False ,passive: True
0.741	[*A*]our top - level clock synchronization module[*R*]is implemented[*A*]as a compound module	context()	negated: False ,passive: True
0.911	[*A*]the modeling framework[*R*]introduced[*A*]in Section 2.2.Recall	context()	negated: False ,passive: True
0.342	[*A*]all[*R*]is needed[*A*]in order	context()	negated: False ,passive: True
[LINE#1147]  Every node, in turn, is a compound module made up of a state transition module, watchdog timers, memory flags, and threshold modules interconnected by channels (modeling various delays) as shown in Fig..
0.903	[*A*]threshold modules[*R*]interconnected[*A*]by channels	context()	negated: False ,passive: True
0.913	[*A*]Every node[*R*]is[*A*]a compound module made up of threshold modules	context()	negated: False ,passive: True
0.903	[*A*]memory flags[*R*]interconnected[*A*]by channels	context()	negated: False ,passive: True
0.911	[*A*]a compound module[*R*]made up[*A*]of memory flags	context()	negated: False ,passive: True
0.913	[*A*]Every node[*R*]is[*A*]a compound module made up of memory flags	context()	negated: False ,passive: True
0.903	[*A*]watchdog timers[*R*]interconnected[*A*]by channels	context()	negated: False ,passive: True
0.913	[*A*]Every node[*R*]is[*A*]a compound module made up of watchdog timers	context()	negated: False ,passive: True
0.919	[*A*]a state transition module[*R*]interconnected[*A*]by channels	context()	negated: False ,passive: True
0.751	[*A*]a compound module[*R*]made up	context()	negated: False ,passive: False
0.944	[*A*]Every node[*R*]is[*A*]a compound module made up of a state transition module	context()	negated: False ,passive: True
[LINE#1148] Finally, a state transition module represents several communicating concurrent asynchronous state machines (with maximum transition time dTrans).
0.956	[*A*]a state transition module[*R*]represents[*A*]several communicating concurrent asynchronous state machines (with maximum transition time dTrans	context()	negated: False ,passive: False
[LINE#1149] It ensures that state transitions of every constituent state machine occur in an orderly fashion, i.e., that every transition happens exactly once and, if need be, memory flags are consistently reset.
0.732	[*A*]memory flags[*R*]are consistently reset	context()	negated: False ,passive: False
0.767	[*A*]need[*R*]be	context()	negated: False ,passive: False
0.780	[*A*]state transitions of every constituent state machine[*R*]occur	context(It ensures)	negated: False ,passive: False
0.279	[*A*]It[*R*]ensures[*A*]that state transitions of every constituent state machine occur in an orderly fashion	context()	negated: False ,passive: False
[LINE#1150] The state of each state machine is encoded in a few bits and conveyed via the top-level channels to all other modules in the system that need to receive it on some input port.
0.767	[*A*]the system[*R*]need to receive[*A*]it[*A*]on some input port	context(the system need)	negated: False ,passive: False
0.767	[*A*]the system[*R*]need[*A*]to receive it on some input port	context()	negated: False ,passive: False
0.732	[*A*]The state[*R*]conveyed	context()	negated: False ,passive: False
0.932	[*A*]The state of each state machine[*R*]is encoded[*A*]in a few bits	context()	negated: False ,passive: True
[LINE#1151] Given this simple internal structure, computing the resulting end-to-end delay bound d (or, for the quick cycle, dmin+ and dmax+, see below) from the constituent delay bounds is straightforward, see Section 6 for details..
[LINE#1152+1153]  State machine representationObviously, the entire logic of our algorithm is encoded in the state machines of a node.
[LINE#1154] In [13], we use a graphical representation that also reveals the layered structure imposed by their communication.
0.848	[*A*]the layered structure[*R*]imposed[*A*]by their communication	context()	negated: False ,passive: True
0.825	[*A*]a graphical representation[*R*]reveals[*A*]the layered structure imposed by their communication	context()	negated: False ,passive: False
0.350	[*A*]we[*R*]use[*A*]a graphical representation that also reveals the layered structure[*A*]In [13	context()	negated: False ,passive: False
[LINE#1155]  We already employed this description in Fig..
0.599	[*A*]We[*R*]employed[*A*]this description[*A*]in Fig[*A*]already	context()	negated: False ,passive: False
[LINE#1156] With the definitions from the previous section at hand, we can now give our graphical representation a precise formal meaning that will allow us to translate the results from [13] to our modeling framework.
0.356	[*A*]us[*R*]to translate[*A*]the results from [13] to our modeling framework	context(a precise formal meaning will allow)	negated: False ,passive: False
0.865	[*A*]a precise formal meaning[*R*]will allow[*A*]us to translate the results from [13] to our modeling framework	context()	negated: False ,passive: False
0.234	[*A*]we[*R*]can give[*A*]our graphical representation[*A*]a precise formal meaning that will allow us to translate the results from [13] to our modeling framework[*A*]now	context()	negated: False ,passive: False
[LINE#1157+1158]  Our graphical representation defines the set of possible states S of a state machine (in Fig. 1 ready, propose, and increase) and, by means of the arrows between the states, the set of possible state transitions.
0.789	[*A*]Our graphical representation[*R*]defines[*A*]the set of possible states S of a state machine ( in Fig	context()	negated: False ,passive: False
[LINE#1159] TS2 (here ready to propose, propose to increase, and increase to ready).
0.133	[*A*]TS2[*R*]to propose	context()	negated: False ,passive: False
[LINE#1160] If, for a state transition from s to s, re(s,s), i.e., there are memory flags that need to be reset, re(s,s) is given in a rectangular box on the arrow.
0.868	[*A*]s[*R*]is given[*A*]in a rectangular box on the arrow[*A*]re(s	context()	negated: False ,passive: True
0.698	[*A*]memory flags[*R*]to be reset	context()	negated: False ,passive: False
0.735	[*A*]memory flags[*R*]need[*A*]to be reset	context()	negated: False ,passive: False
[LINE#1161] we will always reset all memory flags Memi,j,s for j{1,,n} together, we simply write s1,,sk in such a box to represent the fact that all flags Memi,j,s, j{1,,n}, s{s1,,sk}, are to be reset.
0.614	[*A*]s{s1,,sk[*R*]to be reset	context()	negated: False ,passive: False
0.197	[*A*]we[*R*]write[*A*]s1	context()	negated: False ,passive: False
0.269	[*A*]we[*R*]will reset[*A*]all memory flags Memi,j,s for j{1,,n} together, we simply write s1,,sk in such a box to represent the fact that all flags Memi,j,s, j{1,,n}, s{s1,,sk}, are to be reset.[*A*]always	context()	negated: False ,passive: False
[LINE#1162+1163]  Note that some of these states may be from a different state machine, i.e., the states s1,,skneed not all be from S.Completing the description, for each (s,s)T, tr(s,s) is given by the label next to the respective arrow.
0.847	[*A*]skneed[*R*]not be[*A*]from S.Completing the description	context()	negated: True ,passive: True
0.958	[*A*]a different state machine[*R*]s1[*A*]the states	context()	negated: False ,passive: True
[LINE#1164] Again, we make use of a condensed notation.
0.452	[*A*]we[*R*]make[*A*]use of a condensed notation	context()	negated: False ,passive: False
[LINE#1165] Assume that the state machine in question is part of node i.
[LINE#1166+1167]  We will employ threshold conditions like "f+1 s1", whereby we refer to at least f+1 of i's memory flags Memi,j,s1 being in state 1, or "n-f s1 or s2", which is true if jNmax{Memi,j,s1,Memi,j,s2}n-f, i.e., for at least n-f nodes j flag Memi,j,s1 or flag Memi,j,s2 is in state 1.
0.949	[*A*]at least n-f nodes[*R*]flag[*A*]Memi	context()	negated: False ,passive: False
0.844	[*A*]n-f s1 or s2[*R*]is[*A*]true	context()	negated: False ,passive: True
0.309	[*A*]we[*R*]refer[*A*]to at least f+1 of i's memory flags	context()	negated: False ,passive: False
0.852	[*A*]s2[*R*]is[*A*]in state 1	context()	negated: False ,passive: True
0.452	[*A*]We[*R*]will employ[*A*]threshold conditions like "f+1 s1	context()	negated: False ,passive: False
[LINE#1168]  An example for such a rule is the transition from propose to increase in Fig..
0.931	[*A*]the transition from propose[*R*]to increase[*A*]in Fig	context()	negated: False ,passive: True
0.956	[*A*]An example for such a rule[*R*]is[*A*]the transition from propose to increase in Fig	context()	negated: False ,passive: True
[LINE#1169] Such conditions will be translated to a binary signal by feeding the memory flags' signals (or, in the latter case, the output of n OR-gates with inputs Memi,j,s1 and Memi,j,s2) into a threshold gate (of threshold f+1 or n-f, respectively).
0.903	[*A*]Such conditions[*R*]will be translated[*A*]to a binary signal	context()	negated: False ,passive: True
[LINE#1170] Further abbreviations we use for timeouts.
0.452	[*A*]we[*R*]use[*A*]for timeouts	context()	negated: False ,passive: False
[LINE#1171+1172]  Recall that for a timeout (T,s,C), we omit the clock C from the notation, i.e., write (T,s)(T,s) switches to 1 after T local time units (i.e., between T/ and T+dTrans reference time) has passed since the last switch to state s was triggered.
0.801	[*A*]the last switch to state s[*R*]was triggered	context()	negated: False ,passive: False
[LINE#1173] In case it is part of a transition rule, we write (T,s) for the condition TimeT,s,C=1, and if the transition goes from the state s to which the timeout corresponds to some state s, we simply write T.
0.392	[*A*]we[*R*]write[*A*]T.	context(the timeout corresponds s)	negated: False ,passive: False
0.875	[*A*]the timeout[*R*]corresponds s[*A*]to some state	context()	negated: False ,passive: True
0.903	[*A*]the transition[*R*]goes[*A*]from the state s	context()	negated: False ,passive: True
0.610	[*A*]it[*R*]is[*A*]part of a transition rule[*A*]In case	context(In case it is part of a transition rule write)	negated: False ,passive: True
0.695	[*A*]In case it is part of a transition rule[*R*]write[*A*]we	context()	negated: False ,passive: True
[LINE#1174] For instance, the condition "3d local time has passed" in Fig. 1 is concisely stated as "3d".
0.992	[*A*]1[*R*]is stated as[*A*]3 d	context()	negated: False ,passive: False
0.381	[*A*]1[*R*]is concisely stated[*A*]as "3d	context()	negated: False ,passive: True
0.888	[*A*]the condition[*R*]has passed[*A*]in Fig	context()	negated: False ,passive: True
[LINE#1175] Finally, as for memory flag resets, transition rules may also refer to a state s of another state machine.
0.916	[*A*]transition rules[*R*]may refer[*A*]to a state s of another state machine[*A*]Finally	context()	negated: False ,passive: False
[LINE#1176] In the special case that a predicate solely depends on the current state of another of the node's state machines, we write "in s" or "not in s" to indicate the predicates p=s and (p=s), respectively, where p is the input port connected to the channel communicating the other state machine's state to the state transition module.
0.751	[*A*]the input port[*R*]connected	context()	negated: False ,passive: False
0.852	[*A*]p[*R*]is[*A*]the input port connected to the channel	context()	negated: False ,passive: True
0.411	[*A*]we[*R*]to indicate[*A*]the predicates	context()	negated: False ,passive: False
0.418	[*A*]we[*R*]write[*A*]In the special case that a predicate solely depends on the current state of another of the node's state machines	context()	negated: False ,passive: False
0.903	[*A*]the channel[*R*]communicating[*A*]the other state machine's state[*A*]to the state transition module	context()	negated: False ,passive: False
0.937	[*A*]a predicate[*R*]solely depends[*A*]on the current state of another of the node's state machines	context()	negated: False ,passive: False
[LINE#1177] Finally, the above rules can be composed by logical AND or OR, which we display by connecting expressions with and or or, respectively.
[LINE#1178] In Fig. 1, such a composition occurs in tr(ready,propose).
0.957	[*A*]such a composition[*R*]occurs[*A*]in tr(ready,propose[*A*]In Fig. 1	context()	negated: False ,passive: True
[LINE#1179] Overview of the algorithmEach node is a collection of several state machines that are organized in a layered structure.
0.897	[*A*]several state machines[*R*]are organized[*A*]in a layered structure	context()	negated: False ,passive: True
0.957	[*A*]Overview of the algorithmEach node[*R*]is[*A*]a collection of several state machines	context()	negated: False ,passive: True
[LINE#1180] On each layer, the state machines of the (at least n-f) non-faulty nodes cooperate in order to establish certain synchronization properties of their output signals.
[LINE#1181] The higher is a state machine in the hierarchy, the stronger are these guarantees; the lower it is, the weaker are the synchronization properties its input signals need to satisfy for stabilization.
0.599	[*A*]its input signals[*R*]need to satisfy[*A*]for stabilization	context(the weaker are the synchronization properties its input signals need)	negated: False ,passive: False
0.599	[*A*]its input signals[*R*]need[*A*]to satisfy for stabilization	context(the weaker are the synchronization properties)	negated: False ,passive: False
0.796	[*A*]the synchronization[*R*]properties[*A*]its input signals need to satisfy for stabilization	context(the weaker are)	negated: False ,passive: False
0.503	[*A*]the stronger[*R*]are[*A*]these guarantees	context(the weaker are)	negated: False ,passive: True
0.469	[*A*]the weaker[*R*]are[*A*]the synchronization properties its input signals need to satisfy for stabilization	context()	negated: False ,passive: True
0.589	[*A*]the lower[*R*]is[*A*]it	context()	negated: False ,passive: True
0.636	[*A*]The higher[*R*]is[*A*]a state machine in the hierarchy	context()	negated: False ,passive: True
[LINE#1182] The lowest-layer state machine utilizes randomization to recover from any configuration (provided its basic modules are correct (again), i.e., guarantee feasible executions).
0.643	[*A*]i.e.[*R*]guarantee[*A*]feasible executions[*A*]again	context()	negated: False ,passive: False
0.406	[*A*]its basic modules[*R*]are[*A*]correct	context()	negated: False ,passive: True
0.923	[*A*]The lowest-layer state machine[*R*]utilizes[*A*]randomization[*A*]to recover from any configuration (provided its basic modules are correct (again), i.e., guarantee feasible executions	context()	negated: False ,passive: False
[LINE#1183] Each other layer utilizes auxiliary information from the layer below to stabilize.
0.911	[*A*]Each other layer[*R*]utilizes[*A*]auxiliary information from the layer below to stabilize	context()	negated: False ,passive: False
[LINE#1184] Finally, the top level state machine outputs the logical clocks Li.
0.964	[*A*]the top level state machine[*R*]outputs[*A*]the logical clocks[*A*]Li[*A*]Finally	context()	negated: False ,passive: False
[LINE#1185+1186]  More specifically, we have the following state machines.Atthe top level, we have the quick cycle state machine (Fig. 6) that outputs Li.
0.397	[*A*]we[*R*]have[*A*]the quick cycle state machine	context()	negated: False ,passive: False
[LINE#1187] The quick cycle is very similar to the algorithm given in Fig. 1, except that it is coupled to the state machine beneath it in order to ensure eventual stabilization.
0.309	[*A*]it[*R*]is coupled[*A*]to the state machine beneath it[*A*]in order	context()	negated: False ,passive: True
0.918	[*A*]the algorithm[*R*]given[*A*]in Fig	context()	negated: False ,passive: True
0.932	[*A*]The quick cycle[*R*]is[*A*]very similar to the algorithm	context()	negated: False ,passive: True
[LINE#1188+1189]  Once the system is stabilized, it consistently and deterministically increases Li at a high frequency while guaranteeing small clock imprecision.The main state machine(Fig. 8) is the centerpiece of the stabilization mechanism.
0.293	[*A*]it[*R*]deterministically increases Li guaranteeing[*A*]small clock	context(it deterministically increases Fig is)	negated: False ,passive: False
0.577	[*A*]it[*R*]deterministically increases[*A*]Li[*A*]while guaranteeing small clock imprecision.The main state machine[*A*]Once the system is stabilized	context(Fig is)	negated: False ,passive: False
0.293	[*A*]it[*R*]consistently increases Li guaranteeing[*A*]small clock	context(it consistently increases Fig is)	negated: False ,passive: False
0.577	[*A*]it[*R*]consistently increases[*A*]Li[*A*]while guaranteeing small clock imprecision.The main state machine[*A*]Once the system is stabilized	context(Fig is)	negated: False ,passive: False
0.836	[*A*]Fig[*R*]is[*A*]the centerpiece of the stabilization mechanism	context()	negated: False ,passive: True
0.732	[*A*]the system[*R*]is stabilized	context()	negated: False ,passive: False
[LINE#1190] Once stabilized, it generates slow, roughly synchronized "pulses" within certain frequency bounds.
0.702	[*A*]it[*R*]generates[*A*]slow, roughly synchronized "pulses" within certain frequency bounds[*A*]Once stabilized	context()	negated: False ,passive: False
[LINE#1191] These pulses can be seen as a "heartbeat" of the system; at each pulse, the quick cycle's clocks are reset to 0 and the quick cycle's state machines are forced into state accept+ (corresponding to the increase state in Fig. 1).
0.932	[*A*]the quick cycle 's state machines[*R*]are forced[*A*]into state accept+	context()	negated: False ,passive: True
0.878	[*A*]These pulses[*R*]can be seen[*A*]as a " heartbeat " of the system	context(the quick cycle 's clocks are reset)	negated: False ,passive: True
0.945	[*A*]the quick cycle 's clocks[*R*]are reset[*A*]to 0[*A*]at each pulse	context()	negated: False ,passive: True
[LINE#1192+1193]  This enforces exactly the initial synchrony that we explained to be necessary for the correct operation of the algorithm from Fig.1.By itself, however, the main state machine is not capable of recovering from every possible initial configuration of the non-faulty nodes.
0.131	[*A*]This[*R*]enforces[*A*]exactly the initial synchrony that we explained to be necessary	context(the main state machine is not)	negated: False ,passive: False
0.933	[*A*]the main state machine[*R*]is not[*A*]capable of recovering from every possible initial configuration of the non-faulty nodes	context()	negated: True ,passive: True
0.905	[*A*]the main state machine[*R*]of recovering[*A*]from every possible initial configuration of the non-faulty nodes	context()	negated: False ,passive: True
0.771	[*A*]exactly the initial synchrony[*R*]to be[*A*]necessary	context()	negated: False ,passive: True
0.771	[*A*]exactly the initial synchrony[*R*]explained[*A*]to be necessary	context()	negated: False ,passive: True
[LINE#1194] In certain cases, it requires some coarse synchrony to be established first in order to stabilize, which is probabilistically provided by the underlying layer.
0.531	[*A*]it[*R*]requires[*A*]some coarse synchrony to be established first in order[*A*]In certain cases	context()	negated: False ,passive: False
0.897	[*A*]some coarse synchrony[*R*]is probabilistically provided[*A*]by the underlying layer	context()	negated: False ,passive: True
[LINE#1195] We remark that, once stabilized, the main state machine operates fully independently of this layer (and thus deterministically).The auxiliary information potentially required for stabilization by the main state machine is provided by a simple intermediate layer we refer to as extension of the main state machine (Fig. 9).
0.897	[*A*]The auxiliary information[*R*]required[*A*]for stabilization by the main state machine	context()	negated: False ,passive: True
0.452	[*A*]we[*R*]refer[*A*]to[*A*]as extension of the main state machine	context()	negated: False ,passive: False
0.826	[*A*]the main state machine[*R*]operates fully independently[*A*]once stabilized	context(We remark)	negated: False ,passive: True
0.202	[*A*]We[*R*]remark[*A*]that, once stabilized, the main state machine operates fully independently of this layer (and thus deterministically).The auxiliary information potentially required for stabilization by the main state machine is provided by a simple intermediate layer we refer to as extension of the main state machine (Fig. 9)	context()	negated: False ,passive: False
[LINE#1196] Essentially, it is supposed to be consistently reset by the underlying layer and then communicate information vital for stabilization to the main state machine.
0.448	[*A*]it[*R*]to communicate[*A*]information vital for stabilization to the main state machine[*A*]then	context()	negated: False ,passive: False
0.569	[*A*]it[*R*]is supposed[*A*]to then communicate information vital for stabilization to the main state machine	context()	negated: False ,passive: True
0.411	[*A*]it[*R*]to be consistently reset[*A*]by the underlying layer	context()	negated: False ,passive: True
0.452	[*A*]it[*R*]is supposed[*A*]to be consistently reset by the underlying layer	context()	negated: False ,passive: True
[LINE#1197+1198]  This information depends both on the time of reset and the current states of the n main state machines, which ittherefore monitors.Finally, the resynchronization routine (Fig. 10) utilizes randomized timeouts to consistently generate events at all non-faulty nodes that could be understood as "randomized pulses".
0.756	[*A*]the n main state machines[*R*]ittherefore monitors.Finally	context()	negated: False ,passive: False
0.937	[*A*]This information[*R*]depends[*A*]both on the current states of the n main state machines	context()	negated: False ,passive: False
0.905	[*A*]at all non-faulty nodes[*R*]could be understood[*A*]as " randomized pulses	context()	negated: False ,passive: True
0.903	[*A*]randomized timeouts[*R*]to consistently generate[*A*]events	context()	negated: False ,passive: False
0.897	[*A*]the resynchronization routine[*R*]utilizes[*A*]randomized timeouts[*A*]to consistently generate events at all non-faulty nodes	context()	negated: False ,passive: False
0.903	[*A*]This information[*R*]depends[*A*]both on the time of reset	context()	negated: False ,passive: False
[LINE#1199+1200]  Such a pulse is correct for our purposes if all non-faulty nodes generate a respective event in coarse synchrony andno non-faulty node generates another such event within a time window of a certain length.
0.943	[*A*]all non-faulty nodes[*R*]generate[*A*]a respective event in coarse synchrony andno non-faulty node generates another such event within a time window of a certain length	context()	negated: False ,passive: False
0.828	[*A*]Such a pulse[*R*]is[*A*]correct	context()	negated: False ,passive: True
[LINE#1201] The crux of the matter is that a single such pulse suffices to achieve stabilization deterministically.
0.900	[*A*]a single such pulse[*R*]suffices to achieve[*A*]stabilization[*A*]deterministically	context(The crux of the matter is a single such pulse suffices)	negated: False ,passive: False
0.900	[*A*]a single such pulse[*R*]suffices[*A*]to achieve stabilization deterministically	context(The crux of the matter is)	negated: False ,passive: False
0.886	[*A*]The crux of the matter[*R*]is[*A*]that a single such pulse suffices to achieve stabilization deterministically	context()	negated: False ,passive: True
[LINE#1202] Relying on (pseudo-)randomness on this layer greatly simplifies the task of overcoming the interference by faulty nodes at low costs in both time and communication.
0.970	[*A*]Relying on ( pseudo - ) randomness on this layer[*R*]greatly simplifies[*A*]the task of overcoming the interference by faulty nodes at low costs in communication	context()	negated: False ,passive: False
0.970	[*A*]Relying on ( pseudo - ) randomness on this layer[*R*]greatly simplifies[*A*]the task of overcoming the interference by faulty nodes at low costs in both time	context()	negated: False ,passive: False
[LINE#1203] We note that the main state machine masks this randomness once stabilization is achieved, facilitating deterministic behavior of the higher levels and, ultimately, the nodes' clocks Li.
0.452	[*A*]We[*R*]note[*A*]deterministic behavior of the higher levels	context()	negated: False ,passive: False
0.713	[*A*]stabilization[*R*]is achieved	context()	negated: False ,passive: False
0.367	[*A*]We[*R*]note[*A*]that the main state machine masks this randomness once stabilization is achieved and , ultimately , the nodes ' clocks Li	context()	negated: False ,passive: False
[LINE#1204] We will now present the individual state machines.
0.490	[*A*]We[*R*]will present[*A*]the individual state machines[*A*]now	context()	negated: False ,passive: False
[LINE#1205] We refrain from a discussion of choosing appropriate durations for the timers, confining ourselves to stating a feasible family of choices later on. .
0.418	[*A*]We[*R*]refrain[*A*]from a discussion of choosing appropriate durations for the timers, confining ourselves to stating a feasible family of choices later on	context()	negated: False ,passive: False
[LINE#1206]  The quick cycleThe quick cycle state machine is depicted in Fig..
0.948	[*A*]The quick cycleThe quick cycle state machine[*R*]is depicted[*A*]in Fig	context()	negated: False ,passive: True
[LINE#1207] It introduces an additional notation: As the states ready+ and accept+ are not distinguished in any of the transition conditions in the other state machines, the same state none+ can be communicated here.
0.388	[*A*]It[*R*]introduces[*A*]an additional notation	context(the same state can be communicated)	negated: False ,passive: False
0.388	[*A*]It[*R*]introduces[*A*]an additional notation	context(the same state can be communicated)	negated: False ,passive: False
0.702	[*A*]the same state[*R*]can be communicated[*A*]here	context()	negated: False ,passive: True
0.927	[*A*]the states[*R*]are not[*A*]distinguished in any of the transition conditions in the other state machines	context()	negated: True ,passive: True
[LINE#1208] This allows for a very efficient single-bit representation of the communicated states.
0.497	[*A*]This[*R*]allows[*A*]for a very efficient single-bit representation of the communicated states	context()	negated: False ,passive: False
[LINE#1209] 6, this is expressed by dividing the circles representing states, putting the state names in the upper part and the communicated states in the lower part.
0.381	[*A*]this[*R*]is expressed[*A*]by the communicated states in the lower part	context()	negated: False ,passive: True
0.903	[*A*]the circles[*R*]representing[*A*]states	context()	negated: False ,passive: False
0.153	[*A*]this[*R*]is expressed	context()	negated: False ,passive: False
[LINE#1210] Apart from saving a wire, this permits to use trivial encoding and decoding of the signal, a simplification of the logic that minimizes delays and therefore maximizes the clock frequency that can be achieved.
0.718	[*A*]the clock frequency[*R*]can be achieved	context()	negated: False ,passive: False
0.742	[*A*]the logic[*R*]maximizes[*A*]the clock frequency that can be achieved	context()	negated: False ,passive: False
0.887	[*A*]the logic[*R*]minimizes[*A*]delays	context()	negated: False ,passive: False
[LINE#1211] Essentially, the quick cycle works as the algorithm given in Fig. 1, where the logical clock is increased whenever the machine switches to state accept+.
0.903	[*A*]the machine[*R*]switches[*A*]to state accept+	context()	negated: False ,passive: False
0.751	[*A*]the logical clock[*R*]is increased	context()	negated: False ,passive: False
0.918	[*A*]the algorithm[*R*]given[*A*]in Fig	context()	negated: False ,passive: True
0.932	[*A*]the quick cycle[*R*]works[*A*]as the algorithm	context()	negated: False ,passive: False
[LINE#1212] However, the quick cycle differs from the algorithm in Fig. 1 in that there is an interface to the main state machine given in Fig. 8.
0.699	[*A*]the quick cycle[*R*]differs	context()	negated: False ,passive: False
0.931	[*A*]the main state machine[*R*]given[*A*]in Fig	context()	negated: False ,passive: True
[LINE#1213]  These state machines communicate by means of two signals only, one for each direction of the communication: (i).
0.911	[*A*]These state machines[*R*]communicate[*A*]by means of two signals only	context()	negated: False ,passive: False
[LINE#1214+1215+1216]  The quick cycle state machine of node i generates the nexti signal by which it exerts some limited influence on the time between two successive pulses generated by the main state machine, and (ii)it observes the (T2+,accept) timer.
0.911	[*A*]two successive pulses[*R*]generated[*A*]by the main state machine	context()	negated: False ,passive: True
0.569	[*A*]it[*R*]exerts[*A*]some limited influence on the time between two successive pulses	context()	negated: False ,passive: False
0.418	[*A*]i[*R*]generates[*A*]the nexti signal by which it exerts some limited influence on the time between two successive pulses	context()	negated: False ,passive: False
0.498	[*A*]it[*R*]observes[*A*]the ( T2+ , accept ) timer	context()	negated: False ,passive: False
[LINE#1217] This timer is coupled to the state accept of Fig. 8, in which the pulse synchronization algorithm generates a new pulse.
0.953	[*A*]the pulse synchronization algorithm[*R*]generates[*A*]a new pulse[*A*]8	context()	negated: False ,passive: False
0.918	[*A*]This timer[*R*]is coupled[*A*]to the state accept of Fig	context()	negated: False ,passive: True
[LINE#1218] The signal's purpose is to enforce a consistent reset of the quick cycle state machine (once the main state machine has stabilized).
0.769	[*A*]the main state machine[*R*]has stabilized	context()	negated: False ,passive: False
0.960	[*A*]The signal's purpose[*R*]is[*A*]to enforce a consistent reset of the quick cycle state machine (once the main state machine has stabilized	context()	negated: False ,passive: True
[LINE#1219] The feedback mechanism (i) makes sure that, during regular operation, the reset of the quick cycle does not have any effect on the clocks.
0.961	[*A*]the reset of the quick cycle[*R*]does not have[*A*]any effect on the clocks[*A*]during regular operation	context()	negated: True ,passive: False
0.836	[*A*]The feedback mechanism[*R*]makes[*A*]sure that, during regular operation, the reset of the quick cycle does not have any effect on the clocks	context()	negated: False ,passive: False
[LINE#1220+1221]  This is guaranteed by triggering pulses (by means of the non-faulty nodes briefly changing the nexti signal to 1 and back to 0 again) exactly at the wrap-around of the logical clock Li, i.e., at the time when Li is "increased" from the maximal clock value K-1=2b-1 (of a b-bit clock) to 0=KmodK.Similar to Fig.1, the transition conditions of the quick cycle ensure that the logical clocks never have a clock imprecision of more than one.
0.921	[*A*]Li[*R*]is[*A*]the time	context()	negated: False ,passive: True
0.909	[*A*]the non-faulty nodes[*R*]briefly changing back again[*A*]the nexti signal[*A*]to 1	context()	negated: False ,passive: False
0.891	[*A*]the logical clocks[*R*]never have[*A*]a clock imprecision of more than one	context(the transition conditions of the quick cycle ensure)	negated: True ,passive: False
0.876	[*A*]the transition conditions of the quick cycle[*R*]ensure[*A*]that the logical clocks never have a clock imprecision of more than one	context()	negated: False ,passive: False
[LINE#1222] To increase the frequency further, each node could increase the number of clock "ticks" generated in each iteration of the quick cycle by means of a high-frequency local clock (essentially, a watchdog timer together with a counter), at the expense of larger clock imprecision (see [13]). .
0.897	[*A*]clock "ticks[*R*]generated[*A*]in each iteration of the quick cycle[*A*]by means of a high-frequency local clock	context()	negated: False ,passive: True
0.503	[*A*]further[*R*]could increase[*A*]the number of clock "ticks	context()	negated: False ,passive: True
[LINE#1223]  Main state machineBefore we show the complete main state machine, consider its basic cycle depicted in Fig..
0.700	[*A*]its basic cycle[*R*]depicted[*A*]in Fig	context()	negated: False ,passive: True
0.313	[*A*]we[*R*]consider[*A*]its basic cycle depicted in Fig	context()	negated: False ,passive: False
[LINE#1224] Once the main state machines have stabilized, all non-faulty nodes will undergo the states of the basic cycle in rough synchrony.
0.948	[*A*]all non-faulty nodes[*R*]will undergo[*A*]the states of the basic cycle in rough synchrony[*A*]Once the main state machines have stabilized	context()	negated: False ,passive: True
0.769	[*A*]the main state machines[*R*]have stabilized	context()	negated: False ,passive: False
[LINE#1225] The states sleep, sleepwaking, and waking serve diagnostic purposes related to the stabilization process.
0.903	[*A*]diagnostic purposes[*R*]related[*A*]to the stabilization process	context()	negated: False ,passive: True
0.544	[*A*]waking[*R*]serve[*A*]diagnostic purposes related to the stabilization process	context()	negated: False ,passive: False
0.589	[*A*]The states[*R*]sleep sleepwaking	context(The states sleep)	negated: False ,passive: False
0.687	[*A*]The states[*R*]sleep[*A*]sleepwaking	context()	negated: False ,passive: False
[LINE#1226] The duration T2 of the timer (T2,accept) triggering the transition from waking to ready is so large that the node will always be in state waking long before the timer expires.
0.916	[*A*]the node[*R*]will be[*A*]in state waking[*A*]always	context()	negated: False ,passive: True
0.947	[*A*]The duration T2 of the timer (T2,accept[*R*]is[*A*]so large that the node will always be in state waking	context()	negated: False ,passive: True
0.804	[*A*]The duration[*R*]accept triggering[*A*]the transition from waking to ready	context(The duration accept)	negated: False ,passive: False
0.649	[*A*]The duration[*R*]accept	context()	negated: False ,passive: False
[LINE#1227] Thus, we can see that the basic cycle has an underlying structure that is very similar to the quick cycle.
0.860	[*A*]the basic cycle[*R*]has[*A*]an underlying structure that is very similar to the quick cycle	context(we can see)	negated: False ,passive: False
0.188	[*A*]we[*R*]can see[*A*]that the basic cycle has an underlying structure	context()	negated: False ,passive: False
0.920	[*A*]an underlying structure[*R*]is[*A*]very similar to the quick cycle	context()	negated: False ,passive: True
[LINE#1228] Due to the more complicated logic and conditions on the duration of timers required for the stabilization mechanism, it is however executed at a frequency that is by orders of magnitude smaller than that of the quick cycle.
0.860	[*A*]a frequency[*R*]is[*A*]by orders of magnitude smaller than that of the quick cycle	context()	negated: False ,passive: True
0.350	[*A*]it[*R*]is executed[*A*]at a frequency	context()	negated: False ,passive: True
0.894	[*A*]timers[*R*]required[*A*]for the stabilization mechanism	context()	negated: False ,passive: True
[LINE#1229] The difference in the rules for switching to propose and accept, respectively, are also mostly related to the stabilization process.
0.908	[*A*]The difference in the rules for switching[*R*]are related[*A*]to the stabilization process	context()	negated: False ,passive: True
[LINE#1230] An exception is the condition "T3 and nexti=1" that can trigger a transition from ready to propose.
0.905	[*A*]the condition " nexti=1[*R*]can trigger[*A*]a transition from ready to propose	context()	negated: False ,passive: False
0.879	[*A*]An exception[*R*]is[*A*]the condition " nexti=1 " that can trigger a transition from ready to propose	context()	negated: False ,passive: True
0.925	[*A*]An exception[*R*]is[*A*]the condition	context()	negated: False ,passive: True
[LINE#1231] Choosing T3 smaller than T4 and taking the signal nexti into account, we permit the quick cycle to adjust the time between pulses (i.e., switches to accept) triggered by the main state machine: Once both state machines are roughly synchronized among all non-faulty nodes, the main state machines will always be in state ready before the logical clocks Li maintained by the quick cycle reach the wrap-around (i.e., become 0 modulo K) and trigger the nexti signals.
0.931	[*A*]the main state machines[*R*]will be ready[*A*]Once both state machines are roughly synchronized among all non-faulty nodes[*A*]always	context()	negated: False ,passive: True
0.549	[*A*]i.e.[*R*]become[*A*]0 modulo K	context()	negated: False ,passive: True
0.911	[*A*]the quick cycle[*R*]to adjust[*A*]the time between pulses	context()	negated: False ,passive: False
0.911	[*A*]both state machines[*R*]are roughly synchronized[*A*]among all non-faulty nodes	context()	negated: False ,passive: True
0.897	[*A*]the logical clocks[*R*]maintained[*A*]by the quick cycle	context()	negated: False ,passive: True
[LINE#1232+1233]  Moreover, this happens at all nodes at close times and before any timer(T4,ready) expires at one of the non-faulty nodes.
0.921	[*A*]any timer(T4,ready[*R*]expires[*A*]at one of the non-faulty nodes	context()	negated: False ,passive: True
0.497	[*A*]this[*R*]happens[*A*]at all[*A*]before any timer(T4,ready) expires at one of the non-faulty nodes	context()	negated: False ,passive: True
[LINE#1234] Hence, by a reasoning similar as for Fig. 1, all non-faulty nodes will switch to propose and subsequently accept in a well-synchronized fashion, caused by the wrap-around of the logical clocks.
0.941	[*A*]all non-faulty nodes[*R*]will switch accept[*A*]caused by the wrap - around of the logical clocks[*A*]subsequently	context()	negated: False ,passive: False
0.699	[*A*]all non-faulty nodes[*R*]will switch to propose to propose	context(all non-faulty nodes will switch)	negated: False ,passive: False
0.736	[*A*]all non-faulty nodes[*R*]will switch[*A*]to propose	context()	negated: False ,passive: False
[LINE#1235] An important observation that is proved in [13] is that, once the main state machines stabilized, the nodes execute the basic cycle deterministically and any state transition is certainly completed before one of the conditions for leaving the basic cycle can be satisfied.
0.883	[*A*]An important observation that is proved in [ 13 ][*R*]is[*A*]can be satisfied	context()	negated: False ,passive: True
0.896	[*A*]any state transition[*R*]is completed[*A*]before one of the conditions for leaving the basic cycle	context(An important observation that is proved in [ 13 ] is)	negated: False ,passive: True
0.972	[*A*]An important observation that is proved in [ 13 ][*R*]is[*A*]any state transition is certainly completed before one of the conditions for leaving the basic cycle	context()	negated: False ,passive: True
0.879	[*A*]the nodes[*R*]execute deterministically[*A*]once the main state machines stabilized	context(An important observation that is proved in [ 13 ] is)	negated: False ,passive: False
0.926	[*A*]An important observation that is proved in [ 13 ][*R*]is[*A*]that , once the main state machines stabilized , the nodes execute the basic cycle deterministically	context()	negated: False ,passive: True
0.769	[*A*]the main state machines[*R*]stabilized	context()	negated: False ,passive: False
0.754	[*A*]An important observation[*R*]is proved[*A*]in [ 13	context()	negated: False ,passive: True
[LINE#1236] Apart from small additional slacks in the timer durations, this is a consequence of the fact that none of the transition conditions of the basic cycle refer to the probabilistic lower layers of the protocol; all evaluated timers and memory flags solely involve states of the basic cycle only, and the nexti signal is provided by the quick cycle.
0.269	[*A*]this[*R*]is[*A*]a consequence of the fact that none of the transition conditions of the basic cycle refer to the probabilistic lower layers of the protocol	context(memory flags solely involve)	negated: False ,passive: True
0.878	[*A*]memory flags[*R*]solely involve[*A*]states of the basic cycle only	context()	negated: False ,passive: True
0.269	[*A*]this[*R*]is[*A*]a consequence of the fact that none of the transition conditions of the basic cycle refer to the probabilistic lower layers of the protocol	context(all evaluated timers flags solely involve)	negated: False ,passive: True
0.897	[*A*]all evaluated timers flags[*R*]solely involve[*A*]states of the basic cycle only	context()	negated: False ,passive: True
0.948	[*A*]none of the transition conditions of the basic cycle[*R*]refer[*A*]to the probabilistic lower layers of the protocol	context()	negated: False ,passive: False
0.911	[*A*]the nexti signal[*R*]is provided[*A*]by the quick cycle	context()	negated: False ,passive: True
[LINE#1237] As we will discuss in Section 6, this property prevents non-faulty nodes from introducing metastability once stabilization is achieved.
0.713	[*A*]stabilization[*R*]is achieved	context()	negated: False ,passive: False
0.903	[*A*]non-faulty nodes[*R*]from introducing[*A*]metastability	context()	negated: False ,passive: False
0.903	[*A*]this property[*R*]prevents[*A*]non-faulty nodes[*A*]from introducing metastability	context()	negated: False ,passive: False
0.498	[*A*]we[*R*]will discuss[*A*]in Section 6	context()	negated: False ,passive: False
[LINE#1238]  We now turn our attention to the full main state machine that is shown in Fig..
0.927	[*A*]the full main state machine[*R*]is shown[*A*]in Fig	context()	negated: False ,passive: True
0.473	[*A*]We[*R*]turn[*A*]our attention[*A*]to the full main state machine[*A*]now	context()	negated: False ,passive: False
[LINE#1239] Compared to the basic cycle, we have two additional states, resync and join, that can be occupied by non-faulty nodes during the stabilization process only, and an additional reset of memory flags on the transition from sleepwaking to waking.
0.112	[*A*]that[*R*]can be occupied[*A*]by non-faulty nodes[*A*]during the stabilization process only	context(we join)	negated: False ,passive: True
0.162	[*A*]we[*R*]join	context()	negated: False ,passive: False
0.136	[*A*]that[*R*]can be occupied[*A*]by non-faulty nodes[*A*]during the stabilization process only	context()	negated: False ,passive: True
0.195	[*A*]we[*R*]resync	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]have[*A*]two additional states	context()	negated: False ,passive: False
[LINE#1240] The various conditions for leaving the basic cycle and switching to recover are consistency checks.
0.938	[*A*]The various conditions for switching to recover[*R*]are[*A*]consistency checks	context()	negated: False ,passive: True
0.943	[*A*]The various conditions for leaving the basic cycle[*R*]are[*A*]consistency checks	context()	negated: False ,passive: True
[LINE#1241] A node will only leave the basic cycle if it is certain that the system is not operating as desired.
0.732	[*A*]the system[*R*]is not operating	context()	negated: True ,passive: False
0.285	[*A*]it[*R*]is[*A*]certain that the system is not operating	context()	negated: False ,passive: True
0.659	[*A*]A node[*R*]will leave[*A*]the basic cycle[*A*]if it is certain that the system is not operating	context()	negated: False ,passive: False
[LINE#1242] As the high-level operation of the algorithm is not the subject of this article, we limit our exposition to briefly discussing the two possible ways to re-enter the basic cycle, corresponding to two different stabilization mechanisms.
0.388	[*A*]we[*R*]limit our exposition to briefly discussing[*A*]the two possible ways to re-enter the basic cycle	context(we limit)	negated: False ,passive: False
0.256	[*A*]we[*R*]limit[*A*]our exposition[*A*]to briefly discussing the two possible ways	context()	negated: False ,passive: False
0.943	[*A*]the high-level operation of the algorithm[*R*]is not[*A*]the subject of this article	context()	negated: True ,passive: True
[LINE#1243] The first stabilization mechanism is very simple, and it is much faster than the second one.
0.522	[*A*]it[*R*]is[*A*]much faster than the second one	context()	negated: False ,passive: True
0.841	[*A*]The first stabilization mechanism[*R*]is[*A*]very simple	context()	negated: False ,passive: True
[LINE#1244] Assuming that at least n-f non-faulty nodes are executing the basic cycle (i.e., the main state machines have already stabilized if we consider the remaining nodes faulty), a recovering node just needs to "jump on the train" and start executing the basic cycle as well.
0.870	[*A*]a recovering node[*R*]needs to start executing[*A*]the basic cycle[*A*]as well	context(a recovering node needs to start)	negated: False ,passive: False
0.870	[*A*]a recovering node[*R*]needs to start[*A*]executing the basic cycle as well	context(a recovering node needs)	negated: False ,passive: False
0.870	[*A*]a recovering node[*R*]needs[*A*]to start executing the basic cycle as well	context()	negated: False ,passive: False
0.452	[*A*]we[*R*]consider[*A*]the remaining nodes faulty	context()	negated: False ,passive: False
0.795	[*A*]the main state machines[*R*]have stabilized[*A*]already	context()	negated: False ,passive: True
0.813	[*A*]a recovering node[*R*]needs to jump[*A*]on the train	context(a recovering node needs)	negated: False ,passive: False
0.870	[*A*]a recovering node[*R*]needs[*A*]to " jump on the train	context()	negated: False ,passive: False
[LINE#1245] This is realized by the condition for switching from recover to accept.
0.381	[*A*]This[*R*]is realized[*A*]by the condition for switching from recover	context()	negated: False ,passive: True
[LINE#1246] It is not hard to see that due to this condition, the node will switch to accept in sufficient synchrony with the majority of n-f synchronized, non-faulty nodes within at most two consecutive pulses and subsequently follow the basic cycle as well.
0.801	[*A*]the majority of n - f[*R*]synchronized	context()	negated: False ,passive: False
[LINE#1247] Note that this condition makes direct use of the state signals instead of using memory flags.
[LINE#1248] This potentially induces metastability at the joining node, but we will explain in Section 6 why the risk is low.1717Recall that during stabilization we cannot exclude metastability with certainty even in the absence of any further faults.
0.531	[*A*]we[*R*]can not exclude[*A*]metastability[*A*]with certainty[*A*]even in the absence of any further faults[*A*]during stabilization	context(we will explain)	negated: True ,passive: False
0.195	[*A*]we[*R*]will explain[*A*]in Section 6[*A*]that during stabilization we can not exclude metastability with certainty even in the absence of any further faults	context()	negated: False ,passive: False
0.813	[*A*]the risk[*R*]is[*A*]low.1717Recall	context()	negated: False ,passive: True
0.342	[*A*]This[*R*]induces[*A*]metastability[*A*]at the joining node	context()	negated: False ,passive: False
[LINE#1249] On the plus side, this simplifies the algorithm, as the node does not need to implement frequent resets of the respective memory flags to ensure consistent observation of others' states; the sending nodes will just do this implicitly by leaving state accept.
0.878	[*A*]the node[*R*]does not need to implement frequent resets of the respective memory flags to ensure[*A*]consistent observation of others' states	context(the node does not need to implement)	negated: True ,passive: False
0.878	[*A*]the node[*R*]does not need to implement[*A*]frequent resets of the respective memory flags[*A*]to ensure consistent observation of others' states	context(the node does not need)	negated: True ,passive: False
0.920	[*A*]the node[*R*]does not need[*A*]to implement frequent resets of the respective memory flags to ensure consistent observation of others' states	context()	negated: True ,passive: False
0.838	[*A*]the sending nodes[*R*]will do implicitly by leaving[*A*]state accept	context(the sending nodes will do implicitly)	negated: False ,passive: False
0.458	[*A*]this[*R*]simplifies[*A*]the algorithm[*A*]On the plus side	context(the sending nodes will do implicitly)	negated: False ,passive: False
0.730	[*A*]the sending nodes[*R*]will do implicitly[*A*]this	context()	negated: False ,passive: False
[LINE#1250] Clearly, the first stabilization mechanism will fail in certain settings.
0.919	[*A*]the first stabilization mechanism[*R*]will fail[*A*]in certain settings	context()	negated: False ,passive: True
[LINE#1251] Most obviously, it cannot "restart" the system if all nodes are in state recover.
0.903	[*A*]all nodes[*R*]are[*A*]in state recover	context()	negated: False ,passive: True
0.310	[*A*]it[*R*]can not restart[*A*]the system[*A*]if all nodes are in state recover	context()	negated: True ,passive: False
[LINE#1252] Hence it may not surprise that the second stabilization mechanism, which deals with such cases, is much more involved.
0.860	[*A*]the second stabilization mechanism, which deals with such cases[*R*]is[*A*]much more involved	context(it may not surprise)	negated: False ,passive: True
0.271	[*A*]it[*R*]may not surprise[*A*]that the second stabilization mechanism, which deals with such cases, is much more involved	context()	negated: True ,passive: False
0.905	[*A*]the second stabilization mechanism[*R*]deals[*A*]with such cases	context()	negated: False ,passive: False
[LINE#1253]  Careful attention has to be paid to avoiding the potential for system-wide dead-.
0.887	[*A*]Careful attention[*R*]to be paid[*A*]to avoiding the potential for	context()	negated: False ,passive: True
[LINE#1254] In view of our design goals, state-of-the-art deterministic solutions for this problem are not sufficiently efficient.
0.896	[*A*]state-of-the-art deterministic solutions for this problem[*R*]are not[*A*]sufficiently efficient	context()	negated: True ,passive: True
[LINE#1255] Hence, the main state machine relies on a probabilistic lower layer that provides certain guarantees with a very large probability. .
0.905	[*A*]a probabilistic lower layer[*R*]provides[*A*]certain guarantees	context()	negated: False ,passive: False
0.919	[*A*]the main state machine[*R*]relies[*A*]on a probabilistic lower layer	context()	negated: False ,passive: False
[LINE#1256] machineThe extension of the main state machine, given in Fig. 9, can be seen as a simple control structure for the phases of stabilization.
0.953	[*A*]machineThe extension of the main state machine[*R*]can be seen[*A*]as a simple control structure for the phases of stabilization	context()	negated: False ,passive: True
0.920	[*A*]the main state machine[*R*]given[*A*]in Fig	context()	negated: False ,passive: True
[LINE#1257] The intricacy lies in designing the interface such that this control does not interfere with the basic cycle if the system is stable.
0.813	[*A*]the system[*R*]is[*A*]stable	context()	negated: False ,passive: True
0.903	[*A*]this control[*R*]does not interfere[*A*]with the basic cycle[*A*]if the system is stable	context()	negated: True ,passive: False
0.845	[*A*]The intricacy[*R*]lies[*A*]in designing the interface such that this control does not interfere with the basic cycle	context()	negated: False ,passive: True
[LINE#1258+1259+1260]  Consequently, the influence of the extension of the main state machine is limited to (i) resetting the join and sleepwaking flags upon "initializing" the stabilization process (by switching from dormant to passive) providing the signals of the timersand (T7,passive) the main state machine utilizes in the transition rule from recover to join.
0.877	[*A*]the influence of the extension of the main state machine[*R*]is limited[*A*]to (i)	context()	negated: False ,passive: True
0.919	[*A*]the main state machine[*R*]utilizes[*A*]in the transition rule from recover[*A*]to join	context()	negated: False ,passive: False
0.970	[*A*]the influence of the extension of the main state machine[*R*]is limited[*A*]to (i) resetting the join flags upon " initializing " the stabilization process ( by switching from dormant to passive ) providing the signals of the timersand ( T7 , passive	context()	negated: False ,passive: True
[LINE#1261] Roughly speaking, the main state machines will stabilize deterministically under the condition that their extensions switch at all non-faulty nodes from dormant to passive in rough synchrony and then do not switch back to dormant too quickly, i.e., before the second stabilization mechanism of the main state machine completes its work.
0.764	[*A*]the condition[*R*]do not switch back too quickly[*A*]then	context()	negated: True ,passive: False
0.638	[*A*]their extensions[*R*]switch at all[*A*]non-faulty nodes[*A*]from dormant[*A*]to passive	context()	negated: False ,passive: False
0.769	[*A*]the main state machines[*R*]will stabilize deterministically	context()	negated: False ,passive: False
[LINE#1262] Putting it simply, we require a single, coarsely synchronized pulse, whose generation is the purpose of the lowest layer we present now. .
0.504	[*A*]we[*R*]require[*A*]a single, coarsely synchronized pulse, whose generation is the purpose of the lowest layer	context()	negated: False ,passive: False
0.754	[*A*]the lowest layer[*R*]present[*A*]now	context()	negated: False ,passive: True
0.939	[*A*]a single, coarsely synchronized pulse[*R*]is[*A*]the purpose of the lowest layer	context()	negated: False ,passive: True
[LINE#1263]  machineThe resynchronization state machine is specified in Fig..
0.949	[*A*]machineThe resynchronization state machine[*R*]is specified[*A*]in Fig	context()	negated: False ,passive: True
[LINE#1264] Strictly speaking, it actually consists of two separate state machines, one of which is however extremely simple.
0.817	[*A*]two separate state machines[*R*]is[*A*]however[*A*]extremely simple	context()	negated: False ,passive: True
0.411	[*A*]it[*R*]consists[*A*]of two separate state machines	context()	negated: False ,passive: True
[LINE#1265+1266]  Every now and then, each node will briefly switch to the init state, seeking to induce the generation of a "pulse" (where the pulse here is locally triggered by switching to resync)that causes a consistent switch of all non-faulty nodes from dormant to passive.
0.943	[*A*]each node[*R*]will briefly switch[*A*]to the init state[*A*]then	context()	negated: False ,passive: False
0.923	[*A*]the pulse here[*R*]is triggered[*A*]by switching to resync[*A*]a " pulse[*A*]locally	context()	negated: False ,passive: True
0.949	[*A*]the generation of a " pulse[*R*]causes[*A*]a consistent switch of all non-faulty nodes from dormant to passive	context()	negated: False ,passive: False
0.943	[*A*]each node[*R*]will briefly switch[*A*]to the init state[*A*]Every now	context()	negated: False ,passive: False
[LINE#1267] Leaving resync will force the extension state machine back into state dormant.
0.903	[*A*]Leaving resync[*R*]will force[*A*]the extension state machine[*A*]back into state dormant	context()	negated: False ,passive: False
[LINE#1268] This is the only interaction with the above layer, which is sufficient if a pulse is successfully generated once.
0.767	[*A*]a pulse[*R*]is successfully generated[*A*]once	context()	negated: False ,passive: True
0.802	[*A*]the above layer[*R*]is[*A*]sufficient	context()	negated: False ,passive: True
0.449	[*A*]This[*R*]is[*A*]the only interaction with the above layer	context()	negated: False ,passive: True
[LINE#1269] The generation of a pulse is achieved by all non-faulty nodes following the advice of a single node switching to init, thus establishing the common time base required for a synchronized pulse.
0.919	[*A*]the common time base[*R*]required[*A*]for a synchronized pulse	context()	negated: False ,passive: True
0.911	[*A*]a single node[*R*]switching[*A*]to init	context()	negated: False ,passive: False
0.911	[*A*]all non-faulty nodes[*R*]following[*A*]the advice of a single node	context()	negated: False ,passive: False
0.926	[*A*]The generation of a pulse[*R*]is achieved[*A*]by all non-faulty nodes[*A*]thus establishing the common time base	context()	negated: False ,passive: True
[LINE#1270] Two obstacles are to be overcome: possibly some of the non-faulty nodes already believe that the system is in the middle of an attempt to stabilize (i.e., they are already in state resync and thus not ready to follow the advice given by another node) and possibly inconsistent information by nodes that remain faulty (causing only some of the non-faulty nodes to switch to resync).In contrast to the higher levels, however, we are satisfied if only occasionally a successful pulse is generated.
0.920	[*A*]nodes[*R*]remain[*A*]faulty[*A*]causing only some of the non-faulty nodes to switch to resync	context()	negated: False ,passive: True
0.452	[*A*]we[*R*]are[*A*]satisfied[*A*]if only occasionally a successful pulse is generated	context()	negated: False ,passive: True
0.903	[*A*]the advice[*R*]given[*A*]by another node	context()	negated: False ,passive: True
0.843	[*A*]a successful pulse[*R*]is generated[*A*]only occasionally	context()	negated: False ,passive: True
0.905	[*A*]the system[*R*]is[*A*]in the middle of an attempt	context(possibly some of the non-faulty nodes believe)	negated: False ,passive: True
0.717	[*A*]Two obstacles[*R*]are[*A*]to be overcome	context(possibly some of the non-faulty nodes believe)	negated: False ,passive: True
0.903	[*A*]possibly some of the non-faulty nodes[*R*]believe[*A*]that the system is in the middle of an attempt[*A*]already	context()	negated: False ,passive: False
0.698	[*A*]Two obstacles[*R*]to be overcome	context()	negated: False ,passive: False
0.616	[*A*]they[*R*]are[*A*]already[*A*]in state resync	context()	negated: False ,passive: True
[LINE#1271] Hence, the above issues can be overcome by randomization.
0.911	[*A*]the above issues[*R*]can be overcome[*A*]by randomization	context()	negated: False ,passive: True
[LINE#1272] The source of randomness here is the randomized timer (R3,wait).
0.952	[*A*]The source of randomness here[*R*]is[*A*]the randomized timer (R3,wait	context()	negated: False ,passive: True
[LINE#1273] The distribution R3 and the logic of the second, more complicated state machine including the state resync are designed such that there is a large probability that within time O(n) all non-faulty nodes will consistently switch to state resync.
0.904	[*A*]the logic of the second , more complicated state machine including the state resync[*R*]are designed[*A*]such that there is a large probability that within time O ( n ) all non-faulty nodes will consistently switch to state resync	context()	negated: False ,passive: True
0.715	[*A*]The distribution[*R*]are designed[*A*]such that there is a large probability that within time O ( n ) all non-faulty nodes will consistently switch to state resync	context()	negated: False ,passive: True
[LINE#1274] This O(n) is essentially the factor by which the second stabilization mechanism of the main state machine is slower than the first one. .
0.895	[*A*]the second stabilization mechanism of the main state machine[*R*]is[*A*]slower than the first one	context()	negated: False ,passive: True
0.965	[*A*]This O(n[*R*]is[*A*]essentially[*A*]the factor by which the second stabilization mechanism of the main state machine is slower than the first one	context()	negated: False ,passive: True
[LINE#1275] Timer durationsClearly, in order for the protocol to operate as desired, the timer durations need to satisfy certain constraints.
0.888	[*A*]the timer durations[*R*]need to satisfy[*A*]certain constraints	context(the timer durations need)	negated: False ,passive: False
0.888	[*A*]the timer durations[*R*]need[*A*]to satisfy certain constraints	context()	negated: False ,passive: False
0.732	[*A*]the protocol[*R*]to operate	context()	negated: False ,passive: False
[LINE#1276] We state a feasible family of durations here; the minimal constraints that are required by the proofs are given in [13].Recall that >1 and that d bounds the maximal end-to-end delay incurred between the time when a state transition condition is met and the time when the respective signal transition is observed at all receivers.
0.993	[*A*]the minimal constraints that are required by the proofs[*R*]are given in[*A*]13 ]	context()	negated: False ,passive: False
0.585	[*A*]that d[*R*]bounds	context()	negated: False ,passive: False
0.397	[*A*]We[*R*]state[*A*]a feasible family of durations here	context(the minimal constraints that are required by the proofs are given)	negated: False ,passive: False
0.838	[*A*]the minimal constraints that are required by the proofs[*R*]are given[*A*]in [ 13	context()	negated: False ,passive: True
0.944	[*A*]a state transition condition[*R*]is met[*A*]the time	context()	negated: False ,passive: True
0.964	[*A*]the maximal end - to - end delay[*R*]incurred[*A*]between the time when a state transition condition is met and the time	context()	negated: False ,passive: True
0.397	[*A*]We[*R*]state[*A*]a feasible family of durations[*A*]here	context(the minimal constraints that are required by the proofs are given in)	negated: False ,passive: False
0.812	[*A*]the minimal constraints that are required by the proofs[*R*]are given in	context()	negated: False ,passive: False
0.897	[*A*]the minimal constraints[*R*]are required[*A*]by the proofs	context()	negated: False ,passive: True
0.953	[*A*]the respective signal transition[*R*]is observed[*A*]at all receivers[*A*]the time	context()	negated: False ,passive: True
[LINE#1277] As the logic of the quick cycle is much simpler than that of the other state machines, it typically permits much tighter upper and lower bounds on this end-to-end delay.
0.528	[*A*]it[*R*]permits[*A*]much tighter lower bounds on this end - to - end delay	context()	negated: False ,passive: False
0.528	[*A*]it[*R*]permits[*A*]much tighter upper bounds on this end - to - end delay	context()	negated: False ,passive: False
0.869	[*A*]the logic of the quick cycle[*R*]is[*A*]much simpler than that of the other state machines	context()	negated: False ,passive: True
[LINE#1278] As in [13], these bounds are denoted by dmin+ and dmax+d.
0.918	[*A*]these bounds[*R*]are denoted[*A*]by dmax+d	context()	negated: False ,passive: True
0.918	[*A*]these bounds[*R*]are denoted[*A*]by dmin+	context()	negated: False ,passive: True
[LINE#1279] In Section 6, we will discuss how d, dmin+, and dmax+ can be computed out of the constituent delays incurred in our basic modules.
0.082	[*A*]dmax+[*R*]can be computed[*A*]out of the constituent delays	context(we will discuss)	negated: False ,passive: True
0.497	[*A*]we[*R*]will discuss[*A*]how d , dmax+ can be computed out of the constituent delays[*A*]In Section 6	context()	negated: False ,passive: False
0.082	[*A*]dmin+[*R*]can be computed[*A*]out of the constituent delays	context(we will discuss)	negated: False ,passive: True
0.497	[*A*]we[*R*]will discuss[*A*]how d , dmin+ can be computed out of the constituent delays[*A*]In Section 6	context()	negated: False ,passive: False
0.848	[*A*]the constituent delays[*R*]incurred[*A*]in our basic modules	context()	negated: False ,passive: True
[LINE#1280+1281+1282]  Defining:=(25-9)/(25)(4/5,1)and:=(T2+T4)/((T2+T3+4d)), for any >1, 1, the following family of timeout durations meets the requirements stated in [13] (see the reference for a proof):T1+:=62d+62dmax+-dmin+T2+:=3d+3dmax+T3+:=63d+63dmax+-2dmin+T1:=4dT2:=463d/(1-)T3:=(2-1)463d/(1-)+313dT4:=463(3-1)d/(1-)+354dT5:=464(3-1)d/(1-)+395dT6:=464d/(1-)T7:=928d/(1-)+785d and further,R1:=466(33-1)d/(1-)+1096dR2:=(927(33-1)/(1-)2+(2187+ 1083)/(1-))(n-f)dR3:=uniformly distributed random variable on[3d+(928(33-1)/(1-)2+(2188+1084)/(1-))(n-f)d,3d+(8(1-)+)(927(33-1)/(1-)2+(2187+1083)/(1-))(n-f)d].
0.991	[*A*]785 d = 466[*R*]see[*A*]the reference for a proof	context()	negated: False ,passive: False
0.992	[*A*]= ( T2+T4 ) / ( ( T2+T3+4 d ) ) , for any > 1 , 1 , the following family of timeout durations meets the requirements[*R*]see[*A*]the reference for a proof	context()	negated: False ,passive: False
0.767	[*A*]the requirements[*R*]stated[*A*]in [ 13	context()	negated: False ,passive: True
0.932	[*A*]the following family of timeout durations[*R*]meets[*A*]the requirements stated in [ 13 ]	context()	negated: False ,passive: False
[LINE#1283] Finally, the maximal logical clock value K-1 is not arbitary, as we require(1)K[(464/(1-)+522)/(12+10dmax+/d),(464/(1-)+322)/(12+12dmax+/d)].
0.834	[*A*]the maximal logical clock value[*R*]not has Finally of[*A*]12 + 10dmax + /	context()	negated: False ,passive: False
0.973	[*A*]the maximal logical clock value[*R*]is not[*A*]12 + 10dmax + /	context()	negated: False ,passive: False
0.195	[*A*]we[*R*]require	context()	negated: False ,passive: False
0.851	[*A*]the maximal logical clock value[*R*]is not[*A*]arbitary[*A*]as we require(1	context()	negated: True ,passive: True
[LINE#1284] Note that, by manipulating , we can make K arbitrarily large, but this comes at the expense of a proportional increase in the timer durations of the main state machine and its underlying layers, increasing the overall stabilization time. .
0.153	[*A*]this[*R*]comes	context()	negated: False ,passive: False
[LINE#1285] Summary of results from theoryWe conclude the section with a summary of the most important statements proved in [13], expressed in terms of the model employed in this article.
0.903	[*A*]the model[*R*]employed[*A*]in this article	context()	negated: False ,passive: True
0.820	[*A*]the most important statements proved in [13][*R*]expressed	context()	negated: False ,passive: False
0.964	[*A*]Summary of results from theoryWe[*R*]conclude[*A*]the section with a summary of the most important statements	context()	negated: False ,passive: False
[LINE#1286] To this end, we need to specify the protocol as a compound implementation about that we will formulate our theorems.
0.188	[*A*]we[*R*]need to specify[*A*]the protocol[*A*]as a compound implementation about that	context(we need)	negated: False ,passive: False
0.399	[*A*]we[*R*]need[*A*]to specify the protocol as a compound implementation about that[*A*]To this end	context()	negated: False ,passive: False
0.309	[*A*]we[*R*]will formulate[*A*]our theorems	context()	negated: False ,passive: False
[LINE#1287] ProtocolThe FATAL+ protocol is a compound module consisting of nodes i{1,,n}.
0.911	[*A*]a compound module[*R*]consisting[*A*]of nodes	context()	negated: False ,passive: True
0.905	[*A*]ProtocolThe FATAL+ protocol[*R*]is[*A*]a compound module consisting of nodes	context()	negated: False ,passive: True
[LINE#1288+1289]  It has no input ports and an output port Li for each node i. The n input ports of node i are connected to the output ports of the channels.
0.195	[*A*]i[*R*]are connected	context()	negated: False ,passive: False
0.488	[*A*]It[*R*]has[*A*]The n input ports of node i are connected to the output ports of the channels	context()	negated: False ,passive: False
0.522	[*A*]It[*R*]has[*A*]an output port	context()	negated: False ,passive: False
0.522	[*A*]It[*R*]has[*A*]no input ports	context()	negated: False ,passive: False
[LINE#1290] Each node is comprised of one copy of each of the state machines presented in this section, and the implementation of each node is derived from the implementations (given in Section 6) of the basic modules defined in Section 2.2 that are connected as specified in this section.
0.789	[*A*]the basic modules defined in Section 2.2[*R*]are connected	context()	negated: False ,passive: False
0.926	[*A*]the implementation of each node[*R*]is derived[*A*]from the implementations	context()	negated: False ,passive: True
0.911	[*A*]the state machines[*R*]presented[*A*]in this section	context()	negated: False ,passive: True
0.903	[*A*]Each node[*R*]is comprised[*A*]of one copy of each of the state machines	context()	negated: False ,passive: True
[LINE#1291] i is the output port of its quick cycle state machine.
0.372	[*A*]i[*R*]is[*A*]the output port of its quick cycle state machine	context()	negated: False ,passive: True
[LINE#1292] The first theorem states a probabilistic stabilization result.
0.911	[*A*]The first theorem[*R*]states[*A*]a probabilistic stabilization result	context()	negated: False ,passive: False
[LINE#1293] Since we did not formally define probabilistically stabilizing implementations, its formulation is somewhat cumbersome.
0.388	[*A*]we[*R*]did not formally define probabilistically stabilizing[*A*]implementations	context(we did not formally define)	negated: True ,passive: False
0.388	[*A*]we[*R*]did not formally define[*A*]probabilistically stabilizing implementations	context()	negated: True ,passive: False
0.452	[*A*]its formulation[*R*]is[*A*]somewhat cumbersome	context()	negated: False ,passive: True
[LINE#1294] Intuitively (and slightly inaccurately), the statement is to be read as "no matter what the initial state and the execution, the protocol stabilizes almost certainly within Tslow time".
0.718	[*A*]the statement[*R*]is no matter[*A*]to be read as	context(the protocol stabilizes almost certainly)	negated: False ,passive: True
0.686	[*A*]the protocol[*R*]stabilizes almost certainly	context()	negated: False ,passive: False
0.719	[*A*]the statement[*R*]is no matter[*A*]to be read as	context(the protocol stabilizes almost certainly)	negated: False ,passive: True
0.735	[*A*]the statement[*R*]to be read[*A*]as	context()	negated: False ,passive: True
0.903	[*A*]the protocol[*R*]stabilizes almost certainly[*A*]within Tslow time	context()	negated: False ,passive: True
0.735	[*A*]the statement[*R*]to be read[*A*]as " no matter	context()	negated: False ,passive: True
[LINE#1295] Theorem 5.2Fix any ff:=(n-1)/3 and feasible , setTslow:=(24(1-)+3)R2+R1/+T1++T3++(9+8)d+5dmax+-dmax-(n), and pick K(n) in accordance with inequality (1).Consider an execution on [t-,t+] of the FATAL+ protocol where (at least) n-f nodes are feasible.
0.960	[*A*]n-f nodes[*R*]are[*A*]feasible[*A*]the FATAL+ protocol	context()	negated: False ,passive: True
[LINE#1296] Assume that an adversary that knows everything about the system except that it does not learn about the durations of randomized watchdog timers before they expire controls all other aspects of the execution (clock drifts and delays of feasible submodules within the admissible bounds as well as the output ports' signals of faulty modules).
0.418	[*A*]it[*R*]does not learn[*A*]about the durations of randomized watchdog timers[*A*]before they expire controls all other aspects of the execution	context()	negated: True ,passive: False
0.418	[*A*]it[*R*]does not learn[*A*]about the durations of randomized watchdog timers[*A*]before they expire controls all other aspects of the execution delays	context()	negated: True ,passive: False
0.418	[*A*]it[*R*]does not learn[*A*]about the durations of randomized watchdog timers[*A*]before they expire controls all other aspects of the execution ( clock drifts	context()	negated: True ,passive: False
0.769	[*A*]an adversary[*R*]knows[*A*]everything about the system except that it does not learn about the durations of randomized watchdog timers	context()	negated: False ,passive: False
[LINE#1297+1298]  Then the execution restricted to [t-+Tslow,t+] is with probability at least 1-2-(n-f) a feasible execution of a clock synchronization module with clock imprecision =1, amortized frequency bounds A-=1/(T1++T3++3dmax+) and.
0.943	[*A*]the execution[*R*]restricted[*A*]to [t-+Tslow,t+[*A*]Then	context()	negated: False ,passive: True
[LINE#1299+1300]  A+=1/((T1++T3+)), slacks -=+=2, maximum frequency F+=1/((T1++T3+ -2dmax++dmin+)), at most f faults, and clocks of size K(n).In this sense, for each ff, the FATAL+ protocol is an f-tolerant implementation of a clock synchronization module with the respective parameters that stabilizes with probability at least 1-2-(n-f) within time.
0.897	[*A*]the respective parameters[*R*]stabilizes[*A*]with probability	context()	negated: False ,passive: True
0.967	[*A*]the FATAL+ protocol[*R*]is[*A*]an f - tolerant implementation of a clock synchronization module with the respective parameters	context()	negated: False ,passive: True
[LINE#1301] TslowO(n).The above theorem corresponds to the slow, but robust, second stabilization mechanism.
0.911	[*A*]The above theorem[*R*]corresponds[*A*]to the robust , second stabilization mechanism	context()	negated: False ,passive: True
0.783	[*A*]The above theorem[*R*]corresponds[*A*]to the slow	context()	negated: False ,passive: True
[LINE#1302] The next theorem, which corresponds to the faster first stabilization mechanism, essentially states that in an execution where n-f nodes already stabilized, any further non-faulty nodes recover quickly and deterministically, within O() time.
0.928	[*A*]any further non-faulty nodes[*R*]recover deterministically[*A*]time[*A*]in an execution	context(The next theorem , which corresponds to the faster first stabilization mechanism states)	negated: False ,passive: True
0.918	[*A*]The next theorem , which corresponds to the faster first stabilization mechanism[*R*]states[*A*]that in an execution where n - f nodes already stabilized , any further non-faulty nodes recover deterministically , within O ( ) time	context()	negated: False ,passive: False
0.928	[*A*]any further non-faulty nodes[*R*]recover quickly[*A*]time[*A*]in an execution	context(The next theorem , which corresponds to the faster first stabilization mechanism states)	negated: False ,passive: True
0.918	[*A*]The next theorem , which corresponds to the faster first stabilization mechanism[*R*]states[*A*]that in an execution where n - f nodes already stabilized , any further non-faulty nodes recover quickly , within O ( ) time	context()	negated: False ,passive: False
0.945	[*A*]n - f nodes[*R*]stabilized[*A*]an execution[*A*]already	context()	negated: False ,passive: True
0.897	[*A*]The next theorem[*R*]corresponds[*A*]to the faster first stabilization mechanism	context()	negated: False ,passive: True
[LINE#1303] Theorem 5.3We use the notation of the previous theorem.
0.575	[*A*]Theorem[*R*]use[*A*]the notation of the previous theorem	context()	negated: False ,passive: False
[LINE#1304] Moreover,Tfast:=T2+T4+(1+5/(2))R1+5d().Suppose an execution of the FATAL+ protocol is feasible on [t-,t+] with respect to the clock synchronization module specified in Theorem 5.2.
[LINE#1305] WN whose restricted executions on [t-,t+] are feasible.
0.845	[*A*]whose restricted executions on [t-,t+[*R*]are[*A*]feasible	context()	negated: False ,passive: True
[LINE#1306] Then the execution restricted to [t-+Tfast,t+] is feasible with respect to a clock synchronization module with the same parameters, except that it tolerates n-|W| faults only.
0.498	[*A*]it[*R*]tolerates[*A*]n-|W| faults only	context()	negated: False ,passive: False
0.887	[*A*]t+[*R*]is[*A*]feasible with respect to a clock synchronization module with the same parameters	context()	negated: False ,passive: True
0.864	[*A*]the execution[*R*]restricted[*A*]to [t-+Tfast,t+] is feasible with respect to a clock synchronization module with the same parameters, except that it tolerates n-|W| faults only[*A*]Then	context()	negated: False ,passive: True
[LINE#1307] We should like to mention that in [13] a number of further results on stabilization are given.
0.993	[*A*]a number of further results on stabilization[*R*]are given in[*A*]13 ]	context()	negated: False ,passive: False
0.859	[*A*]a number of further results on stabilization[*R*]are given[*A*]in [13	context(We should like to mention)	negated: False ,passive: True
0.271	[*A*]We[*R*]should like to mention[*A*]that in [13] a number of further results on stabilization are given	context(We should like)	negated: False ,passive: False
0.271	[*A*]We[*R*]should like[*A*]to mention that in [13] a number of further results on stabilization are given	context()	negated: False ,passive: False
[LINE#1308] In particular, if the faulty nodes exhibit only little coordination among themselves or do not tune their operations to the non-faulty nodes' states, also the "slow" stabilization mechanism will succeed quickly, granted that the resynchronization state machines are not in a "too bad" configuration, i.e., most timers of type R2 are expired and timeouts of type R3 are in (roughly) random states.
0.801	[*A*]the "slow" stabilization mechanism[*R*]will succeed quickly	context()	negated: False ,passive: False
0.967	[*A*]i.e., most timers of type R2 are expired and timeouts of type R3[*R*]are[*A*]in (roughly) random states	context()	negated: False ,passive: True
0.825	[*A*]the faulty nodes[*R*]do not tune[*A*]their operations	context()	negated: True ,passive: False
0.816	[*A*]the faulty nodes[*R*]exhibit[*A*]only little coordination among themselves	context(most timers of type R2 are expired)	negated: False ,passive: False
0.745	[*A*]most timers of type R2[*R*]are expired	context()	negated: False ,passive: False
[LINE#1309+1310]  We will informally discuss some of these scenarios in Section7.Finally, we emphasize again that the power of the above theorems severely depends on the quality of basic implementations (cf.
0.913	[*A*]the power of the above theorems[*R*]severely depends[*A*]on the quality of basic implementations	context(we emphasize)	negated: False ,passive: False
0.433	[*A*]We[*R*]will informally discuss[*A*]some of these scenarios in Section7.Finally	context(we emphasize)	negated: False ,passive: False
0.271	[*A*]we[*R*]emphasize[*A*]again[*A*]that the power of the above theorems severely depends on the quality of basic implementations	context()	negated: False ,passive: False
[LINE#1311] While compound modules' properties can be formally analyzed, e.g. giving rise to the theorems above, these results are meaningless if too many basic implementations are infeasible too frequently.
0.799	[*A*]too many basic implementations[*R*]are[*A*]infeasible[*A*]too frequently	context()	negated: False ,passive: True
0.903	[*A*]these results[*R*]are[*A*]meaningless[*A*]if too many basic implementations are infeasible too frequently	context()	negated: False ,passive: True
0.769	[*A*]compound modules' properties[*R*]can be formally analyzed	context()	negated: False ,passive: False
[LINE#1312] Hence it is vital to come up with robust implementations of the basic modules, which is the subject of the next section.
0.272	[*A*]which[*R*]is the subject of[*A*]the next section	context()	negated: False ,passive: False
0.920	[*A*]the basic modules[*R*]is[*A*]the subject of the next section	context()	negated: False ,passive: True
